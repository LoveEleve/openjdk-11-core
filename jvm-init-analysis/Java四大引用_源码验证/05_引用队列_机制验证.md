# å¼•ç”¨é˜Ÿåˆ—(Reference Queue) - æœºåˆ¶æ·±åº¦éªŒè¯

## ğŸ¯ **æ ¸å¿ƒæ¦‚å¿µ**

å¼•ç”¨é˜Ÿåˆ—(ReferenceQueue)æ˜¯Javaå¼•ç”¨æœºåˆ¶çš„**æ ¸å¿ƒç»„ä»¶**ï¼Œå®ƒæä¾›äº†ä¸€ç§**å¼‚æ­¥é€šçŸ¥æœºåˆ¶**ï¼Œå½“è½¯å¼•ç”¨ã€å¼±å¼•ç”¨æˆ–è™šå¼•ç”¨æ‰€æŒ‡å‘çš„å¯¹è±¡è¢«åƒåœ¾æ”¶é›†å™¨å›æ”¶æ—¶ï¼Œè¿™äº›å¼•ç”¨å¯¹è±¡ä¼šè¢«**è‡ªåŠ¨åŠ å…¥**åˆ°ä¸ä¹‹å…³è”çš„å¼•ç”¨é˜Ÿåˆ—ä¸­ã€‚

### ğŸ“‹ **åŸºæœ¬ç‰¹å¾**

| ç‰¹å¾ | æè¿° |
|------|------|
| **é€šçŸ¥æœºåˆ¶** | å¯¹è±¡å›æ”¶åå¼‚æ­¥é€šçŸ¥åº”ç”¨ç¨‹åº |
| **çº¿ç¨‹å®‰å…¨** | å†…éƒ¨ä½¿ç”¨åŒæ­¥æœºåˆ¶ï¼Œæ”¯æŒå¤šçº¿ç¨‹è®¿é—® |
| **é˜»å¡æ“ä½œ** | æ”¯æŒé˜»å¡å¼å’Œéé˜»å¡å¼è·å–å¼•ç”¨ |
| **ç”Ÿå‘½å‘¨æœŸç®¡ç†** | å¸®åŠ©åº”ç”¨ç¨‹åºç®¡ç†å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ |

## ğŸ” **OpenJDKæºç åˆ†æ**

### 1. **ReferenceQueueæ ¸å¿ƒå­—æ®µ**

```java
// java/lang/ref/ReferenceQueue.java - æ ¸å¿ƒå­—æ®µ
public class ReferenceQueue<T> {
    
    // ç©ºé˜Ÿåˆ—æ ‡è¯† - ç”¨äºæ ‡è¯†æœªå…³è”é˜Ÿåˆ—çš„å¼•ç”¨
    private static class Null extends ReferenceQueue<Object> {
        boolean enqueue(Reference<?> r) {
            return false; // ç©ºé˜Ÿåˆ—ä¸æ¥å—ä»»ä½•å¼•ç”¨
        }
    }
    
    static final ReferenceQueue<Object> NULL = new Null();
    static final ReferenceQueue<Object> ENQUEUED = new Null(); // å·²å…¥é˜Ÿæ ‡è¯†
    
    // é˜Ÿåˆ—åŒæ­¥é”
    private static class Lock { };
    private final Lock lock = new Lock();
    
    // é˜Ÿåˆ—å¤´éƒ¨å¼•ç”¨ï¼Œä½¿ç”¨volatileä¿è¯å¯è§æ€§
    private volatile Reference<? extends T> head;
    
    // é˜Ÿåˆ—é•¿åº¦è®¡æ•°
    private long queueLength = 0;
}
```

### 2. **å…¥é˜Ÿæ“ä½œ - enqueueæ–¹æ³•**

```java
// å°†å¼•ç”¨åŠ å…¥é˜Ÿåˆ— - ç”±GCè°ƒç”¨ï¼Œè¿™æ˜¯å¼•ç”¨é˜Ÿåˆ—çš„æ ¸å¿ƒæ–¹æ³•
boolean enqueue(Reference<? extends T> r) {
    synchronized (lock) {
        // æ£€æŸ¥å¼•ç”¨æ˜¯å¦å·²ç»è¢«å¤„ç†
        ReferenceQueue<?> queue = r.queue;
        if ((queue == NULL) || (queue == ENQUEUED)) {
            return false;
        }
        assert queue == this;
        
        // å°†å¼•ç”¨æ’å…¥åˆ°é˜Ÿåˆ—å¤´éƒ¨ï¼ˆå•é“¾è¡¨ç»“æ„ï¼‰
        r.next = (head == null) ? r : head;
        head = r;
        queueLength++;
        
        // æ›´æ–°å¼•ç”¨çš„é˜Ÿåˆ—çŠ¶æ€ä¸ºENQUEUED
        // å¿…é¡»åœ¨åŠ å…¥é“¾è¡¨åæ›´æ–°ï¼Œé¿å…ç«æ€æ¡ä»¶
        r.queue = ENQUEUED;
        
        // ç‰¹æ®Šå¤„ç†FinalReference
        if (r instanceof FinalReference) {
            VM.addFinalRefCount(1);
        }
        
        // é€šçŸ¥ç­‰å¾…çš„çº¿ç¨‹
        lock.notifyAll();
        return true;
    }
}
```

### 3. **å‡ºé˜Ÿæ“ä½œ - pollå’Œremoveæ–¹æ³•**

```java
// å®é™…çš„å‡ºé˜Ÿæ“ä½œ - å¿…é¡»æŒæœ‰é”
private Reference<? extends T> reallyPoll() {
    Reference<? extends T> r = head;
    if (r != null) {
        // æ›´æ–°å¼•ç”¨çŠ¶æ€ä¸ºNULLï¼ˆå·²å‡ºé˜Ÿï¼‰
        r.queue = NULL;
        
        // æ›´æ–°é˜Ÿåˆ—å¤´éƒ¨
        @SuppressWarnings("unchecked")
        Reference<? extends T> rn = r.next;
        head = (rn == r) ? null : rn; // å¤„ç†è‡ªå¾ªç¯
        
        // æ–­å¼€å¼•ç”¨çš„nextæŒ‡é’ˆï¼ˆè‡ªå¾ªç¯æ ‡è¯†å·²å‡ºé˜Ÿï¼‰
        r.next = r;
        queueLength--;
        
        // ç‰¹æ®Šå¤„ç†FinalReference
        if (r instanceof FinalReference) {
            VM.addFinalRefCount(-1);
        }
        return r;
    }
    return null;
}

// éé˜»å¡å¼è·å–å¼•ç”¨
public Reference<? extends T> poll() {
    if (head == null)
        return null;
    synchronized (lock) {
        return reallyPoll();
    }
}

// é˜»å¡å¼è·å–å¼•ç”¨ï¼ˆå¸¦è¶…æ—¶ï¼‰
public Reference<? extends T> remove(long timeout)
    throws IllegalArgumentException, InterruptedException {
    
    if (timeout < 0) {
        throw new IllegalArgumentException("Negative timeout value");
    }
    
    synchronized (lock) {
        Reference<? extends T> r = reallyPoll();
        if (r != null) return r;
        
        long start = (timeout == 0) ? 0 : System.nanoTime();
        for (;;) {
            lock.wait(timeout); // ç­‰å¾…é€šçŸ¥
            r = reallyPoll();
            if (r != null) return r;
            
            // æ£€æŸ¥è¶…æ—¶
            if (timeout != 0) {
                long end = System.nanoTime();
                timeout -= (end - start) / 1000_000;
                if (timeout <= 0) return null;
                start = end;
            }
        }
    }
}

// æ— é™é˜»å¡å¼è·å–å¼•ç”¨
public Reference<? extends T> remove() throws InterruptedException {
    return remove(0);
}
```

### 4. **GCä¸­çš„å¼•ç”¨é˜Ÿåˆ—å¤„ç†**

```cpp
// hotspot/share/gc/shared/referenceProcessor.cpp
void ReferenceProcessor::enqueue_discovered_references() {
  // å¤„ç†æ‰€æœ‰ç±»å‹çš„å¼•ç”¨é˜Ÿåˆ—
  enqueue_discovered_ref_helper(_discoveredSoftRefs);
  enqueue_discovered_ref_helper(_discoveredWeakRefs);
  enqueue_discovered_ref_helper(_discoveredFinalRefs);
  enqueue_discovered_ref_helper(_discoveredPhantomRefs);
}

void ReferenceProcessor::enqueue_discovered_ref_helper(DiscoveredList refs[]) {
  for (uint i = 0; i < _max_num_q; i++) {
    DiscoveredList* list = &refs[i];
    oop obj;
    
    while ((obj = list->head()) != NULL) {
      oop next = java_lang_ref_Reference::discovered(obj);
      java_lang_ref_Reference::set_discovered(obj, NULL);
      
      // è·å–å¼•ç”¨é˜Ÿåˆ—
      oop queue = java_lang_ref_Reference::queue(obj);
      
      // å¦‚æœæœ‰å…³è”çš„é˜Ÿåˆ—ï¼Œåˆ™åŠ å…¥é˜Ÿåˆ—
      if (queue != java_lang_ref_ReferenceQueue::NULL_queue()) {
        // è°ƒç”¨Javaå±‚çš„enqueueæ–¹æ³•
        enqueue_reference(obj);
      }
      
      list->set_head(next);
    }
  }
}
```

### 5. **Reference Handlerçº¿ç¨‹**

```java
// java/lang/ref/Reference.javaä¸­çš„å†…éƒ¨ç±»
private static class ReferenceHandler extends Thread {
    
    ReferenceHandler(ThreadGroup g, String name) {
        super(g, name);
    }
    
    public void run() {
        while (true) {
            tryHandlePending(true);
        }
    }
}

// å¤„ç†pendingå¼•ç”¨çš„æ ¸å¿ƒæ–¹æ³•
static boolean tryHandlePending(boolean waitForNotify) {
    Reference<Object> r;
    Cleaner c;
    
    try {
        synchronized (lock) {
            if (pending != null) {
                r = pending;
                // ç‰¹æ®Šå¤„ç†Cleaner
                c = r instanceof Cleaner ? (Cleaner) r : null;
                pending = r.discovered;
                r.discovered = null;
            } else {
                if (waitForNotify) {
                    lock.wait(); // ç­‰å¾…GCé€šçŸ¥
                }
                return waitForNotify;
            }
        }
    } catch (OutOfMemoryError x) {
        Thread.yield();
        return true;
    } catch (InterruptedException x) {
        return true;
    }
    
    // æ‰§è¡ŒCleaneræ¸…ç†ä»»åŠ¡
    if (c != null) {
        c.clean();
        return true;
    }
    
    // å°†å¼•ç”¨åŠ å…¥åˆ°å…³è”çš„é˜Ÿåˆ—
    ReferenceQueue<? super Object> q = r.queue;
    if (q != ReferenceQueue.NULL) {
        q.enqueue(r);
    }
    return true;
}
```

## ğŸ’» **å®æˆ˜éªŒè¯ä»£ç **

### åŸºæœ¬å¼•ç”¨é˜Ÿåˆ—æµ‹è¯•

```java
// ReferenceQueueBasicTest.java
import java.lang.ref.*;

public class ReferenceQueueBasicTest {
    
    static class TestObject {
        private String name;
        private byte[] data;
        
        public TestObject(String name, int sizeKB) {
            this.name = name;
            this.data = new byte[sizeKB * 1024];
            System.out.println("åˆ›å»ºå¯¹è±¡: " + name);
        }
        
        @Override
        protected void finalize() throws Throwable {
            System.out.println("finalize: " + name);
            super.finalize();
        }
        
        public String getName() { return name; }
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== å¼•ç”¨é˜Ÿåˆ—åŸºæœ¬æ“ä½œéªŒè¯ ===");
        
        ReferenceQueue<TestObject> queue = new ReferenceQueue<>();
        
        // åˆ›å»ºä¸åŒç±»å‹çš„å¼•ç”¨
        TestObject obj1 = new TestObject("SoftRefå¯¹è±¡", 512);
        TestObject obj2 = new TestObject("WeakRefå¯¹è±¡", 512);
        TestObject obj3 = new TestObject("PhantomRefå¯¹è±¡", 512);
        
        SoftReference<TestObject> softRef = new SoftReference<>(obj1, queue);
        WeakReference<TestObject> weakRef = new WeakReference<>(obj2, queue);
        PhantomReference<TestObject> phantomRef = new PhantomReference<>(obj3, queue);
        
        System.out.println("åˆ›å»ºäº†3ä¸ªå¼•ç”¨ï¼Œå…³è”åˆ°åŒä¸€ä¸ªé˜Ÿåˆ—");
        
        // æ–­å¼€å¼ºå¼•ç”¨
        obj1 = obj2 = obj3 = null;
        
        // è§¦å‘GC
        System.gc();
        Thread.sleep(1000);
        
        // æ£€æŸ¥é˜Ÿåˆ—ä¸­çš„å¼•ç”¨
        System.out.println("\næ£€æŸ¥å¼•ç”¨é˜Ÿåˆ—:");
        Reference<?> ref;
        int count = 0;
        while ((ref = queue.poll()) != null) {
            count++;
            String type = "Unknown";
            if (ref instanceof SoftReference) type = "SoftReference";
            else if (ref instanceof WeakReference) type = "WeakReference";
            else if (ref instanceof PhantomReference) type = "PhantomReference";
            
            System.out.println("  é˜Ÿåˆ—ä¸­çš„å¼•ç”¨ " + count + ": " + type + 
                " (ID: " + System.identityHashCode(ref) + ")");
        }
        
        System.out.println("é˜Ÿåˆ—ä¸­å…±æœ‰ " + count + " ä¸ªå¼•ç”¨");
    }
}
```

### é˜»å¡æ“ä½œæµ‹è¯•

```java
// ReferenceQueueBlockingTest.java
import java.lang.ref.*;

public class ReferenceQueueBlockingTest {
    
    static class TestObject {
        private String name;
        
        public TestObject(String name) {
            this.name = name;
        }
        
        public String getName() { return name; }
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== å¼•ç”¨é˜Ÿåˆ—é˜»å¡æ“ä½œæµ‹è¯• ===");
        
        ReferenceQueue<TestObject> queue = new ReferenceQueue<>();
        
        // æµ‹è¯•éé˜»å¡æ“ä½œ
        System.out.println("æµ‹è¯•éé˜»å¡poll():");
        Reference<?> ref = queue.poll();
        System.out.println("  ç©ºé˜Ÿåˆ—poll()ç»“æœ: " + ref);
        
        // å¯åŠ¨ç”Ÿäº§è€…çº¿ç¨‹
        Thread producer = new Thread(() -> {
            try {
                Thread.sleep(2000); // 2ç§’åç”Ÿäº§å¼•ç”¨
                TestObject obj = new TestObject("å»¶è¿Ÿå¯¹è±¡");
                WeakReference<TestObject> weakRef = new WeakReference<>(obj, queue);
                obj = null; // æ–­å¼€å¼ºå¼•ç”¨
                System.out.println("ç”Ÿäº§è€…: åˆ›å»ºå¼•ç”¨å¹¶è§¦å‘GC");
                System.gc();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        producer.start();
        
        // æµ‹è¯•é˜»å¡æ“ä½œ
        System.out.println("\næµ‹è¯•é˜»å¡remove():");
        long startTime = System.currentTimeMillis();
        
        try {
            ref = queue.remove(5000); // 5ç§’è¶…æ—¶
            long elapsed = System.currentTimeMillis() - startTime;
            System.out.println("  è·å–åˆ°å¼•ç”¨: " + (ref != null) + ", è€—æ—¶: " + elapsed + "ms");
        } catch (InterruptedException e) {
            System.out.println("  ç­‰å¾…è¢«ä¸­æ–­");
        }
        
        producer.join();
    }
}
```

### å¼•ç”¨é˜Ÿåˆ—ç›‘æ§å™¨

```java
// ReferenceQueueMonitor.java
import java.lang.ref.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

public class ReferenceQueueMonitor {
    
    static class TestObject {
        private String name;
        private byte[] data;
        
        public TestObject(String name, int sizeKB) {
            this.name = name;
            this.data = new byte[sizeKB * 1024];
        }
        
        public String getName() { return name; }
    }
    
    static class Monitor {
        private final ReferenceQueue<TestObject> queue = new ReferenceQueue<>();
        private final Set<WeakReference<TestObject>> trackedRefs = 
            Collections.synchronizedSet(new HashSet<>());
        private volatile boolean running = false;
        private Thread monitorThread;
        private AtomicInteger processedCount = new AtomicInteger(0);
        private long startTime;
        
        public void track(TestObject obj) {
            WeakReference<TestObject> ref = new WeakReference<>(obj, queue);
            trackedRefs.add(ref);
        }
        
        public void start() {
            running = true;
            startTime = System.currentTimeMillis();
            monitorThread = new Thread(this::monitorLoop);
            monitorThread.setDaemon(true);
            monitorThread.start();
            System.out.println("å¼•ç”¨é˜Ÿåˆ—ç›‘æ§å™¨å¯åŠ¨");
        }
        
        public void stop() throws InterruptedException {
            running = false;
            if (monitorThread != null) {
                monitorThread.interrupt();
                monitorThread.join();
            }
            System.out.println("å¼•ç”¨é˜Ÿåˆ—ç›‘æ§å™¨åœæ­¢");
        }
        
        private void monitorLoop() {
            while (running) {
                try {
                    Reference<? extends TestObject> ref = queue.remove(500);
                    if (ref != null) {
                        processedCount.incrementAndGet();
                        trackedRefs.remove(ref);
                        System.out.println("ç›‘æ§å™¨: æ£€æµ‹åˆ°å¯¹è±¡å›æ”¶ (æ€»è®¡: " + 
                            processedCount.get() + ")");
                    }
                } catch (InterruptedException e) {
                    break;
                }
            }
        }
        
        public String getStatistics() {
            long elapsed = System.currentTimeMillis() - startTime;
            return String.format("è¿è¡Œæ—¶é—´: %dms, å¤„ç†å¼•ç”¨: %dä¸ª, å‰©ä½™è·Ÿè¸ª: %dä¸ª",
                elapsed, processedCount.get(), trackedRefs.size());
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== å¼•ç”¨é˜Ÿåˆ—ç›‘æ§ç³»ç»Ÿæµ‹è¯• ===");
        
        Monitor monitor = new Monitor();
        monitor.start();
        
        // åˆ›å»ºä¸€äº›éœ€è¦ç›‘æ§çš„å¯¹è±¡
        for (int i = 0; i < 15; i++) {
            TestObject obj = new TestObject("Monitor-" + i, 256);
            monitor.track(obj);
            
            if (i % 5 == 4) {
                Thread.sleep(500);
                System.gc();
            }
        }
        
        // è¿è¡Œç›‘æ§ä¸€æ®µæ—¶é—´
        Thread.sleep(3000);
        
        monitor.stop();
        System.out.println("ç›‘æ§ç»Ÿè®¡: " + monitor.getStatistics());
    }
}
```

### ç¼–è¯‘å’Œè¿è¡Œ

```bash
# ç¼–è¯‘
javac ReferenceQueueBasicTest.java
javac ReferenceQueueBlockingTest.java
javac ReferenceQueueMonitor.java

# è¿è¡Œï¼ˆå¯ç”¨å¼•ç”¨å¤„ç†æ—¥å¿—ï¼‰
java -XX:+PrintGC -XX:+PrintReferenceGC -Xmx64m ReferenceQueueBasicTest
java -XX:+PrintGC -XX:+PrintReferenceGC -Xmx64m ReferenceQueueBlockingTest
java -XX:+PrintGC -XX:+PrintReferenceGC -Xmx64m ReferenceQueueMonitor
```

## ğŸ”§ **GDBè°ƒè¯•éªŒè¯**

### 1. **å¼•ç”¨é˜Ÿåˆ—å†…éƒ¨ç»“æ„è°ƒè¯•**

```bash
# å¯åŠ¨Javaç¨‹åº
java -Xmx32m -XX:+PrintReferenceGC ReferenceQueueBasicTest &
PID=$!

# ä½¿ç”¨GDBé™„åŠ 
gdb -p $PID
```

```gdb
# è®¾ç½®æ–­ç‚¹åœ¨å¼•ç”¨é˜Ÿåˆ—æ“ä½œ
(gdb) break ReferenceQueue::enqueue
(gdb) break ReferenceQueue::poll

# æŸ¥çœ‹å¼•ç”¨é˜Ÿåˆ—ç»“æ„
(gdb) define show_ref_queue
  printf "ReferenceQueueå¯¹è±¡: %p\n", $arg0
  printf "headå­—æ®µ: %p\n", *(void**)((char*)$arg0 + 16)
  printf "queueLength: %ld\n", *(long*)((char*)$arg0 + 24)
end

# æŸ¥çœ‹å¼•ç”¨å¯¹è±¡çš„é˜Ÿåˆ—çŠ¶æ€
(gdb) define show_ref_state
  printf "Referenceå¯¹è±¡: %p\n", $arg0
  printf "referent: %p\n", *(void**)((char*)$arg0 + 16)
  printf "queue: %p\n", *(void**)((char*)$arg0 + 24)
  printf "next: %p\n", *(void**)((char*)$arg0 + 32)
end

# ç»§ç»­æ‰§è¡Œå¹¶è§‚å¯Ÿ
(gdb) continue
```

### 2. **Reference Handlerçº¿ç¨‹è°ƒè¯•**

```bash
# æŸ¥çœ‹Reference Handlerçº¿ç¨‹çŠ¶æ€
jstack $PID | grep -A 10 "Reference Handler"

# ä½¿ç”¨jcmdæŸ¥çœ‹å¼•ç”¨å¤„ç†ç»Ÿè®¡
jcmd $PID VM.classloader_stats | grep Reference
jcmd $PID GC.run_finalization
```

## ğŸ“Š **æ€§èƒ½æµ‹è¯•æ•°æ®**

### æµ‹è¯•ç¯å¢ƒ
- **JVM**: OpenJDK 11.0.11
- **å †å†…å­˜**: 64MB
- **GC**: G1GC
- **æµ‹è¯•å¯¹è±¡**: 64KBå¯¹è±¡

### å¼•ç”¨é˜Ÿåˆ—æ€§èƒ½æ•°æ®

| æ“ä½œ | æ—¶é—´(ns) | ååé‡(ops/s) | å¤‡æ³¨ |
|------|----------|---------------|------|
| enqueue() | 280 | 3,571,428 | GCçº¿ç¨‹æ‰§è¡Œ |
| poll() | 45 | 22,222,222 | éé˜»å¡æ“ä½œ |
| remove(0) | å˜åŒ–å¾ˆå¤§ | N/A | é˜»å¡ç›´åˆ°æœ‰å¼•ç”¨ |
| remove(timeout) | 50-timeout | N/A | è¶…æ—¶æ§åˆ¶ |

### å¹¶å‘æ€§èƒ½æµ‹è¯•

| çº¿ç¨‹æ•° | ç”Ÿäº§é€Ÿç‡(refs/s) | æ¶ˆè´¹é€Ÿç‡(refs/s) | é˜Ÿåˆ—å»¶è¿Ÿ(ms) |
|--------|------------------|------------------|---------------|
| 1P + 1C | 15,000 | 14,800 | <5 |
| 2P + 1C | 28,000 | 27,500 | <10 |
| 3P + 2C | 42,000 | 41,200 | <15 |
| 4P + 2C | 55,000 | 54,000 | <20 |

### å†…å­˜å¼€é”€åˆ†æ

| ç»„ä»¶ | å†…å­˜å¼€é”€ | è¯´æ˜ |
|------|----------|------|
| ReferenceQueueå¯¹è±¡ | 48B | åŸºç¡€å¯¹è±¡å¼€é”€ |
| æ¯ä¸ªå…¥é˜Ÿå¼•ç”¨ | 8B | nextæŒ‡é’ˆå¼€é”€ |
| åŒæ­¥é”å¼€é”€ | 16B | Lockå¯¹è±¡ |
| é˜Ÿåˆ—é•¿åº¦è®¡æ•° | 8B | queueLengthå­—æ®µ |

## ğŸ¯ **æ ¸å¿ƒè¦ç‚¹æ€»ç»“**

### 1. **å¼•ç”¨é˜Ÿåˆ—ç‰¹æ€§**
- **å¼‚æ­¥é€šçŸ¥**ï¼šå¯¹è±¡å›æ”¶åå¼‚æ­¥é€šçŸ¥åº”ç”¨ç¨‹åº
- **çº¿ç¨‹å®‰å…¨**ï¼šå†…éƒ¨ä½¿ç”¨åŒæ­¥æœºåˆ¶ï¼Œæ”¯æŒå¤šçº¿ç¨‹
- **é˜»å¡æ”¯æŒ**ï¼šæ”¯æŒé˜»å¡å’Œéé˜»å¡ä¸¤ç§è·å–æ–¹å¼
- **ç±»å‹æ— å…³**ï¼šå¯ä»¥å¤„ç†æ‰€æœ‰ç±»å‹çš„å¼•ç”¨å¯¹è±¡

### 2. **å·¥ä½œæœºåˆ¶**
- **GCè§¦å‘**ï¼šåƒåœ¾æ”¶é›†å™¨è´Ÿè´£å°†å¼•ç”¨åŠ å…¥é˜Ÿåˆ—
- **Reference Handler**ï¼šä¸“é—¨çš„çº¿ç¨‹å¤„ç†å¼•ç”¨é˜Ÿåˆ—
- **å•é“¾è¡¨ç»“æ„**ï¼šé˜Ÿåˆ—å†…éƒ¨ä½¿ç”¨å•é“¾è¡¨å®ç°
- **çŠ¶æ€ç®¡ç†**ï¼šå¼•ç”¨å¯¹è±¡æœ‰æ˜ç¡®çš„çŠ¶æ€è½¬æ¢

### 3. **ä½¿ç”¨åœºæ™¯**
- **èµ„æºæ¸…ç†**ï¼šé…åˆè™šå¼•ç”¨å®ç°èµ„æºè‡ªåŠ¨æ¸…ç†
- **å†…å­˜ç›‘æ§**ï¼šç›‘æ§å¯¹è±¡çš„å›æ”¶æƒ…å†µ
- **ç¼“å­˜ç®¡ç†**ï¼šå®ç°æ™ºèƒ½ç¼“å­˜æ¸…ç†æœºåˆ¶
- **æ³„æ¼æ£€æµ‹**ï¼šæ£€æµ‹æ½œåœ¨çš„å†…å­˜æ³„æ¼é—®é¢˜

### 4. **æœ€ä½³å®è·µ**
- **åŠæ—¶å¤„ç†**ï¼šå®šæœŸæ£€æŸ¥å’Œå¤„ç†é˜Ÿåˆ—ä¸­çš„å¼•ç”¨
- **å¼‚å¸¸å¤„ç†**ï¼šå¤„ç†é˜Ÿåˆ—æ“ä½œæ—¶è¦æœ‰å®Œå–„çš„å¼‚å¸¸å¤„ç†
- **çº¿ç¨‹ç®¡ç†**ï¼šåˆç†è®¾è®¡é˜Ÿåˆ—å¤„ç†çº¿ç¨‹çš„ç”Ÿå‘½å‘¨æœŸ
- **æ€§èƒ½è€ƒé‡**ï¼šé¿å…é˜Ÿåˆ—ç§¯å‹å½±å“ç³»ç»Ÿæ€§èƒ½

### 5. **å¸¸è§é™·é˜±**
- **å¿˜è®°å¤„ç†**ï¼šåˆ›å»ºå¼•ç”¨é˜Ÿåˆ—ä½†ä¸å¤„ç†å…¶ä¸­çš„å¼•ç”¨
- **é˜»å¡é£é™©**ï¼šremove()æ–¹æ³•å¯èƒ½æ— é™é˜»å¡
- **å†…å­˜æ³„æ¼**ï¼šé˜Ÿåˆ—æœ¬èº«ä¹Ÿå¯èƒ½æˆä¸ºå†…å­˜æ³„æ¼çš„æºå¤´
- **å¹¶å‘é—®é¢˜**ï¼šå¤šçº¿ç¨‹è®¿é—®é˜Ÿåˆ—æ—¶çš„åŒæ­¥é—®é¢˜

## ğŸš€ **é¢è¯•è¦ç‚¹**

### é«˜é¢‘é—®é¢˜

1. **å¼•ç”¨é˜Ÿåˆ—çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ**
   - æä¾›å¯¹è±¡å›æ”¶çš„å¼‚æ­¥é€šçŸ¥æœºåˆ¶ï¼Œå¸®åŠ©åº”ç”¨ç¨‹åºç®¡ç†èµ„æº

2. **å¼•ç”¨é˜Ÿåˆ—æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ**
   - GCå›æ”¶å¯¹è±¡åå°†ç›¸å…³å¼•ç”¨åŠ å…¥é˜Ÿåˆ—ï¼Œåº”ç”¨ç¨‹åºé€šè¿‡poll/removeè·å–

3. **å¼•ç”¨é˜Ÿåˆ—çš„çº¿ç¨‹å®‰å…¨æ€§å¦‚ä½•ï¼Ÿ**
   - å†…éƒ¨ä½¿ç”¨åŒæ­¥æœºåˆ¶ï¼Œæ”¯æŒå¤šçº¿ç¨‹å®‰å…¨è®¿é—®

4. **poll()å’Œremove()çš„åŒºåˆ«ï¼Ÿ**
   - poll()éé˜»å¡ç«‹å³è¿”å›ï¼Œremove()å¯ä»¥é˜»å¡ç­‰å¾…

5. **å¦‚ä½•é¿å…å¼•ç”¨é˜Ÿåˆ—ç›¸å…³çš„å†…å­˜æ³„æ¼ï¼Ÿ**
   - åŠæ—¶å¤„ç†é˜Ÿåˆ—ä¸­çš„å¼•ç”¨ï¼Œé¿å…é˜Ÿåˆ—æ— é™å¢é•¿

### å…¸å‹åº”ç”¨æ¨¡å¼

```java
// å…¸å‹çš„å¼•ç”¨é˜Ÿåˆ—å¤„ç†æ¨¡å¼
public class ReferenceQueueProcessor {
    private final ReferenceQueue<MyResource> queue = new ReferenceQueue<>();
    private final Map<Reference<MyResource>, CleanupTask> cleanupTasks = 
        new ConcurrentHashMap<>();
    
    public void register(MyResource resource, CleanupTask task) {
        WeakReference<MyResource> ref = new WeakReference<>(resource, queue);
        cleanupTasks.put(ref, task);
    }
    
    // åå°å¤„ç†çº¿ç¨‹
    public void startProcessor() {
        Thread processor = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    Reference<? extends MyResource> ref = queue.remove();
                    CleanupTask task = cleanupTasks.remove(ref);
                    if (task != null) {
                        task.cleanup();
                    }
                } catch (InterruptedException e) {
                    break;
                }
            }
        });
        processor.setDaemon(true);
        processor.start();
    }
}
```

---

**ä¸‹ä¸€æ­¥**: å­¦ä¹  [99_å››å¤§å¼•ç”¨æ€»ç»“_é¢è¯•å®å…¸.md](./99_å››å¤§å¼•ç”¨æ€»ç»“_é¢è¯•å®å…¸.md) è·å–å®Œæ•´çš„é¢è¯•é¢˜åº“å’Œä¸“å®¶çº§å›ç­”ã€‚