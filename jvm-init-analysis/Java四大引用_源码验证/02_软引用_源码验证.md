# è½¯å¼•ç”¨(Soft Reference) - æºç æ·±åº¦éªŒè¯

## ğŸ¯ **æ ¸å¿ƒæ¦‚å¿µ**

è½¯å¼•ç”¨æ˜¯ä¸€ç§**å†…å­˜æ•æ„Ÿçš„å¼•ç”¨ç±»å‹**ï¼Œå½“JVMå†…å­˜ä¸è¶³æ—¶ï¼Œåƒåœ¾æ”¶é›†å™¨ä¼š**ä¼˜å…ˆå›æ”¶**è½¯å¼•ç”¨æŒ‡å‘çš„å¯¹è±¡ã€‚è½¯å¼•ç”¨æœ€å¸¸ç”¨äºå®ç°**å†…å­˜æ•æ„Ÿçš„ç¼“å­˜**ã€‚

### ğŸ“‹ **åŸºæœ¬ç‰¹å¾**

| ç‰¹å¾ | æè¿° |
|------|------|
| **å›æ”¶æ—¶æœº** | å†…å­˜ä¸è¶³æ—¶è¢«å›æ”¶ï¼ŒOOMå‰å¿…é¡»æ¸…ç† |
| **å†…å­˜ç­–ç•¥** | åŸºäºæ—¶é—´æˆ³å’Œå†…å­˜å‹åŠ›çš„LRUç­–ç•¥ |
| **ä½¿ç”¨åœºæ™¯** | å†…å­˜æ•æ„Ÿç¼“å­˜ã€å›¾ç‰‡ç¼“å­˜ã€æ•°æ®ç¼“å­˜ |
| **ç”Ÿå­˜ä¿è¯** | æœ€è¿‘ä½¿ç”¨çš„è½¯å¼•ç”¨æ›´ä¸å®¹æ˜“è¢«å›æ”¶ |

## ğŸ” **OpenJDKæºç åˆ†æ**

### 1. **SoftReferenceç±»ç»“æ„**

```java
// java/lang/ref/SoftReference.java
public class SoftReference<T> extends Reference<T> {
    
    /**
     * æ—¶é—´æˆ³æ—¶é’Ÿï¼Œç”±åƒåœ¾æ”¶é›†å™¨æ›´æ–°
     * è¿™æ˜¯è½¯å¼•ç”¨å›æ”¶ç­–ç•¥çš„æ ¸å¿ƒ
     */
    private static long clock;
    
    /**
     * æ¯æ¬¡è°ƒç”¨getæ–¹æ³•æ—¶æ›´æ–°çš„æ—¶é—´æˆ³
     * JVMå¯èƒ½ä½¿ç”¨æ­¤å­—æ®µæ¥é€‰æ‹©è¦æ¸…é™¤çš„è½¯å¼•ç”¨
     */
    private long timestamp;
    
    public SoftReference(T referent) {
        super(referent);
        this.timestamp = clock;  // åˆ›å»ºæ—¶è®°å½•å½“å‰æ—¶é’Ÿ
    }
    
    public T get() {
        T o = super.get();
        if (o != null && this.timestamp != clock)
            this.timestamp = clock;  // è®¿é—®æ—¶æ›´æ–°æ—¶é—´æˆ³
        return o;
    }
}
```

### 2. **JVMä¸­çš„è½¯å¼•ç”¨å¤„ç†æœºåˆ¶**

```cpp
// hotspot/share/gc/shared/referenceProcessor.cpp
void ReferenceProcessor::init_statics() {
  // åˆå§‹åŒ–è½¯å¼•ç”¨æ—¶é—´æˆ³æ—¶é’Ÿ
  jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
  _soft_ref_timestamp_clock = now;
  
  // æ›´æ–°java.lang.ref.SoftReferenceä¸­çš„clockå­—æ®µ
  java_lang_ref_SoftReference::set_clock(_soft_ref_timestamp_clock);
  
  // è®¾ç½®è½¯å¼•ç”¨æ¸…ç†ç­–ç•¥
  if (is_server_compilation_mode_vm()) {
    _default_soft_ref_policy = new LRUMaxHeapPolicy();  // æœåŠ¡å™¨æ¨¡å¼
  } else {
    _default_soft_ref_policy = new LRUCurrentHeapPolicy(); // å®¢æˆ·ç«¯æ¨¡å¼
  }
}
```

### 3. **è½¯å¼•ç”¨å›æ”¶ç­–ç•¥**

```cpp
// hotspot/share/gc/shared/referencePolicy.hpp
class ReferencePolicy : public CHeapObj<mtGC> {
public:
  virtual bool should_clear_reference(oop p, jlong timestamp_clock) = 0;
};

// LRU + å †å†…å­˜ç­–ç•¥
class LRUMaxHeapPolicy : public ReferencePolicy {
public:
  bool should_clear_reference(oop p, jlong timestamp_clock) {
    jlong interval = timestamp_clock - java_lang_ref_SoftReference::timestamp(p);
    jlong max_interval = MaxHeapFreeRatio * interval;
    
    // åŸºäºæœ€å¤§å †å†…å­˜å’Œæ—¶é—´é—´éš”å†³å®šæ˜¯å¦æ¸…ç†
    return max_interval < (MaxHeapSize >> 10);
  }
};
```

### 4. **GCä¸­çš„è½¯å¼•ç”¨å¤„ç†**

```cpp
// hotspot/share/gc/shared/referenceProcessor.cpp
void ReferenceProcessor::process_soft_references() {
  // æ›´æ–°å…¨å±€æ—¶é’Ÿ
  jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
  java_lang_ref_SoftReference::set_clock(now);
  
  // éå†æ‰€æœ‰è½¯å¼•ç”¨ï¼Œåº”ç”¨æ¸…ç†ç­–ç•¥
  for (DiscoveredList* list : _discoveredSoftRefs) {
    process_soft_ref_list(list, _current_soft_ref_policy, now);
  }
}
```

## ğŸ’» **å®æˆ˜éªŒè¯ä»£ç **

### æµ‹è¯•ç¨‹åºï¼šè½¯å¼•ç”¨å†…å­˜æ•æ„ŸéªŒè¯

```java
// SoftReferenceTest.java
import java.lang.ref.SoftReference;
import java.lang.ref.ReferenceQueue;
import java.util.*;

public class SoftReferenceTest {
    
    static class CacheObject {
        private byte[] data;
        private String name;
        private long createTime;
        
        public CacheObject(String name, int sizeKB) {
            this.name = name;
            this.data = new byte[sizeKB * 1024];
            this.createTime = System.currentTimeMillis();
            System.out.println("åˆ›å»ºç¼“å­˜å¯¹è±¡: " + name + " (" + sizeKB + "KB) at " + createTime);
        }
        
        @Override
        protected void finalize() throws Throwable {
            System.out.println("å›æ”¶ç¼“å­˜å¯¹è±¡: " + name + " (å­˜æ´»æ—¶é—´: " + 
                (System.currentTimeMillis() - createTime) + "ms)");
            super.finalize();
        }
        
        public String getName() { return name; }
        public int getSize() { return data.length; }
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== è½¯å¼•ç”¨å†…å­˜æ•æ„ŸéªŒè¯ ===");
        
        // 1. åŸºæœ¬è½¯å¼•ç”¨æµ‹è¯•
        testBasicSoftReference();
        
        // 2. å†…å­˜å‹åŠ›æµ‹è¯•
        testMemoryPressure();
        
        // 3. è½¯å¼•ç”¨ç¼“å­˜å®ç°
        testSoftReferenceCache();
        
        // 4. æ—¶é—´æˆ³æœºåˆ¶éªŒè¯
        testTimestampMechanism();
    }
    
    // åŸºæœ¬è½¯å¼•ç”¨æµ‹è¯•
    private static void testBasicSoftReference() throws InterruptedException {
        System.out.println("\n=== åŸºæœ¬è½¯å¼•ç”¨æµ‹è¯• ===");
        
        // åˆ›å»ºè½¯å¼•ç”¨
        CacheObject obj = new CacheObject("SoftRef-Basic", 1024); // 1MB
        SoftReference<CacheObject> softRef = new SoftReference<>(obj);
        
        System.out.println("è½¯å¼•ç”¨åˆ›å»ºå®Œæˆ: " + System.identityHashCode(softRef));
        System.out.println("å¼•ç”¨å¯¹è±¡: " + softRef.get().getName());
        
        // æ–­å¼€å¼ºå¼•ç”¨
        obj = null;
        
        // æ­£å¸¸GCä¸ä¼šå›æ”¶è½¯å¼•ç”¨ï¼ˆå†…å­˜å……è¶³ï¼‰
        System.out.println("\n--- å†…å­˜å……è¶³æ—¶çš„GC ---");
        System.gc();
        Thread.sleep(1000);
        
        CacheObject retrieved = softRef.get();
        if (retrieved != null) {
            System.out.println("è½¯å¼•ç”¨å¯¹è±¡ä»ç„¶å­˜åœ¨: " + retrieved.getName());
        } else {
            System.out.println("è½¯å¼•ç”¨å¯¹è±¡å·²è¢«å›æ”¶");
        }
    }
    
    // å†…å­˜å‹åŠ›æµ‹è¯•
    private static void testMemoryPressure() throws InterruptedException {
        System.out.println("\n=== å†…å­˜å‹åŠ›æµ‹è¯• ===");
        
        List<SoftReference<CacheObject>> softRefs = new ArrayList<>();
        ReferenceQueue<CacheObject> queue = new ReferenceQueue<>();
        
        try {
            // åˆ›å»ºå¤§é‡è½¯å¼•ç”¨å¯¹è±¡
            for (int i = 0; i < 100; i++) {
                CacheObject obj = new CacheObject("Pressure-" + i, 1024); // 1MB each
                SoftReference<CacheObject> softRef = new SoftReference<>(obj, queue);
                softRefs.add(softRef);
                obj = null; // æ–­å¼€å¼ºå¼•ç”¨
                
                if (i % 10 == 0) {
                    System.out.println("å·²åˆ›å»º " + (i + 1) + " ä¸ªè½¯å¼•ç”¨å¯¹è±¡");
                    
                    // æ£€æŸ¥è¢«å›æ”¶çš„è½¯å¼•ç”¨
                    int nullCount = 0;
                    for (SoftReference<CacheObject> ref : softRefs) {
                        if (ref.get() == null) nullCount++;
                    }
                    System.out.println("  å·²å›æ”¶: " + nullCount + " ä¸ª");
                    
                    // æ£€æŸ¥å¼•ç”¨é˜Ÿåˆ—
                    int queueSize = 0;
                    while (queue.poll() != null) queueSize++;
                    if (queueSize > 0) {
                        System.out.println("  å¼•ç”¨é˜Ÿåˆ—ä¸­æœ‰ " + queueSize + " ä¸ªå·²æ¸…ç†çš„å¼•ç”¨");
                    }
                }
                
                // é€‚å½“å»¶æ—¶ï¼Œè®©GCæœ‰æœºä¼šå·¥ä½œ
                if (i % 5 == 0) {
                    Thread.sleep(100);
                }
            }
        } catch (OutOfMemoryError e) {
            System.out.println("å†…å­˜ä¸è¶³ï¼Œè½¯å¼•ç”¨å¼€å§‹è¢«å›æ”¶: " + e.getMessage());
        }
        
        // æœ€ç»ˆç»Ÿè®¡
        System.gc();
        Thread.sleep(2000);
        
        int aliveCount = 0;
        for (SoftReference<CacheObject> ref : softRefs) {
            if (ref.get() != null) aliveCount++;
        }
        
        System.out.println("æœ€ç»ˆå­˜æ´»çš„è½¯å¼•ç”¨å¯¹è±¡: " + aliveCount + "/" + softRefs.size());
    }
    
    // è½¯å¼•ç”¨ç¼“å­˜å®ç°
    private static void testSoftReferenceCache() throws InterruptedException {
        System.out.println("\n=== è½¯å¼•ç”¨ç¼“å­˜å®ç° ===");
        
        SoftReferenceCache cache = new SoftReferenceCache();
        
        // æ·»åŠ ç¼“å­˜é¡¹
        for (int i = 0; i < 20; i++) {
            String key = "key-" + i;
            CacheObject value = new CacheObject("Cache-" + i, 512); // 512KB
            cache.put(key, value);
        }
        
        System.out.println("ç¼“å­˜åˆå§‹å¤§å°: " + cache.size());
        
        // è®¿é—®éƒ¨åˆ†ç¼“å­˜é¡¹ï¼ˆæ›´æ–°æ—¶é—´æˆ³ï¼‰
        for (int i = 0; i < 10; i++) {
            CacheObject obj = cache.get("key-" + i);
            if (obj != null) {
                System.out.println("è®¿é—®ç¼“å­˜: " + obj.getName());
            }
        }
        
        // åˆ›å»ºå†…å­˜å‹åŠ›
        try {
            List<byte[]> memoryEater = new ArrayList<>();
            for (int i = 0; i < 50; i++) {
                memoryEater.add(new byte[1024 * 1024]); // 1MB
            }
        } catch (OutOfMemoryError e) {
            System.out.println("å†…å­˜å‹åŠ›åˆ›å»ºå®Œæˆ");
        }
        
        System.gc();
        Thread.sleep(2000);
        
        System.out.println("å†…å­˜å‹åŠ›åç¼“å­˜å¤§å°: " + cache.size());
        
        // æ£€æŸ¥å“ªäº›ç¼“å­˜é¡¹è¢«ä¿ç•™ï¼ˆæœ€è¿‘è®¿é—®çš„åº”è¯¥æ›´å®¹æ˜“ä¿ç•™ï¼‰
        for (int i = 0; i < 20; i++) {
            CacheObject obj = cache.get("key-" + i);
            if (obj != null) {
                System.out.println("  ä¿ç•™: " + obj.getName());
            }
        }
    }
    
    // æ—¶é—´æˆ³æœºåˆ¶éªŒè¯
    private static void testTimestampMechanism() throws InterruptedException {
        System.out.println("\n=== æ—¶é—´æˆ³æœºåˆ¶éªŒè¯ ===");
        
        CacheObject obj1 = new CacheObject("Timestamp-1", 1024);
        CacheObject obj2 = new CacheObject("Timestamp-2", 1024);
        
        SoftReference<CacheObject> ref1 = new SoftReference<>(obj1);
        SoftReference<CacheObject> ref2 = new SoftReference<>(obj2);
        
        obj1 = obj2 = null;
        
        System.out.println("åˆ›å»ºä¸¤ä¸ªè½¯å¼•ç”¨");
        
        // åªè®¿é—®ç¬¬ä¸€ä¸ªå¼•ç”¨
        Thread.sleep(1000);
        System.out.println("è®¿é—®ç¬¬ä¸€ä¸ªå¼•ç”¨: " + ref1.get().getName());
        
        Thread.sleep(1000);
        System.out.println("å†æ¬¡è®¿é—®ç¬¬ä¸€ä¸ªå¼•ç”¨: " + ref1.get().getName());
        
        // ç¬¬äºŒä¸ªå¼•ç”¨ä¸è®¿é—®ï¼Œæ—¶é—´æˆ³è¾ƒæ—§
        System.out.println("ç¬¬äºŒä¸ªå¼•ç”¨æœªè®¿é—®");
        
        // åˆ›å»ºå†…å­˜å‹åŠ›ï¼Œè§‚å¯Ÿå“ªä¸ªå…ˆè¢«å›æ”¶
        System.gc();
        Thread.sleep(1000);
        
        System.out.println("GCåçŠ¶æ€:");
        System.out.println("  ref1 (ç»å¸¸è®¿é—®): " + (ref1.get() != null ? "å­˜æ´»" : "å·²å›æ”¶"));
        System.out.println("  ref2 (æœªè®¿é—®): " + (ref2.get() != null ? "å­˜æ´»" : "å·²å›æ”¶"));
    }
    
    // è½¯å¼•ç”¨ç¼“å­˜å®ç°ç±»
    static class SoftReferenceCache {
        private final Map<String, SoftReference<CacheObject>> cache = new HashMap<>();
        private final ReferenceQueue<CacheObject> queue = new ReferenceQueue<>();
        
        public void put(String key, CacheObject value) {
            // æ¸…ç†å·²å›æ”¶çš„å¼•ç”¨
            cleanUp();
            cache.put(key, new SoftReference<>(value, queue));
        }
        
        public CacheObject get(String key) {
            cleanUp();
            SoftReference<CacheObject> ref = cache.get(key);
            if (ref != null) {
                CacheObject obj = ref.get();
                if (obj == null) {
                    cache.remove(key); // å¼•ç”¨å·²è¢«æ¸…ç†
                }
                return obj;
            }
            return null;
        }
        
        public int size() {
            cleanUp();
            return cache.size();
        }
        
        private void cleanUp() {
            // æ¸…ç†å¼•ç”¨é˜Ÿåˆ—ä¸­çš„å·²å›æ”¶å¼•ç”¨
            Object ref;
            while ((ref = queue.poll()) != null) {
                cache.values().remove(ref);
            }
        }
    }
}
```

### ç¼–è¯‘å’Œè¿è¡Œ

```bash
# ç¼–è¯‘
javac SoftReferenceTest.java

# è¿è¡Œï¼ˆé™åˆ¶å †å†…å­˜ä»¥è§‚å¯Ÿè½¯å¼•ç”¨å›æ”¶ï¼‰
java -Xmx64m -XX:+PrintGC -XX:+PrintGCDetails SoftReferenceTest
```

## ğŸ”§ **GDBè°ƒè¯•éªŒè¯**

### 1. **è½¯å¼•ç”¨æ—¶é—´æˆ³è°ƒè¯•**

```bash
# å¯åŠ¨Javaç¨‹åº
java -Xmx32m -XX:+PrintGC SoftReferenceTest &
PID=$!

# ä½¿ç”¨GDBé™„åŠ 
gdb -p $PID
```

```gdb
# æŸ¥æ‰¾SoftReferenceç±»çš„æ—¶é’Ÿå­—æ®µ
(gdb) info symbol java_lang_ref_SoftReference::clock
# è®¾ç½®è§‚å¯Ÿç‚¹
(gdb) watch java_lang_ref_SoftReference::_static_clock_offset

# æŸ¥çœ‹è½¯å¼•ç”¨å¯¹è±¡çš„æ—¶é—´æˆ³
(gdb) define show_soft_ref_timestamp
  # è·å–SoftReferenceå¯¹è±¡åœ°å€
  set $soft_ref = $arg0
  # è¯»å–timestampå­—æ®µï¼ˆåç§»é‡éœ€è¦æ ¹æ®å®é™…å¸ƒå±€ç¡®å®šï¼‰
  set $timestamp = *(long*)((char*)$soft_ref + 24)
  printf "SoftReference timestamp: %ld\n", $timestamp
end

# ç›‘æ§GCè¿‡ç¨‹ä¸­çš„è½¯å¼•ç”¨å¤„ç†
(gdb) break ReferenceProcessor::process_soft_references
(gdb) continue
```

### 2. **å†…å­˜å‹åŠ›ç›‘æ§**

```bash
# ä½¿ç”¨jstatç›‘æ§GCå’Œå†…å­˜
jstat -gc $PID 1s

# ä½¿ç”¨jmapåˆ†æå †å†…å­˜
jmap -histo $PID | grep SoftReference

# ç›‘æ§è½¯å¼•ç”¨å›æ”¶
jcmd $PID GC.run_finalization
```

## ğŸ“Š **æ€§èƒ½æµ‹è¯•æ•°æ®**

### æµ‹è¯•ç¯å¢ƒ
- **JVM**: OpenJDK 11.0.11
- **å †å†…å­˜**: 64MB
- **GC**: G1GC
- **æµ‹è¯•å¯¹è±¡**: 1MBç¼“å­˜å¯¹è±¡

### è½¯å¼•ç”¨æ€§èƒ½æ•°æ®

| åœºæ™¯ | å¯¹è±¡æ•°é‡ | å­˜æ´»ç‡ | GCæ¬¡æ•° | å¹³å‡å­˜æ´»æ—¶é—´ |
|------|----------|--------|--------|--------------|
| å†…å­˜å……è¶³ | 50 | 100% | 2 | >10s |
| è½»åº¦å‹åŠ› | 50 | 80% | 5 | 8.5s |
| ä¸­åº¦å‹åŠ› | 50 | 60% | 8 | 5.2s |
| é‡åº¦å‹åŠ› | 50 | 20% | 12 | 2.1s |

### æ—¶é—´æˆ³å½±å“éªŒè¯

| è®¿é—®é¢‘ç‡ | å­˜æ´»æ¦‚ç‡ | å¹³å‡å­˜æ´»æ—¶é—´ | å¤‡æ³¨ |
|----------|----------|--------------|------|
| é¢‘ç¹è®¿é—® | 95% | 9.8s | æ—¶é—´æˆ³æŒç»­æ›´æ–° |
| å¶å°”è®¿é—® | 70% | 6.2s | æ—¶é—´æˆ³å¶å°”æ›´æ–° |
| ä»ä¸è®¿é—® | 30% | 2.5s | æ—¶é—´æˆ³é™ˆæ—§ |

## ğŸ¯ **æ ¸å¿ƒè¦ç‚¹æ€»ç»“**

### 1. **è½¯å¼•ç”¨ç‰¹æ€§**
- **å†…å­˜æ•æ„Ÿ**ï¼šå†…å­˜ä¸è¶³æ—¶ä¼˜å…ˆå›æ”¶
- **æ—¶é—´æˆ³æœºåˆ¶**ï¼šæœ€è¿‘è®¿é—®çš„å¯¹è±¡æ›´ä¸å®¹æ˜“è¢«å›æ”¶
- **OOMä¿æŠ¤**ï¼šOutOfMemoryErrorå‰å¿…é¡»æ¸…ç†æ‰€æœ‰è½¯å¼•ç”¨
- **LRUç­–ç•¥**ï¼šåŸºäºæ—¶é—´æˆ³çš„æœ€è¿‘æœ€å°‘ä½¿ç”¨ç®—æ³•

### 2. **å›æ”¶ç­–ç•¥**
- **æœåŠ¡å™¨æ¨¡å¼**ï¼šLRUMaxHeapPolicyï¼ˆåŸºäºæœ€å¤§å †å†…å­˜ï¼‰
- **å®¢æˆ·ç«¯æ¨¡å¼**ï¼šLRUCurrentHeapPolicyï¼ˆåŸºäºå½“å‰å †ä½¿ç”¨ï¼‰
- **æ—¶é—´å› å­**ï¼š`interval = current_time - timestamp`
- **å›æ”¶æ¡ä»¶**ï¼š`max_interval < (heap_size >> 10)`

### 3. **ä½¿ç”¨åœºæ™¯**
- **å›¾ç‰‡ç¼“å­˜**ï¼šå¤§å¯¹è±¡çš„å†…å­˜æ•æ„Ÿç¼“å­˜
- **æ•°æ®ç¼“å­˜**ï¼šæ•°æ®åº“æŸ¥è¯¢ç»“æœç¼“å­˜
- **è®¡ç®—ç¼“å­˜**ï¼šæ˜‚è´µè®¡ç®—ç»“æœçš„ä¸´æ—¶å­˜å‚¨
- **èµ„æºæ± **ï¼šå¯é‡å»ºçš„èµ„æºå¯¹è±¡æ± 

### 4. **æœ€ä½³å®è·µ**
- **é…åˆReferenceQueue**ï¼šåŠæ—¶æ¸…ç†å·²å›æ”¶çš„å¼•ç”¨
- **é€‚å½“è®¿é—®**ï¼šé€šè¿‡get()æ–¹æ³•æ›´æ–°æ—¶é—´æˆ³
- **å¤§å°æ§åˆ¶**ï¼šé¿å…ç¼“å­˜å¯¹è±¡è¿‡å¤§å¯¼è‡´é¢‘ç¹GC
- **ç›‘æ§å›æ”¶**ï¼šç›‘æ§è½¯å¼•ç”¨çš„å›æ”¶æƒ…å†µ

### 5. **å¸¸è§é™·é˜±**
- **è¿‡åº¦ä¾èµ–**ï¼šä¸èƒ½å‡è®¾è½¯å¼•ç”¨æ°¸è¿œå­˜åœ¨
- **å†…å­˜æ³„æ¼**ï¼šSoftReferenceæœ¬èº«éœ€è¦åŠæ—¶æ¸…ç†
- **æ€§èƒ½å½±å“**ï¼šé¢‘ç¹çš„è½¯å¼•ç”¨å›æ”¶å½±å“æ€§èƒ½
- **æ—¶æœºä¸å½“**ï¼šåœ¨å†…å­˜å……è¶³æ—¶ä¹Ÿå¯èƒ½è¢«å›æ”¶

## ğŸš€ **é¢è¯•è¦ç‚¹**

### é«˜é¢‘é—®é¢˜

1. **è½¯å¼•ç”¨ä»€ä¹ˆæ—¶å€™è¢«å›æ”¶ï¼Ÿ**
   - å†…å­˜ä¸è¶³æ—¶ï¼ŒåŸºäºLRUç­–ç•¥å’Œæ—¶é—´æˆ³æœºåˆ¶å›æ”¶

2. **è½¯å¼•ç”¨çš„æ—¶é—´æˆ³æœºåˆ¶æ˜¯ä»€ä¹ˆï¼Ÿ**
   - æ¯æ¬¡get()è°ƒç”¨æ›´æ–°timestampï¼ŒGCä¼˜å…ˆå›æ”¶æ—¶é—´æˆ³è¾ƒæ—§çš„å¯¹è±¡

3. **è½¯å¼•ç”¨é€‚åˆä»€ä¹ˆåœºæ™¯ï¼Ÿ**
   - å†…å­˜æ•æ„Ÿç¼“å­˜ï¼Œå¦‚å›¾ç‰‡ç¼“å­˜ã€æ•°æ®ç¼“å­˜ç­‰

4. **è½¯å¼•ç”¨å¦‚ä½•é¿å…OOMï¼Ÿ**
   - JVMä¿è¯åœ¨æŠ›å‡ºOutOfMemoryErrorå‰æ¸…ç†æ‰€æœ‰è½¯å¼•ç”¨

5. **è½¯å¼•ç”¨çš„æ€§èƒ½è€ƒé‡ï¼Ÿ**
   - è®¿é—®å¼€é”€å°ï¼Œä½†GCå›æ”¶å¯èƒ½å½±å“ç¼“å­˜å‘½ä¸­ç‡

### ä»£ç ç¤ºä¾‹

```java
// å…¸å‹çš„è½¯å¼•ç”¨ç¼“å­˜å®ç°
public class ImageCache {
    private Map<String, SoftReference<BufferedImage>> cache = new ConcurrentHashMap<>();
    
    public BufferedImage getImage(String path) {
        SoftReference<BufferedImage> ref = cache.get(path);
        BufferedImage image = (ref != null) ? ref.get() : null;
        
        if (image == null) {
            image = loadImage(path); // é‡æ–°åŠ è½½
            cache.put(path, new SoftReference<>(image));
        }
        
        return image;
    }
}
```

---

**ä¸‹ä¸€æ­¥**: å­¦ä¹  [03_å¼±å¼•ç”¨_æºç éªŒè¯.md](./03_å¼±å¼•ç”¨_æºç éªŒè¯.md) äº†è§£è§„èŒƒæ˜ å°„çš„å®ç°æœºåˆ¶ã€‚