# G1GC辅助数据结构内存开销精确分析

> **环境**: -Xms8g -Xmx8g, 非大页(UseLargePages=false), 非NUMA, 64位Linux, OpenJDK 11
> **目标**: 精确计算G1GC所有辅助数据结构的内存开销

## 一、辅助数据结构总览 (已修正)

G1GC为了高效管理堆内存，需要维护多个辅助数据结构：

| 数据结构 | 作用 | 粒度 | 大小 |
|---------|------|------|------|
| CardTable | 跨Region引用跟踪 | 512B→1B | 16MB |
| BOT | 对象起始地址定位 | 512B→1B | 16MB |
| **Prev Bitmap** | 上轮并发标记结果 | **64B→1B** | **128MB** ★修正 |
| **Next Bitmap** | 当前并发标记结果 | **64B→1B** | **128MB** ★修正 |
| Card Counts | 热卡缓存优化 | 512B→1B | 16MB |
| HeapRegion对象 | Region元数据 | 4MB→~400B | ~800KB |
| 管理结构 | Region管理 | - | ~200KB |

> **重要修正**: CMBitMap的粒度是64字节堆内存对应1字节位图（8位），而非1位。

---

## 二、CardTable详细分析

### 2.1 源码定义

**文件**: `src/hotspot/share/gc/shared/cardTable.hpp:232-237`

```cpp
enum SomePublicConstants {
  card_shift                  = 9,   // 地址右移9位得到卡索引
  card_size                   = 1 << card_shift,  // 512 bytes
  card_size_in_words          = card_size / sizeof(HeapWord)  // 64 words
};
```

### 2.2 精确计算

```
参数:
  堆大小 = 8GB = 8,589,934,592 bytes
  卡大小 = 512 bytes

计算:
  卡表条目数 = 堆大小 / 卡大小 = 8,589,934,592 / 512 = 16,777,216 条目
  卡表大小 = 16,777,216 × 1 byte = 16,777,216 bytes = 16MB

每Region卡数:
  CardsPerRegion = 4MB / 512 = 8,192 cards
```

### 2.3 G1CardTable卡值定义

**文件**: `src/hotspot/share/gc/g1/g1CardTable.hpp`

```cpp
enum G1CardValues {
  g1_young_gen = CT_MR_BS_last_reserved << 1,  // 32
  // 年轻代Region的卡值固定为32，不参与脏卡处理
};
```

**卡值状态**:
| 值 | 名称 | 含义 |
|----|------|------|
| -1 (0xFF) | clean_card | 干净卡，无跨代引用 |
| 0 | dirty_card | 脏卡，有引用修改 |
| 1 | precleaned_card | 预清理卡 |
| 2 | claimed_card | 已认领卡 |
| 4 | deferred_card | 延迟处理卡 |
| 32 | g1_young_gen | 年轻代卡 |

### 2.4 内存布局示意

```
CardTable内存布局 (16MB连续内存)
┌────────────────────────────────────────────────────────────┐
│ Index:  0    1    2    ...   8191   8192  ...  16777215   │
│         ↓    ↓    ↓          ↓      ↓          ↓          │
│       ┌────┬────┬────┬─────┬────┬─────┬─────┬────────┐    │
│       │ 32 │ 32 │ 32 │ ... │ 32 │ 0   │ ... │ -1     │    │
│       └────┴────┴────┴─────┴────┴─────┴─────┴────────┘    │
│       ←───── Region 0 ─────→←──── Region 1 ────→ ...      │
│            (Eden)               (Old)                      │
└────────────────────────────────────────────────────────────┘

每个字节对应512字节堆内存
```

---

## 三、Block Offset Table (BOT) 详细分析

### 3.1 源码定义

**文件**: `src/hotspot/share/gc/shared/blockOffsetTable.hpp:50-76`

```cpp
class BOTConstants : public AllStatic {
public:
  static const uint LogN = 9;                        // 每条目覆盖512字节
  static const uint LogN_words = LogN - LogHeapWordSize;  // 9 - 3 = 6
  static const uint N_bytes = 1 << LogN;             // 512 bytes
  static const uint N_words = 1 << LogN_words;       // 64 words
  
  // 跳跃编码常量
  static const uint LogBase = 4;
  static const uint Base = (1 << LogBase);           // 16
  static const uint N_powers = 14;                   // 最大跳跃层数
};
```

### 3.2 精确计算

```
参数:
  堆大小 = 8GB = 8,589,934,592 bytes
  BOT条目粒度 = 512 bytes

计算:
  BOT条目数 = 堆大小 / N_bytes = 8,589,934,592 / 512 = 16,777,216 条目
  BOT大小 = 16,777,216 × 1 byte = 16,777,216 bytes = 16MB

每Region BOT条目数:
  BOT条目/Region = 4MB / 512 = 8,192 entries
```

### 3.3 BOT编码规则

BOT条目值编码两种信息：

1. **直接偏移** (值 < 64): 表示从当前卡起始到对象起始的偏移(单位: words)
2. **跳跃编码** (值 ≥ 64): 表示需要向前跳跃查找

```
跳跃编码公式:
  值 = 64 + power
  跳跃距离 = Base^power = 16^power 个卡

示例:
  64: 跳1卡 (16^0 = 1)
  65: 跳16卡 (16^1 = 16)
  66: 跳256卡 (16^2 = 256)
  67: 跳4096卡 (16^3 = 4096)
  ...
  77: 跳16^13卡 (最大)
```

### 3.4 BOT查找算法

**源码**: `src/hotspot/share/gc/g1/g1BlockOffsetTable.cpp`

```cpp
HeapWord* G1BlockOffsetTable::block_start(const void* addr) {
  // 1. 计算addr所在的卡索引
  size_t index = pointer_delta(addr, _bottom) >> BOTConstants::LogN;
  
  // 2. 读取BOT条目
  uint8_t offset = _offset_array[index];
  
  // 3. 如果是跳跃编码，递归向前查找
  while (offset >= N_words) {
    size_t jump = power_to_cards_back(offset - N_words);
    index -= jump;
    offset = _offset_array[index];
  }
  
  // 4. 计算对象起始地址
  HeapWord* block_start = _bottom + (index << LogN_words) - offset;
  return block_start;
}
```

---

## 四、并发标记位图 (CMBitMap) 详细分析

### 4.1 源码定义

**文件**: `src/hotspot/share/gc/g1/g1ConcurrentMarkBitMap.cpp:43`

```cpp
G1CMBitMap::G1CMBitMap() : MarkBitMap(), _listener() {
  // 继承自MarkBitMap
  // mark_distance = 64 bytes
  // _shifter = 0
}
```

**文件**: `src/hotspot/share/gc/shared/markBitMap.hpp`

```cpp
class MarkBitMap : public CHeapObj<mtGC> {
protected:
  HeapWord* _covered_start;
  HeapWord* _covered_end;
  BitMap    _bm;
  int       _shifter;  // 地址右移位数
  
public:
  static size_t compute_size(size_t heap_size) {
    // 每64字节堆内存对应1位
    return heap_size / mark_distance / BitsPerByte;
  }
};
```

### 4.2 精确计算 (已修正)

**源码计算公式**:
```cpp
// src/hotspot/share/gc/g1/g1ConcurrentMarkBitMap.cpp:38-44
size_t G1CMBitMap::compute_size(size_t heap_size) {
  return ReservedSpace::allocation_align_size_up(heap_size / mark_distance());
}

size_t G1CMBitMap::mark_distance() {
  return MinObjAlignmentInBytes * BitsPerByte;  // 8 * 8 = 64
}
```

**关键理解**: `compute_size`直接返回字节数，每64字节堆内存对应1字节位图(8位)

```
参数:
  堆大小 = 8GB = 8,589,934,592 bytes
  mark_distance = 8 × 8 = 64 bytes

计算:
  单个位图大小 = heap_size / mark_distance = 8GB / 64 = 134,217,728 bytes = 128MB ★修正
  
两个位图:
  Prev Bitmap: 128MB (存储上轮标记结果) ★修正
  Next Bitmap: 128MB (存储当前标记结果) ★修正
  总计: 256MB ★修正
```

**NMT验证**: GC mmap部分约337MB，其中CardTable+BOT+CardCounts=48MB，剩余~289MB用于位图和其他结构，与256MB+33MB对齐填充吻合。

### 4.3 位图操作

```cpp
// 标记对象
inline bool G1CMBitMap::mark(HeapWord* addr) {
  size_t index = pointer_to_index(addr);
  return _bm.par_set_bit(index);  // CAS原子操作
}

// 检查对象是否标记
inline bool G1CMBitMap::is_marked(HeapWord* addr) const {
  size_t index = pointer_to_index(addr);
  return _bm.at(index);
}

// 地址转索引
inline size_t pointer_to_index(HeapWord* addr) const {
  return pointer_delta(addr, _covered_start) >> (_shifter + LogHeapWordSize);
  // _shifter = 0, LogHeapWordSize = 3
  // index = (addr - start) >> 3 = 字节偏移 / 8
}
```

### 4.4 双缓冲机制

```
并发标记周期:
  ┌────────────────────────────────────────────────────────┐
  │ 阶段1: Initial Mark                                    │
  │   - _next_mark_bitmap 清空                             │
  │   - 标记根对象到 _next_mark_bitmap                      │
  └────────────────────────────────────────────────────────┘
                          ↓
  ┌────────────────────────────────────────────────────────┐
  │ 阶段2: Concurrent Mark                                 │
  │   - 并发遍历对象图                                      │
  │   - 在 _next_mark_bitmap 中设置标记位                   │
  │   - SATB队列记录并发修改                                │
  └────────────────────────────────────────────────────────┘
                          ↓
  ┌────────────────────────────────────────────────────────┐
  │ 阶段3: Remark (STW)                                    │
  │   - 处理SATB队列                                        │
  │   - 完成剩余标记                                        │
  └────────────────────────────────────────────────────────┘
                          ↓
  ┌────────────────────────────────────────────────────────┐
  │ 阶段4: Cleanup                                         │
  │   - 交换: swap(_prev_mark_bitmap, _next_mark_bitmap)    │
  │   - _prev_mark_bitmap 现在包含最新标记结果               │
  │   - Mixed GC使用 _prev_mark_bitmap 判断存活性           │
  └────────────────────────────────────────────────────────┘
```

---

## 五、Card Counts Table详细分析

### 5.1 源码定义

**文件**: `src/hotspot/share/gc/g1/g1CardCounts.hpp`

```cpp
class G1CardCounts : public CHeapObj<mtGC> {
private:
  G1CardTable* _ct;
  size_t _num_cards;
  uint8_t* _card_counts;  // 每个卡对应一个计数器
  
public:
  static size_t compute_size(size_t reserved_region_size) {
    return reserved_region_size >> G1CardTable::card_shift;
  }
};
```

### 5.2 精确计算

```
参数:
  堆大小 = 8GB = 8,589,934,592 bytes
  卡大小 = 512 bytes

计算:
  Card Counts条目数 = 堆大小 / 卡大小 = 8,589,934,592 / 512 = 16,777,216
  Card Counts大小 = 16,777,216 × 1 byte = 16,777,216 bytes = 16MB
```

### 5.3 热卡缓存机制

```cpp
// 源码: src/hotspot/share/gc/g1/g1HotCardCache.cpp
void G1HotCardCache::insert(jbyte* card_ptr) {
  // 1. 增加卡计数
  uint count = _card_counts->add_card_count(card_ptr);
  
  // 2. 如果计数超过阈值，加入热卡缓存
  if (count >= G1ConcRefinementThresholdStep) {
    // 延迟处理热卡
    _hot_cache->add(card_ptr);
  }
}
```

---

## 六、HeapRegion对象详细分析

### 6.1 HeapRegion类定义

**文件**: `src/hotspot/share/gc/g1/heapRegion.hpp:191-450`

```cpp
class HeapRegion: public G1ContiguousSpace {
private:
  // Region元数据
  HeapRegion* _humongous_start_region;
  HeapRegionRemSet* _rem_set;
  HeapRegion* _next;
  HeapRegion* _prev;
  
  // 类型和状态
  HeapRegionType _type;
  uint _young_index_in_cset;
  SurvRateGroup* _surv_rate_group;
  int _age_index;
  
  // GC相关
  uint _gc_efficiency;
  int _not_yet_parsed_bytes;
  
  // 时间戳
  uint _timestamp;
  
  // 父类G1ContiguousSpace的成员
  // HeapWord* volatile _top;
  // G1BlockOffsetTablePart _bot_part;
  // Mutex _par_alloc_lock;
  // HeapWord* _pre_dummy_top;
};
```

### 6.2 HeapRegion对象大小估算

```
成员变量估算:
  指针成员 (64位):
    _humongous_start_region: 8 bytes
    _rem_set: 8 bytes
    _next: 8 bytes
    _prev: 8 bytes
    _surv_rate_group: 8 bytes
    _top: 8 bytes
    _pre_dummy_top: 8 bytes
  
  整数成员:
    _young_index_in_cset: 4 bytes
    _age_index: 4 bytes
    _gc_efficiency: 4 bytes
    _not_yet_parsed_bytes: 4 bytes
    _timestamp: 4 bytes
    _type (枚举): 4 bytes
  
  _bot_part (G1BlockOffsetTablePart): ~48 bytes
  _par_alloc_lock (Mutex): ~64 bytes
  
  继承开销:
    虚函数表指针: 8 bytes
    父类成员: ~100 bytes
  
估算总大小: ~350-400 bytes/Region
```

### 6.3 精确计算

```
参数:
  Region数量 = 2,048
  每Region对象大小 ≈ 400 bytes

计算:
  HeapRegion对象总大小 ≈ 2,048 × 400 = 819,200 bytes ≈ 800KB
```

---

## 七、HeapRegionManager管理结构

### 7.1 源码定义

**文件**: `src/hotspot/share/gc/g1/heapRegionManager.hpp`

```cpp
class HeapRegionManager : public CHeapObj<mtGC> {
private:
  G1HeapRegionTable _regions;       // HeapRegion*数组
  CHeapBitMap _available_map;       // 可用Region位图
  uint _num_committed;              // 已提交Region数
  uint _allocated_heapregions_length;
  
  // 空闲Region管理
  FreeRegionList _free_list;
};
```

### 7.2 精确计算

```
G1HeapRegionTable:
  - 实质是 HeapRegion* 数组
  - 大小 = 2,048 × 8 bytes = 16,384 bytes = 16KB

CHeapBitMap (_available_map):
  - 2,048个Region对应2,048位
  - 大小 = 2,048 / 8 = 256 bytes

FreeRegionList:
  - 双向链表头尾指针
  - 大小 ≈ 32 bytes

管理结构总计 ≈ 20KB
```

---

## 八、Remembered Set (RSet)

### 8.1 概述

RSet是G1GC中最复杂的数据结构，用于记录指向某个Region的所有跨Region引用。

**源码**: `src/hotspot/share/gc/g1/heapRegionRemSet.hpp`

### 8.2 结构层次

```cpp
class HeapRegionRemSet : public CHeapObj<mtGC> {
private:
  G1BlockOffsetTable* _bot;
  OtherRegionsTable _other_regions;  // 核心数据结构
  HeapRegion* _hr;
};

class OtherRegionsTable : public CHeapObj<mtGC> {
private:
  PerRegionTable** _fine_grain_regions;  // 细粒度表
  SparsePRT _sparse_table;               // 稀疏表
  BitMap _coarse_map;                    // 粗粒度位图
};
```

### 8.3 三级粒度

| 级别 | 数据结构 | 粒度 | 适用场景 |
|------|---------|------|---------|
| Sparse | SparsePRT | 卡级别 | 少量引用 |
| Fine | PerRegionTable | 卡级别 | 中等引用 |
| Coarse | BitMap | Region级别 | 大量引用 |

### 8.4 内存开销估算

```
每个HeapRegionRemSet:
  - OtherRegionsTable: ~200 bytes (基础开销)
  - SparsePRT: 动态增长
  - PerRegionTable: 动态增长
  - CoarseBitMap: 2048 bits = 256 bytes (最大)

典型情况下:
  - 年轻代Region: RSet为空或很小
  - 老年代Region: RSet大小取决于被引用次数

估算:
  平均每Region RSet ≈ 3KB (包含动态分配)
  总RSet ≈ 2,048 × 3KB = 6MB (典型值)
  
范围: 2MB ~ 20MB (取决于应用特性)
```

---

## 九、内存开销总表 (已修正)

### 9.1 固定开销

| 组件 | 大小(Bytes) | 大小(MB) | 占堆比例 | 粒度 |
|------|-------------|----------|----------|------|
| CardTable | 16,777,216 | 16 | 0.195% | 512B→1B |
| BOT | 16,777,216 | 16 | 0.195% | 512B→1B |
| **Prev Bitmap** | **134,217,728** | **128** | **1.563%** | **64B→1B** ★修正 |
| **Next Bitmap** | **134,217,728** | **128** | **1.563%** | **64B→1B** ★修正 |
| Card Counts | 16,777,216 | 16 | 0.195% | 512B→1B |
| **固定总计** | **318,767,104** | **304** | **3.711%** | - ★修正 |

### 9.2 可变开销

| 组件 | 典型大小 | 范围 | 占堆比例 |
|------|----------|------|----------|
| HeapRegion对象 | ~800KB | 固定 | ~0.01% |
| 管理结构 | ~20KB | 固定 | ~0.0002% |
| RemSet | ~6MB | 2-20MB | ~0.07% |
| **可变总计** | **~7MB** | 3-21MB | ~0.085% |

### 9.3 总开销

```
┌─────────────────────────────────────────────────────────────┐
│              G1 GC 8GB堆内存开销统计 (已修正)               │
├─────────────────────────────────────────────────────────────┤
│ 固定开销:                                                   │
│   CardTable:      16 MB  (0.195%)                           │
│   BOT:            16 MB  (0.195%)                           │
│   Prev Bitmap:   128 MB  (1.563%)  ★修正: 原16MB            │
│   Next Bitmap:   128 MB  (1.563%)  ★修正: 原16MB            │
│   Card Counts:    16 MB  (0.195%)                           │
│   ─────────────────────────────                             │
│   小计:          304 MB  (3.711%)  ★修正: 原80MB            │
├─────────────────────────────────────────────────────────────┤
│ 可变开销:                                                   │
│   HeapRegion对象: ~800 KB (0.010%)                          │
│   管理结构:       ~20  KB (0.000%)                          │
│   RemSet:         ~6   MB (0.070%)                          │
│   ─────────────────────────────                             │
│   小计:           ~7   MB (0.085%)                          │
├─────────────────────────────────────────────────────────────┤
│ 总计:             ~311 MB (3.80%)   ★修正: 原87MB           │
│ 实际可用堆:       ~7689 MB (96.20%) ★修正: 原7913MB         │
└─────────────────────────────────────────────────────────────┘
```

---

## 十、NMT验证 (已修正分析)

```bash
$ java -Xms8g -Xmx8g -XX:+UseG1GC -XX:NativeMemoryTracking=detail -XX:+PrintNMTStatistics -version

# GC部分输出:
-                        GC (reserved=392,627,087, committed=392,627,087)
                            (malloc=39,498,639 #14801)
                            (mmap: reserved=353,128,448, committed=353,128,448)

分析 (已修正):
  mmap部分 (337MB):
    - CardTable: 16MB
    - BOT: 16MB
    - Prev Bitmap: 128MB ★修正
    - Next Bitmap: 128MB ★修正
    - Card Counts: 16MB
    - 小计: 304MB
    - 对齐填充/其他: ~33MB
  
  malloc部分 (38MB):
    - HeapRegion对象: ~800KB
    - RemSet: ~6MB
    - 其他动态分配: ~31MB
```

---

## 十一、源码文件索引

| 数据结构 | 源码文件 |
|---------|---------|
| CardTable | cardTable.hpp, g1CardTable.hpp |
| BOT | blockOffsetTable.hpp, g1BlockOffsetTable.hpp |
| CMBitMap | markBitMap.hpp, g1ConcurrentMarkBitMap.hpp |
| Card Counts | g1CardCounts.hpp |
| HeapRegion | heapRegion.hpp, heapRegion.cpp |
| HeapRegionManager | heapRegionManager.hpp |
| RemSet | heapRegionRemSet.hpp |
| G1RegionToSpaceMapper | g1RegionToSpaceMapper.hpp |
