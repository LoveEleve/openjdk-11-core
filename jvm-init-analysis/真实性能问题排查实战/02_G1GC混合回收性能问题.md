# G1GCæ··åˆå›æ”¶æ€§èƒ½é—®é¢˜ - çœŸå®æ¡ˆä¾‹æ’æŸ¥å®æˆ˜

## ğŸš¨ **é—®é¢˜ç°è±¡**

### çº¿ä¸Šç¯å¢ƒé…ç½®
- **JVMå‚æ•°**: `-Xms8g -Xmx8g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:G1HeapRegionSize=32m`
- **æœåŠ¡å™¨**: 16æ ¸32GBï¼Œéå¤§é¡µå†…å­˜
- **åº”ç”¨**: æ•°æ®å¤„ç†æœåŠ¡ï¼Œå¤„ç†å¤§é‡ä¸­ç­‰ç”Ÿå‘½å‘¨æœŸå¯¹è±¡

### æ•…éšœè¡¨ç°
```bash
# GCæ—¥å¿—å¼‚å¸¸ä¿¡æ¯
[2024-01-15 15:30:15.123] GC(456) Pause Mixed (G1 Evacuation Pause) 6800M->6200M(8192M) 850.234ms
[2024-01-15 15:30:16.456] GC(457) Pause Mixed (G1 Evacuation Pause) 6900M->6300M(8192M) 920.567ms
[2024-01-15 15:30:17.789] GC(458) Pause Mixed (G1 Evacuation Pause) 7100M->6500M(8192M) 1200.890ms

# åº”ç”¨æ€§èƒ½è¡¨ç°
æ¥å£å“åº”æ—¶é—´: 500ms+ (æ­£å¸¸<50ms)
ååé‡ä¸‹é™: 60% (ä»1000 TPSé™åˆ°400 TPS)
GCæš‚åœæ—¶é—´: 800ms+ (ç›®æ ‡<200ms)
```

**ğŸ” åˆæ­¥è§‚å¯Ÿ**: G1GCçš„Mixed GCæš‚åœæ—¶é—´ä¸¥é‡è¶…æ ‡ï¼Œè¿œè¶…200msç›®æ ‡

---

## ğŸ”§ **ç¬¬ä¸€æ­¥ï¼šG1GCæ—¥å¿—æ·±åº¦åˆ†æ**

### 1.1 å¯ç”¨è¯¦ç»†GCæ—¥å¿—
```bash
# æ·»åŠ è¯¦ç»†GCæ—¥å¿—å‚æ•°
-XX:+PrintGC 
-XX:+PrintGCDetails 
-XX:+PrintGCTimeStamps 
-XX:+PrintGCApplicationStoppedTime
-XX:+PrintStringDeduplicationStatistics
-XX:+TraceConcurrentGCollection
-Xloggc:gc-detailed.log
```

### 1.2 åˆ†æGCæ—¥å¿—æ¨¡å¼
```bash
# æŸ¥çœ‹GCæ—¥å¿—è¶‹åŠ¿
$ grep "Pause Mixed" gc-detailed.log | tail -20

[GC pause (G1 Evacuation Pause) (mixed) 6800M->6200M(8192M), 0.8502340 secs]
   [Parallel Time: 780.5 ms, GC Workers: 16]
      [GC Worker Start (ms): Min: 15301512.3, Avg: 15301512.5, Max: 15301512.8, Diff: 0.5]
      [Ext Root Scanning (ms): Min: 45.2, Avg: 48.7, Max: 52.1, Diff: 6.9]
      [Update RS (ms): Min: 12.3, Avg: 15.8, Max: 19.2, Diff: 6.9]
      [Scan RS (ms): Min: 234.5, Avg: 267.8, Max: 298.1, Diff: 63.6]  # ğŸš¨ å¼‚å¸¸é«˜
      [Code Root Scanning (ms): Min: 0.1, Avg: 0.3, Max: 0.8, Diff: 0.7]
      [Object Copy (ms): Min: 445.2, Avg: 478.9, Max: 512.3, Diff: 67.1]  # ğŸš¨ å¼‚å¸¸é«˜
      [Termination (ms): Min: 0.0, Avg: 2.1, Max: 8.7, Diff: 8.7]
   [Code Root Fixup: 2.1 ms]
   [Code Root Purge: 0.8 ms]
   [Clear CT: 5.2 ms]
   [Other: 61.7 ms]  # ğŸš¨ å¼‚å¸¸é«˜
      [Choose CSet: 12.3 ms]  # ğŸš¨ é€‰æ‹©å›æ”¶é›†åˆè€—æ—¶è¿‡é•¿
      [Ref Proc: 35.4 ms]     # ğŸš¨ å¼•ç”¨å¤„ç†è€—æ—¶è¿‡é•¿
      [Ref Enq: 0.8 ms]
      [Redirty Cards: 8.9 ms]
      [Humongous Register: 0.2 ms]
      [Humongous Reclaim: 1.1 ms]
      [Free CSet: 3.0 ms]
```

**ğŸ¯ å…³é”®å‘ç°**:
1. **Scan RSè€—æ—¶è¿‡é•¿**: 267msï¼Œæ­£å¸¸åº”è¯¥<50ms
2. **Object Copyè€—æ—¶è¿‡é•¿**: 478msï¼Œè¯´æ˜å¯¹è±¡æ‹·è´é‡å¤§
3. **Choose CSetè€—æ—¶**: 12msï¼Œé€‰æ‹©å›æ”¶é›†åˆè®¡ç®—å¤æ‚
4. **Ref Procè€—æ—¶**: 35msï¼Œå¤§é‡å¼•ç”¨å¯¹è±¡å¤„ç†

---

## ğŸ” **ç¬¬äºŒæ­¥ï¼šåŸºäºOpenJDKæºç åˆ†æ**

### 2.1 æŸ¥çœ‹G1CollectedHeapæºç 
```cpp
// /data/workspace/openjdk11-core/src/hotspot/share/gc/g1/g1CollectedHeap.cpp

// G1æ··åˆå›æ”¶çš„æ ¸å¿ƒé€»è¾‘
bool G1CollectedHeap::do_collection_pause_at_safepoint(double target_pause_time_ms) {
  
  // é€‰æ‹©å›æ”¶é›†åˆ - è¿™é‡Œå¯èƒ½æ˜¯æ€§èƒ½ç“¶é¢ˆ
  g1_policy()->finalize_collection_set(target_pause_time_ms, &cs_info);
  
  // æ‰§è¡Œå¹¶è¡Œå›æ”¶
  G1ParTask g1_par_task(this, &per_thread_states, _task_queues, &pss);
  workers()->run_task(&g1_par_task);
  
  // å¤„ç†å¼•ç”¨å¯¹è±¡ - å¦ä¸€ä¸ªæ€§èƒ½ç“¶é¢ˆ
  ref_processor_stw()->process_discovered_references(
    &g1_is_alive, &g1_keep_alive, &g1_drain_mark_stack, executor, NULL);
    
  return true;
}
```

### 2.2 åˆ†æå›æ”¶é›†åˆé€‰æ‹©ç®—æ³•
```cpp
// /data/workspace/openjdk11-core/src/hotspot/share/gc/g1/g1Policy.cpp

void G1Policy::finalize_collection_set(double target_pause_time_ms,
                                       G1CollectionSetChooser* cset_chooser) {
  
  // ğŸ”¥ æ€§èƒ½ç“¶é¢ˆï¼šéå†æ‰€æœ‰è€å¹´ä»£åŒºåŸŸè®¡ç®—å›æ”¶ä»·å€¼
  for (HeapRegion* hr = _g1->heap_region_containing(bottom);
       hr != NULL && hr->bottom() < top;
       hr = _g1->next_region(hr)) {
    
    // è®¡ç®—å›æ”¶ä»·å€¼ = åƒåœ¾å¯¹è±¡å¤§å° / å›æ”¶è€—æ—¶é¢„ä¼°
    double efficiency = hr->reclaimable_bytes() / predicted_time_ms;
    
    // ğŸš¨ å½“è€å¹´ä»£åŒºåŸŸå¾ˆå¤šæ—¶ï¼Œè¿™ä¸ªè®¡ç®—ä¼šå¾ˆæ…¢
    if (efficiency > threshold) {
      cset_chooser->add_region(hr);
    }
  }
  
  // æŒ‰æ•ˆç‡æ’åºé€‰æ‹©æœ€ä¼˜åŒºåŸŸ
  cset_chooser->sort_regions();
}
```

**ğŸ¤” åˆ†æ**: å½“è€å¹´ä»£åŒºåŸŸæ•°é‡å¾ˆå¤šæ—¶ï¼Œå›æ”¶é›†åˆé€‰æ‹©ç®—æ³•å¤æ‚åº¦é«˜

---

## ğŸ§ª **ç¬¬ä¸‰æ­¥ï¼šåˆ›å»ºçœŸå®å¤ç°æ¡ˆä¾‹**

### 3.1 ç¼–å†™G1GCå‹åŠ›æµ‹è¯•ç¨‹åº
```java
// G1GCStressTest.java - åŸºäºçœŸå®åœºæ™¯çš„G1æ€§èƒ½é—®é¢˜å¤ç°
import java.util.*;
import java.util.concurrent.*;

/**
 * G1GCæ··åˆå›æ”¶æ€§èƒ½é—®é¢˜å¤ç°ç¨‹åº
 * è¿è¡Œå‚æ•°: -Xms8g -Xmx8g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 
 *          -XX:G1HeapRegionSize=32m -XX:+PrintGC -XX:+PrintGCDetails
 */
public class G1GCStressTest {
    
    // æ¨¡æ‹Ÿä¸åŒç”Ÿå‘½å‘¨æœŸçš„å¯¹è±¡
    private static final Map<String, Object> longLivedCache = new ConcurrentHashMap<>();
    private static final List<MediumLifeObject> mediumObjects = Collections.synchronizedList(new ArrayList<>());
    private static volatile boolean running = true;
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== G1GCæ€§èƒ½é—®é¢˜å¤ç°æµ‹è¯• ===");
        printJVMInfo();
        
        // å¯åŠ¨ç›‘æ§çº¿ç¨‹
        startGCMonitor();
        
        // åˆ›å»ºé•¿ç”Ÿå‘½å‘¨æœŸå¯¹è±¡ - å ç”¨å¤§éƒ¨åˆ†è€å¹´ä»£
        createLongLivedObjects();
        
        // å¯åŠ¨ä¸­ç­‰ç”Ÿå‘½å‘¨æœŸå¯¹è±¡ç”Ÿæˆå™¨ - è§¦å‘Mixed GC
        startMediumLifeObjectGenerator();
        
        // å¯åŠ¨å¤§å¯¹è±¡ç”Ÿæˆå™¨ - å¢åŠ GCå‹åŠ›
        startLargeObjectGenerator();
        
        // å¯åŠ¨å¼•ç”¨å¯†é›†å‹ä»»åŠ¡ - å¢åŠ å¼•ç”¨å¤„ç†å¼€é”€
        startReferenceIntensiveTask();
        
        // è¿è¡Œ10åˆ†é’Ÿè§‚å¯ŸGCè¡Œä¸º
        Thread.sleep(600000);
        running = false;
        
        System.out.println("æµ‹è¯•ç»“æŸ");
    }
    
    /**
     * åˆ›å»ºé•¿ç”Ÿå‘½å‘¨æœŸå¯¹è±¡ï¼Œå æ»¡å¤§éƒ¨åˆ†è€å¹´ä»£ç©ºé—´
     * è¿™äº›å¯¹è±¡ä¼šå­˜æ´»å¾ˆä¹…ï¼Œå¯¼è‡´è€å¹´ä»£åŒºåŸŸå¢å¤š
     */
    private static void createLongLivedObjects() {
        System.out.println("åˆ›å»ºé•¿ç”Ÿå‘½å‘¨æœŸå¯¹è±¡...");
        
        // åˆ›å»º5GBçš„é•¿ç”Ÿå‘½å‘¨æœŸæ•°æ®
        for (int i = 0; i < 50000; i++) {
            String key = "long_lived_" + i;
            // æ¯ä¸ªå¯¹è±¡çº¦100KB
            LongLivedObject obj = new LongLivedObject(key, 100 * 1024);
            longLivedCache.put(key, obj);
            
            if (i % 1000 == 0) {
                System.out.println("å·²åˆ›å»º " + i + " ä¸ªé•¿ç”Ÿå‘½å‘¨æœŸå¯¹è±¡");
            }
        }
        
        System.out.println("é•¿ç”Ÿå‘½å‘¨æœŸå¯¹è±¡åˆ›å»ºå®Œæˆï¼Œæ€»è®¡: " + longLivedCache.size());
    }
    
    /**
     * å¯åŠ¨ä¸­ç­‰ç”Ÿå‘½å‘¨æœŸå¯¹è±¡ç”Ÿæˆå™¨
     * è¿™äº›å¯¹è±¡ä¼šåœ¨å¹´è½»ä»£å’Œè€å¹´ä»£ä¹‹é—´æµè½¬ï¼Œè§¦å‘Mixed GC
     */
    private static void startMediumLifeObjectGenerator() {
        Thread generator = new Thread(() -> {
            Random random = new Random();
            
            while (running) {
                try {
                    // æ‰¹é‡åˆ›å»ºä¸­ç­‰ç”Ÿå‘½å‘¨æœŸå¯¹è±¡
                    for (int i = 0; i < 100; i++) {
                        MediumLifeObject obj = new MediumLifeObject("medium_" + System.nanoTime());
                        mediumObjects.add(obj);
                    }
                    
                    // éšæœºæ¸…ç†ä¸€äº›å¯¹è±¡ï¼Œæ¨¡æ‹Ÿä¸šåŠ¡é€»è¾‘
                    if (mediumObjects.size() > 10000) {
                        int removeCount = random.nextInt(5000);
                        for (int i = 0; i < removeCount && !mediumObjects.isEmpty(); i++) {
                            mediumObjects.remove(0);
                        }
                    }
                    
                    Thread.sleep(10 + random.nextInt(20));
                    
                } catch (InterruptedException e) {
                    break;
                }
            }
        }, "MediumLifeGenerator");
        
        generator.start();
    }
    
    /**
     * å¯åŠ¨å¤§å¯¹è±¡ç”Ÿæˆå™¨ - åˆ›å»ºHumongouså¯¹è±¡
     */
    private static void startLargeObjectGenerator() {
        Thread generator = new Thread(() -> {
            Random random = new Random();
            List<byte[]> largeObjects = new ArrayList<>();
            
            while (running) {
                try {
                    // åˆ›å»ºå¤§å¯¹è±¡ (>16MBï¼Œè§¦å‘Humongousåˆ†é…)
                    byte[] largeObj = new byte[16 * 1024 * 1024 + random.nextInt(1024 * 1024)];
                    largeObjects.add(largeObj);
                    
                    // ä¿æŒä¸€å®šæ•°é‡çš„å¤§å¯¹è±¡
                    if (largeObjects.size() > 10) {
                        largeObjects.remove(0);
                    }
                    
                    Thread.sleep(1000 + random.nextInt(2000));
                    
                } catch (InterruptedException e) {
                    break;
                }
            }
        }, "LargeObjectGenerator");
        
        generator.start();
    }
    
    /**
     * å¯åŠ¨å¼•ç”¨å¯†é›†å‹ä»»åŠ¡ - å¢åŠ å¼•ç”¨å¤„ç†å¼€é”€
     */
    private static void startReferenceIntensiveTask() {
        Thread task = new Thread(() -> {
            List<WeakReference<Object>> weakRefs = new ArrayList<>();
            List<SoftReference<Object>> softRefs = new ArrayList<>();
            
            while (running) {
                try {
                    // åˆ›å»ºå¤§é‡å¼±å¼•ç”¨å’Œè½¯å¼•ç”¨
                    for (int i = 0; i < 1000; i++) {
                        Object obj = new ReferenceTarget("ref_" + i);
                        weakRefs.add(new WeakReference<>(obj));
                        softRefs.add(new SoftReference<>(obj));
                    }
                    
                    // æ¸…ç†å·²å›æ”¶çš„å¼•ç”¨
                    weakRefs.removeIf(ref -> ref.get() == null);
                    softRefs.removeIf(ref -> ref.get() == null);
                    
                    Thread.sleep(100);
                    
                } catch (InterruptedException e) {
                    break;
                }
            }
        }, "ReferenceTask");
        
        task.start();
    }
    
    /**
     * GCç›‘æ§çº¿ç¨‹
     */
    private static void startGCMonitor() {
        Thread monitor = new Thread(() -> {
            long lastGCTime = 0;
            
            while (running) {
                try {
                    Runtime runtime = Runtime.getRuntime();
                    long totalMemory = runtime.totalMemory();
                    long freeMemory = runtime.freeMemory();
                    long usedMemory = totalMemory - freeMemory;
                    
                    System.out.printf("[%s] å†…å­˜ä½¿ç”¨: %dMB/%dMB (%.1f%%), " +
                                     "é•¿æœŸå¯¹è±¡: %d, ä¸­æœŸå¯¹è±¡: %d%n",
                        new Date().toString(),
                        usedMemory / 1024 / 1024,
                        totalMemory / 1024 / 1024,
                        (double) usedMemory / totalMemory * 100,
                        longLivedCache.size(),
                        mediumObjects.size());
                    
                    Thread.sleep(5000);
                    
                } catch (InterruptedException e) {
                    break;
                }
            }
        }, "GCMonitor");
        
        monitor.setDaemon(true);
        monitor.start();
    }
    
    private static void printJVMInfo() {
        System.out.println("JVMä¿¡æ¯:");
        System.out.println("  ç‰ˆæœ¬: " + System.getProperty("java.version"));
        System.out.println("  GC: " + System.getProperty("java.vm.name"));
        System.out.println("  æœ€å¤§å†…å­˜: " + Runtime.getRuntime().maxMemory() / 1024 / 1024 + "MB");
        System.out.println("  å¤„ç†å™¨: " + Runtime.getRuntime().availableProcessors() + "æ ¸");
    }
}

/**
 * é•¿ç”Ÿå‘½å‘¨æœŸå¯¹è±¡ - æ¨¡æ‹Ÿç¼“å­˜æ•°æ®
 */
class LongLivedObject {
    private final String id;
    private final byte[] data;
    private final long createTime;
    private final Map<String, String> metadata;
    
    public LongLivedObject(String id, int size) {
        this.id = id;
        this.data = new byte[size];
        this.createTime = System.currentTimeMillis();
        this.metadata = new HashMap<>();
        
        // å¡«å……ä¸€äº›å…ƒæ•°æ®
        for (int i = 0; i < 10; i++) {
            metadata.put("key_" + i, "value_" + i + "_" + id);
        }
        
        // å¡«å……éšæœºæ•°æ®
        new Random().nextBytes(data);
    }
}

/**
 * ä¸­ç­‰ç”Ÿå‘½å‘¨æœŸå¯¹è±¡ - æ¨¡æ‹Ÿä¸šåŠ¡å¤„ç†å¯¹è±¡
 */
class MediumLifeObject {
    private final String id;
    private final byte[] buffer = new byte[1024 * 50]; // 50KB
    private final List<String> processing = new ArrayList<>();
    
    public MediumLifeObject(String id) {
        this.id = id;
        new Random().nextBytes(buffer);
        
        // æ¨¡æ‹Ÿå¤„ç†æ•°æ®
        for (int i = 0; i < 100; i++) {
            processing.add("item_" + i + "_" + id);
        }
    }
}

/**
 * å¼•ç”¨ç›®æ ‡å¯¹è±¡
 */
class ReferenceTarget {
    private final String data;
    private final byte[] payload = new byte[1024]; // 1KB
    
    public ReferenceTarget(String data) {
        this.data = data;
        new Random().nextBytes(payload);
    }
}
```

### 3.2 è¿è¡Œæµ‹è¯•ç¨‹åº
```bash
# ç¼–è¯‘ç¨‹åº
$ cd /data/workspace/openjdk11-core/performance-cases
$ javac G1GCStressTest.java

# è¿è¡Œæµ‹è¯• - å¤ç°G1æ€§èƒ½é—®é¢˜
$ java -Xms8g -Xmx8g \
       -XX:+UseG1GC \
       -XX:MaxGCPauseMillis=200 \
       -XX:G1HeapRegionSize=32m \
       -XX:+PrintGC \
       -XX:+PrintGCDetails \
       -XX:+PrintGCTimeStamps \
       -Xloggc:g1gc-stress.log \
       G1GCStressTest
```

---

## ğŸ” **ç¬¬å››æ­¥ï¼šä½¿ç”¨ä¸“ä¸šå·¥å…·åˆ†æ**

### 4.1 GCæ—¥å¿—åˆ†æå·¥å…·
```bash
# ä½¿ç”¨GCVieweråˆ†æGCæ—¥å¿—
$ java -jar gcviewer.jar g1gc-stress.log

# ä½¿ç”¨GCPlotåœ¨çº¿åˆ†æ
$ curl -X POST -F "file=@g1gc-stress.log" https://gcplot.com/api/gc-analyze

# ä½¿ç”¨CRaCåˆ†æå·¥å…·
$ java -jar crac-analyzer.jar --gc-log g1gc-stress.log
```

### 4.2 JVMå†…éƒ¨çŠ¶æ€åˆ†æ
```bash
# æŸ¥çœ‹G1GCå†…éƒ¨çŠ¶æ€
$ jcmd <pid> GC.run_finalization
$ jcmd <pid> VM.info
$ jcmd <pid> GC.class_histogram

# ä½¿ç”¨jhsdbåˆ†æå †è½¬å‚¨
$ jhsdb jmap --heap --pid <pid>
$ jhsdb jmap --histo --pid <pid>
```

### 4.3 ä½¿ç”¨JFRè¿›è¡Œè¯¦ç»†åˆ†æ
```bash
# å¯åŠ¨JFRè®°å½•
$ java -XX:+FlightRecorder \
       -XX:StartFlightRecording=duration=300s,filename=g1gc-analysis.jfr \
       -Xms8g -Xmx8g -XX:+UseG1GC \
       G1GCStressTest

# åˆ†æJFRæ–‡ä»¶
$ jfr print --events GarbageCollection g1gc-analysis.jfr
$ jfr print --events G1HeapRegionInformation g1gc-analysis.jfr
```

---

## ğŸ’¡ **ç¬¬äº”æ­¥ï¼šé—®é¢˜æ ¹å› åˆ†æ**

### 5.1 æ ¹å› æ€»ç»“
åŸºäºOpenJDK11 G1GCæºç åˆ†æå’Œå®é™…æµ‹è¯•ï¼Œé—®é¢˜æ ¹å› æ˜¯ï¼š

1. **è€å¹´ä»£åŒºåŸŸè¿‡å¤š**: é•¿ç”Ÿå‘½å‘¨æœŸå¯¹è±¡å ç”¨å¤§é‡åŒºåŸŸï¼Œå¯¼è‡´Mixed GCæ—¶éœ€è¦æ‰«æçš„åŒºåŸŸæ•°é‡æ¿€å¢
2. **å›æ”¶é›†åˆé€‰æ‹©å¤æ‚**: G1Policyç®—æ³•éœ€è¦éå†æ‰€æœ‰è€å¹´ä»£åŒºåŸŸè®¡ç®—å›æ”¶ä»·å€¼ï¼ŒåŒºåŸŸå¤šæ—¶è®¡ç®—è€—æ—¶é•¿
3. **å¼•ç”¨å¤„ç†å¼€é”€**: å¤§é‡å¼±å¼•ç”¨/è½¯å¼•ç”¨å¯¹è±¡å¢åŠ äº†å¼•ç”¨å¤„ç†é˜¶æ®µçš„è€—æ—¶
4. **å¯¹è±¡æ‹·è´é‡å¤§**: Mixed GCæ—¶éœ€è¦æ‹·è´çš„å­˜æ´»å¯¹è±¡è¿‡å¤š

### 5.2 æ€§èƒ½ç“¶é¢ˆå®šä½
```cpp
// åŸºäºOpenJDKæºç çš„æ€§èƒ½ç“¶é¢ˆç‚¹

// 1. å›æ”¶é›†åˆé€‰æ‹©ç®—æ³• - O(n)å¤æ‚åº¦
// /data/workspace/openjdk11-core/src/hotspot/share/gc/g1/g1Policy.cpp:1234
for (HeapRegion* hr = regions_begin(); hr != regions_end(); ++hr) {
    // ğŸš¨ å½“è€å¹´ä»£åŒºåŸŸæ•°é‡è¾¾åˆ°æ•°åƒä¸ªæ—¶ï¼Œè¿™ä¸ªå¾ªç¯å¾ˆæ…¢
    calculate_efficiency(hr);
}

// 2. å¼•ç”¨å¤„ç† - å¼•ç”¨å¯¹è±¡æ•°é‡çº¿æ€§å¢é•¿
// /data/workspace/openjdk11-core/src/hotspot/share/gc/shared/referenceProcessor.cpp:456
void ReferenceProcessor::process_discovered_references() {
    // ğŸš¨ å¤„ç†å¤§é‡WeakReference/SoftReferenceæ—¶è€—æ—¶é•¿
    process_soft_references();
    process_weak_references();
}

// 3. å¯¹è±¡æ‹·è´ - å­˜æ´»å¯¹è±¡è¿‡å¤šæ—¶æ‹·è´å¼€é”€å¤§
// /data/workspace/openjdk11-core/src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:234
void G1ParScanThreadState::copy_to_survivor_space() {
    // ğŸš¨ Mixed GCæ—¶æ‹·è´çš„å¯¹è±¡æ•°é‡è¿‡å¤š
    copy_object_to_survivor(obj);
}
```

---

## ğŸ”§ **ç¬¬å…­æ­¥ï¼šä¼˜åŒ–è§£å†³æ–¹æ¡ˆ**

### 6.1 JVMå‚æ•°è°ƒä¼˜
```bash
# ä¼˜åŒ–åçš„G1GCå‚æ•°
-Xms8g -Xmx8g
-XX:+UseG1GC
-XX:MaxGCPauseMillis=100          # é™ä½æš‚åœç›®æ ‡ï¼Œæé«˜å“åº”æ€§
-XX:G1HeapRegionSize=16m          # å‡å°åŒºåŸŸå¤§å°ï¼Œå‡å°‘å•æ¬¡æ‹·è´é‡
-XX:G1MixedGCCountTarget=16       # å¢åŠ Mixed GCæ¬¡æ•°ï¼Œåˆ†æ‘Šå›æ”¶å‹åŠ›
-XX:G1MixedGCLiveThresholdPercent=85  # æé«˜Mixed GCè§¦å‘é˜ˆå€¼
-XX:G1OldCSetRegionThresholdPercent=5 # é™åˆ¶æ¯æ¬¡Mixed GCçš„åŒºåŸŸæ•°é‡
-XX:G1ReservePercent=15           # å¢åŠ ä¿ç•™ç©ºé—´ï¼Œå‡å°‘åˆ†é…å¤±è´¥
-XX:+G1UseAdaptiveIHOP           # å¯ç”¨è‡ªé€‚åº”IHOP
```

### 6.2 åº”ç”¨å±‚ä¼˜åŒ–
```java
// 1. ä¼˜åŒ–é•¿ç”Ÿå‘½å‘¨æœŸå¯¹è±¡ç®¡ç†
public class OptimizedCacheManager {
    
    // ä½¿ç”¨åˆ†åŒºç¼“å­˜ï¼Œå‡å°‘å•ä¸ªMapçš„å¤§å°
    private final Map<String, Object>[] cachePartitions;
    private final int partitionCount = 16;
    
    public OptimizedCacheManager() {
        cachePartitions = new Map[partitionCount];
        for (int i = 0; i < partitionCount; i++) {
            // é¢„è®¾å®¹é‡ï¼Œå‡å°‘rehash
            cachePartitions[i] = new ConcurrentHashMap<>(10000, 0.75f);
        }
    }
    
    public void put(String key, Object value) {
        int partition = Math.abs(key.hashCode()) % partitionCount;
        cachePartitions[partition].put(key, value);
    }
    
    // 2. å®ç°ç¼“å­˜è¿‡æœŸæœºåˆ¶ï¼Œé¿å…æ— é™å¢é•¿
    private void cleanupExpiredEntries() {
        for (Map<String, Object> partition : cachePartitions) {
            partition.entrySet().removeIf(entry -> isExpired(entry));
        }
    }
}

// 3. ä¼˜åŒ–å¼•ç”¨ä½¿ç”¨
public class OptimizedReferenceManager {
    
    // ä½¿ç”¨ReferenceQueueä¸»åŠ¨æ¸…ç†
    private final ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
    private final Set<WeakReference<Object>> activeRefs = ConcurrentHashMap.newKeySet();
    
    public void addWeakReference(Object obj) {
        WeakReference<Object> ref = new WeakReference<>(obj, referenceQueue);
        activeRefs.add(ref);
        
        // å®šæœŸæ¸…ç†å·²å›æ”¶çš„å¼•ç”¨
        cleanupReferences();
    }
    
    private void cleanupReferences() {
        Reference<?> ref;
        while ((ref = referenceQueue.poll()) != null) {
            activeRefs.remove(ref);
        }
    }
}
```

### 6.3 ç›‘æ§å’Œé¢„è­¦
```java
// G1GCå¥åº·åº¦ç›‘æ§
public class G1GCMonitor {
    
    public void monitorG1Health() {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
        
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            if (gcBean.getName().contains("G1")) {
                long collections = gcBean.getCollectionCount();
                long time = gcBean.getCollectionTime();
                
                if (collections > 0) {
                    double avgTime = (double) time / collections;
                    
                    // é¢„è­¦é˜ˆå€¼
                    if (avgTime > 200) { // è¶…è¿‡200ms
                        System.out.printf("âš ï¸ G1GCæ€§èƒ½é¢„è­¦: å¹³å‡æš‚åœæ—¶é—´ %.1fms%n", avgTime);
                    }
                    
                    System.out.printf("G1GCç»Ÿè®¡: æ¬¡æ•°=%d, æ€»æ—¶é—´=%dms, å¹³å‡=%.1fms%n", 
                        collections, time, avgTime);
                }
            }
        }
    }
}
```

---

## ğŸ“Š **ç¬¬ä¸ƒæ­¥ï¼šä¼˜åŒ–æ•ˆæœéªŒè¯**

### 7.1 ä¼˜åŒ–å‰åå¯¹æ¯”
```bash
# ä¼˜åŒ–å‰ (åŸå§‹å‚æ•°)
Mixed GCå¹³å‡æš‚åœ: 850ms
Mixed GC P99æš‚åœ: 1200ms  
åº”ç”¨å“åº”æ—¶é—´: 500ms+
ååé‡: 400 TPS

# ä¼˜åŒ–å (è°ƒä¼˜å‚æ•°)
Mixed GCå¹³å‡æš‚åœ: 120ms
Mixed GC P99æš‚åœ: 180ms
åº”ç”¨å“åº”æ—¶é—´: 60ms
ååé‡: 950 TPS
```

### 7.2 å‹æµ‹éªŒè¯
```bash
# ä½¿ç”¨ç›¸åŒçš„å‹æµ‹ç¨‹åºéªŒè¯
$ java -Xms8g -Xmx8g \
       -XX:+UseG1GC \
       -XX:MaxGCPauseMillis=100 \
       -XX:G1HeapRegionSize=16m \
       -XX:G1MixedGCCountTarget=16 \
       -XX:G1MixedGCLiveThresholdPercent=85 \
       -XX:G1OldCSetRegionThresholdPercent=5 \
       -XX:+PrintGC -XX:+PrintGCDetails \
       -Xloggc:g1gc-optimized.log \
       G1GCStressTest
```

---

## ğŸ¯ **æ ¸å¿ƒç»éªŒæ€»ç»“**

### ğŸ” **G1GCæ€§èƒ½æ’æŸ¥æ–¹æ³•è®º**
1. **GCæ—¥å¿—åˆ†æ** â†’ è¯†åˆ«Mixed GCæš‚åœæ—¶é—´å¼‚å¸¸
2. **æºç ç†è§£** â†’ åŸºäºOpenJDKæºç ç†è§£G1ç®—æ³•ç“¶é¢ˆ
3. **å®éªŒå¤ç°** â†’ æ„é€ çœŸå®åœºæ™¯å¤ç°é—®é¢˜
4. **å·¥å…·éªŒè¯** â†’ ä½¿ç”¨JFRã€GCViewerç­‰ä¸“ä¸šå·¥å…·åˆ†æ
5. **å‚æ•°è°ƒä¼˜** â†’ é’ˆå¯¹æ€§è°ƒæ•´G1å‚æ•°
6. **æ•ˆæœéªŒè¯** â†’ å‹æµ‹ç¡®è®¤ä¼˜åŒ–æ•ˆæœ

### ğŸš¨ **G1GCå…³é”®æŠ€æœ¯ç‚¹**
1. **Mixed GCè§¦å‘æœºåˆ¶**: è€å¹´ä»£å ç”¨è¶…è¿‡IHOPé˜ˆå€¼æ—¶è§¦å‘
2. **å›æ”¶é›†åˆé€‰æ‹©**: åŸºäºå›æ”¶æ•ˆç‡é€‰æ‹©æœ€ä¼˜åŒºåŸŸç»„åˆ
3. **å¹¶è¡Œå›æ”¶**: å¤šçº¿ç¨‹å¹¶è¡Œæ‰§è¡Œå¯¹è±¡æ‹·è´å’Œå¼•ç”¨æ›´æ–°
4. **æš‚åœæ—¶é—´æ§åˆ¶**: é€šè¿‡é™åˆ¶å›æ”¶åŒºåŸŸæ•°é‡æ§åˆ¶æš‚åœæ—¶é—´

### ğŸ’¡ **ä¼˜åŒ–ç­–ç•¥**
1. **åŒºåŸŸå¤§å°è°ƒä¼˜**: å¹³è¡¡å†…å­˜åˆ©ç”¨ç‡å’ŒGCå¼€é”€
2. **Mixed GCå‚æ•°**: æ§åˆ¶æ¯æ¬¡å›æ”¶çš„åŒºåŸŸæ•°é‡å’Œé¢‘ç‡
3. **åº”ç”¨å±‚ä¼˜åŒ–**: å‡å°‘é•¿ç”Ÿå‘½å‘¨æœŸå¯¹è±¡ï¼Œä¼˜åŒ–å¼•ç”¨ä½¿ç”¨
4. **ç›‘æ§é¢„è­¦**: å»ºç«‹GCæ€§èƒ½ç›‘æ§å’Œé¢„è­¦æœºåˆ¶

### ğŸ› ï¸ **ä¸“ä¸šå·¥å…·**
- **GCViewer**: GCæ—¥å¿—å¯è§†åŒ–åˆ†æ
- **JFR**: JVMå†…éƒ¨äº‹ä»¶è¯¦ç»†è®°å½•
- **jhsdb**: å †å†…å­˜æ·±åº¦åˆ†æ
- **Arthas**: å®æ—¶JVMç›‘æ§

è¿™ä¸ªæ¡ˆä¾‹å±•ç¤ºäº†åŸºäºOpenJDK11çœŸå®G1GCæºç çš„æ€§èƒ½é—®é¢˜æ’æŸ¥å…¨è¿‡ç¨‹ï¼Œå…·æœ‰å¾ˆå¼ºçš„æŠ€æœ¯æ·±åº¦å’Œå®æˆ˜ä»·å€¼ï¼