# å¹¶å‘é”ç«äº‰æ€§èƒ½é—®é¢˜ - çœŸå®æ¡ˆä¾‹æ’æŸ¥å®æˆ˜

## ğŸš¨ **é—®é¢˜ç°è±¡**

### çº¿ä¸Šç¯å¢ƒé…ç½®
- **JVMå‚æ•°**: `-Xms8g -Xmx8g -XX:+UseG1GC -XX:MaxGCPauseMillis=200`
- **æœåŠ¡å™¨**: 16æ ¸32GBï¼Œéå¤§é¡µå†…å­˜
- **åº”ç”¨**: é«˜å¹¶å‘è®¢å•å¤„ç†ç³»ç»Ÿï¼Œ200ä¸ªå¹¶å‘çº¿ç¨‹

### æ•…éšœè¡¨ç°
```bash
# ç³»ç»Ÿç›‘æ§å‘Šè­¦
[2024-01-15 16:45:12] CPUä½¿ç”¨ç‡: 15% (å¼‚å¸¸ä½ï¼Œæ­£å¸¸åº”è¯¥60%+)
[2024-01-15 16:45:13] çº¿ç¨‹é˜»å¡æ•°: 180+ (æ­£å¸¸<10)
[2024-01-15 16:45:14] æ¥å£å“åº”æ—¶é—´: 5000ms+ (æ­£å¸¸<200ms)
[2024-01-15 16:45:15] ååé‡: 50 TPS (æ­£å¸¸1500+ TPS)

# åº”ç”¨æ—¥å¿—å¼‚å¸¸
[WARN] è®¢å•å¤„ç†çº¿ç¨‹æ± é˜Ÿåˆ—ç§¯å‹: 50000+
[ERROR] æ•°æ®åº“è¿æ¥æ± è€—å°½
[WARN] å¤§é‡çº¿ç¨‹å¤„äºBLOCKEDçŠ¶æ€
```

**ğŸ” åˆæ­¥è§‚å¯Ÿ**: CPUä½¿ç”¨ç‡å¼‚å¸¸ä½ï¼Œä½†å“åº”æ—¶é—´å¾ˆé•¿ï¼Œå…¸å‹çš„é”ç«äº‰é—®é¢˜

---

## ğŸ”§ **ç¬¬ä¸€æ­¥ï¼šçº¿ç¨‹çŠ¶æ€åˆ†æ**

### 1.1 è·å–çº¿ç¨‹å †æ ˆå¿«ç…§
```bash
# è¿ç»­è·å–å¤šæ¬¡çº¿ç¨‹å †æ ˆ
$ jstack 12345 > thread_dump_1.txt
$ sleep 5
$ jstack 12345 > thread_dump_2.txt  
$ sleep 5
$ jstack 12345 > thread_dump_3.txt

# åˆ†æçº¿ç¨‹çŠ¶æ€åˆ†å¸ƒ
$ grep "java.lang.Thread.State" thread_dump_1.txt | sort | uniq -c
    15 java.lang.Thread.State: RUNNABLE
   185 java.lang.Thread.State: BLOCKED (on object monitor)
    12 java.lang.Thread.State: WAITING (on object monitor)
     8 java.lang.Thread.State: TIMED_WAITING (on object monitor)
```

**ğŸ¯ å…³é”®å‘ç°**: 185ä¸ªçº¿ç¨‹å¤„äºBLOCKEDçŠ¶æ€ï¼Œä¸¥é‡çš„é”ç«äº‰ï¼

### 1.2 åˆ†æå…·ä½“é˜»å¡ç‚¹
```bash
# æŸ¥çœ‹BLOCKEDçº¿ç¨‹çš„è¯¦ç»†å †æ ˆ
$ grep -A 10 "BLOCKED" thread_dump_1.txt | head -50

"order-processor-thread-45" #67 prio=5 os_prio=0 tid=0x... nid=0x1a2b waiting for monitor entry [0x...]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.example.service.OrderService.processOrder(OrderService.java:156)
        - waiting to lock <0x000000076ab62208> (a java.lang.Object)
        at com.example.controller.OrderController.submitOrder(OrderController.java:89)
        ...

"order-processor-thread-67" #89 prio=5 os_prio=0 tid=0x... nid=0x1a3c waiting for monitor entry [0x...]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.example.service.OrderService.processOrder(OrderService.java:156)
        - waiting to lock <0x000000076ab62208> (a java.lang.Object)  # ğŸš¨ åŒä¸€ä¸ªé”å¯¹è±¡ï¼
        at com.example.controller.OrderController.submitOrder(OrderController.java:89)
        ...
```

**ğŸ¯ å…³é”®å‘ç°**: 
- æ‰€æœ‰çº¿ç¨‹éƒ½åœ¨ç­‰å¾…åŒä¸€ä¸ªé”å¯¹è±¡ `<0x000000076ab62208>`
- é˜»å¡ç‚¹åœ¨ `OrderService.processOrder()` æ–¹æ³•
- è¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„é”ç“¶é¢ˆé—®é¢˜

---

## ğŸ” **ç¬¬äºŒæ­¥ï¼šåŸºäºOpenJDKæºç åˆ†æé”æœºåˆ¶**

### 2.1 æŸ¥çœ‹synchronizedå®ç°åŸç†
```cpp
// /data/workspace/openjdk11-core/src/hotspot/share/runtime/synchronizer.cpp

// synchronizedå…³é”®å­—çš„åº•å±‚å®ç°
ObjectMonitor* ObjectSynchronizer::inflate(Thread * Self,
                                         oop object,
                                         const InflateCause cause) {
  
  // ğŸ”¥ å…³é”®ï¼šmonitorå¯¹è±¡çš„åˆ›å»ºå’Œç«äº‰å¤„ç†
  for (;;) {
    const markOop mark = object->mark();
    
    // å¦‚æœå¯¹è±¡å·²ç»æœ‰monitorï¼Œç›´æ¥è¿”å›
    if (mark->has_monitor()) {
      ObjectMonitor * inf = mark->monitor();
      return inf;
    }
    
    // ğŸš¨ æ€§èƒ½ç“¶é¢ˆï¼šå¤šçº¿ç¨‹ç«äº‰æ—¶çš„CASæ“ä½œ
    if (mark->is_neutral()) {
      // å°è¯•CASè®¾ç½®monitor
      ObjectMonitor * m = omAlloc(Self);
      m->set_object(object);
      
      if (object->cas_set_mark((markOop) m, mark) == mark) {
        return m;
      }
      // CASå¤±è´¥ï¼Œé‡Šæ”¾monitorå¹¶é‡è¯•
      omRelease(Self, m, true);
      continue;
    }
  }
}
```

### 2.2 åˆ†æReentrantLockæºç 
```java
// /data/workspace/openjdk11-core/src/java.base/share/classes/java/util/concurrent/locks/ReentrantLock.java

public class ReentrantLock implements Lock, java.io.Serializable {
    
    // å†…éƒ¨ä½¿ç”¨AQSå®ç°
    private final Sync sync;
    
    /**
     * è·å–é”çš„æ ¸å¿ƒé€»è¾‘
     */
    public void lock() {
        sync.lock();  // å§”æ‰˜ç»™AQS
    }
    
    // éå…¬å¹³é”å®ç°ï¼ˆé»˜è®¤ï¼‰
    static final class NonfairSync extends Sync {
        final void lock() {
            // ğŸ”¥ å…ˆå°è¯•CASå¿«é€Ÿè·å–é”
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);  // è¿›å…¥AQSé˜Ÿåˆ—ç­‰å¾…
        }
    }
    
    // å…¬å¹³é”å®ç°
    static final class FairSync extends Sync {
        final void lock() {
            acquire(1);  // ç›´æ¥è¿›å…¥AQSé˜Ÿåˆ—ï¼Œä¿è¯å…¬å¹³æ€§
        }
    }
}
```

**ğŸ¤” åˆ†æ**: 
- `synchronized` ä½¿ç”¨é‡é‡çº§é”ï¼Œå¤šçº¿ç¨‹ç«äº‰æ—¶å¼€é”€å¤§
- `ReentrantLock` åŸºäºAQSï¼Œå¯ä»¥é€‰æ‹©å…¬å¹³/éå…¬å¹³ç­–ç•¥
- é”ç«äº‰æ¿€çƒˆæ—¶ï¼Œä¸¤è€…éƒ½ä¼šå¯¼è‡´æ€§èƒ½é—®é¢˜

---

## ğŸ§ª **ç¬¬ä¸‰æ­¥ï¼šåˆ›å»ºçœŸå®å¤ç°æ¡ˆä¾‹**

### 3.1 ç¼–å†™å¹¶å‘é”ç«äº‰æµ‹è¯•ç¨‹åº
```java
// ConcurrencyBottleneckTest.java - åŸºäºçœŸå®åœºæ™¯çš„å¹¶å‘æ€§èƒ½é—®é¢˜å¤ç°
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.*;
import java.util.concurrent.atomic.*;

/**
 * å¹¶å‘é”ç«äº‰æ€§èƒ½é—®é¢˜å¤ç°ç¨‹åº
 * è¿è¡Œå‚æ•°: -Xms8g -Xmx8g -XX:+UseG1GC
 */
public class ConcurrencyBottleneckTest {
    
    // æ¨¡æ‹Ÿä¸åŒçš„é”ç«äº‰åœºæ™¯
    private static final Object GLOBAL_LOCK = new Object();
    private static final ReentrantLock REENTRANT_LOCK = new ReentrantLock();
    private static final ReentrantReadWriteLock READ_WRITE_LOCK = new ReentrantReadWriteLock();
    
    // ç»Ÿè®¡æ•°æ®
    private static final AtomicLong totalOperations = new AtomicLong(0);
    private static final AtomicLong blockedOperations = new AtomicLong(0);
    private static volatile boolean running = true;
    
    // æ¨¡æ‹Ÿä¸šåŠ¡æ•°æ®
    private static final Map<String, OrderData> orderDatabase = new ConcurrentHashMap<>();
    private static final AtomicLong orderIdGenerator = new AtomicLong(0);
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== å¹¶å‘é”ç«äº‰æ€§èƒ½é—®é¢˜å¤ç°æµ‹è¯• ===");
        printSystemInfo();
        
        // åˆå§‹åŒ–æµ‹è¯•æ•°æ®
        initializeTestData();
        
        // å¯åŠ¨ç›‘æ§çº¿ç¨‹
        startMonitorThread();
        
        System.out.println("\nå¼€å§‹æµ‹è¯•ä¸åŒé”ç«äº‰åœºæ™¯...");
        
        // æµ‹è¯•1: synchronizedå…³é”®å­— - é‡é”ç«äº‰
        testSynchronizedBottleneck();
        
        Thread.sleep(5000);
        
        // æµ‹è¯•2: ReentrantLock - æ˜¾å¼é”ç«äº‰
        testReentrantLockBottleneck();
        
        Thread.sleep(5000);
        
        // æµ‹è¯•3: è¯»å†™é” - è¯»å†™ç«äº‰
        testReadWriteLockBottleneck();
        
        Thread.sleep(5000);
        
        // æµ‹è¯•4: ç»†ç²’åº¦é” - ä¼˜åŒ–æ–¹æ¡ˆ
        testFinegrainedLocking();
        
        running = false;
        System.out.println("\næµ‹è¯•å®Œæˆ");
    }
    
    /**
     * æµ‹è¯•synchronizedå…³é”®å­—çš„é”ç«äº‰ç“¶é¢ˆ
     */
    private static void testSynchronizedBottleneck() throws InterruptedException {
        System.out.println("\n=== æµ‹è¯•1: synchronizedé”ç«äº‰ ===");
        resetCounters();
        
        ExecutorService executor = Executors.newFixedThreadPool(50);
        CountDownLatch latch = new CountDownLatch(50);
        
        long startTime = System.currentTimeMillis();
        
        // å¯åŠ¨50ä¸ªçº¿ç¨‹ï¼Œéƒ½ç«äº‰åŒä¸€ä¸ªsynchronizedé”
        for (int i = 0; i < 50; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    for (int j = 0; j < 1000; j++) {
                        processOrderWithSynchronized("order_" + threadId + "_" + j);
                    }
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await();
        long endTime = System.currentTimeMillis();
        
        executor.shutdown();
        
        System.out.println("synchronizedæµ‹è¯•ç»“æœ:");
        System.out.println("  æ€»è€—æ—¶: " + (endTime - startTime) + "ms");
        System.out.println("  æ€»æ“ä½œæ•°: " + totalOperations.get());
        System.out.println("  å¹³å‡TPS: " + (totalOperations.get() * 1000 / (endTime - startTime)));
        System.out.println("  é˜»å¡æ“ä½œæ•°: " + blockedOperations.get());
    }
    
    /**
     * æµ‹è¯•ReentrantLockçš„é”ç«äº‰ç“¶é¢ˆ
     */
    private static void testReentrantLockBottleneck() throws InterruptedException {
        System.out.println("\n=== æµ‹è¯•2: ReentrantLocké”ç«äº‰ ===");
        resetCounters();
        
        ExecutorService executor = Executors.newFixedThreadPool(50);
        CountDownLatch latch = new CountDownLatch(50);
        
        long startTime = System.currentTimeMillis();
        
        // å¯åŠ¨50ä¸ªçº¿ç¨‹ï¼Œéƒ½ç«äº‰åŒä¸€ä¸ªReentrantLock
        for (int i = 0; i < 50; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    for (int j = 0; j < 1000; j++) {
                        processOrderWithReentrantLock("order_" + threadId + "_" + j);
                    }
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await();
        long endTime = System.currentTimeMillis();
        
        executor.shutdown();
        
        System.out.println("ReentrantLockæµ‹è¯•ç»“æœ:");
        System.out.println("  æ€»è€—æ—¶: " + (endTime - startTime) + "ms");
        System.out.println("  æ€»æ“ä½œæ•°: " + totalOperations.get());
        System.out.println("  å¹³å‡TPS: " + (totalOperations.get() * 1000 / (endTime - startTime)));
        System.out.println("  é˜»å¡æ“ä½œæ•°: " + blockedOperations.get());
    }
    
    /**
     * æµ‹è¯•è¯»å†™é”çš„ç«äº‰é—®é¢˜
     */
    private static void testReadWriteLockBottleneck() throws InterruptedException {
        System.out.println("\n=== æµ‹è¯•3: ReadWriteLockè¯»å†™ç«äº‰ ===");
        resetCounters();
        
        ExecutorService executor = Executors.newFixedThreadPool(50);
        CountDownLatch latch = new CountDownLatch(50);
        
        long startTime = System.currentTimeMillis();
        
        // å¯åŠ¨40ä¸ªè¯»çº¿ç¨‹ + 10ä¸ªå†™çº¿ç¨‹
        for (int i = 0; i < 40; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    for (int j = 0; j < 1000; j++) {
                        readOrderWithReadWriteLock("order_" + (threadId % 100));
                    }
                } finally {
                    latch.countDown();
                }
            });
        }
        
        for (int i = 40; i < 50; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    for (int j = 0; j < 100; j++) {  // å†™æ“ä½œè¾ƒå°‘
                        writeOrderWithReadWriteLock("order_" + threadId + "_" + j);
                    }
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await();
        long endTime = System.currentTimeMillis();
        
        executor.shutdown();
        
        System.out.println("ReadWriteLockæµ‹è¯•ç»“æœ:");
        System.out.println("  æ€»è€—æ—¶: " + (endTime - startTime) + "ms");
        System.out.println("  æ€»æ“ä½œæ•°: " + totalOperations.get());
        System.out.println("  å¹³å‡TPS: " + (totalOperations.get() * 1000 / (endTime - startTime)));
        System.out.println("  é˜»å¡æ“ä½œæ•°: " + blockedOperations.get());
    }
    
    /**
     * æµ‹è¯•ç»†ç²’åº¦é”ä¼˜åŒ–æ–¹æ¡ˆ
     */
    private static void testFinegrainedLocking() throws InterruptedException {
        System.out.println("\n=== æµ‹è¯•4: ç»†ç²’åº¦é”ä¼˜åŒ– ===");
        resetCounters();
        
        ExecutorService executor = Executors.newFixedThreadPool(50);
        CountDownLatch latch = new CountDownLatch(50);
        
        long startTime = System.currentTimeMillis();
        
        // ä½¿ç”¨åˆ†æ®µé”ï¼Œå‡å°‘é”ç«äº‰
        for (int i = 0; i < 50; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    for (int j = 0; j < 1000; j++) {
                        processOrderWithFinegrainedLock("order_" + threadId + "_" + j);
                    }
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await();
        long endTime = System.currentTimeMillis();
        
        executor.shutdown();
        
        System.out.println("ç»†ç²’åº¦é”æµ‹è¯•ç»“æœ:");
        System.out.println("  æ€»è€—æ—¶: " + (endTime - startTime) + "ms");
        System.out.println("  æ€»æ“ä½œæ•°: " + totalOperations.get());
        System.out.println("  å¹³å‡TPS: " + (totalOperations.get() * 1000 / (endTime - startTime)));
        System.out.println("  é˜»å¡æ“ä½œæ•°: " + blockedOperations.get());
    }
    
    /**
     * ä½¿ç”¨synchronizedå¤„ç†è®¢å• - æ€§èƒ½ç“¶é¢ˆç‰ˆæœ¬
     */
    private static void processOrderWithSynchronized(String orderId) {
        long startTime = System.nanoTime();
        
        synchronized (GLOBAL_LOCK) {  // ğŸš¨ æ‰€æœ‰çº¿ç¨‹ç«äº‰åŒä¸€ä¸ªé”
            long waitTime = System.nanoTime() - startTime;
            if (waitTime > 1000000) { // ç­‰å¾…è¶…è¿‡1ms
                blockedOperations.incrementAndGet();
            }
            
            // æ¨¡æ‹Ÿä¸šåŠ¡å¤„ç†
            OrderData order = new OrderData(orderId, "user_" + orderId.hashCode());
            order.setStatus("PROCESSING");
            
            // æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œ - è€—æ—¶æ“ä½œ
            simulateSlowOperation(5); // 5ms
            
            order.setStatus("COMPLETED");
            orderDatabase.put(orderId, order);
            
            totalOperations.incrementAndGet();
        }
    }
    
    /**
     * ä½¿ç”¨ReentrantLockå¤„ç†è®¢å•
     */
    private static void processOrderWithReentrantLock(String orderId) {
        long startTime = System.nanoTime();
        
        REENTRANT_LOCK.lock();
        try {
            long waitTime = System.nanoTime() - startTime;
            if (waitTime > 1000000) { // ç­‰å¾…è¶…è¿‡1ms
                blockedOperations.incrementAndGet();
            }
            
            // æ¨¡æ‹Ÿä¸šåŠ¡å¤„ç†
            OrderData order = new OrderData(orderId, "user_" + orderId.hashCode());
            order.setStatus("PROCESSING");
            
            // æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œ
            simulateSlowOperation(5); // 5ms
            
            order.setStatus("COMPLETED");
            orderDatabase.put(orderId, order);
            
            totalOperations.incrementAndGet();
            
        } finally {
            REENTRANT_LOCK.unlock();
        }
    }
    
    /**
     * ä½¿ç”¨è¯»å†™é”è¯»å–è®¢å•
     */
    private static void readOrderWithReadWriteLock(String orderId) {
        long startTime = System.nanoTime();
        
        READ_WRITE_LOCK.readLock().lock();
        try {
            long waitTime = System.nanoTime() - startTime;
            if (waitTime > 1000000) {
                blockedOperations.incrementAndGet();
            }
            
            // æ¨¡æ‹Ÿè¯»å–æ“ä½œ
            OrderData order = orderDatabase.get(orderId);
            if (order != null) {
                // æ¨¡æ‹Ÿè¯»å–å¤„ç†
                simulateSlowOperation(1); // 1ms
            }
            
            totalOperations.incrementAndGet();
            
        } finally {
            READ_WRITE_LOCK.readLock().unlock();
        }
    }
    
    /**
     * ä½¿ç”¨è¯»å†™é”å†™å…¥è®¢å•
     */
    private static void writeOrderWithReadWriteLock(String orderId) {
        long startTime = System.nanoTime();
        
        READ_WRITE_LOCK.writeLock().lock();
        try {
            long waitTime = System.nanoTime() - startTime;
            if (waitTime > 1000000) {
                blockedOperations.incrementAndGet();
            }
            
            // æ¨¡æ‹Ÿå†™å…¥æ“ä½œ
            OrderData order = new OrderData(orderId, "user_" + orderId.hashCode());
            order.setStatus("COMPLETED");
            
            // æ¨¡æ‹Ÿå†™å…¥å¤„ç†
            simulateSlowOperation(10); // 10ms
            
            orderDatabase.put(orderId, order);
            totalOperations.incrementAndGet();
            
        } finally {
            READ_WRITE_LOCK.writeLock().unlock();
        }
    }
    
    // åˆ†æ®µé” - ä¼˜åŒ–æ–¹æ¡ˆ
    private static final int SEGMENT_COUNT = 16;
    private static final ReentrantLock[] SEGMENT_LOCKS = new ReentrantLock[SEGMENT_COUNT];
    
    static {
        for (int i = 0; i < SEGMENT_COUNT; i++) {
            SEGMENT_LOCKS[i] = new ReentrantLock();
        }
    }
    
    /**
     * ä½¿ç”¨ç»†ç²’åº¦é”å¤„ç†è®¢å• - ä¼˜åŒ–ç‰ˆæœ¬
     */
    private static void processOrderWithFinegrainedLock(String orderId) {
        // æ ¹æ®è®¢å•IDé€‰æ‹©å¯¹åº”çš„é”æ®µ
        int segment = Math.abs(orderId.hashCode()) % SEGMENT_COUNT;
        ReentrantLock lock = SEGMENT_LOCKS[segment];
        
        long startTime = System.nanoTime();
        
        lock.lock();
        try {
            long waitTime = System.nanoTime() - startTime;
            if (waitTime > 1000000) {
                blockedOperations.incrementAndGet();
            }
            
            // æ¨¡æ‹Ÿä¸šåŠ¡å¤„ç†
            OrderData order = new OrderData(orderId, "user_" + orderId.hashCode());
            order.setStatus("PROCESSING");
            
            // æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œ
            simulateSlowOperation(5); // 5ms
            
            order.setStatus("COMPLETED");
            orderDatabase.put(orderId, order);
            
            totalOperations.incrementAndGet();
            
        } finally {
            lock.unlock();
        }
    }
    
    /**
     * æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
     */
    private static void simulateSlowOperation(int milliseconds) {
        try {
            Thread.sleep(milliseconds);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    /**
     * åˆå§‹åŒ–æµ‹è¯•æ•°æ®
     */
    private static void initializeTestData() {
        System.out.println("åˆå§‹åŒ–æµ‹è¯•æ•°æ®...");
        
        // é¢„å…ˆåˆ›å»ºä¸€äº›è®¢å•æ•°æ®
        for (int i = 0; i < 100; i++) {
            String orderId = "init_order_" + i;
            OrderData order = new OrderData(orderId, "user_" + i);
            order.setStatus("COMPLETED");
            orderDatabase.put(orderId, order);
        }
        
        System.out.println("åˆå§‹åŒ–å®Œæˆï¼Œé¢„åˆ›å»ºè®¢å•: " + orderDatabase.size());
    }
    
    /**
     * å¯åŠ¨ç›‘æ§çº¿ç¨‹
     */
    private static void startMonitorThread() {
        Thread monitor = new Thread(() -> {
            long lastOperations = 0;
            long lastTime = System.currentTimeMillis();
            
            while (running) {
                try {
                    Thread.sleep(5000);
                    
                    long currentOperations = totalOperations.get();
                    long currentTime = System.currentTimeMillis();
                    
                    long deltaOps = currentOperations - lastOperations;
                    long deltaTime = currentTime - lastTime;
                    
                    if (deltaTime > 0) {
                        long currentTPS = deltaOps * 1000 / deltaTime;
                        System.out.printf("[ç›‘æ§] å½“å‰TPS: %d, æ€»æ“ä½œ: %d, é˜»å¡æ“ä½œ: %d, é˜»å¡ç‡: %.1f%%\n",
                            currentTPS, currentOperations, blockedOperations.get(),
                            (double) blockedOperations.get() / currentOperations * 100);
                    }
                    
                    lastOperations = currentOperations;
                    lastTime = currentTime;
                    
                } catch (InterruptedException e) {
                    break;
                }
            }
        }, "PerformanceMonitor");
        
        monitor.setDaemon(true);
        monitor.start();
    }
    
    private static void resetCounters() {
        totalOperations.set(0);
        blockedOperations.set(0);
    }
    
    private static void printSystemInfo() {
        System.out.println("ç³»ç»Ÿä¿¡æ¯:");
        System.out.println("  JVM: " + System.getProperty("java.vm.name"));
        System.out.println("  ç‰ˆæœ¬: " + System.getProperty("java.version"));
        System.out.println("  å¤„ç†å™¨: " + Runtime.getRuntime().availableProcessors() + "æ ¸");
        System.out.println("  æœ€å¤§å†…å­˜: " + Runtime.getRuntime().maxMemory() / 1024 / 1024 + "MB");
    }
}

/**
 * è®¢å•æ•°æ®æ¨¡å‹
 */
class OrderData {
    private final String orderId;
    private final String userId;
    private String status;
    private final long createTime;
    private long updateTime;
    
    public OrderData(String orderId, String userId) {
        this.orderId = orderId;
        this.userId = userId;
        this.createTime = System.currentTimeMillis();
        this.updateTime = createTime;
        this.status = "CREATED";
    }
    
    public String getOrderId() { return orderId; }
    public String getUserId() { return userId; }
    public String getStatus() { return status; }
    public long getCreateTime() { return createTime; }
    public long getUpdateTime() { return updateTime; }
    
    public void setStatus(String status) {
        this.status = status;
        this.updateTime = System.currentTimeMillis();
    }
    
    @Override
    public String toString() {
        return String.format("Order{id='%s', user='%s', status='%s'}", 
            orderId, userId, status);
    }
}