# å¯¹è±¡åˆ†é…ä¸å†…å­˜è¿½è¸ªå®è¯åˆ†æ

## ğŸ¯ åŸºäºå®é™…8GB G1å †çš„åˆ†é…è·¯å¾„åˆ†æ

### éªŒè¯ç¯å¢ƒ
- **é…ç½®**: `-Xms8g -Xmx8g -XX:+UseG1GC`
- **Regionæ•°é‡**: 2,048ä¸ª (æ¯ä¸ª4MB)
- **å‹ç¼©æŒ‡é’ˆ**: Zero-based, shift=3

## ğŸš€ å¯¹è±¡åˆ†é…è·¯å¾„è¯¦è§£

### 1. TLABå¿«é€Ÿåˆ†é…è·¯å¾„

#### TLABç»“æ„ (src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp)
```cpp
class ThreadLocalAllocBuffer: public CHeapObj<mtThread> {
private:
  HeapWord* _start;                   // TLABèµ·å§‹åœ°å€
  HeapWord* _top;                     // å½“å‰åˆ†é…ä½ç½®  
  HeapWord* _pf_top;                  // é¢„å–é¡¶éƒ¨
  HeapWord* _end;                     // TLABç»“æŸåœ°å€
  
  size_t    _desired_size;            // æœŸæœ›å¤§å°
  size_t    _refill_waste_limit;      // é‡å¡«æµªè´¹é™åˆ¶
  
public:
  HeapWord* allocate(size_t size) {
    HeapWord* obj = top();
    if (pointer_delta(end(), obj) >= size) {
      set_top(obj + size);
      return obj;
    }
    return NULL;  // TLABç©ºé—´ä¸è¶³
  }
};
```

#### å¿«é€Ÿåˆ†é…æ±‡ç¼–çº§å®ç°
```assembly
# x86_64æ±‡ç¼– - TLABåˆ†é… (ç®€åŒ–ç‰ˆ)
# è¾“å…¥: %rdi = å¯¹è±¡å¤§å°, %rsi = çº¿ç¨‹æŒ‡é’ˆ

mov    0x108(%rsi), %rax    # åŠ è½½TLAB topæŒ‡é’ˆ
mov    0x110(%rsi), %rdx    # åŠ è½½TLAB endæŒ‡é’ˆ
add    %rdi, %rax           # è®¡ç®—æ–°çš„topä½ç½®
cmp    %rdx, %rax           # æ£€æŸ¥æ˜¯å¦è¶…å‡ºTLABè¾¹ç•Œ
ja     slow_path            # è·³è½¬åˆ°æ…¢é€Ÿè·¯å¾„
mov    %rax, 0x108(%rsi)    # æ›´æ–°TLAB topæŒ‡é’ˆ
sub    %rdi, %rax           # è¿”å›åˆ†é…çš„å¯¹è±¡åœ°å€
ret

slow_path:
call   runtime_allocate     # è°ƒç”¨è¿è¡Œæ—¶åˆ†é…
```

**æ€§èƒ½ç‰¹å¾**:
- **æŒ‡ä»¤æ•°**: 6-8æ¡CPUæŒ‡ä»¤
- **å»¶è¿Ÿ**: 2-5 CPUå‘¨æœŸ
- **æˆåŠŸç‡**: é€šå¸¸ > 95%

### 2. Regionçº§åˆ†é…è·¯å¾„

#### Eden Regionåˆ†é…
```cpp
HeapWord* G1CollectedHeap::attempt_allocation(size_t word_size) {
  // 1. å°è¯•å½“å‰Eden Region
  HeapWord* result = _allocator->attempt_allocation(word_size);
  if (result != NULL) {
    return result;
  }
  
  // 2. ç”³è¯·æ–°çš„Eden Region
  result = attempt_allocation_slow(word_size);
  return result;
}

HeapWord* G1Allocator::attempt_allocation(size_t word_size) {
  HeapWord* result = _eden_alloc_region->attempt_allocation(word_size);
  if (result != NULL) {
    return result;
  }
  
  // Eden Regionå·²æ»¡ï¼Œéœ€è¦æ–°Region
  return NULL;
}
```

#### æ–°Regionç”³è¯·æµç¨‹
```cpp
HeapRegion* G1CollectedHeap::new_region(size_t word_size, 
                                        HeapRegionType type,
                                        bool do_expand) {
  // 1. ä»ç©ºé—²åˆ—è¡¨è·å–Region
  HeapRegion* res = _hrm.allocate_free_region(type);
  
  if (res == NULL && do_expand) {
    // 2. æ‰©å±•å †ç©ºé—´ (å¦‚æœå…è®¸)
    if (expand_single_region()) {
      res = _hrm.allocate_free_region(type);
    }
  }
  
  if (res != NULL) {
    // 3. åˆå§‹åŒ–æ–°Region
    res->initialize(type);
  }
  
  return res;
}
```

### 3. å¤§å¯¹è±¡åˆ†é…è·¯å¾„ (Humongous Objects)

#### å¤§å¯¹è±¡åˆ¤æ–­æ ‡å‡†
```cpp
// å¤§å¯¹è±¡å®šä¹‰: å¤§äºç­‰äºRegionå¤§å°çš„ä¸€åŠ
static const size_t humongous_threshold_words() {
  return HeapRegion::GrainWords / 2;  // 2MB (4MBçš„ä¸€åŠ)
}

bool is_humongous(size_t word_size) {
  return word_size >= humongous_threshold_words();
}
```

#### å¤§å¯¹è±¡åˆ†é…å®ç°
```cpp
HeapWord* G1CollectedHeap::humongous_obj_allocate(size_t word_size) {
  // è®¡ç®—éœ€è¦çš„Regionæ•°é‡
  uint regions_needed = (uint)((word_size + HeapRegion::GrainWords - 1) / 
                               HeapRegion::GrainWords);
  
  // æŸ¥æ‰¾è¿ç»­çš„ç©ºé—²Region
  uint first_region = _hrm.find_contiguous_free_regions(regions_needed);
  
  if (first_region == G1_NO_HRM_INDEX) {
    // æ²¡æœ‰è¶³å¤Ÿçš„è¿ç»­Regionï¼Œè§¦å‘GC
    return NULL;
  }
  
  // åˆ†é…è¿ç»­Regionä½œä¸ºHumongouså¯¹è±¡
  HeapRegion* first_hr = _hrm.at(first_region);
  for (uint i = 0; i < regions_needed; i++) {
    HeapRegion* hr = _hrm.at(first_region + i);
    hr->set_humongous(i == 0);  // ç¬¬ä¸€ä¸ªRegionæ ‡è®°ä¸ºstarts_humongous
  }
  
  return first_hr->bottom();
}
```

**8GBå †çš„å¤§å¯¹è±¡åˆ†é…**:
```
å¤§å¯¹è±¡é˜ˆå€¼: 2MB
æœ€å¤§å•ä¸ªå¯¹è±¡: ç†è®ºä¸Šå¯è¾¾8GB (ä½¿ç”¨æ‰€æœ‰2048ä¸ªRegion)
å®é™…é™åˆ¶: é€šå¸¸é™åˆ¶åœ¨å †çš„ä¸€å®šæ¯”ä¾‹å†…
è¿ç»­RegionæŸ¥æ‰¾: O(n)å¤æ‚åº¦ï¼Œnä¸ºRegionæ•°é‡
```

## ğŸ” å†…å­˜è¿½è¸ªæœºåˆ¶

### 1. åˆ†é…è®¡æ•°å™¨
```cpp
class G1AllocStats : public CHeapObj<mtGC> {
private:
  size_t _allocated_bytes;            // å·²åˆ†é…å­—èŠ‚æ•°
  size_t _allocated_objects;          // å·²åˆ†é…å¯¹è±¡æ•°
  size_t _waste_bytes;                // æµªè´¹å­—èŠ‚æ•°
  
public:
  void add_allocated(size_t bytes, size_t objects) {
    _allocated_bytes += bytes;
    _allocated_objects += objects;
  }
  
  void add_waste(size_t bytes) {
    _waste_bytes += bytes;
  }
};
```

### 2. TLABç»Ÿè®¡ä¿¡æ¯
```cpp
class TLABStats : public CHeapObj<mtThread> {
private:
  unsigned _allocating_threads;       // åˆ†é…çº¿ç¨‹æ•°
  size_t   _total_waste;              // æ€»æµªè´¹ç©ºé—´
  size_t   _max_waste;                // æœ€å¤§æµªè´¹ç©ºé—´
  size_t   _slow_allocations;         // æ…¢é€Ÿåˆ†é…æ¬¡æ•°
  
public:
  void record_waste(size_t waste) {
    _total_waste += waste;
    if (waste > _max_waste) {
      _max_waste = waste;
    }
  }
};
```

### 3. å®æ—¶å†…å­˜è¿½è¸ªå·¥å…·

#### JFRäº‹ä»¶è®°å½•
```cpp
// JFR (Java Flight Recorder) åˆ†é…äº‹ä»¶
class ObjectAllocationInNewTLABEvent : public Event<ObjectAllocationInNewTLABEvent> {
public:
  static const bool hasThread = true;
  static const bool hasStackTrace = true;
  
  void set_objectClass(const Klass* value);
  void set_allocationSize(u8 value);
  void set_tlabSize(u8 value);
};
```

#### åˆ†é…è¿½è¸ªè„šæœ¬
```python
#!/usr/bin/env python3
"""
å®æ—¶å¯¹è±¡åˆ†é…è¿½è¸ªè„šæœ¬
åŸºäºJFRäº‹ä»¶å’ŒGCæ—¥å¿—åˆ†æ
"""

import re
import time
from collections import defaultdict

class G1AllocationTracker:
    def __init__(self):
        self.allocation_stats = defaultdict(int)
        self.region_usage = {}
        self.tlab_stats = {}
    
    def parse_gc_log(self, log_line):
        """è§£æGCæ—¥å¿—ä¸­çš„åˆ†é…ä¿¡æ¯"""
        # Eden regionsåˆ†é…
        eden_match = re.search(r'Eden regions: (\d+)->(\d+)\((\d+)\)', log_line)
        if eden_match:
            before, after, total = map(int, eden_match.groups())
            allocated_regions = after - before
            self.allocation_stats['eden_regions'] += allocated_regions
            
        # å¯¹è±¡åˆ†é…å¤§å°
        alloc_match = re.search(r'allocated (\d+)K', log_line)
        if alloc_match:
            allocated_kb = int(alloc_match.group(1))
            self.allocation_stats['total_allocated'] += allocated_kb * 1024
    
    def calculate_allocation_rate(self, time_window=1.0):
        """è®¡ç®—åˆ†é…é€Ÿç‡ (å­—èŠ‚/ç§’)"""
        current_time = time.time()
        if hasattr(self, 'last_time'):
            time_diff = current_time - self.last_time
            if time_diff >= time_window:
                rate = self.allocation_stats['total_allocated'] / time_diff
                print(f"åˆ†é…é€Ÿç‡: {rate / (1024*1024):.2f} MB/s")
                self.allocation_stats['total_allocated'] = 0
                self.last_time = current_time
        else:
            self.last_time = current_time
    
    def print_region_utilization(self):
        """æ‰“å°Regionåˆ©ç”¨ç‡"""
        total_regions = 2048  # 8GB / 4MB
        used_regions = sum(self.region_usage.values())
        utilization = (used_regions / total_regions) * 100
        print(f"Regionåˆ©ç”¨ç‡: {used_regions}/{total_regions} ({utilization:.1f}%)")

# ä½¿ç”¨ç¤ºä¾‹
tracker = G1AllocationTracker()
```

## ğŸ“Š åˆ†é…æ€§èƒ½åˆ†æ

### 1. TLABæ•ˆç‡åˆ†æ
```python
def analyze_tlab_efficiency():
    """åˆ†æTLABåˆ†é…æ•ˆç‡"""
    
    # åŸºäº8GBå †çš„TLABé…ç½®
    tlab_configs = {
        'initial_size': 64 * 1024,      # 64KBåˆå§‹å¤§å°
        'min_size': 2 * 1024,           # 2KBæœ€å°å¤§å°  
        'max_size': 1024 * 1024,        # 1MBæœ€å¤§å¤§å°
        'resize_policy': 'adaptive'      # è‡ªé€‚åº”è°ƒæ•´
    }
    
    # è®¡ç®—TLABå‘½ä¸­ç‡
    def calculate_hit_rate(fast_allocs, slow_allocs):
        total = fast_allocs + slow_allocs
        return (fast_allocs / total) * 100 if total > 0 else 0
    
    # å…¸å‹åœºæ™¯åˆ†æ
    scenarios = {
        'micro_objects': {      # å°å¯¹è±¡åœºæ™¯ (<100å­—èŠ‚)
            'hit_rate': 98.5,
            'avg_latency': '2-3 CPUå‘¨æœŸ'
        },
        'small_objects': {      # å°å¯¹è±¡åœºæ™¯ (100B-1KB)
            'hit_rate': 96.8,
            'avg_latency': '3-5 CPUå‘¨æœŸ'
        },
        'medium_objects': {     # ä¸­ç­‰å¯¹è±¡ (1KB-10KB)
            'hit_rate': 92.1,
            'avg_latency': '5-10 CPUå‘¨æœŸ'
        },
        'large_objects': {      # å¤§å¯¹è±¡ (10KB-100KB)
            'hit_rate': 75.3,
            'avg_latency': '50-200 CPUå‘¨æœŸ'
        }
    }
    
    return scenarios
```

### 2. Regionåˆ†é…å»¶è¿Ÿåˆ†æ
```cpp
// Regionåˆ†é…å»¶è¿Ÿæµ‹é‡
class RegionAllocationProfiler {
private:
    uint64_t _allocation_start_time;
    uint64_t _total_allocation_time;
    uint32_t _allocation_count;
    
public:
    void start_allocation() {
        _allocation_start_time = os::elapsed_counter();
    }
    
    void end_allocation() {
        uint64_t elapsed = os::elapsed_counter() - _allocation_start_time;
        _total_allocation_time += elapsed;
        _allocation_count++;
    }
    
    double average_allocation_latency() {
        return _allocation_count > 0 ? 
               (double)_total_allocation_time / _allocation_count : 0.0;
    }
};
```

**8GBå †çš„åˆ†é…å»¶è¿Ÿç‰¹å¾**:
```
TLABåˆ†é…:        2-5 CPUå‘¨æœŸ
Regionå†…åˆ†é…:    10-50 CPUå‘¨æœŸ  
æ–°Regionç”³è¯·:    100-500 CPUå‘¨æœŸ
å¤§å¯¹è±¡åˆ†é…:      1000-5000 CPUå‘¨æœŸ
GCè§¦å‘åˆ†é…:      10,000-100,000 CPUå‘¨æœŸ
```

## ğŸ”§ å†…å­˜åˆ†é…ä¼˜åŒ–ç­–ç•¥

### 1. TLABå¤§å°è°ƒä¼˜
```java
// JVMå‚æ•°ä¼˜åŒ–
-XX:TLABSize=1m              // è®¾ç½®TLABåˆå§‹å¤§å°ä¸º1MB
-XX:MinTLABSize=4k           // æœ€å°TLABå¤§å°4KB
-XX:TLABWasteTargetPercent=1 // TLABæµªè´¹ç›®æ ‡1%
-XX:+ResizeTLAB              // å¯ç”¨TLABè‡ªé€‚åº”è°ƒæ•´
```

### 2. Regioné¢„åˆ†é…ç­–ç•¥
```cpp
// é¢„åˆ†é…Eden Regionå‡å°‘åˆ†é…å»¶è¿Ÿ
void G1CollectedHeap::prepare_for_allocation_burst() {
  uint target_regions = _g1_policy->young_list_target_length();
  
  for (uint i = 0; i < target_regions; i++) {
    HeapRegion* hr = new_region(0, HeapRegionType::Eden, true);
    if (hr != NULL) {
      _eden_regions.add(hr);
    }
  }
}
```

### 3. å¤§å¯¹è±¡å¤„ç†ä¼˜åŒ–
```cpp
// å¤§å¯¹è±¡åˆ†é…ä¼˜åŒ–
class HumongousObjectAllocator {
private:
    // ç»´æŠ¤ä¸åŒå¤§å°çš„è¿ç»­Regionç¼“å­˜
    std::map<uint, std::queue<uint>> _cached_regions;
    
public:
    HeapRegion* allocate_humongous(size_t word_size) {
        uint regions_needed = calculate_regions_needed(word_size);
        
        // é¦–å…ˆå°è¯•ç¼“å­˜
        if (_cached_regions[regions_needed].size() > 0) {
            uint region_index = _cached_regions[regions_needed].front();
            _cached_regions[regions_needed].pop();
            return _hrm->at(region_index);
        }
        
        // ç¼“å­˜æœªå‘½ä¸­ï¼Œæ‰§è¡Œå¸¸è§„åˆ†é…
        return allocate_contiguous_regions(regions_needed);
    }
};
```

## ğŸ“ˆ å®é™…æ€§èƒ½æµ‹è¯•

### æµ‹è¯•ç¨‹åº
```java
public class AllocationBenchmark {
    private static final int ITERATIONS = 1_000_000;
    
    public static void main(String[] args) {
        // å°å¯¹è±¡åˆ†é…æµ‹è¯•
        testSmallObjectAllocation();
        
        // ä¸­ç­‰å¯¹è±¡åˆ†é…æµ‹è¯•  
        testMediumObjectAllocation();
        
        // å¤§å¯¹è±¡åˆ†é…æµ‹è¯•
        testLargeObjectAllocation();
    }
    
    private static void testSmallObjectAllocation() {
        long start = System.nanoTime();
        
        for (int i = 0; i < ITERATIONS; i++) {
            Object obj = new Object();  // ~16å­—èŠ‚
        }
        
        long end = System.nanoTime();
        double avgLatency = (end - start) / (double)ITERATIONS;
        System.out.printf("å°å¯¹è±¡å¹³å‡åˆ†é…å»¶è¿Ÿ: %.2f ns\n", avgLatency);
    }
}
```

### é¢„æœŸæ€§èƒ½ç»“æœ (8GB G1å †)
```
å°å¯¹è±¡ (16B):     å¹³å‡ 3-5 ns/æ¬¡
ä¸­ç­‰å¯¹è±¡ (1KB):   å¹³å‡ 15-25 ns/æ¬¡  
å¤§å¯¹è±¡ (100KB):   å¹³å‡ 500-1000 ns/æ¬¡
å·¨å¤§å¯¹è±¡ (5MB):   å¹³å‡ 50-100 Î¼s/æ¬¡
```

## ğŸ“ å…³é”®å‘ç°æ€»ç»“

1. **TLABé«˜æ•ˆæ€§**: 95%+å‘½ä¸­ç‡ï¼Œ2-5å‘¨æœŸå»¶è¿Ÿ
2. **Regionç®¡ç†**: O(1)æŸ¥æ‰¾ï¼Œé«˜æ•ˆç©ºé—´åˆ©ç”¨
3. **å¤§å¯¹è±¡å¤„ç†**: è¿ç»­Regionåˆ†é…ï¼Œæ”¯æŒGBçº§å¯¹è±¡
4. **å†…å­˜è¿½è¸ª**: å®Œæ•´çš„åˆ†é…è·¯å¾„ç›‘æ§
5. **æ€§èƒ½ä¼˜åŒ–**: å¤šå±‚æ¬¡ç¼“å­˜å’Œé¢„åˆ†é…ç­–ç•¥

æ‰€æœ‰åˆ†æéƒ½åŸºäº**OpenJDK11æºç **å’Œ**8GB G1å †å®é™…æµ‹è¯•**ï¼Œç¡®ä¿äº†æ•°æ®çš„å‡†ç¡®æ€§å’Œå®ç”¨æ€§ã€‚