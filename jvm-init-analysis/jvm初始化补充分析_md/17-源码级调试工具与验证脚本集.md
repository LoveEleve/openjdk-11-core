# æºç çº§è°ƒè¯•å·¥å…·ä¸éªŒè¯è„šæœ¬é›†

## ğŸ¯ åŸºäºOpenJDK11æºç çš„å®Œæ•´è°ƒè¯•å·¥å…·é“¾

### å·¥å…·æ¦‚è¿°
- **GDBè°ƒè¯•è„šæœ¬**: æ·±å…¥JVMå†…éƒ¨æ•°æ®ç»“æ„
- **æ€§èƒ½éªŒè¯å·¥å…·**: åŸºå‡†æµ‹è¯•å’Œæ€§èƒ½åˆ†æ
- **å†…å­˜å¸ƒå±€æ£€æŸ¥**: å®æ—¶å†…å­˜çŠ¶æ€ç›‘æ§
- **æºç è¿½è¸ªè„šæœ¬**: è‡ªåŠ¨åŒ–æºç åˆ†æ
- **åˆ†ææ¡ä»¶**: `-Xms8g -Xmx8g -XX:+UseG1GC`

## ğŸ”§ GDBè°ƒè¯•è„šæœ¬é›†

### 1. G1å †ç»“æ„è°ƒè¯•è„šæœ¬

```gdb
# G1CollectedHeapå®Œæ•´ä¿¡æ¯
define g1_heap_complete_info
  set $g1h = (G1CollectedHeap*)Universe::_collectedHeap
  
  printf "=== G1CollectedHeap Complete Analysis ===\n"
  printf "Heap @ %p\n", $g1h
  
  # åŸºæœ¬ä¿¡æ¯
  printf "\n--- Basic Information ---\n"
  printf "Reserved region: [%p, %p)\n", $g1h->_reserved._start, $g1h->_reserved.end()
  printf "Heap size: %lu MB\n", ($g1h->_reserved.end() - $g1h->_reserved._start) * 8 / (1024*1024)
  
  # Regionç®¡ç†
  printf "\n--- Region Management ---\n"
  printf "Region count: %u\n", $g1h->_hrm._allocated_heapregions_length
  printf "Committed regions: %u\n", $g1h->_hrm._num_committed
  printf "Free regions: %u\n", $g1h->_hrm._free_list.length()
  printf "Region size: %lu MB\n", HeapRegion::GrainBytes / (1024*1024)
  
  # å†…å­˜ä½¿ç”¨
  printf "\n--- Memory Usage ---\n"
  printf "Used bytes: %lu MB\n", $g1h->_summary_bytes_used / (1024*1024)
  printf "Eden regions: %u\n", $g1h->_eden_regions.length()
  printf "Survivor regions: %u\n", $g1h->_survivor_regions.length()
  printf "Old regions: %u\n", $g1h->_old_set.length()
  printf "Humongous regions: %u\n", $g1h->_humongous_set.length()
  
  # GCçŠ¶æ€
  printf "\n--- GC State ---\n"
  printf "Young only phase: %s\n", $g1h->_collector_state.in_young_only_phase() ? "true" : "false"
  printf "Initial mark GC: %s\n", $g1h->_collector_state.in_initial_mark_gc() ? "true" : "false"
  printf "Mark in progress: %s\n", $g1h->_collector_state.mark_or_rebuild_in_progress() ? "true" : "false"
  
  # å‹ç¼©æŒ‡é’ˆ
  printf "\n--- Compressed OOPs ---\n"
  printf "UseCompressedOops: %s\n", UseCompressedOops ? "true" : "false"
  printf "Base address: %p\n", Universe::_narrow_oop._base
  printf "Shift amount: %d\n", Universe::_narrow_oop._shift
  printf "Mode: %d\n", Universe::narrow_oop_mode()
end

# Regionè¯¦ç»†ä¿¡æ¯
define g1_region_detail
  set $region = (HeapRegion*)$arg0
  
  printf "=== HeapRegion Detail Analysis ===\n"
  printf "Region @ %p\n", $region
  printf "Index: %u\n", $region->_hrm_index
  printf "Type: %d (%s)\n", $region->_type._value, $region->get_type_str()
  printf "Bottom: %p\n", $region->_bottom
  printf "Top: %p\n", $region->_top
  printf "End: %p\n", $region->_end
  
  set $used = ($region->_top - $region->_bottom) * 8
  set $free = ($region->_end - $region->_top) * 8
  set $total = ($region->_end - $region->_bottom) * 8
  
  printf "Used: %lu bytes (%.1f%%)\n", $used, (double)$used / $total * 100
  printf "Free: %lu bytes (%.1f%%)\n", $free, (double)$free / $total * 100
  
  if $region->_rem_set != 0
    printf "RemSet: %p\n", $region->_rem_set
  end
  
  if $region->_humongous_start_region != 0
    printf "Humongous start: %p\n", $region->_humongous_start_region
  end
end

# éå†æ‰€æœ‰Region
define g1_scan_all_regions
  set $hrm = &((G1CollectedHeap*)Universe::_collectedHeap)->_hrm
  set $max_regions = $hrm->max_length()
  
  printf "=== Scanning All Regions ===\n"
  printf "Total regions to scan: %u\n", $max_regions
  
  set $eden_count = 0
  set $survivor_count = 0
  set $old_count = 0
  set $humongous_count = 0
  set $free_count = 0
  
  set $i = 0
  while $i < $max_regions
    set $region = $hrm->at($i)
    if $region != 0
      set $type = $region->_type._value
      if $type == 0
        set $eden_count = $eden_count + 1
      end
      if $type == 1
        set $survivor_count = $survivor_count + 1
      end
      if $type == 2
        set $old_count = $old_count + 1
      end
      if $type >= 3 && $type <= 5
        set $humongous_count = $humongous_count + 1
      end
    else
      set $free_count = $free_count + 1
    end
    set $i = $i + 1
  end
  
  printf "Region distribution:\n"
  printf "  Eden: %u\n", $eden_count
  printf "  Survivor: %u\n", $survivor_count
  printf "  Old: %u\n", $old_count
  printf "  Humongous: %u\n", $humongous_count
  printf "  Free: %u\n", $free_count
end

# åœ°å€åˆ°Regionæ˜ å°„æµ‹è¯•
define g1_test_addr_mapping
  set $addr = (HeapWord*)$arg0
  set $hrm = &((G1CollectedHeap*)Universe::_collectedHeap)->_hrm
  
  printf "=== Address to Region Mapping Test ===\n"
  printf "Test address: %p\n", $addr
  
  # è®¡ç®—Regionç´¢å¼•
  set $heap_bottom = $hrm->heap_bottom()
  set $offset = $addr - $heap_bottom
  set $region_index = $offset >> HeapRegion::LogOfHRGrainWords
  
  printf "Heap bottom: %p\n", $heap_bottom
  printf "Offset: %lu words\n", $offset
  printf "Calculated region index: %u\n", $region_index
  
  # è·å–Region
  if $region_index < $hrm->max_length()
    set $region = $hrm->at($region_index)
    if $region != 0
      printf "Found region: %p\n", $region
      printf "Region index: %u\n", $region->_hrm_index
      printf "Region bounds: [%p, %p)\n", $region->_bottom, $region->_end
      
      if $addr >= $region->_bottom && $addr < $region->_end
        printf "Address is within region bounds: YES\n"
      else
        printf "Address is within region bounds: NO\n"
      end
    else
      printf "Region not allocated\n"
    end
  else
    printf "Region index out of bounds\n"
  end
end
```

### 2. å‹ç¼©æŒ‡é’ˆè°ƒè¯•è„šæœ¬

```gdb
# å‹ç¼©æŒ‡é’ˆå®Œæ•´åˆ†æ
define compressed_oops_complete_analysis
  printf "=== Compressed OOPs Complete Analysis ===\n"
  
  # åŸºæœ¬é…ç½®
  printf "\n--- Configuration ---\n"
  printf "UseCompressedOops: %s\n", UseCompressedOops ? "true" : "false"
  printf "UseCompressedClassPointers: %s\n", UseCompressedClassPointers ? "true" : "false"
  printf "Base address: %p\n", Universe::_narrow_oop._base
  printf "Shift amount: %d\n", Universe::_narrow_oop._shift
  printf "Use implicit null checks: %s\n", Universe::_narrow_oop._use_implicit_null_checks ? "true" : "false"
  
  # æ¨¡å¼åˆ†æ
  printf "\n--- Mode Analysis ---\n"
  set $mode = Universe::narrow_oop_mode()
  printf "Mode: %d (", $mode
  if $mode == 0
    printf "UnscaledNarrowOop"
  end
  if $mode == 1
    printf "ZeroBasedNarrowOop"
  end
  if $mode == 2
    printf "DisjointBaseNarrowOop"
  end
  if $mode == 3
    printf "HeapBasedNarrowOop"
  end
  printf ")\n"
  
  # å¯»å€èƒ½åŠ›
  printf "\n--- Addressing Capability ---\n"
  set $max_compressed = 0xFFFFFFFF
  set $shift = Universe::_narrow_oop._shift
  set $max_addressable = $max_compressed << $shift
  set $heap_size = ((G1CollectedHeap*)Universe::_collectedHeap)->_reserved.byte_size()
  
  printf "Max compressed value: 0x%08x\n", $max_compressed
  printf "Max addressable size: %lu GB\n", $max_addressable / (1024*1024*1024)
  printf "Current heap size: %lu GB\n", $heap_size / (1024*1024*1024)
  printf "Utilization: %.1f%%\n", (double)$heap_size / $max_addressable * 100
end

# å‹ç¼©æŒ‡é’ˆè½¬æ¢æµ‹è¯•
define test_oop_encoding_decoding
  set $test_addr = (oop)$arg0
  
  printf "=== OOP Encoding/Decoding Test ===\n"
  printf "Test address: %p\n", $test_addr
  
  # æ‰‹åŠ¨è®¡ç®—ç¼–ç 
  set $base = Universe::_narrow_oop._base
  set $shift = Universe::_narrow_oop._shift
  set $offset = (uintptr_t)$test_addr - (uintptr_t)$base
  set $manual_encoded = $offset >> $shift
  
  printf "Manual calculation:\n"
  printf "  Base: %p\n", $base
  printf "  Shift: %d\n", $shift
  printf "  Offset: 0x%lx\n", $offset
  printf "  Encoded: 0x%08x\n", $manual_encoded
  
  # éªŒè¯è§£ç 
  set $manual_decoded = $base + ($manual_encoded << $shift)
  printf "  Decoded: %p\n", $manual_decoded
  printf "  Match: %s\n", ($test_addr == $manual_decoded) ? "YES" : "NO"
end

# æ‰¹é‡åœ°å€è½¬æ¢æµ‹è¯•
define batch_address_conversion_test
  printf "=== Batch Address Conversion Test ===\n"
  
  set $heap_base = ((G1CollectedHeap*)Universe::_collectedHeap)->_reserved._start
  set $heap_size = ((G1CollectedHeap*)Universe::_collectedHeap)->_reserved.byte_size()
  
  printf "Testing key addresses in 8GB heap:\n"
  
  # æµ‹è¯•åœ°å€åˆ—è¡¨
  set $test_addrs[0] = $heap_base
  set $test_addrs[1] = $heap_base + 8
  set $test_addrs[2] = $heap_base + 1024*1024
  set $test_addrs[3] = $heap_base + 4*1024*1024*1024
  set $test_addrs[4] = $heap_base + $heap_size - 8
  
  set $descriptions[0] = "Heap start"
  set $descriptions[1] = "First object"
  set $descriptions[2] = "1MB position"
  set $descriptions[3] = "4GB position"
  set $descriptions[4] = "Heap end-8"
  
  set $i = 0
  while $i < 5
    set $addr = $test_addrs[$i]
    printf "\n%s: %p\n", $descriptions[$i], $addr
    
    # ç¼–ç 
    set $base = Universe::_narrow_oop._base
    set $shift = Universe::_narrow_oop._shift
    set $encoded = ((uintptr_t)$addr - (uintptr_t)$base) >> $shift
    
    # è§£ç éªŒè¯
    set $decoded = $base + ($encoded << $shift)
    
    printf "  Encoded: 0x%08x\n", $encoded
    printf "  Decoded: %p\n", $decoded
    printf "  Correct: %s\n", ($addr == $decoded) ? "YES" : "NO"
    
    set $i = $i + 1
  end
end
```

### 3. GCçŠ¶æ€ç›‘æ§è„šæœ¬

```gdb
# G1 GCçŠ¶æ€å®Œæ•´ç›‘æ§
define g1_gc_state_monitor
  set $g1h = (G1CollectedHeap*)Universe::_collectedHeap
  set $policy = $g1h->_g1_policy
  set $cm = $g1h->_cm
  
  printf "=== G1 GC State Monitor ===\n"
  
  # æ”¶é›†å™¨çŠ¶æ€
  printf "\n--- Collector State ---\n"
  set $state = &$g1h->_collector_state
  printf "Young only phase: %s\n", $state->in_young_only_phase() ? "true" : "false"
  printf "Initial mark GC: %s\n", $state->in_initial_mark_gc() ? "true" : "false"
  printf "Mark or rebuild in progress: %s\n", $state->mark_or_rebuild_in_progress() ? "true" : "false"
  printf "Young GC before mixed: %s\n", $state->in_young_gc_before_mixed() ? "true" : "false"
  
  # ç­–ç•¥ä¿¡æ¯
  printf "\n--- Policy Information ---\n"
  printf "Young list target length: %u\n", $policy->_young_list_target_length
  printf "Young list max length: %u\n", $policy->_young_list_max_length
  printf "Reserve regions: %u\n", $policy->_reserve_regions
  
  # å¹¶å‘æ ‡è®°çŠ¶æ€
  printf "\n--- Concurrent Mark State ---\n"
  printf "Concurrent marking in progress: %s\n", $cm->_concurrent_marking_in_progress ? "true" : "false"
  printf "Concurrent phase started: %s\n", $cm->_concurrent_phase_started ? "true" : "false"
  
  # å†…å­˜ç»Ÿè®¡
  printf "\n--- Memory Statistics ---\n"
  printf "Eden regions: %u (%lu MB)\n", $g1h->_eden_regions.length(), $g1h->_eden_regions.length() * HeapRegion::GrainBytes / (1024*1024)
  printf "Survivor regions: %u (%lu MB)\n", $g1h->_survivor_regions.length(), $g1h->_survivor_regions.length() * HeapRegion::GrainBytes / (1024*1024)
  printf "Old regions: %u (%lu MB)\n", $g1h->_old_set.length(), $g1h->_old_set.length() * HeapRegion::GrainBytes / (1024*1024)
  printf "Free regions: %u (%lu MB)\n", $g1h->_hrm._free_list.length(), $g1h->_hrm._free_list.length() * HeapRegion::GrainBytes / (1024*1024)
end

# GCæ€§èƒ½ç»Ÿè®¡
define g1_gc_performance_stats
  set $g1h = (G1CollectedHeap*)Universe::_collectedHeap
  
  printf "=== G1 GC Performance Statistics ===\n"
  
  # åŸºæœ¬ç»Ÿè®¡
  printf "\n--- Basic Statistics ---\n"
  printf "Old marking cycles started: %u\n", $g1h->_old_marking_cycles_started
  printf "Old marking cycles completed: %u\n", $g1h->_old_marking_cycles_completed
  
  # è®¡ç®—å®Œæˆç‡
  if $g1h->_old_marking_cycles_started > 0
    set $completion_rate = (double)$g1h->_old_marking_cycles_completed / $g1h->_old_marking_cycles_started * 100
    printf "Marking cycle completion rate: %.1f%%\n", $completion_rate
  end
  
  # å†…å­˜åˆ©ç”¨ç‡
  set $total_regions = $g1h->_hrm._allocated_heapregions_length
  set $used_regions = $total_regions - $g1h->_hrm._free_list.length()
  set $utilization = (double)$used_regions / $total_regions * 100
  
  printf "\n--- Memory Utilization ---\n"
  printf "Total regions: %u\n", $total_regions
  printf "Used regions: %u\n", $used_regions
  printf "Heap utilization: %.1f%%\n", $utilization
end
```

## ğŸ§ª æ€§èƒ½éªŒè¯å·¥å…·

### 1. RegionæŸ¥æ‰¾æ€§èƒ½æµ‹è¯•

```cpp
// RegionæŸ¥æ‰¾æ€§èƒ½åŸºå‡†æµ‹è¯•
class RegionLookupBenchmark {
private:
  static constexpr size_t TEST_ITERATIONS = 1000000;
  
public:
  static void benchmark_addr_to_region() {
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    HeapRegionManager* hrm = &g1h->hrm();
    
    // ç”Ÿæˆæµ‹è¯•åœ°å€
    std::vector<HeapWord*> test_addresses;
    HeapWord* heap_base = hrm->heap_bottom();
    size_t heap_size = g1h->reserved_region().byte_size();
    
    for (size_t i = 0; i < TEST_ITERATIONS; i++) {
      size_t offset = (i * 12345) % heap_size;  // ä¼ªéšæœºåç§»
      test_addresses.push_back(heap_base + offset / HeapWordSize);
    }
    
    // æ€§èƒ½æµ‹è¯•
    auto start = std::chrono::high_resolution_clock::now();
    
    for (HeapWord* addr : test_addresses) {
      HeapRegion* region = hrm->addr_to_region(addr);
      // é˜²æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–æ‰
      volatile HeapRegion* dummy = region;
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
    
    double avg_latency = (double)duration.count() / TEST_ITERATIONS;
    printf("Region lookup average latency: %.2f ns\n", avg_latency);
  }
  
  // éªŒè¯æŸ¥æ‰¾æ­£ç¡®æ€§
  static void verify_lookup_correctness() {
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    HeapRegionManager* hrm = &g1h->hrm();
    
    printf("=== Region Lookup Correctness Verification ===\n");
    
    uint max_regions = hrm->max_length();
    uint correct_lookups = 0;
    uint total_tests = 0;
    
    for (uint i = 0; i < max_regions; i++) {
      HeapRegion* region = hrm->at(i);
      if (region != NULL) {
        // æµ‹è¯•Regionå†…çš„å¤šä¸ªåœ°å€
        HeapWord* test_addrs[] = {
          region->bottom(),
          region->bottom() + 1,
          region->top() - 1,
          region->end() - 1
        };
        
        for (HeapWord* addr : test_addrs) {
          if (addr >= region->bottom() && addr < region->end()) {
            HeapRegion* found = hrm->addr_to_region(addr);
            total_tests++;
            if (found == region) {
              correct_lookups++;
            } else {
              printf("Lookup error: addr %p should map to region %u, got %u\n",
                     addr, region->hrm_index(), 
                     found ? found->hrm_index() : UINT_MAX);
            }
          }
        }
      }
    }
    
    printf("Lookup correctness: %u/%u (%.2f%%)\n", 
           correct_lookups, total_tests,
           (double)correct_lookups / total_tests * 100);
  }
};
```

### 2. å‹ç¼©æŒ‡é’ˆæ€§èƒ½æµ‹è¯•

```cpp
// å‹ç¼©æŒ‡é’ˆæ€§èƒ½åŸºå‡†æµ‹è¯•
class CompressedOopsPerformanceBenchmark {
private:
  static constexpr size_t BENCHMARK_SIZE = 10000000;
  
public:
  // ç¼–ç æ€§èƒ½æµ‹è¯•
  static void benchmark_encoding_performance() {
    std::vector<oop> test_oops;
    std::vector<narrowOop> results;
    
    // ç”Ÿæˆæµ‹è¯•æ•°æ®
    HeapWord* heap_base = Universe::heap()->base();
    for (size_t i = 0; i < BENCHMARK_SIZE; i++) {
      test_oops.push_back((oop)(heap_base + i * 2));  // 8å­—èŠ‚å¯¹é½
    }
    results.resize(BENCHMARK_SIZE);
    
    // ç¼–ç æ€§èƒ½æµ‹è¯•
    auto start = std::chrono::high_resolution_clock::now();
    
    for (size_t i = 0; i < BENCHMARK_SIZE; i++) {
      results[i] = CompressedOops::encode(test_oops[i]);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
    
    double avg_latency = (double)duration.count() / BENCHMARK_SIZE;
    printf("Encoding average latency: %.3f ns\n", avg_latency);
    
    // éªŒè¯ç»“æœæ­£ç¡®æ€§
    uint correct_encodings = 0;
    for (size_t i = 0; i < std::min(BENCHMARK_SIZE, (size_t)1000); i++) {
      oop decoded = CompressedOops::decode(results[i]);
      if (decoded == test_oops[i]) {
        correct_encodings++;
      }
    }
    printf("Encoding correctness: %u/1000 (%.1f%%)\n", 
           correct_encodings, correct_encodings / 10.0);
  }
  
  // è§£ç æ€§èƒ½æµ‹è¯•
  static void benchmark_decoding_performance() {
    std::vector<narrowOop> test_narrow_oops;
    std::vector<oop> results;
    
    // ç”Ÿæˆæµ‹è¯•æ•°æ®
    for (size_t i = 0; i < BENCHMARK_SIZE; i++) {
      test_narrow_oops.push_back((narrowOop)(i * 2));  // é¿å…NULL
    }
    results.resize(BENCHMARK_SIZE);
    
    // è§£ç æ€§èƒ½æµ‹è¯•
    auto start = std::chrono::high_resolution_clock::now();
    
    for (size_t i = 0; i < BENCHMARK_SIZE; i++) {
      results[i] = CompressedOops::decode(test_narrow_oops[i]);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
    
    double avg_latency = (double)duration.count() / BENCHMARK_SIZE;
    printf("Decoding average latency: %.3f ns\n", avg_latency);
  }
  
  // å¾€è¿”è½¬æ¢æµ‹è¯•
  static void benchmark_roundtrip_conversion() {
    std::vector<oop> original_oops;
    std::vector<oop> final_oops;
    
    // ç”Ÿæˆæµ‹è¯•æ•°æ®
    HeapWord* heap_base = Universe::heap()->base();
    for (size_t i = 0; i < BENCHMARK_SIZE; i++) {
      original_oops.push_back((oop)(heap_base + i * 2));
    }
    final_oops.resize(BENCHMARK_SIZE);
    
    // å¾€è¿”è½¬æ¢æ€§èƒ½æµ‹è¯•
    auto start = std::chrono::high_resolution_clock::now();
    
    for (size_t i = 0; i < BENCHMARK_SIZE; i++) {
      narrowOop compressed = CompressedOops::encode(original_oops[i]);
      final_oops[i] = CompressedOops::decode(compressed);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
    
    double avg_latency = (double)duration.count() / BENCHMARK_SIZE;
    printf("Roundtrip conversion average latency: %.3f ns\n", avg_latency);
    
    // éªŒè¯å¾€è¿”è½¬æ¢æ­£ç¡®æ€§
    uint correct_conversions = 0;
    for (size_t i = 0; i < BENCHMARK_SIZE; i++) {
      if (original_oops[i] == final_oops[i]) {
        correct_conversions++;
      }
    }
    printf("Roundtrip correctness: %u/%lu (%.3f%%)\n", 
           correct_conversions, BENCHMARK_SIZE,
           (double)correct_conversions / BENCHMARK_SIZE * 100);
  }
};
```

## ğŸ“Š å†…å­˜å¸ƒå±€éªŒè¯å·¥å…·

### 1. å †å†…å­˜å¸ƒå±€æ£€æŸ¥å™¨

```cpp
// å †å†…å­˜å¸ƒå±€å®Œæ•´æ£€æŸ¥å™¨
class HeapLayoutVerifier {
public:
  static void verify_complete_layout() {
    printf("=== Complete Heap Layout Verification ===\n");
    
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    
    // åŸºæœ¬é…ç½®éªŒè¯
    verify_basic_configuration(g1h);
    
    // Regionå¸ƒå±€éªŒè¯
    verify_region_layout(g1h);
    
    // å‹ç¼©æŒ‡é’ˆéªŒè¯
    verify_compressed_oops_configuration();
    
    // å†…å­˜å¯¹é½éªŒè¯
    verify_memory_alignment(g1h);
    
    // åœ°å€æ˜ å°„éªŒè¯
    verify_address_mapping(g1h);
  }
  
private:
  static void verify_basic_configuration(G1CollectedHeap* g1h) {
    printf("\n--- Basic Configuration Verification ---\n");
    
    size_t heap_size = g1h->reserved_region().byte_size();
    size_t region_size = HeapRegion::GrainBytes;
    uint expected_regions = heap_size / region_size;
    
    printf("Heap size: %lu GB\n", heap_size / (1024*1024*1024));
    printf("Region size: %lu MB\n", region_size / (1024*1024));
    printf("Expected regions: %u\n", expected_regions);
    printf("Actual max regions: %u\n", g1h->hrm().max_length());
    
    assert(expected_regions == g1h->hrm().max_length(), 
           "Region count mismatch");
    printf("âœ“ Region count verification passed\n");
  }
  
  static void verify_region_layout(G1CollectedHeap* g1h) {
    printf("\n--- Region Layout Verification ---\n");
    
    HeapRegionManager* hrm = &g1h->hrm();
    HeapWord* expected_addr = hrm->heap_bottom();
    
    uint verified_regions = 0;
    uint max_regions = hrm->max_length();
    
    for (uint i = 0; i < max_regions; i++) {
      HeapRegion* region = hrm->at(i);
      if (region != NULL) {
        // éªŒè¯Regionåœ°å€è¿ç»­æ€§
        if (region->bottom() != expected_addr) {
          printf("âœ— Region %u address discontinuity: expected %p, got %p\n",
                 i, expected_addr, region->bottom());
        }
        
        // éªŒè¯Regionå¤§å°
        size_t region_size = region->end() - region->bottom();
        if (region_size != HeapRegion::GrainWords) {
          printf("âœ— Region %u size mismatch: expected %lu, got %lu\n",
                 i, HeapRegion::GrainWords, region_size);
        }
        
        verified_regions++;
      }
      expected_addr += HeapRegion::GrainWords;
    }
    
    printf("âœ“ Verified %u regions layout\n", verified_regions);
  }
  
  static void verify_compressed_oops_configuration() {
    printf("\n--- Compressed OOPs Configuration Verification ---\n");
    
    if (UseCompressedOops) {
      address base = Universe::narrow_oop_base();
      int shift = Universe::narrow_oop_shift();
      
      printf("Base address: %p\n", base);
      printf("Shift amount: %d\n", shift);
      
      // éªŒè¯shiftå€¼åˆç†æ€§
      assert(shift >= 0 && shift <= 3, "Invalid shift amount");
      printf("âœ“ Shift amount verification passed\n");
      
      // éªŒè¯å¯»å€èƒ½åŠ›
      size_t max_addressable = (0xFFFFFFFFULL << shift);
      size_t heap_size = Universe::heap()->reserved_region().byte_size();
      
      if (heap_size <= max_addressable) {
        printf("âœ“ Addressing capability sufficient\n");
      } else {
        printf("âœ— Addressing capability insufficient\n");
      }
    } else {
      printf("Compressed OOPs disabled\n");
    }
  }
  
  static void verify_memory_alignment(G1CollectedHeap* g1h) {
    printf("\n--- Memory Alignment Verification ---\n");
    
    // éªŒè¯å †åŸºåœ°å€å¯¹é½
    HeapWord* heap_base = g1h->reserved_region().start();
    if ((uintptr_t)heap_base % HeapRegion::GrainBytes == 0) {
      printf("âœ“ Heap base address properly aligned\n");
    } else {
      printf("âœ— Heap base address misaligned\n");
    }
    
    // éªŒè¯Regionè¾¹ç•Œå¯¹é½
    HeapRegionManager* hrm = &g1h->hrm();
    uint alignment_errors = 0;
    
    for (uint i = 0; i < hrm->max_length(); i++) {
      HeapRegion* region = hrm->at(i);
      if (region != NULL) {
        if ((uintptr_t)region->bottom() % HeapRegion::GrainBytes != 0) {
          alignment_errors++;
        }
      }
    }
    
    if (alignment_errors == 0) {
      printf("âœ“ All regions properly aligned\n");
    } else {
      printf("âœ— %u regions misaligned\n", alignment_errors);
    }
  }
  
  static void verify_address_mapping(G1CollectedHeap* g1h) {
    printf("\n--- Address Mapping Verification ---\n");
    
    HeapRegionManager* hrm = &g1h->hrm();
    uint mapping_errors = 0;
    uint total_tests = 0;
    
    // æµ‹è¯•æ¯ä¸ªRegionçš„åœ°å€æ˜ å°„
    for (uint i = 0; i < hrm->max_length(); i++) {
      HeapRegion* region = hrm->at(i);
      if (region != NULL) {
        // æµ‹è¯•Regionå†…çš„å‡ ä¸ªåœ°å€
        HeapWord* test_addrs[] = {
          region->bottom(),
          region->bottom() + HeapRegion::GrainWords / 4,
          region->bottom() + HeapRegion::GrainWords / 2,
          region->end() - 1
        };
        
        for (HeapWord* addr : test_addrs) {
          if (addr >= region->bottom() && addr < region->end()) {
            HeapRegion* mapped = hrm->addr_to_region(addr);
            total_tests++;
            
            if (mapped != region) {
              mapping_errors++;
            }
          }
        }
      }
    }
    
    printf("Address mapping tests: %u\n", total_tests);
    printf("Mapping errors: %u\n", mapping_errors);
    
    if (mapping_errors == 0) {
      printf("âœ“ All address mappings correct\n");
    } else {
      printf("âœ— %u address mapping errors\n", mapping_errors);
    }
  }
};
```

## ğŸš€ è‡ªåŠ¨åŒ–æºç åˆ†æè„šæœ¬

### 1. æºç ç»“æ„åˆ†æè„šæœ¬

```bash
#!/bin/bash
# G1 GCæºç ç»“æ„è‡ªåŠ¨åˆ†æè„šæœ¬

OPENJDK_ROOT="/data/workspace/openjdk11-core"
G1_SOURCE_DIR="$OPENJDK_ROOT/src/hotspot/share/gc/g1"
OUTPUT_DIR="./source_analysis"

mkdir -p "$OUTPUT_DIR"

echo "=== G1 GC Source Code Structure Analysis ==="

# 1. ç»Ÿè®¡æºç æ–‡ä»¶
echo "1. Source file statistics:"
find "$G1_SOURCE_DIR" -name "*.hpp" | wc -l | xargs echo "  Header files:"
find "$G1_SOURCE_DIR" -name "*.cpp" | wc -l | xargs echo "  Implementation files:"
find "$G1_SOURCE_DIR" -name "*.inline.hpp" | wc -l | xargs echo "  Inline files:"

# 2. åˆ†ææ ¸å¿ƒç±»
echo -e "\n2. Core class analysis:"
echo "  G1CollectedHeap:"
grep -n "class G1CollectedHeap" "$G1_SOURCE_DIR"/*.hpp | head -5

echo "  HeapRegion:"
grep -n "class HeapRegion" "$G1_SOURCE_DIR"/*.hpp | head -5

echo "  HeapRegionManager:"
grep -n "class HeapRegionManager" "$G1_SOURCE_DIR"/*.hpp | head -5

# 3. åˆ†æå…³é”®æ–¹æ³•
echo -e "\n3. Key method analysis:"
echo "  Collection pause methods:"
grep -rn "do_collection_pause" "$G1_SOURCE_DIR" | wc -l | xargs echo "    Found methods:"

echo "  Region allocation methods:"
grep -rn "allocate.*region" "$G1_SOURCE_DIR" | wc -l | xargs echo "    Found methods:"

echo "  Compressed oops methods:"
grep -rn "CompressedOops" "$OPENJDK_ROOT/src/hotspot/share/oops" | wc -l | xargs echo "    Found references:"

# 4. ç”Ÿæˆç±»ä¾èµ–å…³ç³»
echo -e "\n4. Generating class dependency graph..."
cat > "$OUTPUT_DIR/class_dependencies.dot" << 'EOF'
digraph G1Dependencies {
  rankdir=TB;
  
  // Core classes
  G1CollectedHeap [shape=box, style=filled, fillcolor=lightblue];
  HeapRegionManager [shape=box, style=filled, fillcolor=lightgreen];
  HeapRegion [shape=box, style=filled, fillcolor=lightgreen];
  G1Policy [shape=box, style=filled, fillcolor=lightyellow];
  G1ConcurrentMark [shape=box, style=filled, fillcolor=lightcoral];
  
  // Dependencies
  G1CollectedHeap -> HeapRegionManager;
  G1CollectedHeap -> G1Policy;
  G1CollectedHeap -> G1ConcurrentMark;
  HeapRegionManager -> HeapRegion;
  G1Policy -> HeapRegion;
  G1ConcurrentMark -> HeapRegion;
}
EOF

# 5. åˆ†æå†…å­˜ç®¡ç†ç›¸å…³ä»£ç 
echo -e "\n5. Memory management code analysis:"
echo "  Memory allocation patterns:"
grep -rn "allocate\|malloc\|new " "$G1_SOURCE_DIR" | wc -l | xargs echo "    Allocation calls:"

echo "  Memory deallocation patterns:"
grep -rn "deallocate\|free\|delete " "$G1_SOURCE_DIR" | wc -l | xargs echo "    Deallocation calls:"

# 6. ç”Ÿæˆæ–¹æ³•è°ƒç”¨ç»Ÿè®¡
echo -e "\n6. Method call statistics:"
cat > "$OUTPUT_DIR/method_stats.txt" << EOF
G1 GC Method Call Statistics
============================

Collection Methods:
$(grep -rn "collect\|gc\|pause" "$G1_SOURCE_DIR" | wc -l) total calls

Region Management:
$(grep -rn "region" "$G1_SOURCE_DIR" | wc -l) total references

Memory Operations:
$(grep -rn "alloc\|free\|commit" "$G1_SOURCE_DIR" | wc -l) total operations

Concurrent Operations:
$(grep -rn "concurrent\|parallel" "$G1_SOURCE_DIR" | wc -l) total references
EOF

echo "Analysis complete. Results saved to $OUTPUT_DIR/"
```

### 2. æ€§èƒ½çƒ­ç‚¹åˆ†æè„šæœ¬

```bash
#!/bin/bash
# G1 GCæ€§èƒ½çƒ­ç‚¹æºç åˆ†æ

echo "=== G1 GC Performance Hotspot Analysis ==="

G1_DIR="/data/workspace/openjdk11-core/src/hotspot/share/gc/g1"

# 1. æŸ¥æ‰¾å…³é”®æ€§èƒ½è·¯å¾„
echo "1. Critical performance paths:"

echo "  Fast allocation paths:"
grep -rn "TLAB\|fast.*alloc\|quick.*alloc" "$G1_DIR" | head -10

echo -e "\n  GC pause critical sections:"
grep -rn "safepoint\|STW\|pause" "$G1_DIR" | head -10

echo -e "\n  Concurrent operations:"
grep -rn "concurrent.*mark\|concurrent.*refine" "$G1_DIR" | head -10

# 2. åˆ†æå†…è”å‡½æ•°
echo -e "\n2. Inline function analysis:"
find "$G1_DIR" -name "*.inline.hpp" -exec basename {} \; | sort

# 3. æŸ¥æ‰¾æ€§èƒ½å…³é”®çš„æ•°æ®ç»“æ„
echo -e "\n3. Performance-critical data structures:"
grep -rn "volatile\|atomic\|lock.*free" "$G1_DIR" | wc -l | xargs echo "  Lock-free operations:"
grep -rn "cache.*line\|align" "$G1_DIR" | wc -l | xargs echo "  Cache-aware code:"

# 4. åˆ†æç®—æ³•å¤æ‚åº¦
echo -e "\n4. Algorithm complexity analysis:"
echo "  O(1) operations (direct array access):"
grep -rn "\[.*\].*=" "$G1_DIR" | wc -l

echo "  O(log n) operations (binary search, trees):"
grep -rn "binary.*search\|tree\|log.*n" "$G1_DIR" | wc -l

echo "  O(n) operations (linear scans):"
grep -rn "for.*length\|while.*count" "$G1_DIR" | wc -l

# 5. ç”Ÿæˆæ€§èƒ½ä¼˜åŒ–å»ºè®®
cat > "./performance_analysis.md" << 'EOF'
# G1 GC Performance Analysis

## Critical Performance Paths

### 1. Object Allocation
- TLAB allocation: O(1) fast path
- Region allocation: O(1) with free list
- Humongous allocation: O(n) region search

### 2. GC Pauses
- Root scanning: Parallel, O(roots)
- Object evacuation: Parallel, O(live objects)
- Reference updating: Parallel, O(references)

### 3. Concurrent Operations
- Concurrent marking: O(heap size)
- Concurrent refinement: O(dirty cards)

## Optimization Opportunities

1. **Cache Optimization**
   - Region array access patterns
   - Card table scanning
   - Object field access

2. **Lock-Free Operations**
   - TLAB allocation
   - Free region management
   - Statistics collection

3. **Parallel Scaling**
   - Work stealing algorithms
   - Load balancing
   - NUMA awareness
EOF

echo -e "\nPerformance analysis saved to ./performance_analysis.md"
```

## ğŸ“ ä½¿ç”¨æŒ‡å—

### 1. GDBè°ƒè¯•ä¼šè¯ç¤ºä¾‹

```bash
# å¯åŠ¨å¸¦è°ƒè¯•ä¿¡æ¯çš„JVM
gdb --args java -Xms8g -Xmx8g -XX:+UseG1GC -XX:+PrintGC YourTestProgram

# åœ¨GDBä¸­åŠ è½½è°ƒè¯•è„šæœ¬
(gdb) source g1_debug_scripts.gdb

# è®¾ç½®æ–­ç‚¹å¹¶è¿è¡Œ
(gdb) break G1CollectedHeap::do_collection_pause_at_safepoint
(gdb) run

# å½“æ–­ç‚¹è§¦å‘æ—¶ï¼Œä½¿ç”¨è°ƒè¯•å‘½ä»¤
(gdb) g1_heap_complete_info
(gdb) g1_gc_state_monitor
(gdb) compressed_oops_complete_analysis
```

### 2. æ€§èƒ½æµ‹è¯•æ‰§è¡Œ

```bash
# ç¼–è¯‘æ€§èƒ½æµ‹è¯•ç¨‹åº
g++ -O2 -I$JAVA_HOME/include -I$JAVA_HOME/include/linux performance_tests.cpp -o perf_test

# è¿è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•
./perf_test

# åˆ†æç»“æœ
echo "Performance test completed. Check output for latency measurements."
```

## ğŸ“Š é¢„æœŸè¾“å‡ºç¤ºä¾‹

```
=== G1CollectedHeap Complete Analysis ===
Heap @ 0x7f8b4c000000
Reserved region: [0x600000000, 0x800000000)
Heap size: 8192 MB
Region count: 2048
Region size: 4 MB
Used bytes: 1024 MB
Eden regions: 51
Survivor regions: 8
Old regions: 200
Free regions: 1789

=== Compressed OOPs Complete Analysis ===
UseCompressedOops: true
Base address: 0x600000000
Shift amount: 3
Mode: 1 (ZeroBasedNarrowOop)
Max addressable size: 32 GB
Current heap size: 8 GB
Utilization: 25.0%

Region lookup average latency: 2.34 ns
Encoding average latency: 0.087 ns
Decoding average latency: 0.093 ns
```

è¿™å¥—å®Œæ•´çš„è°ƒè¯•å·¥å…·é“¾ä¸ºæ·±å…¥ç†è§£å’Œä¼˜åŒ–G1 GCæä¾›äº†å¼ºå¤§çš„æ”¯æŒï¼Œé€šè¿‡æºç çº§çš„åˆ†æå’ŒéªŒè¯ï¼Œç¡®ä¿äº†å¯¹JVMå†…å­˜ç®¡ç†æœºåˆ¶çš„å‡†ç¡®ç†è§£ã€‚