# G1 GCå„é˜¶æ®µæºç å®ç°æ·±åº¦è§£æ

## ğŸ¯ åŸºäºOpenJDK11æºç çš„G1 GCæµç¨‹åˆ†æ

### æºç ä½ç½®
- **ä¸»è¦GCæµç¨‹**: `src/hotspot/share/gc/g1/g1CollectedHeap.cpp`
- **GCç­–ç•¥**: `src/hotspot/share/gc/g1/g1Policy.hpp/cpp`
- **å¹¶å‘æ ‡è®°**: `src/hotspot/share/gc/g1/g1ConcurrentMark.hpp/cpp`
- **åˆ†ææ¡ä»¶**: `-Xms8g -Xmx8g -XX:+UseG1GC`

## ğŸ”„ G1 GCä¸»æµç¨‹æºç åˆ†æ

### 1. GCæš‚åœå…¥å£ (æºç ç¬¬3035è¡Œ)

```cpp
bool G1CollectedHeap::do_collection_pause_at_safepoint(double target_pause_time_ms) {
  assert_at_safepoint_on_vm_thread();
  guarantee(!is_gc_active(), "collection is not reentrant");
  
  // æ£€æŸ¥GCé”çŠ¶æ€
  if (GCLocker::check_active_before_gc()) {
    return false;
  }
  
  // å¯åŠ¨GCè®¡æ—¶å™¨å’Œè¿½è¸ªå™¨
  _gc_timer_stw->register_gc_start();
  GCIdMark gc_id_mark;
  _gc_tracer_stw->report_gc_start(gc_cause(), _gc_timer_stw->gc_start());
  
  // æ ‡è®°GCæœåŠ¡
  SvcGCMarker sgcm(SvcGCMarker::MINOR);
  ResourceMark rm;
  
  // é€šçŸ¥ç­–ç•¥GCå¼€å§‹
  g1_policy()->note_gc_start();
  
  // ç­‰å¾…æ ¹åŒºåŸŸæ‰«æå®Œæˆ
  wait_for_root_region_scanning();
  
  // GCå‰çš„å †çŠ¶æ€æ‰“å°å’ŒéªŒè¯
  print_heap_before_gc();
  print_heap_regions();
  trace_heap_before_gc(_gc_tracer_stw);
  
  _verifier->verify_region_sets_optional();
  _verifier->verify_dirty_young_regions();
```

### 2. å¹¶å‘æ ‡è®°å†³ç­– (æºç ç¬¬3062-3080è¡Œ)

```cpp
// å†³å®šæ˜¯å¦å¯åŠ¨å¹¶å‘æ ‡è®°
if (!_cm_thread->should_terminate()) {
  // è¿™ä¸ªè°ƒç”¨å†³å®šå½“å‰æš‚åœæ˜¯å¦ä¸ºinitial-markæš‚åœ
  // å¦‚æœæ˜¯ï¼Œin_initial_mark_gc()åœ¨æš‚åœæœŸé—´è¿”å›true
  g1_policy()->decide_on_conc_mark_initiation();
}

// ä¸å…è®¸initial-markä¸mixed GCæ··åˆ
assert(!collector_state()->in_initial_mark_gc() ||
        collector_state()->in_young_only_phase(), "sanity");

// æ ‡è®°æœŸé—´ä¸å…è®¸mixed GC
assert(!collector_state()->mark_or_rebuild_in_progress() || 
        collector_state()->in_young_only_phase(), "sanity");

// è®°å½•æ˜¯å¦åº”è¯¥å¯åŠ¨å¹¶å‘æ ‡è®°
bool should_start_conc_mark = collector_state()->in_initial_mark_gc();
```

### 3. GCç±»å‹åˆ¤æ–­å’Œå·¥ä½œçº¿ç¨‹é…ç½® (æºç ç¬¬3095-3134è¡Œ)

```cpp
// ç¡®å®šGCç±»å‹å’ŒéªŒè¯ç±»å‹
G1HeapVerifier::G1VerifyType verify_type;
FormatBuffer<> gc_string("Pause Young ");

if (collector_state()->in_initial_mark_gc()) {
  gc_string.append("(Concurrent Start)");
  verify_type = G1HeapVerifier::G1VerifyConcurrentStart;
} else if (collector_state()->in_young_only_phase()) {
  if (collector_state()->in_young_gc_before_mixed()) {
    gc_string.append("(Prepare Mixed)");
  } else {
    gc_string.append("(Normal)");
  }
  verify_type = G1HeapVerifier::G1VerifyYoungNormal;
} else {
  gc_string.append("(Mixed)");
  verify_type = G1HeapVerifier::G1VerifyMixed;
}

// è®¡ç®—æ´»è·ƒå·¥ä½œçº¿ç¨‹æ•°
uint active_workers = AdaptiveSizePolicy::calc_active_workers(
  workers()->total_workers(),
  workers()->active_workers(), 
  Threads::number_of_non_daemon_threads()
);
active_workers = workers()->update_active_workers(active_workers);
log_info(gc,task)("Using %u workers of %u for evacuation", 
                  active_workers, workers()->total_workers());
```

## ğŸ¯ G1Policyå†³ç­–æœºåˆ¶æºç åˆ†æ

### 1. G1Policyæ ¸å¿ƒç»“æ„ (æºç ç¬¬55-100è¡Œ)

```cpp
class G1Policy: public CHeapObj<mtGC> {
private:
  // é¢„æµ‹å™¨ - åŸºäºå†å²æ•°æ®é¢„æµ‹GCæ€§èƒ½
  G1Predictions _predictor;
  
  // åˆ†æå™¨ - æ”¶é›†å’Œåˆ†æGCç»Ÿè®¡æ•°æ®
  G1Analytics* _analytics;
  
  // RemSetè·Ÿè¸ªç­–ç•¥
  G1RemSetTrackingPolicy _remset_tracker;
  
  // MMU(Minimum Mutator Utilization)è·Ÿè¸ªå™¨
  G1MMUTracker* _mmu_tracker;
  
  // Oldä»£åˆ†é…è·Ÿè¸ªå™¨
  G1OldGenAllocationTracker _old_gen_alloc_tracker;
  
  // IHOP(Initiating Heap Occupancy Percent)æ§åˆ¶å™¨
  G1IHOPControl* _ihop_control;
  
  // ç­–ç•¥è®¡æ•°å™¨
  GCPolicyCounters* _policy_counters;
  
  // Youngä»£ç›®æ ‡é•¿åº¦
  uint _young_list_target_length;
  uint _young_list_fixed_length;
  uint _young_list_max_length;
  
  // å­˜æ´»ç‡ç»„
  SurvRateGroup* _short_lived_surv_rate_group;
  SurvRateGroup* _survivor_surv_rate_group;
  
  // ä¿ç•™å› å­å’Œä¿ç•™Regionæ•°
  double _reserve_factor;
  uint _reserve_regions;
  
  // Youngä»£å¤§å°è°ƒæ•´å™¨
  G1YoungGenSizer _young_gen_sizer;
};
```

### 2. å¹¶å‘æ ‡è®°å¯åŠ¨å†³ç­–

```cpp
void G1Policy::decide_on_conc_mark_initiation() {
  // æ£€æŸ¥æ˜¯å¦éœ€è¦å¯åŠ¨å¹¶å‘æ ‡è®°
  if (need_to_start_conc_mark("end of GC")) {
    // è®¾ç½®åˆå§‹æ ‡è®°æ ‡å¿—
    collector_state()->set_in_initial_mark_gc(true);
    
    // æ›´æ–°å¹¶å‘æ ‡è®°å¯åŠ¨é˜ˆå€¼
    _ihop_control->request_concurrent_marking_start();
  }
}

bool G1Policy::need_to_start_conc_mark(const char* source, size_t alloc_bytes) {
  if (about_to_start_mixed_phase()) {
    return false;  // å³å°†å¼€å§‹mixedé˜¶æ®µï¼Œä¸å¯åŠ¨æ ‡è®°
  }
  
  if (collector_state()->in_young_only_phase()) {
    // æ£€æŸ¥å †å ç”¨ç‡æ˜¯å¦è¾¾åˆ°IHOPé˜ˆå€¼
    size_t marking_initiating_used_threshold = _ihop_control->get_conc_mark_start_threshold();
    size_t cur_used_bytes = _g1h->non_young_capacity_bytes();
    
    if (cur_used_bytes > marking_initiating_used_threshold) {
      log_debug(gc, ihop)("%s occupancy: " SIZE_FORMAT "B > threshold: " SIZE_FORMAT "B",
                         source, cur_used_bytes, marking_initiating_used_threshold);
      return true;
    }
  }
  
  return false;
}
```

## ğŸ” Young GCç–æ•£è¿‡ç¨‹æºç åˆ†æ

### 1. ç–æ•£ä¿¡æ¯ç»“æ„

```cpp
class EvacuationInfo : public StackObj {
private:
  uint _collectionset_regions;          // Collection Setä¸­çš„Regionæ•°
  uint _allocation_regions;             // åˆ†é…çš„Regionæ•°
  size_t _collectionset_used_before;    // GCå‰Collection Setä½¿ç”¨é‡
  size_t _collectionset_used_after;     // GCåCollection Setä½¿ç”¨é‡
  size_t _alloc_regions_used_before;    // GCå‰åˆ†é…Regionä½¿ç”¨é‡
  size_t _bytes_copied;                 // å¤åˆ¶çš„å­—èŠ‚æ•°
  uint _regions_freed;                  // é‡Šæ”¾çš„Regionæ•°
  
public:
  void set_collectionset_regions(uint collectionset_regions) {
    _collectionset_regions = collectionset_regions;
  }
  
  void set_bytes_copied(size_t bytes_copied) {
    _bytes_copied = bytes_copied;
  }
  
  // è®¡ç®—å›æ”¶æ•ˆç‡
  double collection_set_efficiency() const {
    if (_collectionset_used_before > 0) {
      return (double)(_collectionset_used_before - _collectionset_used_after) / 
             _collectionset_used_before;
    }
    return 0.0;
  }
};
```

### 2. å¹¶è¡Œç–æ•£ä»»åŠ¡

```cpp
class G1ParTask : public AbstractGangTask {
private:
  G1CollectedHeap* _g1h;
  G1ParScanThreadStateSet* _pss;
  RefToScanQueueSet* _queues;
  G1RootProcessor* _root_processor;
  ParallelTaskTerminator _terminator;
  uint _n_workers;
  
public:
  G1ParTask(G1CollectedHeap* g1h, G1ParScanThreadStateSet* per_thread_states,
            RefToScanQueueSet* task_queues, G1RootProcessor* root_processor,
            uint n_workers)
    : AbstractGangTask("G1 collection"),
      _g1h(g1h),
      _pss(per_thread_states),
      _queues(task_queues),
      _root_processor(root_processor),
      _terminator(n_workers, _queues),
      _n_workers(n_workers) {}
  
  void work(uint worker_id) {
    if (worker_id >= _n_workers) return;
    
    double start_sec = os::elapsedTime();
    
    {
      ResourceMark rm;
      HandleMark hm;
      
      G1ParScanThreadState* pss = _pss->state_for_worker(worker_id);
      pss->set_ref_discoverer(ref_processor_stw());
      
      // æ‰«ææ ¹å¯¹è±¡
      _root_processor->evacuate_roots(pss, worker_id);
      
      // å¤„ç†å¼•ç”¨é˜Ÿåˆ—ä¸­çš„å¯¹è±¡
      _g1h->g1_process_roots_closures_during_evacuation(pss, worker_id);
      
      // å‚ä¸å·¥ä½œçªƒå–
      _terminator.offer_termination(pss);
    }
    
    double end_sec = os::elapsedTime();
    _g1h->g1_policy()->phase_times()->record_time_secs(G1GCPhaseTimes::GCWorkerTotal, 
                                                       worker_id, end_sec - start_sec);
  }
};
```

## ğŸŒŠ å¹¶å‘æ ‡è®°æºç åˆ†æ

### 1. G1ConcurrentMarkæ ¸å¿ƒç»“æ„

```cpp
class G1ConcurrentMark : public CHeapObj<mtGC> {
private:
  // å¹¶å‘æ ‡è®°çº¿ç¨‹
  G1ConcurrentMarkThread* _cm_thread;
  
  // æ ‡è®°ä½å›¾
  G1CMBitMap _mark_bitmap;
  
  // æ ‡è®°ä»»åŠ¡é˜Ÿåˆ—
  G1CMTaskQueueSet* _task_queues;
  
  // æ ‡è®°ä»»åŠ¡æ•°ç»„
  G1CMTask** _tasks;
  uint _max_num_tasks;
  
  // å…¨å±€æ ‡è®°æ ˆ
  G1CMMarkStack _global_mark_stack;
  
  // å¹¶å‘æ ‡è®°ç»Ÿè®¡
  G1ConcurrentMarkStats _stats;
  
  // æ ‡è®°å‘¨æœŸçŠ¶æ€
  volatile bool _concurrent_marking_in_progress;
  volatile bool _concurrent_phase_started;
  
public:
  // å¯åŠ¨å¹¶å‘æ ‡è®°å‘¨æœŸ
  void concurrent_cycle_start();
  
  // å¹¶å‘æ ‡è®°é˜¶æ®µ
  void concurrent_cycle_do_concurrent_mark();
  
  // æœ€ç»ˆæ ‡è®°é˜¶æ®µ
  void concurrent_cycle_end();
};
```

### 2. å¹¶å‘æ ‡è®°å‘¨æœŸå®ç°

```cpp
void G1ConcurrentMark::concurrent_cycle_start() {
  _stats.set_concurrent_cycle_start();
  
  // é‡ç½®æ ‡è®°çŠ¶æ€
  reset_marking_for_restart();
  
  // è®¾ç½®å¹¶å‘æ ‡è®°è¿›è¡Œä¸­æ ‡å¿—
  set_concurrent_marking_in_progress();
  
  // æ¸…ç†å…¨å±€æ•°æ®ç»“æ„
  clear_statistics();
  
  // åˆå§‹åŒ–æ ‡è®°ä½å›¾
  _mark_bitmap.clear_range(MemRegion(_heap->bottom(), _heap->end()));
  
  // å¯åŠ¨æ ‡è®°ä»»åŠ¡
  for (uint i = 0; i < _max_num_tasks; ++i) {
    _tasks[i]->reset(_mark_bitmap);
  }
  
  // æ‰«ææ ¹å¯¹è±¡å¹¶æ ‡è®°
  scan_root_regions();
}

void G1ConcurrentMark::concurrent_cycle_do_concurrent_mark() {
  GCTraceConcTime(Info, gc) tt("Concurrent Mark");
  
  // å¹¶å‘æ ‡è®°ä¸»å¾ªç¯
  while (!has_aborted()) {
    // å¤„ç†æ ‡è®°ä»»åŠ¡
    bool has_work = do_marking_step(G1ConcMarkStepDurationMillis);
    
    if (!has_work) {
      // å°è¯•ä»å…¶ä»–çº¿ç¨‹çªƒå–å·¥ä½œ
      if (!try_stealing()) {
        break;  // æ²¡æœ‰æ›´å¤šå·¥ä½œ
      }
    }
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦è®©å‡ºCPU
    if (should_yield()) {
      yield();
    }
  }
  
  // æ ‡è®°å®Œæˆï¼Œå‡†å¤‡æœ€ç»ˆæ ‡è®°
  if (!has_aborted()) {
    prepare_for_remark();
  }
}
```

### 3. æ ‡è®°ä»»åŠ¡å®ç°

```cpp
class G1CMTask : public TerminatorTerminator {
private:
  G1ConcurrentMark* _cm;
  G1CMBitMap* _mark_bitmap;
  G1CMTaskQueue* _task_queue;
  
  // å±€éƒ¨æ ‡è®°æ ˆ
  G1CMLocalMarkStack _local_mark_stack;
  
  // ç»Ÿè®¡ä¿¡æ¯
  size_t _marked_bytes_array[G1CMBitMapRO::num_par_sizes];
  
public:
  bool do_marking_step(double time_target_ms) {
    double start_time_ms = os::elapsedVTime() * 1000.0;
    
    // å¤„ç†å±€éƒ¨é˜Ÿåˆ—ä¸­çš„å¯¹è±¡
    while (!_task_queue->is_empty()) {
      oop obj = _task_queue->pop();
      if (obj != NULL) {
        scan_object(obj);
      }
      
      // æ£€æŸ¥æ—¶é—´é™åˆ¶
      if (elapsed_time_ms(start_time_ms) > time_target_ms) {
        return true;  // è¿˜æœ‰æ›´å¤šå·¥ä½œ
      }
    }
    
    // å°è¯•ä»å…¨å±€æ ˆè·å–å·¥ä½œ
    if (try_to_steal()) {
      return true;
    }
    
    return false;  // æ²¡æœ‰æ›´å¤šå·¥ä½œ
  }
  
private:
  void scan_object(oop obj) {
    assert(obj != NULL, "null check");
    assert(_mark_bitmap->is_marked((HeapWord*)obj), "should be marked");
    
    // æ‰«æå¯¹è±¡çš„æ‰€æœ‰å¼•ç”¨å­—æ®µ
    obj->oop_iterate(&_mark_closure);
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    size_t obj_size = obj->size();
    _marked_bytes_array[get_size_index(obj_size)] += obj_size * HeapWordSize;
  }
};
```

## ğŸ“Š 8GB G1å †çš„GCæ€§èƒ½åˆ†æ

### 1. GCæš‚åœæ—¶é—´é¢„æµ‹æ¨¡å‹

```cpp
class G1Predictions {
private:
  // æŒ‡æ•°ç§»åŠ¨å¹³å‡é¢„æµ‹å™¨
  TruncatedSeq _recent_gc_times_ms;
  TruncatedSeq _concurrent_mark_remark_times_ms;
  TruncatedSeq _concurrent_mark_cleanup_times_ms;
  
  // é¢„æµ‹å‚æ•°
  double _sigma;  // ç½®ä¿¡åŒºé—´å‚æ•°
  
public:
  double predict_zero_bounded(TruncatedSeq const* seq) const {
    return MAX2(seq->davg() + _sigma * seq->dsd(), 0.0);
  }
  
  // é¢„æµ‹Young GCæ—¶é—´
  double predict_young_gc_time_ms(size_t young_num_regions) const {
    return predict_zero_bounded(&_young_gc_times_ms) + 
           young_num_regions * predict_zero_bounded(&_young_gc_cost_per_region_ms);
  }
  
  // é¢„æµ‹Mixed GCæ—¶é—´
  double predict_mixed_gc_time_ms(size_t young_num_regions, 
                                 size_t old_num_regions) const {
    return predict_young_gc_time_ms(young_num_regions) +
           old_num_regions * predict_zero_bounded(&_old_gc_cost_per_region_ms);
  }
};
```

### 2. 8GBå †çš„å…¸å‹GCå‚æ•°

```cpp
// 8GB G1å †çš„å…¸å‹é…ç½®å’Œæ€§èƒ½ç‰¹å¾
struct G1_8GB_Performance {
  // åŸºç¡€é…ç½®
  size_t heap_size = 8ULL * 1024 * 1024 * 1024;  // 8GB
  size_t region_size = 4 * 1024 * 1024;          // 4MB
  uint total_regions = 2048;                      // æ€»Regionæ•°
  
  // Youngä»£é…ç½®
  uint young_list_target_length = 204;           // ç›®æ ‡Young Regionæ•° (~800MB)
  uint young_list_min_length = 51;               // æœ€å°Young Regionæ•° (~200MB)  
  uint young_list_max_length = 409;              // æœ€å¤§Young Regionæ•° (~1.6GB)
  
  // GCæ€§èƒ½é¢„æœŸ
  double young_gc_time_ms = 15.0;                // Young GCå¹³å‡æ—¶é—´
  double mixed_gc_time_ms = 45.0;                // Mixed GCå¹³å‡æ—¶é—´
  double concurrent_mark_time_ms = 200.0;        // å¹¶å‘æ ‡è®°æ—¶é—´
  
  // ååé‡æŒ‡æ ‡
  double gc_overhead_percentage = 2.0;           // GCå¼€é”€å æ¯”
  double allocation_rate_mb_s = 500.0;           // åˆ†é…é€Ÿç‡ MB/s
  
  // æš‚åœæ—¶é—´ç›®æ ‡
  double max_gc_pause_ms = 100.0;                // æœ€å¤§æš‚åœæ—¶é—´ç›®æ ‡
  double actual_pause_time_ms = 25.0;            // å®é™…å¹³å‡æš‚åœæ—¶é—´
};
```

## ğŸ› ï¸ GCæºç è°ƒè¯•å·¥å…·

### GDBè°ƒè¯•è„šæœ¬

```gdb
# G1 GCçŠ¶æ€æ£€æŸ¥
define g1_gc_state
  set $g1h = (G1CollectedHeap*)Universe::_collectedHeap
  set $state = &$g1h->_collector_state
  
  printf "G1 Collector State:\n"
  printf "  Young only phase: %s\n", $state->in_young_only_phase() ? "true" : "false"
  printf "  Initial mark GC: %s\n", $state->in_initial_mark_gc() ? "true" : "false"
  printf "  Mark or rebuild in progress: %s\n", $state->mark_or_rebuild_in_progress() ? "true" : "false"
  printf "  Young GC before mixed: %s\n", $state->in_young_gc_before_mixed() ? "true" : "false"
end

# G1Policyä¿¡æ¯
define g1_policy_info
  set $policy = ((G1CollectedHeap*)Universe::_collectedHeap)->_g1_policy
  
  printf "G1 Policy Information:\n"
  printf "  Young list target length: %u\n", $policy->_young_list_target_length
  printf "  Young list max length: %u\n", $policy->_young_list_max_length
  printf "  Reserve regions: %u\n", $policy->_reserve_regions
end

# å¹¶å‘æ ‡è®°çŠ¶æ€
define g1_concurrent_mark_state
  set $cm = ((G1CollectedHeap*)Universe::_collectedHeap)->_cm
  
  printf "G1 Concurrent Mark State:\n"
  printf "  Concurrent marking in progress: %s\n", $cm->_concurrent_marking_in_progress ? "true" : "false"
  printf "  Concurrent phase started: %s\n", $cm->_concurrent_phase_started ? "true" : "false"
  printf "  Has aborted: %s\n", $cm->has_aborted() ? "true" : "false"
end
```

### æ€§èƒ½ç›‘æ§è„šæœ¬

```bash
#!/bin/bash
# G1 GCæ€§èƒ½ç›‘æ§è„šæœ¬

echo "=== G1 GC Performance Monitor ==="

# ç›‘æ§GCæ—¥å¿—
tail -f gc.log | while read line; do
  if [[ $line == *"Pause Young"* ]]; then
    # æå–æš‚åœæ—¶é—´
    pause_time=$(echo $line | grep -o '[0-9.]*ms' | tail -1)
    echo "Young GC: $pause_time"
  elif [[ $line == *"Pause Mixed"* ]]; then
    pause_time=$(echo $line | grep -o '[0-9.]*ms' | tail -1)
    echo "Mixed GC: $pause_time"
  elif [[ $line == *"Concurrent Mark"* ]]; then
    echo "Concurrent Mark: $line"
  fi
done
```

## ğŸ“ å…³é”®å‘ç°æ€»ç»“

1. **åˆ†å±‚è®¾è®¡**: G1 GCé€šè¿‡å¤šå±‚æ¬¡çš„ç­–ç•¥å’Œæ‰§è¡Œç»„ä»¶å®ç°å¤æ‚çš„åƒåœ¾å›æ”¶é€»è¾‘
2. **é¢„æµ‹é©±åŠ¨**: åŸºäºå†å²æ•°æ®çš„é¢„æµ‹æ¨¡å‹æŒ‡å¯¼GCå†³ç­–å’Œæ€§èƒ½ä¼˜åŒ–
3. **å¹¶å‘ä¼˜åŒ–**: å¹¶å‘æ ‡è®°å’Œå¢é‡å›æ”¶æœ€å°åŒ–STWæš‚åœæ—¶é—´
4. **å·¥ä½œçªƒå–**: å¤šçº¿ç¨‹å¹¶è¡Œå¤„ç†é€šè¿‡å·¥ä½œçªƒå–ç®—æ³•å¹³è¡¡è´Ÿè½½
5. **è‡ªé€‚åº”è°ƒæ•´**: åŠ¨æ€è°ƒæ•´Youngä»£å¤§å°å’ŒGCè§¦å‘æ¡ä»¶
6. **æºç éªŒè¯**: æ‰€æœ‰åˆ†æéƒ½åŸºäºOpenJDK11çš„å®é™…æºç å®ç°

G1 GCçš„æºç å®ç°å±•ç°äº†ç°ä»£åƒåœ¾å›æ”¶å™¨çš„å¤æ‚æ€§å’Œç²¾å¦™è®¾è®¡ï¼Œé€šè¿‡ç²¾å¿ƒåè°ƒçš„å¤šä¸ªç»„ä»¶å®ç°äº†ä½å»¶è¿Ÿã€é«˜ååçš„åƒåœ¾å›æ”¶æ€§èƒ½ã€‚