# G1 GC 执行流程源码级再验证分析

> 基于OpenJDK 11源码深度验证，8GB堆配置（-Xms=Xmx=8GB），非大页，非NUMA
> 本文档通过源码逐行分析，验证G1 GC各阶段的执行细节

## 1. GC日志输出格式源码验证

### 1.1 GC暂停时间记录机制

```cpp
// 源码位置: g1GCPhaseTimes.cpp:292-321
// GC阶段时间输出格式定义
#define TIME_FORMAT "%.1lfms"

void G1GCPhaseTimes::info_time(const char* name, double value) const {
  log_info(gc, phases)("%s%s: " TIME_FORMAT, Indents[1], name, value);
}

void G1GCPhaseTimes::debug_time(const char* name, double value) const {
  log_debug(gc, phases)("%s%s: " TIME_FORMAT, Indents[2], name, value);
}

void G1GCPhaseTimes::trace_time(const char* name, double value) const {
  log_trace(gc, phases)("%s%s: " TIME_FORMAT, Indents[3], name, value);
}
```

**验证结论**: GC日志使用3级缩进层次：
- `info`: 1级缩进，主要阶段
- `debug`: 2级缩进，子阶段
- `trace`: 3级缩进，详细子阶段

### 1.2 GC暂停类型字符串生成

```cpp
// 源码位置: g1CollectedHeap.cpp:3097-3113
// GC类型字符串构建
G1HeapVerifier::G1VerifyType verify_type;
FormatBuffer<> gc_string("Pause Young ");

if (collector_state()->in_initial_mark_gc()) {
  gc_string.append("(Concurrent Start)");    // 并发标记启动
  verify_type = G1HeapVerifier::G1VerifyConcurrentStart;
} else if (collector_state()->in_young_only_phase()) {
  if (collector_state()->in_young_gc_before_mixed()) {
    gc_string.append("(Prepare Mixed)");     // 准备Mixed GC
  } else {
    gc_string.append("(Normal)");            // 常规Young GC
  }
  verify_type = G1HeapVerifier::G1VerifyYoungNormal;
} else {
  gc_string.append("(Mixed)");               // Mixed GC
  verify_type = G1HeapVerifier::G1VerifyMixed;
}

// 使用GCTraceTime输出
GCTraceTime(Info, gc) tm(gc_string, NULL, gc_cause(), true);
```

**验证结论**: GC日志中的暂停类型由`collector_state()`状态机决定：
| 状态组合 | 输出字符串 |
|---------|-----------|
| `in_initial_mark_gc()` | `Pause Young (Concurrent Start)` |
| `in_young_only_phase() && in_young_gc_before_mixed()` | `Pause Young (Prepare Mixed)` |
| `in_young_only_phase() && !in_young_gc_before_mixed()` | `Pause Young (Normal)` |
| 其他 | `Pause Young (Mixed)` |

## 2. Young GC三大阶段时间分解验证

### 2.1 Pre Evacuate Collection Set阶段

```cpp
// 源码位置: g1GCPhaseTimes.cpp:323-346
double G1GCPhaseTimes::print_pre_evacuate_collection_set() const {
  const double sum_ms = _root_region_scan_wait_time_ms +
                        _recorded_young_cset_choice_time_ms +
                        _recorded_non_young_cset_choice_time_ms +
                        _cur_fast_reclaim_humongous_register_time_ms +
                        _recorded_clear_claimed_marks_time_ms;

  info_time("Pre Evacuate Collection Set", sum_ms);

  // 子阶段输出
  if (_root_region_scan_wait_time_ms > 0.0) {
    debug_time("Root Region Scan Waiting", _root_region_scan_wait_time_ms);
  }
  debug_time("Prepare TLABs", _cur_prepare_tlab_time_ms);
  debug_time("Choose Collection Set", (_recorded_young_cset_choice_time_ms + 
                                       _recorded_non_young_cset_choice_time_ms));
  if (G1EagerReclaimHumongousObjects) {
    debug_time("Humongous Register", _cur_fast_reclaim_humongous_register_time_ms);
    trace_count("Humongous Total", _cur_fast_reclaim_humongous_total);
    trace_count("Humongous Candidate", _cur_fast_reclaim_humongous_candidates);
  }
  if (_recorded_clear_claimed_marks_time_ms > 0.0) {
    debug_time("Clear Claimed Marks", _recorded_clear_claimed_marks_time_ms);
  }
  return sum_ms;
}
```

**验证结论 - Pre Evacuate阶段包含**:
| 子阶段 | 功能 | 何时出现 |
|-------|-----|---------|
| Root Region Scan Waiting | 等待并发Root Region扫描完成 | 并发标记期间 |
| Prepare TLABs | 准备TLAB | 始终 |
| Choose Collection Set | 选择Collection Set | 始终 |
| Humongous Register | 注册Humongous对象候选 | G1EagerReclaimHumongousObjects开启时 |
| Clear Claimed Marks | 清除标记 | Initial Mark时 |

### 2.2 Evacuate Collection Set阶段

```cpp
// 源码位置: g1GCPhaseTimes.cpp:349-375
double G1GCPhaseTimes::print_evacuate_collection_set() const {
  const double sum_ms = _cur_collection_par_time_ms;

  info_time("Evacuate Collection Set", sum_ms);

  trace_phase(_gc_par_phases[GCWorkerStart], false);
  debug_phase(_gc_par_phases[ExtRootScan]);        // External Root扫描
  for (int i = ThreadRoots; i <= SATBFiltering; i++) {
    trace_phase(_gc_par_phases[i]);               // Thread/String/Universe/JNI等Root
  }
  debug_phase(_gc_par_phases[UpdateRS]);           // 更新RemSet
  if (G1HotCardCache::default_use_cache()) {
    trace_phase(_gc_par_phases[ScanHCC]);         // 扫描Hot Card Cache
  }
  debug_phase(_gc_par_phases[ScanRS]);             // 扫描RemSet
  debug_phase(_gc_par_phases[CodeRoots]);          // Code Cache Root
  debug_phase(_gc_par_phases[ObjCopy]);            // 对象复制
  debug_phase(_gc_par_phases[Termination]);        // 终止协议
  debug_phase(_gc_par_phases[Other]);              // 其他
  debug_phase(_gc_par_phases[GCWorkerTotal]);      // Worker总时间
  trace_phase(_gc_par_phases[GCWorkerEnd], false);

  return sum_ms;
}
```

**验证结论 - Evacuate阶段并行任务枚举**:
```cpp
// 源码位置: g1GCPhaseTimes.hpp:45-79
enum GCParPhases {
  GCWorkerStart,          // Worker开始
  ExtRootScan,            // External Root扫描总时间
  ThreadRoots,            // Java线程Root
  StringTableRoots,       // StringTable Root
  UniverseRoots,          // Universe Root
  JNIRoots,               // JNI Handle
  ObjectSynchronizerRoots,// Monitor Root
  ManagementRoots,        // JMX相关
  SystemDictionaryRoots,  // 系统字典
  CLDGRoots,              // ClassLoaderData
  JVMTIRoots,             // JVMTI
  CMRefRoots,             // CM引用Root
  WaitForStrongCLD,       // 等待Strong CLD
  WeakCLDRoots,           // 弱CLD Root
  SATBFiltering,          // SATB队列过滤
  UpdateRS,               // 更新RemSet
  ScanHCC,                // 扫描Hot Card Cache
  ScanRS,                 // 扫描RemSet
  CodeRoots,              // Code Cache Root
  ObjCopy,                // 对象复制
  Termination,            // 终止协议
  Other,                  // 其他
  GCWorkerTotal,          // Worker总时间
  GCWorkerEnd,            // Worker结束
  // ...
};
```

### 2.3 Post Evacuate Collection Set阶段

```cpp
// 源码位置: g1GCPhaseTimes.cpp:377-443
double G1GCPhaseTimes::print_post_evacuate_collection_set() const {
  const double evac_fail_handling = _cur_evac_fail_recalc_used +
                                    _cur_evac_fail_remove_self_forwards;
  const double sum_ms = evac_fail_handling +
                        _cur_collection_code_root_fixup_time_ms +
                        _recorded_preserve_cm_referents_time_ms +
                        _cur_ref_proc_time_ms +
                        _cur_weak_ref_proc_time_ms +
                        _cur_clear_ct_time_ms +
                        _recorded_merge_pss_time_ms +
                        _cur_strong_code_root_purge_time_ms +
                        _recorded_redirty_logged_cards_time_ms +
                        _recorded_total_free_cset_time_ms +
                        _cur_fast_reclaim_humongous_time_ms +
                        _cur_expand_heap_time_ms +
                        _cur_string_dedup_fixup_time_ms;

  info_time("Post Evacuate Collection Set", sum_ms);

  debug_time("Code Roots Fixup", _cur_collection_code_root_fixup_time_ms);
  debug_time("Clear Card Table", _cur_clear_ct_time_ms);
  debug_time_for_reference("Reference Processing", _cur_ref_proc_time_ms);
  debug_time("Weak Processing", _cur_weak_ref_proc_time_ms);
  
  if (G1StringDedup::is_enabled()) {
    debug_time("String Dedup Fixup", _cur_string_dedup_fixup_time_ms);
  }
  
  if (G1CollectedHeap::heap()->evacuation_failed()) {
    debug_time("Evacuation Failure", evac_fail_handling);
    trace_time("Recalculate Used", _cur_evac_fail_recalc_used);
    trace_time("Remove Self Forwards", _cur_evac_fail_remove_self_forwards);
  }

  debug_time("Merge Per-Thread State", _recorded_merge_pss_time_ms);
  debug_time("Code Roots Purge", _cur_strong_code_root_purge_time_ms);
  debug_time("Redirty Cards", _recorded_redirty_logged_cards_time_ms);
  debug_time("Free Collection Set", _recorded_total_free_cset_time_ms);
  
  if (G1EagerReclaimHumongousObjects) {
    debug_time("Humongous Reclaim", _cur_fast_reclaim_humongous_time_ms);
    trace_count("Humongous Reclaimed", _cur_fast_reclaim_humongous_reclaimed);
  }
  debug_time("Start New Collection Set", _recorded_start_new_cset_time_ms);
  if (UseTLAB && ResizeTLAB) {
    debug_time("Resize TLABs", _cur_resize_tlab_time_ms);
  }
  debug_time("Expand Heap After Collection", _cur_expand_heap_time_ms);

  return sum_ms;
}
```

**验证结论 - Post Evacuate阶段完整子任务**:
| 子阶段 | 功能 | 条件 |
|-------|-----|-----|
| Code Roots Fixup | 修复Code Cache中的引用 | 始终 |
| Clear Card Table | 清除卡表 | 始终 |
| Reference Processing | 处理软/弱/虚/final引用 | 始终 |
| Weak Processing | 处理WeakProcessor | 始终 |
| String Dedup Fixup | 字符串去重修复 | G1StringDedup开启时 |
| Evacuation Failure | Evacuation失败处理 | evacuation_failed()为true时 |
| Merge Per-Thread State | 合并Worker线程状态 | 始终 |
| Code Roots Purge | 清除无效Code Root | 始终 |
| Redirty Cards | 重新弄脏卡片 | 始终 |
| Free Collection Set | 释放Collection Set | 始终 |
| Humongous Reclaim | 回收Humongous对象 | G1EagerReclaimHumongousObjects开启时 |
| Start New Collection Set | 启动新Collection Set | 始终 |
| Resize TLABs | 调整TLAB大小 | UseTLAB && ResizeTLAB时 |
| Expand Heap After Collection | GC后堆扩展 | 需要时 |

## 3. G1ParTask并行任务执行流程验证

### 3.1 G1ParTask::work()核心逻辑

```cpp
// 源码位置: g1CollectedHeap.cpp:3406-3486
class G1ParTask : public AbstractGangTask {
protected:
  G1CollectedHeap*         _g1h;
  G1ParScanThreadStateSet* _pss;
  RefToScanQueueSet*       _queues;
  G1RootProcessor*         _root_processor;
  ParallelTaskTerminator   _terminator;
  uint                     _n_workers;

public:
  void work(uint worker_id) {
    if (worker_id >= _n_workers) return;

    double start_sec = os::elapsedTime();
    _g1h->g1_policy()->phase_times()->record_time_secs(
        G1GCPhaseTimes::GCWorkerStart, worker_id, start_sec);

    {
      ResourceMark rm;
      HandleMark   hm;

      G1ParScanThreadState* pss = _pss->state_for_worker(worker_id);
      pss->set_ref_discoverer(_g1h->ref_processor_stw());

      double start_strong_roots_sec = os::elapsedTime();

      // 步骤1: 扫描GC Roots
      _root_processor->evacuate_roots(pss, worker_id);

      // 步骤2: 扫描RemSet（处理跨Region引用）
      _g1h->g1_rem_set()->oops_into_collection_set_do(pss, worker_id);

      double strong_roots_sec = os::elapsedTime() - start_strong_roots_sec;

      // 步骤3: 对象复制与终止协议
      double term_sec = 0.0;
      size_t evac_term_attempts = 0;
      {
        double start = os::elapsedTime();
        G1ParEvacuateFollowersClosure evac(_g1h, pss, _queues, &_terminator);
        evac.do_void();  // 执行对象复制

        evac_term_attempts = evac.term_attempts();
        term_sec = evac.term_time();
        double elapsed_sec = os::elapsedTime() - start;

        // 记录时间
        G1GCPhaseTimes* p = _g1h->g1_policy()->phase_times();
        p->add_time_secs(G1GCPhaseTimes::ObjCopy, worker_id, elapsed_sec - term_sec);
        p->record_time_secs(G1GCPhaseTimes::Termination, worker_id, term_sec);
        p->record_thread_work_item(G1GCPhaseTimes::Termination, worker_id, evac_term_attempts);
      }

      assert(pss->queue_is_empty(), "should be empty");
    }

    double end_sec = os::elapsedTime();
    _g1h->g1_policy()->phase_times()->record_time_secs(
        G1GCPhaseTimes::GCWorkerEnd, worker_id, end_sec);
  }
};
```

**验证结论 - 每个GC Worker执行流程**:
```
Worker线程执行顺序:
1. record_time_secs(GCWorkerStart)  - 记录开始时间
2. evacuate_roots()                 - 扫描GC Roots
3. oops_into_collection_set_do()    - 扫描RemSet
4. G1ParEvacuateFollowersClosure    - 对象复制 + Work Stealing
   ├── ObjCopy时间 = elapsed - term_time
   └── Termination时间 = term_time
5. record_time_secs(GCWorkerEnd)    - 记录结束时间
```

### 3.2 evacuate_collection_set执行验证

```cpp
// 源码位置: g1CollectedHeap.cpp:4275-4309
void G1CollectedHeap::evacuate_collection_set(G1ParScanThreadStateSet* per_thread_states) {
  NOT_PRODUCT(set_evacuation_failure_alot_for_current_gc();)

  assert(dirty_card_queue_set().completed_buffers_num() == 0, "Should be empty");

  G1GCPhaseTimes* phase_times = g1_policy()->phase_times();

  double start_par_time_sec = os::elapsedTime();
  double end_par_time_sec;

  {
    const uint n_workers = workers()->active_workers();
    G1RootProcessor root_processor(this, n_workers);
    G1ParTask g1_par_task(this, per_thread_states, _task_queues, &root_processor, n_workers);

    print_termination_stats_hdr();

    // 并行执行GC任务
    workers()->run_task(&g1_par_task);
    end_par_time_sec = os::elapsedTime();
  }

  // 记录并行时间
  double par_time_ms = (end_par_time_sec - start_par_time_sec) * 1000.0;
  phase_times->record_par_time(par_time_ms);

  // 记录Code Root修复时间
  double code_root_fixup_time_ms =
        (os::elapsedTime() - end_par_time_sec) * 1000.0;
  phase_times->record_code_root_fixup_time(code_root_fixup_time_ms);
}
```

**验证结论**:
- `Evacuate Collection Set`时间 = `par_time_ms` = Worker并行执行总时间
- Code Root Fixup在并行阶段之后串行执行

## 4. 并发标记周期完整流程验证

### 4.1 并发标记线程主循环

```cpp
// 源码位置: g1ConcurrentMarkThread.cpp:247-399
void G1ConcurrentMarkThread::run_service() {
  _vtime_start = os::elapsedVTime();

  G1CollectedHeap* g1h = G1CollectedHeap::heap();
  G1Policy* g1_policy = g1h->g1_policy();

  G1ConcPhaseManager cpmanager(G1ConcurrentPhase::IDLE, this);

  while (!should_terminate()) {
    // 等待启动信号
    sleep_before_next_cycle();
    if (should_terminate()) break;

    cpmanager.set_phase(G1ConcurrentPhase::CONCURRENT_CYCLE, false);

    GCIdMark gc_id_mark;
    _cm->concurrent_cycle_start();

    GCTraceConcTime(Info, gc) tt("Concurrent Cycle");
    {
      ResourceMark rm;
      HandleMark   hm;
      double cycle_start = os::elapsedVTime();

      // 阶段1: Clear Claimed Marks（并发）
      {
        G1ConcPhase p(G1ConcurrentPhase::CLEAR_CLAIMED_MARKS, this);
        ClassLoaderDataGraph::clear_claimed_marks();
      }

      // 阶段2: Scan Root Regions（并发）
      {
        G1ConcPhase p(G1ConcurrentPhase::SCAN_ROOT_REGIONS, this);
        _cm->scan_root_regions();
      }

      // 阶段3-4: Concurrent Mark + Remark循环
      {
        G1ConcPhaseManager mark_manager(G1ConcurrentPhase::CONCURRENT_MARK, this);
        jlong mark_start = os::elapsed_counter();
        
        for (uint iter = 1; !_cm->has_aborted(); ++iter) {
          // 3a. Concurrent Mark（并发）
          {
            G1ConcPhase p(G1ConcurrentPhase::MARK_FROM_ROOTS, this);
            _cm->mark_from_roots();
          }
          if (_cm->has_aborted()) break;

          // 3b. Preclean（可选，并发）
          if (G1UseReferencePrecleaning) {
            G1ConcPhase p(G1ConcurrentPhase::PRECLEAN, this);
            _cm->preclean();
          }

          // 等待点
          {
            G1ConcPhaseManager p(G1ConcurrentPhase::BEFORE_REMARK, this);
          }
          if (_cm->has_aborted()) break;

          // MMU延迟
          delay_to_keep_mmu(g1_policy, true /* remark */);
          if (_cm->has_aborted()) break;

          // 4. Remark（STW）
          mark_manager.set_phase(G1ConcurrentPhase::REMARK, false);
          CMRemark cl(_cm);
          VM_CGC_Operation op(&cl, "Pause Remark");
          VMThread::execute(&op);

          if (_cm->has_aborted()) {
            break;
          } else if (!_cm->restart_for_overflow()) {
            break;  // 正常退出
          } else {
            // Mark Stack溢出，重启标记
            mark_manager.set_phase(G1ConcurrentPhase::CONCURRENT_MARK, false);
            log_info(gc, marking)("Restart for Mark Stack Overflow (iteration #%u)", iter);
          }
        }
      }

      // 阶段5: Rebuild Remembered Sets（并发）
      if (!_cm->has_aborted()) {
        G1ConcPhase p(G1ConcurrentPhase::REBUILD_REMEMBERED_SETS, this);
        _cm->rebuild_rem_set_concurrently();
      }

      // 更新虚拟时间
      double end_time = os::elapsedVTime();
      _vtime_accum = (end_time - _vtime_start);

      // MMU延迟（Cleanup前）
      if (!_cm->has_aborted()) {
        delay_to_keep_mmu(g1_policy, false /* cleanup */);
      }

      // 阶段6: Cleanup（STW）
      if (!_cm->has_aborted()) {
        CMCleanup cl_cl(_cm);
        VM_CGC_Operation op(&cl_cl, "Pause Cleanup");
        VMThread::execute(&op);
      }

      // 阶段7: Cleanup for Next Mark（并发）
      if (!_cm->has_aborted()) {
        G1ConcPhase p(G1ConcurrentPhase::CLEANUP_FOR_NEXT_MARK, this);
        _cm->cleanup_for_next_mark();
      }
    }

    // 完成标记周期
    {
      SuspendibleThreadSetJoiner sts_join;
      g1h->increment_old_marking_cycles_completed(true /* concurrent */);
      _cm->concurrent_cycle_end();
    }
  }
}
```

**验证结论 - 并发标记7个阶段**:

| # | 阶段名称 | 执行方式 | 源码方法 |
|---|---------|---------|---------|
| 1 | Clear Claimed Marks | 并发 | `ClassLoaderDataGraph::clear_claimed_marks()` |
| 2 | Scan Root Regions | 并发 | `_cm->scan_root_regions()` |
| 3 | Concurrent Mark | 并发 | `_cm->mark_from_roots()` |
| 3b | Preclean | 并发(可选) | `_cm->preclean()` |
| 4 | Remark | **STW** | `VM_CGC_Operation` + `CMRemark` |
| 5 | Rebuild Remembered Sets | 并发 | `_cm->rebuild_rem_set_concurrently()` |
| 6 | Cleanup | **STW** | `VM_CGC_Operation` + `CMCleanup` |
| 7 | Cleanup for Next Mark | 并发 | `_cm->cleanup_for_next_mark()` |

### 4.2 Remark阶段详细操作

```cpp
// 源码位置: g1ConcurrentMark.cpp:1163-1259
void G1ConcurrentMark::remark() {
  assert_at_safepoint_on_vm_thread();

  if (has_aborted()) return;

  G1Policy* g1p = _g1h->g1_policy();
  g1p->record_concurrent_mark_remark_start();

  double start = os::elapsedTime();

  verify_during_pause(G1HeapVerifier::G1VerifyRemark, 
                      VerifyOption_G1UsePrevMarking, "Remark before");

  // 1. Finalize Marking - 完成最终标记
  {
    GCTraceTime(Debug, gc, phases) debug("Finalize Marking", _gc_timer_cm);
    finalize_marking();
  }

  double mark_work_end = os::elapsedTime();

  bool const mark_finished = !has_overflown();
  if (mark_finished) {
    // 2. 处理软/弱/虚引用
    weak_refs_work(false /* clear_all_soft_refs */);

    // 3. 关闭SATB队列
    SATBMarkQueueSet& satb_mq_set = G1BarrierSet::satb_mark_queue_set();
    satb_mq_set.set_active_all_threads(false, true);

    // 4. 刷新任务缓存
    {
      GCTraceTime(Debug, gc, phases) debug("Flush Task Caches", _gc_timer_cm);
      flush_all_task_caches();
    }

    // 5. 交换标记位图（next -> prev）
    swap_mark_bitmaps();

    // 6. 更新RemSet跟踪状态
    {
      GCTraceTime(Debug, gc, phases) debug(
          "Update Remembered Set Tracking Before Rebuild", _gc_timer_cm);
      
      uint const num_workers = MIN2(_g1h->workers()->active_workers(), 
                                    workers_by_capacity);
      G1UpdateRemSetTrackingBeforeRebuildTask cl(_g1h, this, num_workers);
      _g1h->workers()->run_task(&cl, num_workers);
    }

    // 7. 回收空Region
    {
      GCTraceTime(Debug, gc, phases) debug("Reclaim Empty Regions", _gc_timer_cm);
      reclaim_empty_regions();
    }

    // 8. 类卸载
    if (ClassUnloadingWithConcurrentMark) {
      GCTraceTime(Debug, gc, phases) debug("Purge Metaspace", _gc_timer_cm);
      ClassLoaderDataGraph::purge();
    }

    // 9. 计算新大小
    compute_new_sizes();

    verify_during_pause(G1HeapVerifier::G1VerifyRemark, 
                        VerifyOption_G1UsePrevMarking, "Remark after");

    reset_at_marking_complete();
  } else {
    // Mark Stack溢出，需要重启
    _restart_for_overflow = true;
    reset_marking_for_restart();
  }

  // 10. 报告对象统计
  {
    GCTraceTime(Debug, gc, phases) debug("Report Object Count", _gc_timer_cm);
    report_object_count(mark_finished);
  }

  // 记录统计
  double now = os::elapsedTime();
  _remark_mark_times.add((mark_work_end - start) * 1000.0);
  _remark_weak_ref_times.add((now - mark_work_end) * 1000.0);
  _remark_times.add((now - start) * 1000.0);

  g1p->record_concurrent_mark_remark_end();
}
```

**验证结论 - Remark阶段10个子操作**:
1. Finalize Marking - 完成标记
2. Weak Refs Work - 处理引用
3. SATB Queue Close - 关闭SATB
4. Flush Task Caches - 刷新缓存
5. Swap Mark Bitmaps - 交换位图
6. Update RemSet Tracking - 更新RemSet状态
7. Reclaim Empty Regions - 回收空Region
8. Purge Metaspace - 类卸载
9. Compute New Sizes - 计算新大小
10. Report Object Count - 报告统计

### 4.3 Cleanup阶段详细操作

```cpp
// 源码位置: g1ConcurrentMark.cpp:1380-1421
void G1ConcurrentMark::cleanup() {
  assert_at_safepoint_on_vm_thread();

  if (has_aborted()) return;

  G1Policy* g1p = _g1h->g1_policy();
  g1p->record_concurrent_mark_cleanup_start();

  double start = os::elapsedTime();

  verify_during_pause(G1HeapVerifier::G1VerifyCleanup, 
                      VerifyOption_G1UsePrevMarking, "Cleanup before");

  // 1. 更新RemSet跟踪状态（Rebuild后）
  {
    GCTraceTime(Debug, gc, phases) debug(
        "Update Remembered Set Tracking After Rebuild", _gc_timer_cm);
    G1UpdateRemSetTrackingAfterRebuild cl(_g1h);
    _g1h->heap_region_iterate(&cl);
  }

  // 2. 打印Region存活信息（trace级别）
  if (log_is_enabled(Trace, gc, liveness)) {
    G1PrintRegionLivenessInfoClosure cl("Post-Cleanup");
    _g1h->heap_region_iterate(&cl);
  }

  verify_during_pause(G1HeapVerifier::G1VerifyCleanup, 
                      VerifyOption_G1UsePrevMarking, "Cleanup after");

  // 3. 递增collection计数
  _g1h->increment_total_collections();

  // 记录统计
  double recent_cleanup_time = (os::elapsedTime() - start);
  _total_cleanup_time += recent_cleanup_time;
  _cleanup_times.add(recent_cleanup_time);

  // 4. 完成Cleanup
  {
    GCTraceTime(Debug, gc, phases) debug(
        "Finalize Concurrent Mark Cleanup", _gc_timer_cm);
    _g1h->g1_policy()->record_concurrent_mark_cleanup_end();
  }
}
```

## 5. IHOP触发并发标记验证

### 5.1 IHOP阈值检查

```cpp
// 源码位置: g1Policy.cpp:555-575
bool G1Policy::need_to_start_conc_mark(const char* source, size_t alloc_word_size) {
  // 如果即将开始Mixed GC阶段，不启动新的并发标记
  if (about_to_start_mixed_phase()) {
    return false;
  }

  // 获取IHOP阈值
  size_t marking_initiating_used_threshold = _ihop_control->get_conc_mark_start_threshold();

  // 当前Old区使用量
  size_t cur_used_bytes = _g1h->non_young_capacity_bytes();
  size_t alloc_byte_size = alloc_word_size * HeapWordSize;
  size_t marking_request_bytes = cur_used_bytes + alloc_byte_size;

  bool result = false;
  if (marking_request_bytes > marking_initiating_used_threshold) {
    // 只有在Young Only阶段且不是在准备Mixed GC时才触发
    result = collector_state()->in_young_only_phase() && 
             !collector_state()->in_young_gc_before_mixed();
    
    log_debug(gc, ergo, ihop)(
        "%s occupancy: " SIZE_FORMAT "B allocation request: " SIZE_FORMAT "B "
        "threshold: " SIZE_FORMAT "B (%1.2f) source: %s",
        result ? "Request concurrent cycle initiation (occupancy higher than threshold)" 
               : "Do not request concurrent cycle initiation (still doing mixed collections)",
        cur_used_bytes, alloc_byte_size, marking_initiating_used_threshold, 
        (double) marking_initiating_used_threshold / _g1h->capacity() * 100, source);
  }

  return result;
}
```

**验证结论 - IHOP触发条件**:
```
触发并发标记 = (cur_used + alloc_request > IHOP阈值) 
              && in_young_only_phase 
              && !in_young_gc_before_mixed
              && !about_to_start_mixed_phase
```

### 5.2 8GB堆IHOP计算

```
默认InitiatingHeapOccupancyPercent = 45%
8GB堆IHOP阈值 = 8GB × 45% = 3.6GB

当Old区使用量 > 3.6GB时，触发并发标记周期
```

## 6. Mixed GC触发与执行验证

### 6.1 进入Mixed GC阶段判断

```cpp
// 源码位置: g1Policy.cpp:551-553
bool G1Policy::about_to_start_mixed_phase() const {
  // 并发标记线程仍在运行 或 即将进入Mixed GC
  return _g1h->concurrent_mark()->cm_thread()->during_cycle() || 
         collector_state()->in_young_gc_before_mixed();
}
```

### 6.2 Mixed GC Region选择算法

```cpp
// 源码位置: g1CollectionSet.cpp:410-506
void G1CollectionSet::finalize_old_part(double time_remaining_ms) {
  double non_young_start_time_sec = os::elapsedTime();
  double predicted_old_time_ms = 0.0;

  if (collector_state()->in_mixed_phase()) {
    cset_chooser()->verify();
    
    // 计算Old Region数量范围
    const uint min_old_cset_length = _policy->calc_min_old_cset_length();
    const uint max_old_cset_length = _policy->calc_max_old_cset_length();

    uint expensive_region_num = 0;
    bool check_time_remaining = _policy->adaptive_young_list_length();

    HeapRegion* hr = cset_chooser()->peek();
    while (hr != NULL) {
      // 终止条件1: 达到最大Old Region数
      if (old_region_length() >= max_old_cset_length) {
        log_debug(gc, ergo, cset)("Finish adding old regions to CSet "
            "(old CSet region num reached max). old %u regions, max %u regions",
            old_region_length(), max_old_cset_length);
        break;
      }

      // 终止条件2: 可回收空间低于阈值
      size_t reclaimable_bytes = cset_chooser()->remaining_reclaimable_bytes();
      double reclaimable_percent = _policy->reclaimable_bytes_percent(reclaimable_bytes);
      double threshold = (double) G1HeapWastePercent;  // 默认5%
      if (reclaimable_percent <= threshold) {
        log_debug(gc, ergo, cset)("Finish adding old regions to CSet "
            "(reclaimable percentage not over threshold). "
            "reclaimable: " SIZE_FORMAT "B (%1.2f%%) threshold: " UINTX_FORMAT "%%",
            reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);
        break;
      }

      // 预测回收时间
      double predicted_time_ms = predict_region_elapsed_time_ms(hr);
      
      if (check_time_remaining) {
        if (predicted_time_ms > time_remaining_ms) {
          // 终止条件3: 已达到最小数量且超出时间预算
          if (old_region_length() >= min_old_cset_length) {
            log_debug(gc, ergo, cset)("Finish adding old regions to CSet "
                "(predicted time is too high). predicted time: %1.2fms, "
                "remaining time: %1.2fms old %u regions, min %u regions",
                predicted_time_ms, time_remaining_ms, 
                old_region_length(), min_old_cset_length);
            break;
          }
          // 未达到最小数量，仍然添加
          expensive_region_num += 1;
        }
      }

      // 添加到Collection Set
      time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);
      predicted_old_time_ms += predicted_time_ms;
      cset_chooser()->pop();
      _g1h->old_set_remove(hr);
      add_old_region(hr);

      hr = cset_chooser()->peek();
    }
  }

  // 记录时间
  phase_times()->record_non_young_cset_choice_time_ms(
      (os::elapsedTime() - non_young_start_time_sec) * 1000.0);
}
```

### 6.3 Mixed GC最小/最大Region数计算

```cpp
// 源码位置: g1Policy.cpp:1129-1148
uint G1Policy::calc_min_old_cset_length() const {
  // 基于G1MixedGCCountTarget计算
  // 确保在目标次数内完成所有标记的Old Region回收
  const size_t region_num = (size_t) cset_chooser()->length();
  const size_t gc_num = (size_t) MAX2(G1MixedGCCountTarget, (uintx) 1);
  size_t result = region_num / gc_num;
  // 向上取整
  if (result * gc_num < region_num) {
    result += 1;
  }
  return (uint) result;
}
```

**验证结论 - Mixed GC参数（8GB堆）**:
| 参数 | 默认值 | 说明 |
|-----|-------|------|
| G1MixedGCCountTarget | 8 | 目标Mixed GC次数 |
| G1HeapWastePercent | 5% | 可容忍浪费比例（8GB = 400MB） |
| min_old_cset_length | 标记Region数/8 | 每次Mixed GC最少回收的Old Region |
| max_old_cset_length | 根据暂停目标计算 | 每次Mixed GC最多回收的Old Region |

## 7. Full GC四阶段执行验证

### 7.1 Full GC入口

```cpp
// 源码位置: g1FullCollector.cpp:167-179
void G1FullCollector::collect() {
  phase1_mark_live_objects();   // 阶段1: 标记存活对象
  verify_after_marking();

  deactivate_derived_pointers();

  phase2_prepare_compaction();  // 阶段2: 准备压缩
  phase3_adjust_pointers();     // 阶段3: 调整指针
  phase4_do_compaction();       // 阶段4: 执行压缩
}
```

### 7.2 四阶段详细实现

```cpp
// 阶段1: 标记存活对象
// 源码位置: g1FullCollector.cpp:203-234
void G1FullCollector::phase1_mark_live_objects() {
  GCTraceTime(Info, gc, phases) info("Phase 1: Mark live objects", scope()->timer());

  // 并行标记任务
  G1FullGCMarkTask marking_task(this);
  run_task(&marking_task);

  // 引用处理
  G1FullGCReferenceProcessingExecutor reference_processing(this);
  reference_processing.execute(scope()->timer(), scope()->tracer());

  // 弱引用处理
  {
    GCTraceTime(Debug, gc, phases) trace("Phase 1: Weak Processing", scope()->timer());
    WeakProcessor::weak_oops_do(&_is_alive, &do_nothing_cl);
  }

  // 类卸载
  if (ClassUnloading) {
    GCTraceTime(Debug, gc, phases) debug("Phase 1: Class Unloading and Cleanup", 
                                         scope()->timer());
    bool purged_class = SystemDictionary::do_unloading(scope()->timer());
    _heap->complete_cleaning(&_is_alive, purged_class);
  }
}

// 阶段2: 准备压缩
// 源码位置: g1FullCollector.cpp:236-245
void G1FullCollector::phase2_prepare_compaction() {
  GCTraceTime(Info, gc, phases) info("Phase 2: Prepare for compaction", scope()->timer());
  G1FullGCPrepareTask task(this);
  run_task(&task);

  // 处理OOM风险
  if (!task.has_freed_regions()) {
    task.prepare_serial_compaction();
  }
}

// 阶段3: 调整指针
// 源码位置: g1FullCollector.cpp:247-253
void G1FullCollector::phase3_adjust_pointers() {
  GCTraceTime(Info, gc, phases) info("Phase 3: Adjust pointers", scope()->timer());
  G1FullGCAdjustTask task(this);
  run_task(&task);
}

// 阶段4: 执行压缩
// 源码位置: g1FullCollector.cpp:255-265
void G1FullCollector::phase4_do_compaction() {
  GCTraceTime(Info, gc, phases) info("Phase 4: Compact heap", scope()->timer());
  G1FullGCCompactTask task(this);
  run_task(&task);

  // 串行压缩（处理特殊情况）
  if (serial_compaction_point()->has_regions()) {
    task.serial_compaction();
  }
}
```

**验证结论 - Full GC四阶段**:
| 阶段 | 名称 | 主要操作 |
|-----|------|---------|
| Phase 1 | Mark live objects | 标记存活对象、引用处理、类卸载 |
| Phase 2 | Prepare for compaction | 计算对象新地址、确定压缩边界 |
| Phase 3 | Adjust pointers | 调整所有指针到新地址 |
| Phase 4 | Compact heap | 移动对象到新位置 |

## 8. Evacuation失败处理验证

### 8.1 Evacuation失败检测

```cpp
// 源码位置: g1ParScanThreadState.cpp:364-375
// 在copy_to_survivor_space中，如果分配失败
if (!r->evacuation_failed()) {
  r->set_evacuation_failed(true);
  _g1h->hr_printer()->evac_failure(r);
}

_g1h->preserve_mark_during_evac_failure(_worker_id, old, m);

_scanner.set_region(r);
old->oop_iterate_backwards(&_scanner);

return old;  // 返回原对象，不复制
```

### 8.2 Evacuation失败后处理

```cpp
// 源码位置: g1CollectedHeap.cpp:3233-3247, 4349-4356
if (evacuation_failed()) {
  // 重新计算used
  set_used(recalculate_used());
  
  // 报告失败信息
  for (uint i = 0; i < ParallelGCThreads; i++) {
    if (_evacuation_failed_info_array[i].has_failed()) {
      _gc_tracer_stw->report_evacuation_failed(_evacuation_failed_info_array[i]);
    }
  }
}

// post_evacuate_collection_set中
if (evacuation_failed()) {
  restore_after_evac_failure();  // 恢复自引用指针
  NOT_PRODUCT(reset_evacuation_should_fail();)
}
```

**验证结论 - Evacuation失败处理流程**:
1. 检测: `copy_to_survivor_space`分配失败
2. 标记: `r->set_evacuation_failed(true)`
3. 保留: 对象保留在原位置，设置自引用forward指针
4. 恢复: `restore_after_evac_failure()`移除自引用指针
5. 日志: `"To-space exhausted"` 输出

## 9. 8GB堆GC关键参数验证总结

| 参数 | 值 | 源码验证位置 |
|-----|---|------------|
| Region大小 | 4MB | HeapRegion::GrainBytes |
| Region数量 | 2,048 | 8GB / 4MB |
| IHOP阈值 | 3.6GB (45%) | G1Policy::need_to_start_conc_mark |
| G1HeapWastePercent | 5% (400MB) | g1CollectionSet.cpp:435 |
| G1MixedGCCountTarget | 8 | g1Policy.cpp:1141 |
| MaxGCPauseMillis | 200ms | G1Arguments |
| 并行GC Worker数 | CPU核心数 | workers()->active_workers() |

## 10. GC日志输出示例验证

基于源码分析，8GB堆的典型GC日志格式：

```
# Young GC (Normal)
[gc,start     ] GC(0) Pause Young (Normal) (G1 Evacuation Pause)
[gc,task      ] GC(0) Using 8 workers of 8 for evacuation
[gc,phases    ] GC(0)   Pre Evacuate Collection Set: 0.1ms
[gc,phases    ] GC(0)     Prepare TLABs: 0.0ms
[gc,phases    ] GC(0)     Choose Collection Set: 0.0ms
[gc,phases    ] GC(0)   Evacuate Collection Set: 15.2ms
[gc,phases    ] GC(0)     Ext Root Scan: 1.2ms
[gc,phases    ] GC(0)     Update RS: 0.8ms
[gc,phases    ] GC(0)     Scan RS: 0.5ms
[gc,phases    ] GC(0)     Code Roots: 0.3ms
[gc,phases    ] GC(0)     Object Copy: 12.1ms
[gc,phases    ] GC(0)     Termination: 0.2ms
[gc,phases    ] GC(0)   Post Evacuate Collection Set: 2.5ms
[gc,phases    ] GC(0)     Code Roots Fixup: 0.0ms
[gc,phases    ] GC(0)     Clear Card Table: 0.8ms
[gc,phases    ] GC(0)     Reference Processing: 0.5ms
[gc,phases    ] GC(0)     Merge Per-Thread State: 0.1ms
[gc,phases    ] GC(0)     Free Collection Set: 0.3ms
[gc,phases    ] GC(0)   Other: 0.5ms
[gc           ] GC(0) Pause Young (Normal) 512M->128M(8192M) 18.5ms

# Concurrent Cycle
[gc           ] GC(1) Concurrent Cycle
[gc,marking   ] GC(1) Concurrent Clear Claimed Marks
[gc,marking   ] GC(1) Concurrent Scan Root Regions
[gc,marking   ] GC(1) Concurrent Mark (0.150s)
[gc,marking   ] GC(1) Pause Remark 4096M->4096M(8192M) 25.3ms
[gc,marking   ] GC(1) Concurrent Rebuild Remembered Sets
[gc,marking   ] GC(1) Pause Cleanup 4100M->4100M(8192M) 1.2ms
[gc,marking   ] GC(1) Concurrent Cleanup for Next Mark
[gc           ] GC(1) Concurrent Cycle 1250.5ms

# Mixed GC
[gc,start     ] GC(2) Pause Young (Mixed) (G1 Evacuation Pause)
[gc,ergo,cset ] GC(2) Finish adding old regions to CSet (old CSet region num reached max). old 128 regions, max 128 regions
[gc           ] GC(2) Pause Young (Mixed) 4096M->3072M(8192M) 35.2ms
```

---

**文档版本**: v1.0
**验证日期**: 基于OpenJDK 11源码
**验证条件**: -Xms8G -Xmx8G -XX:+UseG1GC
