# G1 GC 暂停阶段关键操作源码级验证

> 基于OpenJDK 11源码深度验证，8GB堆配置

## 1. STW暂停类型与入口

### 1.1 GC暂停的VM Operation

```cpp
// 源码位置: vm_operations_g1.hpp:34-89

// G1相关的VM操作类型:
//   - VM_G1CollectForAllocation  : Young/Mixed GC暂停
//   - VM_G1CollectFull           : Full GC暂停  
//   - VM_CGC_Operation           : 并发GC的STW操作(Remark/Cleanup)

// Young/Mixed GC操作
class VM_G1CollectForAllocation: public VM_CollectForAllocation {
private:
  bool      _pause_succeeded;
  bool      _should_initiate_conc_mark;
  bool      _should_retry_gc;
  double    _target_pause_time_ms;
  uint      _old_marking_cycles_completed_before;
  
public:
  VM_G1CollectForAllocation(size_t         word_size,
                            uint           gc_count_before,
                            GCCause::Cause gc_cause,
                            bool           should_initiate_conc_mark,
                            double         target_pause_time_ms);
                            
  virtual VMOp_Type type() const { return VMOp_G1CollectForAllocation; }
  virtual void doit();            // 执行GC
  virtual bool doit_prologue();   // 前置检查
  virtual void doit_epilogue();   // 后置处理
};

// Full GC操作
class VM_G1CollectFull: public VM_GC_Operation {
public:
  VM_G1CollectFull(uint gc_count_before,
                   uint full_gc_count_before,
                   GCCause::Cause cause);
                   
  virtual VMOp_Type type() const { return VMOp_G1CollectFull; }
  virtual void doit();
};

// 并发GC的STW操作(Remark/Cleanup)
class VM_CGC_Operation: public VM_Operation {
  VoidClosure* _cl;
  const char*  _printGCMessage;
  uint         _gc_id;
  
public:
  VM_CGC_Operation(VoidClosure* cl, const char *printGCMsg);
  virtual VMOp_Type type() const { return VMOp_CGC_Operation; }
  virtual void doit();
};
```

### 1.2 Safepoint同步机制

```cpp
// VMThread执行GC操作
void VMThread::execute(VM_Operation* op) {
  // 1. 请求safepoint
  SafepointSynchronize::begin();
  
  // 2. 所有Java线程停止在safepoint
  
  // 3. 执行VM操作
  op->evaluate();
  
  // 4. 结束safepoint
  SafepointSynchronize::end();
}
```

## 2. Young GC暂停详细操作

### 2.1 GC Prologue

```cpp
// 源码位置: g1CollectedHeap.cpp:1633-1680
void G1CollectedHeap::gc_prologue(bool full) {
  // 记录开始时间
  _gc_timer_stw->register_gc_start();
  
  // GC增量集合计数器
  increment_total_collections(full);
  
  // 暂停JIT编译
  CodeCache::gc_prologue();
  
  // JVMTI事件
  JvmtiExport::gc_prologue();
  
  // 派生指针表处理
  #if COMPILER2_OR_JVMCI
  DerivedPointerTable::clear();
  #endif
  
  // 打印堆状态
  if (PrintHeapAtGC) {
    print_heap_before_gc();
  }
}
```

### 2.2 Collection Set最终确定

```cpp
// 源码位置: g1CollectionSet.cpp:356-398
double G1CollectionSet::finalize_young_part(double target_pause_time_ms, 
                                             G1SurvivorRegions* survivors) {
  double young_start_time_sec = os::elapsedTime();
  
  // 完成增量构建
  finalize_incremental_building();
  
  // 计算基础时间预算
  size_t pending_cards = _policy->pending_cards();
  double base_time_ms = _policy->predict_base_elapsed_time_ms(pending_cards);
  double time_remaining_ms = MAX2(target_pause_time_ms - base_time_ms, 0.0);
  
  log_trace(gc, ergo, cset)("Start choosing CSet. pending cards: " SIZE_FORMAT 
                            " predicted base time: %1.2fms remaining time: %1.2fms "
                            "target pause time: %1.2fms",
                            pending_cards, base_time_ms, time_remaining_ms, 
                            target_pause_time_ms);
  
  // 获取Eden和Survivor区域数量
  uint survivor_region_length = survivors->length();
  uint eden_region_length = _g1h->eden_regions_count();
  init_region_lengths(eden_region_length, survivor_region_length);
  
  // 验证Young CSet索引
  verify_young_cset_indices();
  
  // Survivor转换为Eden (下次GC)
  survivors->convert_to_eden();
  
  // 更新统计
  _bytes_used_before = _inc_bytes_used_before;
  time_remaining_ms = MAX2(time_remaining_ms - _inc_predicted_elapsed_time_ms, 0.0);
  
  log_trace(gc, ergo, cset)("Add young regions to CSet. eden: %u regions, "
                            "survivors: %u regions, predicted young region time: %1.2fms, "
                            "target pause time: %1.2fms",
                            eden_region_length, survivor_region_length, 
                            _inc_predicted_elapsed_time_ms, target_pause_time_ms);
  
  // 记录RSets长度
  set_recorded_rs_lengths(_inc_recorded_rs_lengths);
  
  return time_remaining_ms;
}
```

### 2.3 GC分配区域初始化

```cpp
// 源码位置: g1Allocator.cpp
void G1Allocator::init_gc_alloc_regions(EvacuationInfo& evacuation_info) {
  // 初始化Survivor分配区域
  _survivor_gc_alloc_region.init();
  
  // 初始化Old分配区域
  _old_gc_alloc_region.init();
  
  // 记录evacuation信息
  evacuation_info.set_allocation_regions(_survivor_gc_alloc_region.count() + 
                                          _old_gc_alloc_region.count());
}
```

### 2.4 并行Evacuation详解

#### 2.4.1 G1ParScanThreadState初始化

```cpp
// 源码位置: g1ParScanThreadState.cpp:40-90
G1ParScanThreadState::G1ParScanThreadState(G1CollectedHeap* g1h, 
                                           uint worker_id,
                                           size_t young_cset_length)
    : _g1h(g1h),
      _refs(g1h->task_queue(worker_id)),
      _dcq(&g1h->dirty_card_queue_set()),
      _ct(g1h->card_table()),
      _closures(NULL),
      _plab_allocator(NULL),
      _age_table(false),
      _worker_id(worker_id),
      _scanner(g1h, this),
      _old_gen_is_full(false) {
  
  // 初始化PLAB分配器
  _plab_allocator = new G1PLABAllocator(g1h);
  
  // 初始化存活words数组
  _surviving_young_words_base = NEW_C_HEAP_ARRAY(size_t, young_cset_length + 1, mtGC);
  memset(_surviving_young_words_base, 0, (young_cset_length + 1) * sizeof(size_t));
  _surviving_young_words = _surviving_young_words_base + 1;
  
  // 初始化evacuation closures
  _closures = G1EvacuationRootClosures::create_root_closures(this, g1h);
  
  // 初始化tenuring阈值
  _tenuring_threshold = g1h->g1_policy()->tenuring_threshold();
  
  // 初始化Age表
  _age_table.clear();
}
```

#### 2.4.2 Root扫描详解

```cpp
// 源码位置: g1RootProcessor.cpp:120-200
void G1RootProcessor::process_java_roots(G1RootClosures* closures,
                                          G1GCPhaseTimes* phase_times,
                                          uint worker_i) {
  // Thread Roots
  {
    G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ThreadRoots, worker_i);
    Threads::possibly_parallel_oops_do(closures->strong_oops(), 
                                       closures->thread_roots());
  }
  
  // Universe Roots
  {
    G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::UniverseRoots, worker_i);
    if (!_process_strong_tasks.is_task_claimed(G1RP_PS_Universe_oops_do)) {
      Universe::oops_do(closures->strong_oops());
    }
  }
  
  // JNI Handles
  {
    G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::JNIRoots, worker_i);
    if (!_process_strong_tasks.is_task_claimed(G1RP_PS_JNIHandles_oops_do)) {
      JNIHandles::oops_do(closures->strong_oops());
    }
  }
  
  // ObjectSynchronizer (monitors)
  {
    G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ObjectSynchronizerRoots, worker_i);
    if (!_process_strong_tasks.is_task_claimed(G1RP_PS_ObjectSynchronizer_oops_do)) {
      ObjectSynchronizer::oops_do(closures->strong_oops());
    }
  }
  
  // Management (MXBeans)
  {
    G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ManagementRoots, worker_i);
    if (!_process_strong_tasks.is_task_claimed(G1RP_PS_Management_oops_do)) {
      Management::oops_do(closures->strong_oops());
    }
  }
  
  // SystemDictionary
  {
    G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::SystemDictionaryRoots, worker_i);
    if (!_process_strong_tasks.is_task_claimed(G1RP_PS_SystemDictionary_oops_do)) {
      SystemDictionary::oops_do(closures->strong_oops());
    }
  }
  
  // ClassLoaderDataGraph
  {
    G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::CLDGRoots, worker_i);
    if (!_process_strong_tasks.is_task_claimed(G1RP_PS_ClassLoaderDataGraph_oops_do)) {
      ClassLoaderDataGraph::roots_cld_do(closures->strong_clds(), closures->weak_clds());
    }
  }
  
  // JVMTI
  {
    G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::JVMTIRoots, worker_i);
    if (!_process_strong_tasks.is_task_claimed(G1RP_PS_jvmti_oops_do)) {
      JvmtiExport::oops_do(closures->strong_oops());
    }
  }
  
  // CodeCache (nmethods)
  {
    G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::CodeCacheRoots, worker_i);
    if (!_process_strong_tasks.is_task_claimed(G1RP_PS_CodeCache_oops_do)) {
      CodeCache::blobs_do(closures->strong_codeblobs());
    }
  }
  
  // AOT (Ahead-of-Time compiled code)
  #if INCLUDE_AOT
  {
    G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::AOTCodeRoots, worker_i);
    if (UseAOT && !_process_strong_tasks.is_task_claimed(G1RP_PS_aot_oops_do)) {
      AOTLoader::oops_do(closures->strong_oops());
    }
  }
  #endif
}
```

#### 2.4.3 SATB Buffer处理

```cpp
// 源码位置: g1RootProcessor.cpp
void G1RootProcessor::process_vm_roots(G1RootClosures* closures,
                                        G1GCPhaseTimes* phase_times,
                                        uint worker_i) {
  // SATB Buffer过滤
  {
    G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::SATBFiltering, worker_i);
    if (!_process_strong_tasks.is_task_claimed(G1RP_PS_filter_satb_buffers) &&
        closures->trace_metadata()) {
      // 处理SATB队列中的引用
      G1BarrierSet::satb_mark_queue_set().filter_completed_buffers(closures->strong_oops());
    }
  }
}
```

#### 2.4.4 RemSet扫描

```cpp
// 源码位置: g1RemSet.cpp:400-546
void G1RemSet::scan_rem_set(G1ParScanThreadState* pss, uint worker_i) {
  G1ScanRSForRegionClosure scan_cl(_scan_state, pss, worker_i);
  
  // 获取待扫描的region迭代器
  G1HeapRegionClaimer claimer(n_workers);
  
  // 遍历所有脏region的RemSet
  _g1h->heap_region_par_iterate_from_start(&scan_cl, &claimer);
  
  // 记录扫描统计
  _scan_state->record_scan_rs_time(scan_cl.scan_time_ns());
}

void G1RemSet::update_rem_set(G1ParScanThreadState* pss, uint worker_i) {
  // 处理dirty card queue
  G1RefineCardConcurrentlyClosure refine_cl;
  
  // 从dirty card queue set获取buffer
  DirtyCardQueueSet& dcqs = G1BarrierSet::dirty_card_queue_set();
  
  // 处理每个dirty card
  while (dcqs.apply_closure_to_completed_buffer(&refine_cl, worker_i)) {
    // 继续处理
  }
  
  // 处理Hot Card Cache
  if (G1HotCardCache::default_use_cache()) {
    G1EvacPhaseWithTrimTimeTracker timer(pss, _scan_state->trim_ticks());
    _hot_card_cache->drain(worker_i, pss);
  }
}
```

### 2.5 对象复制与Work Stealing

#### 2.5.1 Work Stealing机制

```cpp
// 源码位置: g1CollectedHeap.hpp:1432-1462
class G1ParEvacuateFollowersClosure : public VoidClosure {
  G1CollectedHeap*        _g1h;
  G1ParScanThreadState*   _par_scan_state;
  RefToScanQueueSet*      _queues;
  ParallelTaskTerminator* _terminator;
  
  double _start_term;
  double _term_time;
  size_t _term_attempts;

public:
  void do_void() {
    G1ParScanThreadState* pss = par_scan_state();
    RefToScanQueue* refs = pss->refs();
    
    do {
      // 1. 处理本地队列
      while (!refs->is_empty()) {
        StarTask ref = refs->pop();
        pss->process_reference(ref);
        pss->trim_queue_partially();
      }
      
      // 2. 尝试从其他线程窃取任务
    } while (offer_termination());
  }

private:
  bool offer_termination() {
    _start_term = os::elapsedTime();
    
    // 尝试终止，如果有任务可窃取则继续工作
    bool res = _terminator->offer_termination();
    
    if (res) {
      _term_time += os::elapsedTime() - _start_term;
      _term_attempts++;
    }
    return res;
  }
};
```

#### 2.5.2 PLAB分配

```cpp
// 源码位置: g1PLABAllocator.cpp
HeapWord* G1PLABAllocator::plab_allocate(InCSetState dest, size_t word_sz) {
  G1PLAB* alloc_buf = alloc_buffer(dest);
  
  if (alloc_buf->words_remaining() >= word_sz) {
    HeapWord* obj = alloc_buf->allocate(word_sz);
    assert(obj != NULL, "allocation should succeed");
    return obj;
  }
  return NULL;
}

HeapWord* G1PLABAllocator::allocate_direct_or_new_plab(InCSetState dest,
                                                       size_t word_sz,
                                                       bool* plab_refill_failed) {
  // 尝试分配新PLAB
  size_t plab_word_size = _g1h->desired_plab_sz(dest);
  
  if (plab_word_size >= word_sz) {
    // 分配新PLAB
    HeapWord* buf = _g1h->alloc_buffer_stats(dest)->allocate(plab_word_size);
    if (buf != NULL) {
      G1PLAB* alloc_buf = alloc_buffer(dest);
      alloc_buf->retire();
      alloc_buf->set_buf(buf, plab_word_size);
      return alloc_buf->allocate(word_sz);
    }
    *plab_refill_failed = true;
  }
  
  // PLAB分配失败，直接分配
  return _g1h->par_allocate_during_gc(dest, word_sz);
}
```

### 2.6 引用处理

```cpp
// 源码位置: g1CollectedHeap.cpp:3700-3800
void G1CollectedHeap::process_discovered_references(G1ParScanThreadStateSet* per_thread_states) {
  double ref_proc_start = os::elapsedTime();
  
  ReferenceProcessor* rp = _ref_processor_stw;
  
  // 设置引用处理策略
  ReferenceProcessorIsAliveMutator is_alive_mutator(rp, &_stw_is_alive_closure);
  ReferenceProcessorMTDiscoveryMutator mt_discovery_mutator(rp, false);
  
  // 创建引用处理任务
  G1STWRefProcTaskExecutor par_task_executor(this, per_thread_states, 
                                              workers(), _task_queues);
  
  // 处理软引用
  {
    GCTraceTime(Debug, gc, phases, ref) trace("Soft Reference", _gc_timer_stw);
    rp->process_discovered_references(&_stw_is_alive_closure,
                                      &_stw_keep_alive_closure,
                                      &_stw_drain_closure,
                                      &par_task_executor,
                                      _gc_timer_stw);
  }
  
  // 处理弱引用
  {
    GCTraceTime(Debug, gc, phases, ref) trace("Weak Reference", _gc_timer_stw);
    rp->process_weak_references(&_stw_is_alive_closure,
                                &_stw_keep_alive_closure,
                                &_stw_drain_closure,
                                &par_task_executor,
                                _gc_timer_stw);
  }
  
  // 处理Final引用
  {
    GCTraceTime(Debug, gc, phases, ref) trace("Final Reference", _gc_timer_stw);
    rp->process_final_references(&_stw_is_alive_closure,
                                 &_stw_keep_alive_closure,
                                 &_stw_drain_closure,
                                 &par_task_executor,
                                 _gc_timer_stw);
  }
  
  // 处理Phantom引用
  {
    GCTraceTime(Debug, gc, phases, ref) trace("Phantom Reference", _gc_timer_stw);
    rp->process_phantom_references(&_stw_is_alive_closure,
                                   &_stw_keep_alive_closure,
                                   &par_task_executor,
                                   _gc_timer_stw);
  }
  
  // 处理JNI弱引用
  {
    GCTraceTime(Debug, gc, phases, ref) trace("JNI Weak", _gc_timer_stw);
    rp->process_jni_weak_references(&_stw_is_alive_closure,
                                    &_stw_keep_alive_closure,
                                    _gc_timer_stw);
  }
  
  double ref_proc_time = os::elapsedTime() - ref_proc_start;
  g1_policy()->phase_times()->record_ref_proc_time(ref_proc_time * 1000.0);
}
```

### 2.7 GC Epilogue

```cpp
// 源码位置: g1CollectedHeap.cpp:1682-1720
void G1CollectedHeap::gc_epilogue(bool full) {
  // JVMTI事件
  JvmtiExport::gc_epilogue();
  
  // 恢复JIT编译
  CodeCache::gc_epilogue();
  
  // 派生指针表更新
  #if COMPILER2_OR_JVMCI
  DerivedPointerTable::update_pointers();
  #endif
  
  // 记录结束时间
  _gc_timer_stw->register_gc_end();
  
  // 打印堆状态
  if (PrintHeapAtGC) {
    print_heap_after_gc();
  }
  
  // 重置GC原因
  _gc_cause = GCCause::_no_gc;
}
```

## 3. Remark暂停详细操作

### 3.1 Remark触发

```cpp
// 源码位置: g1ConcurrentMarkThread.cpp:335-344
// Pause Remark.
log_info(gc, marking)("%s (%.3fs, %.3fs) %.3fms",
                      cm_title,
                      TimeHelper::counter_to_seconds(mark_start),
                      TimeHelper::counter_to_seconds(mark_end),
                      TimeHelper::counter_to_millis(mark_end - mark_start));
mark_manager.set_phase(G1ConcurrentPhase::REMARK, false);

// 创建Remark Closure
CMRemark cl(_cm);

// 在VMThread中执行Remark
VM_CGC_Operation op(&cl, "Pause Remark");
VMThread::execute(&op);
```

### 3.2 Remark核心操作

```cpp
// 源码位置: g1ConcurrentMark.cpp:1163-1270
void G1ConcurrentMark::remark() {
  assert_at_safepoint_on_vm_thread();
  
  if (has_aborted()) return;
  
  g1p->record_concurrent_mark_remark_start();
  double start = os::elapsedTime();
  
  // 验证
  verify_during_pause(G1HeapVerifier::G1VerifyRemark, 
                      VerifyOption_G1UsePrevMarking, "Remark before");
  
  // ========== 核心操作1: 最终标记 ==========
  {
    GCTraceTime(Debug, gc, phases) debug("Finalize Marking", _gc_timer_cm);
    finalize_marking();
  }
  
  bool const mark_finished = !has_overflown();
  
  if (mark_finished) {
    // ========== 核心操作2: 弱引用处理 ==========
    weak_refs_work(false /* clear_all_soft_refs */);
    
    // ========== 核心操作3: 禁用SATB ==========
    SATBMarkQueueSet& satb_mq_set = G1BarrierSet::satb_mark_queue_set();
    satb_mq_set.set_active_all_threads(false, /* new active value */
                                       true /* expected_active */);
    
    // ========== 核心操作4: 刷新Task缓存 ==========
    {
      GCTraceTime(Debug, gc, phases) debug("Flush Task Caches", _gc_timer_cm);
      flush_all_task_caches();
    }
    
    // ========== 核心操作5: 交换位图 ==========
    swap_mark_bitmaps();
    
    // ========== 核心操作6: 更新RemSet跟踪 ==========
    {
      GCTraceTime(Debug, gc, phases) debug("Update Remembered Set Tracking Before Rebuild", 
                                           _gc_timer_cm);
      
      uint const workers_by_capacity = (_g1h->num_regions() + 
          G1UpdateRemSetTrackingBeforeRebuildTask::RegionsPerThread - 1) /
          G1UpdateRemSetTrackingBeforeRebuildTask::RegionsPerThread;
      uint const num_workers = MIN2(_g1h->workers()->active_workers(), workers_by_capacity);
      
      G1UpdateRemSetTrackingBeforeRebuildTask cl(_g1h, this, num_workers);
      _g1h->workers()->run_task(&cl, num_workers);
    }
    
    // ========== 核心操作7: 回收空Region ==========
    {
      GCTraceTime(Debug, gc, phases) debug("Reclaim Empty Regions", _gc_timer_cm);
      reclaim_empty_regions();
    }
    
    // ========== 核心操作8: 类卸载 ==========
    if (ClassUnloadingWithConcurrentMark) {
      GCTraceTime(Debug, gc, phases) debug("Purge Metaspace", _gc_timer_cm);
      
      ClassLoaderDataGraph::purge();
      DEBUG_ONLY(MetaspaceUtils::verify();)
    }
    
    // 计算下次标记时间
    compute_new_sizes();
    
    // 清理并发标记task缓存
    {
      GCTraceTime(Debug, gc, phases) debug("Purge Code Root Memories", _gc_timer_cm);
      clear_inactive_tasks_caches();
    }
    
    // 更新并发标记完成时间
    update_accum_task_vtime_statistics();
  }
  
  g1p->record_concurrent_mark_remark_end();
}
```

### 3.3 最终标记实现

```cpp
// 源码位置: g1ConcurrentMark.cpp:1120-1160
void G1ConcurrentMark::finalize_marking() {
  ResourceMark rm;
  HandleMark hm;
  
  _g1h->ensure_parsability(false);
  
  // 处理所有SATB buffer
  G1CMDrainMarkingStackClosure drain_cl(this, task(0), true);
  
  do {
    // 处理全局SATB队列
    SATBMarkQueueSet& satb_mq_set = G1BarrierSet::satb_mark_queue_set();
    satb_mq_set.drain_completed_buffers(&drain_cl);
    
    // 处理全局Mark Stack
    G1CMTask* task = task(0);
    while (task->has_work()) {
      task->do_marking_step(1000000000.0 /* ms */, 
                           true /* do_termination */,
                           false /* is_serial */);
    }
    
  } while (!_mark_stack.is_empty());
  
  // 验证所有工作完成
  assert(_mark_stack.is_empty(), "Mark stack should be empty");
}
```

## 4. Cleanup暂停详细操作

### 4.1 Cleanup核心操作

```cpp
// 源码位置: g1ConcurrentMark.cpp:1380-1421
void G1ConcurrentMark::cleanup() {
  assert_at_safepoint_on_vm_thread();
  
  if (has_aborted()) return;
  
  g1p->record_concurrent_mark_cleanup_start();
  double start = os::elapsedTime();
  
  // 验证
  verify_during_pause(G1HeapVerifier::G1VerifyCleanup, 
                      VerifyOption_G1UsePrevMarking, "Cleanup before");
  
  // ========== 核心操作1: 更新RemSet跟踪状态 ==========
  {
    GCTraceTime(Debug, gc, phases) debug("Update Remembered Set Tracking After Rebuild", 
                                         _gc_timer_cm);
    G1UpdateRemSetTrackingAfterRebuild cl(_g1h);
    _g1h->heap_region_iterate(&cl);
  }
  
  // 打印Region存活信息
  if (log_is_enabled(Trace, gc, liveness)) {
    G1PrintRegionLivenessInfoClosure cl("Post-Cleanup");
    _g1h->heap_region_iterate(&cl);
  }
  
  // 验证
  verify_during_pause(G1HeapVerifier::G1VerifyCleanup, 
                      VerifyOption_G1UsePrevMarking, "Cleanup after");
  
  // ========== 核心操作2: 增加collection计数 ==========
  // 这使得与Cleanup竞争的任何collection pause都会等待
  _g1h->increment_total_collections();
  
  // 记录统计
  double recent_cleanup_time = (os::elapsedTime() - start);
  _total_cleanup_time += recent_cleanup_time;
  _cleanup_times.add(recent_cleanup_time);
  
  // ========== 核心操作3: 最终化Cleanup ==========
  {
    GCTraceTime(Debug, gc, phases) debug("Finalize Concurrent Mark Cleanup", _gc_timer_cm);
    _g1h->g1_policy()->record_concurrent_mark_cleanup_end();
  }
}
```

## 5. Full GC暂停详细操作

### 5.1 Phase 1: Mark Live Objects

```cpp
// 源码位置: g1FullGCMarkTask.cpp
void G1FullGCMarkTask::work(uint worker_id) {
  Ticks start = Ticks::now();
  
  G1FullGCMarker* marker = _collector->marker(worker_id);
  
  // 处理Root
  if (ClassUnloadingWithConcurrentMark) {
    G1FullGCClassUnloadingMarkTask mark_task(this, _collector);
    _root_processor.process_all_roots_no_string_table(
        marker->mark_closure(),
        &mark_task.cld_closure(),
        &mark_task.code_closure());
  } else {
    _root_processor.process_all_roots(
        marker->mark_closure(),
        marker->cld_closure(),
        marker->code_closure());
  }
  
  // 标记传递闭包
  marker->complete_marking(_collector->oop_queue_set(),
                           _collector->array_queue_set(),
                           &_terminator);
  
  log_task("Mark", worker_id, start);
}
```

### 5.2 Phase 2: Prepare Compaction

```cpp
// 源码位置: g1FullGCPrepareTask.cpp
void G1FullGCPrepareTask::work(uint worker_id) {
  Ticks start = Ticks::now();
  
  G1FullGCCompactionPoint* cp = _collector->compaction_point(worker_id);
  G1CalculatePointersClosure cl(_collector->mark_bitmap(), cp);
  
  // 遍历所有region，计算对象新地址
  _collector->heap()->heap_region_par_iterate_from_start(&cl, &_claimer);
  
  // 更新region sets
  cl.update_sets();
  
  // 如果有释放的region
  if (cl.freed_regions()) {
    _has_freed_regions = true;
  }
  
  log_task("Prepare", worker_id, start);
}

// 计算对象新地址
void G1FullGCPrepareTask::G1CalculatePointersClosure::prepare_for_compaction(HeapRegion* hr) {
  if (hr->is_humongous()) {
    // Humongous对象特殊处理
    oop obj = oop(hr->bottom());
    if (_bitmap->is_marked(obj)) {
      // 存活，保持不动
      if (hr->is_starts_humongous()) {
        _cp->add_humongous(hr);
      }
    } else {
      // 死亡，释放
      free_humongous_region(hr);
    }
  } else if (hr->is_old() || hr->is_archive()) {
    // 常规region
    prepare_for_compaction_work(_cp, hr);
  }
}
```

### 5.3 Phase 3: Adjust Pointers

```cpp
// 源码位置: g1FullGCAdjustTask.cpp
void G1FullGCAdjustTask::work(uint worker_id) {
  Ticks start = Ticks::now();
  
  // 调整Root指针
  G1AdjustClosure adjust;
  _root_processor.process_all_roots(&adjust, &adjust, &adjust);
  
  // 调整堆中对象的指针
  G1AdjustRegionClosure blk(_collector->mark_bitmap(), &_adjust);
  _collector->heap()->heap_region_par_iterate_from_start(&blk, &_hrclaimer);
  
  // 调整String Dedup
  if (G1StringDedup::is_enabled()) {
    G1StringDedup::parallel_unlink(&_adjust_string_dedup, worker_id);
  }
  
  log_task("Adjust", worker_id, start);
}

// 调整单个对象的指针
template <class T>
void G1AdjustClosure::do_oop_work(T* p) {
  T heap_oop = RawAccess<>::oop_load(p);
  if (CompressedOops::is_null(heap_oop)) {
    return;
  }
  
  oop obj = CompressedOops::decode_not_null(heap_oop);
  
  // 获取新地址
  oop forwardee = obj->forwardee();
  if (forwardee != NULL) {
    // 更新指针
    RawAccess<IS_NOT_NULL>::oop_store(p, forwardee);
  }
}
```

### 5.4 Phase 4: Compact

```cpp
// 源码位置: g1FullGCCompactTask.cpp
void G1FullGCCompactTask::work(uint worker_id) {
  Ticks start = Ticks::now();
  
  G1FullGCCompactionPoint* cp = _collector->compaction_point(worker_id);
  
  // 遍历压缩点队列
  for (GrowableArrayIterator<HeapRegion*> it = cp->regions()->begin();
       it != cp->regions()->end();
       ++it) {
    HeapRegion* hr = *it;
    
    // 压缩该region
    G1CompactRegionClosure compact(_collector->mark_bitmap());
    hr->apply_to_marked_objects(_collector->mark_bitmap(), &compact);
    
    // 更新region的top
    hr->set_top(hr->compaction_top());
  }
  
  log_task("Compact", worker_id, start);
}

// 移动单个对象
size_t G1FullGCCompactTask::G1CompactRegionClosure::apply(oop obj) {
  size_t size = obj->size();
  
  // 获取目标地址
  HeapWord* destination = (HeapWord*)obj->forwardee();
  
  if (destination != (HeapWord*)obj) {
    // 移动对象
    Copy::aligned_conjoint_words((HeapWord*)obj, destination, size);
  }
  
  // 恢复对象头
  oop(destination)->init_mark_raw();
  
  // 清除位图标记
  _bitmap->clear(obj);
  
  return size;
}
```

## 6. Evacuation失败处理

### 6.1 检测和处理

```cpp
// 源码位置: g1ParScanThreadState.cpp:165-210
oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markOop m) {
  // 尝试自转发（forward to self）
  oop forward_ptr = old->forward_to_atomic(old, memory_order_relaxed);
  
  if (forward_ptr == NULL) {
    // 成功标记为自转发
    
    // 保存原始mark word
    _g1h->preserve_mark_during_evac_failure(_worker_id, old, m);
    
    // 记录失败信息
    _g1h->evacuation_failed_info_array()[_worker_id].register_copy_failure(old->size());
    
    // 标记为存活但失败
    if (_g1h->collector_state()->in_initial_mark_gc()) {
      _g1h->concurrent_mark()->mark_in_next_bitmap(_worker_id, old);
    }
    
    return old;
  } else {
    // 其他线程已处理
    return forward_ptr;
  }
}
```

### 6.2 失败后恢复

```cpp
// 源码位置: g1CollectedHeap.cpp:4150-4200
void G1CollectedHeap::restore_after_evac_failure() {
  // 遍历所有evacuation失败的region
  RemoveSelfForwardPtrObjClosure rspc(this,
                                      concurrent_mark()->next_mark_bitmap(),
                                      workers()->active_workers());
  
  // 并行处理
  workers()->run_task(&rspc);
  
  // 恢复preserved marks
  _preserved_marks_set.restore(workers());
}
```

## 7. 暂停时间预测

### 7.1 时间预测模型

```cpp
// 源码位置: g1Policy.cpp:400-450
double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards) const {
  return
    predict_young_other_time_ms(young_list_target_length()) +
    predict_constant_other_time_ms() +
    predict_update_rs_time_ms(pending_cards);
}

double G1Policy::predict_region_elapsed_time_ms(HeapRegion* hr) const {
  // 预测复制时间
  size_t rs_length = hr->rem_set()->occupied();
  size_t live_bytes = get_live_bytes(hr);
  
  return predict_rs_scan_time_ms(rs_length) +
         predict_object_copy_time_ms(live_bytes);
}

double G1Policy::predict_rs_scan_time_ms(size_t rs_length) const {
  return rs_length * _cost_per_remset_card_ms;
}

double G1Policy::predict_object_copy_time_ms(size_t bytes) const {
  return bytes * _cost_per_byte_ms;
}
```

## 8. 总结

### 8.1 各暂停阶段操作对照表

| 暂停类型 | 主要操作 | 典型耗时 |
|---------|---------|---------|
| Young GC | Root扫描、RemSet扫描、对象复制、引用处理 | 10-50ms |
| Mixed GC | 同Young GC + Old Region处理 | 20-100ms |
| Remark | 最终标记、SATB处理、位图交换 | 10-30ms |
| Cleanup | RemSet更新、空Region回收 | 5-15ms |
| Full GC | Mark、Prepare、Adjust、Compact | 100ms-数秒 |

### 8.2 8GB堆暂停操作统计

```
Young GC暂停操作分布 (典型):
┌────────────────────────────────────────────────────────┐
│ Root Scan        ████████████████        25-30%       │
│ RemSet Scan      ████████████            15-20%       │
│ Object Copy      ████████████████████████ 40-50%      │
│ Reference Proc   ████████                 10-15%      │
│ Other            ████                      5-10%      │
└────────────────────────────────────────────────────────┘

Full GC暂停操作分布 (典型):
┌────────────────────────────────────────────────────────┐
│ Phase 1: Mark    ████████████████████████ 30-40%      │
│ Phase 2: Prepare ████████                 10-15%      │
│ Phase 3: Adjust  ████████████████         20-25%      │
│ Phase 4: Compact ████████████████████     25-35%      │
└────────────────────────────────────────────────────────┘
```
