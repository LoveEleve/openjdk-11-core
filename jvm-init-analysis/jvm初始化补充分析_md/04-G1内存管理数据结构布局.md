# G1å†…å­˜ç®¡ç†æ•°æ®ç»“æ„å¸ƒå±€æ·±åº¦åˆ†æ

> **ğŸ”¥ å†…å­˜å¸ƒå±€è§†è§’**ï¼šæ·±å…¥G1åƒåœ¾æ”¶é›†å™¨çš„å†…å­˜ç®¡ç†æ•°æ®ç»“æ„ï¼Œåˆ†æ8GBå †é…ç½®ä¸‹çš„ç²¾ç¡®å†…å­˜å¸ƒå±€ã€æ•°æ®ç»“æ„å¯¹é½ã€ç¼“å­˜ä¼˜åŒ–ç­–ç•¥

---

## ğŸ¯ G1HeapRegionManageræ•°æ®ç»“æ„åˆ†æ

### ğŸ’» HeapRegionå¯¹è±¡çš„å†…å­˜å¸ƒå±€

```cpp
// ğŸ”¥ HeapRegionç±»çš„ç²¾ç¡®å†…å­˜å¸ƒå±€ï¼ˆ8GBå †é…ç½®ï¼‰
// æ–‡ä»¶ï¼šsrc/hotspot/share/gc/g1/heapRegion.hpp

class HeapRegion : public G1ContiguousSpace {
private:
    // ğŸ”¥ åŸºç¡€å­—æ®µï¼ˆåç§»0-63å­—èŠ‚ï¼‰
    size_t         _region_num;           // åç§»0:  Regionç¼–å· (8å­—èŠ‚)
    HeapWord*      _bottom;               // åç§»8:  Regionèµ·å§‹åœ°å€ (8å­—èŠ‚)  
    HeapWord*      _top;                  // åç§»16: å½“å‰åˆ†é…æŒ‡é’ˆ (8å­—èŠ‚)
    HeapWord*      _end;                  // åç§»24: Regionç»“æŸåœ°å€ (8å­—èŠ‚)
    
    // ğŸ”¥ GCç›¸å…³å­—æ®µï¼ˆåç§»32-95å­—èŠ‚ï¼‰
    G1BlockOffsetTable* _bot;             // åç§»32: BOTè¡¨æŒ‡é’ˆ (8å­—èŠ‚)
    CardTable*     _card_table;           // åç§»40: å¡è¡¨æŒ‡é’ˆ (8å­—èŠ‚)
    volatile size_t _live_bytes;          // åç§»48: å­˜æ´»å­—èŠ‚æ•° (8å­—èŠ‚)
    size_t         _gc_efficiency;        // åç§»56: GCæ•ˆç‡å€¼ (8å­—èŠ‚)
    
    // ğŸ”¥ å¹¶å‘æ ‡è®°å­—æ®µï¼ˆåç§»64-127å­—èŠ‚ï¼‰
    volatile bool  _marked_for_evacuation; // åç§»64: ç–æ•£æ ‡è®° (1å­—èŠ‚)
    bool           _evacuation_failed;    // åç§»65: ç–æ•£å¤±è´¥æ ‡è®° (1å­—èŠ‚)
    uint8_t        _young_index_in_cset;  // åç§»66: å¹´è½»ä»£é›†åˆç´¢å¼• (1å­—èŠ‚)
    uint8_t        _old_index_in_cset;    // åç§»67: è€å¹´ä»£é›†åˆç´¢å¼• (1å­—èŠ‚)
    
    HeapRegionType _type;                 // åç§»68: Regionç±»å‹ (4å­—èŠ‚)
    size_t         _predicted_elapsed_time_ms; // åç§»72: é¢„æµ‹GCæ—¶é—´ (8å­—èŠ‚)
    
    // ğŸ”¥ è®°å¿†é›†ç›¸å…³ï¼ˆåç§»80-143å­—èŠ‚ï¼‰
    HeapRegionRemSet* _rem_set;           // åç§»80: è®°å¿†é›†æŒ‡é’ˆ (8å­—èŠ‚)
    G1CardLiveData*   _card_live_data;    // åç§»88: å¡ç‰‡å­˜æ´»æ•°æ® (8å­—èŠ‚)
    
    // ğŸ”¥ ç¼“å­˜è¡Œå¯¹é½å¡«å……åˆ°128å­—èŠ‚
    char _padding[128 - 96];              // åç§»96: å¡«å……åˆ°ç¼“å­˜è¡Œè¾¹ç•Œ
};

// ğŸ”¥ 8GBå †çš„Regionåˆ†å¸ƒè®¡ç®—
// å †å¤§å°ï¼š8GB = 8,589,934,592 å­—èŠ‚
// Regionå¤§å°ï¼š2MB = 2,097,152 å­—èŠ‚  
// Regionæ•°é‡ï¼š8GB Ã· 2MB = 4,096 ä¸ªRegion
// HeapRegionå¯¹è±¡æ€»å†…å­˜ï¼š4,096 Ã— 128å­—èŠ‚ = 512KB
```

### ğŸ” Regionæ•°ç»„çš„å†…å­˜å¯¹é½ä¼˜åŒ–

```cpp
// ğŸ”¥ G1HeapRegionManagerä¸­çš„Regionæ•°ç»„å¸ƒå±€

class G1HeapRegionManager {
private:
    // ğŸ”¥ Regionæ•°ç»„ï¼ˆç¼“å­˜è¡Œå¯¹é½ï¼‰
    HeapRegion**   _regions;              // RegionæŒ‡é’ˆæ•°ç»„
    uint           _num_committed;        // å·²æäº¤çš„Regionæ•°é‡
    
    // ğŸ”¥ 8GBå †çš„Regionæ•°ç»„å†…å­˜è®¡ç®—
    // æŒ‡é’ˆæ•°ç»„å¤§å°ï¼š4,096 Ã— 8å­—èŠ‚ = 32KB
    // å¯¹é½åˆ°64å­—èŠ‚è¾¹ç•Œï¼Œå®é™…åˆ†é…ï¼š32KB + 64å­—èŠ‚ = 32,832å­—èŠ‚
    
public:
    void initialize_regions() {
        // ğŸ”¥ åˆ†é…å¯¹é½çš„RegionæŒ‡é’ˆæ•°ç»„
        size_t array_size = _max_regions * sizeof(HeapRegion*);
        size_t aligned_size = align_up(array_size, 64);  // ç¼“å­˜è¡Œå¯¹é½
        
        _regions = (HeapRegion**)os::malloc(aligned_size, mtGC);
        
        // ğŸ”¥ åˆå§‹åŒ–æ¯ä¸ªRegionå¯¹è±¡
        for (uint i = 0; i < _max_regions; i++) {
            HeapWord* region_start = _heap_bottom + (i * HeapRegion::GrainBytes);
            
            // ğŸ”¥ åˆ†é…128å­—èŠ‚å¯¹é½çš„HeapRegionå¯¹è±¡
            HeapRegion* region = new (std::align_val_t(128)) HeapRegion();
            
            // ğŸ”¥ åˆå§‹åŒ–Regionçš„å…³é”®å­—æ®µ
            region->_region_num = i;
            region->_bottom = region_start;
            region->_top = region_start;
            region->_end = region_start + HeapRegion::GrainWords;
            
            _regions[i] = region;
        }
    }
};
```

---

## ğŸ¯ G1CardTableæ•°æ®ç»“æ„åˆ†æ

### ğŸ’» å¡è¡¨çš„å†…å­˜å¸ƒå±€å’Œå¯¹é½

```cpp
// ğŸ”¥ G1CardTableçš„ç²¾ç¡®å†…å­˜å¸ƒå±€
// æ–‡ä»¶ï¼šsrc/hotspot/share/gc/g1/g1CardTable.hpp

class G1CardTable : public CardTable {
private:
    // ğŸ”¥ å¡è¡¨åŸºç¡€é…ç½®
    static const size_t card_size = 512;           // æ¯å¼ å¡è¦†ç›–512å­—èŠ‚
    static const size_t card_size_in_words = card_size / HeapWordSize; // 64ä¸ªHeapWord
    
    // ğŸ”¥ 8GBå †çš„å¡è¡¨è®¡ç®—
    // å †å¤§å°ï¼š8GB = 8,589,934,592 å­—èŠ‚
    // å¡ç‰‡æ•°é‡ï¼š8GB Ã· 512å­—èŠ‚ = 16,777,216 å¼ å¡ç‰‡
    // å¡è¡¨å¤§å°ï¼š16,777,216 Ã— 1å­—èŠ‚ = 16MB
    
    jbyte* _byte_map;                              // å¡è¡¨å­—èŠ‚æ•°ç»„
    size_t _byte_map_size;                         // å¡è¡¨å¤§å°
    
    // ğŸ”¥ å¡è¡¨çŠ¶æ€å€¼å®šä¹‰
    enum CardValues {
        clean_card                  = 0,           // å¹²å‡€å¡ç‰‡
        dirty_card                  = 1,           // è„å¡ç‰‡  
        precleaned_card            = 2,           // é¢„æ¸…ç†å¡ç‰‡
        claimed_card               = 3,           // å·²å£°æ˜å¡ç‰‡
        deferred_card              = 4,           // å»¶è¿Ÿå¤„ç†å¡ç‰‡
        young_gen_card             = 5,           // å¹´è½»ä»£å¡ç‰‡
        g1_young_gen_card          = 6            // G1å¹´è½»ä»£å¡ç‰‡
    };
    
public:
    void initialize_card_table() {
        // ğŸ”¥ è®¡ç®—å¡è¡¨æ‰€éœ€å†…å­˜
        size_t heap_size = 8ULL * 1024 * 1024 * 1024;  // 8GB
        _byte_map_size = heap_size / card_size;          // 16MB
        
        // ğŸ”¥ åˆ†é…é¡µé¢å¯¹é½çš„å¡è¡¨å†…å­˜
        size_t aligned_size = align_up(_byte_map_size, os::vm_page_size());
        _byte_map = (jbyte*)os::reserve_memory(aligned_size, NULL, os::vm_page_size());
        
        // ğŸ”¥ æäº¤ç‰©ç†å†…å­˜
        os::commit_memory(_byte_map, aligned_size, false);
        
        // ğŸ”¥ åˆå§‹åŒ–æ‰€æœ‰å¡ç‰‡ä¸ºå¹²å‡€çŠ¶æ€
        memset(_byte_map, clean_card, _byte_map_size);
    }
    
    // ğŸ”¥ å†…è”çš„å¡ç‰‡è®¿é—®å‡½æ•°ï¼ˆæ€§èƒ½å…³é”®ï¼‰
    inline jbyte* byte_for(const void* p) const {
        uintptr_t addr = (uintptr_t)p;
        uintptr_t card_index = addr >> 9;  // é™¤ä»¥512ï¼ˆå³ç§»9ä½ï¼‰
        return &_byte_map[card_index];
    }
    
    // ğŸ”¥ æ ‡è®°å¡ç‰‡ä¸ºè„ï¼ˆå†™å±éšœè°ƒç”¨ï¼‰
    inline void mark_card_dirty(const void* p) {
        *byte_for(p) = dirty_card;
    }
};
```

### ğŸ” å¡è¡¨çš„ç¼“å­˜ä¼˜åŒ–åˆ†æ

```cpp
// ğŸ”¥ å¡è¡¨è®¿é—®çš„ç¼“å­˜æ€§èƒ½ä¼˜åŒ–

class G1CardTableOptimized {
private:
    // ğŸ”¥ ç¼“å­˜è¡Œå¤§å°å¸¸é‡
    static const size_t cache_line_size = 64;
    static const size_t cards_per_cache_line = cache_line_size / sizeof(jbyte); // 64å¼ å¡ç‰‡/ç¼“å­˜è¡Œ
    
    // ğŸ”¥ æ‰¹é‡å¡ç‰‡å¤„ç†ä¼˜åŒ–
    void batch_mark_dirty_cards(void** addresses, size_t count) {
        // ğŸ”¥ æŒ‰ç¼“å­˜è¡Œåˆ†ç»„å¤„ç†å¡ç‰‡
        for (size_t i = 0; i < count; i += cards_per_cache_line) {
            
            // ğŸ”¥ é¢„å–ä¸‹ä¸€ä¸ªç¼“å­˜è¡Œ
            if (i + cards_per_cache_line < count) {
                __builtin_prefetch(byte_for(addresses[i + cards_per_cache_line]), 1, 3);
            }
            
            // ğŸ”¥ æ‰¹é‡å¤„ç†å½“å‰ç¼“å­˜è¡Œçš„å¡ç‰‡
            size_t batch_end = std::min(i + cards_per_cache_line, count);
            for (size_t j = i; j < batch_end; j++) {
                *byte_for(addresses[j]) = dirty_card;
            }
        }
    }
    
    // ğŸ”¥ SIMDä¼˜åŒ–çš„å¡ç‰‡æ¸…ç†
    void simd_clean_cards(jbyte* start, size_t count) {
        // ä½¿ç”¨AVX2æŒ‡ä»¤é›†æ‰¹é‡æ¸…ç†å¡ç‰‡
        __m256i clean_vector = _mm256_set1_epi8(clean_card);
        
        size_t simd_count = count & ~31;  // 32å­—èŠ‚å¯¹é½çš„æ•°é‡
        
        // ğŸ”¥ æ¯æ¬¡å¤„ç†32å¼ å¡ç‰‡
        for (size_t i = 0; i < simd_count; i += 32) {
            _mm256_store_si256((__m256i*)(start + i), clean_vector);
        }
        
        // ğŸ”¥ å¤„ç†å‰©ä½™çš„å¡ç‰‡
        for (size_t i = simd_count; i < count; i++) {
            start[i] = clean_card;
        }
    }
};
```

---

## ğŸ¯ G1BlockOffsetTableæ•°æ®ç»“æ„åˆ†æ

### ğŸ’» BOTè¡¨çš„å†…å­˜å¸ƒå±€

```cpp
// ğŸ”¥ G1BlockOffsetTableçš„ç²¾ç¡®å†…å­˜å¸ƒå±€
// æ–‡ä»¶ï¼šsrc/hotspot/share/gc/g1/g1BlockOffsetTable.hpp

class G1BlockOffsetTable {
private:
    // ğŸ”¥ BOTè¡¨åŸºç¡€é…ç½®
    static const size_t BOT_ENTRY_SIZE = 64;      // æ¯ä¸ªBOTæ¡ç›®è¦†ç›–64å­—èŠ‚
    static const size_t BOT_ENTRY_SHIFT = 6;      // log2(64) = 6
    
    // ğŸ”¥ 8GBå †çš„BOTè¡¨è®¡ç®—
    // å †å¤§å°ï¼š8GB = 8,589,934,592 å­—èŠ‚
    // BOTæ¡ç›®æ•°é‡ï¼š8GB Ã· 64å­—èŠ‚ = 134,217,728 ä¸ªæ¡ç›®
    // BOTè¡¨å¤§å°ï¼š134,217,728 Ã— 1å­—èŠ‚ = 128MB
    // ä½†å®é™…ä½¿ç”¨å‹ç¼©å­˜å‚¨ï¼Œæ¯ä¸ªRegionåªéœ€è¦32KB
    
    u_char* _offset_array;                         // BOTåç§»æ•°ç»„
    size_t  _array_size;                          // æ•°ç»„å¤§å°
    
    // ğŸ”¥ BOTæ¡ç›®å€¼çš„å«ä¹‰
    enum BOTConstants {
        BOT_N_POWERS = 8,                         // 2^8 = 256ä¸ªå¯èƒ½å€¼
        BOT_CARD_SIZE = 512,                      // ä¸å¡è¡¨å¯¹åº”
        BOT_MAX_OFFSET = BOT_CARD_SIZE * (BOT_N_POWERS - 1) // æœ€å¤§åç§»
    };
    
public:
    void initialize_bot_table() {
        // ğŸ”¥ è®¡ç®—BOTè¡¨æ‰€éœ€å†…å­˜ï¼ˆæŒ‰Regionåˆ†é…ï¼‰
        size_t regions_count = 4096;  // 8GB Ã· 2MB
        size_t entries_per_region = HeapRegion::GrainBytes / BOT_ENTRY_SIZE;  // 32768ä¸ªæ¡ç›®/Region
        
        _array_size = regions_count * entries_per_region;  // æ€»æ¡ç›®æ•°
        
        // ğŸ”¥ åˆ†é…å†…å­˜å¯¹é½çš„BOTæ•°ç»„
        size_t aligned_size = align_up(_array_size, os::vm_page_size());
        _offset_array = (u_char*)os::reserve_memory(aligned_size, NULL, os::vm_page_size());
        
        // ğŸ”¥ æäº¤ç‰©ç†å†…å­˜
        os::commit_memory(_offset_array, aligned_size, false);
        
        // ğŸ”¥ åˆå§‹åŒ–BOTæ¡ç›®
        memset(_offset_array, 0, _array_size);
    }
    
    // ğŸ”¥ å†…è”çš„BOTæŸ¥æ‰¾å‡½æ•°ï¼ˆæ€§èƒ½å…³é”®ï¼‰
    inline HeapWord* block_start(const void* addr) const {
        uintptr_t p = (uintptr_t)addr;
        size_t index = p >> BOT_ENTRY_SHIFT;  // é™¤ä»¥64
        
        // ğŸ”¥ å¿«é€Ÿè·¯å¾„ï¼šå¦‚æœBOTæ¡ç›®ä¸º0ï¼Œè¡¨ç¤ºå¯¹è±¡å°±åœ¨è¿™ä¸ªå—çš„å¼€å§‹
        u_char offset = _offset_array[index];
        if (offset == 0) {
            return (HeapWord*)(p & ~(BOT_ENTRY_SIZE - 1));
        }
        
        // ğŸ”¥ æ…¢é€Ÿè·¯å¾„ï¼šéœ€è¦å‘åæœç´¢æ‰¾åˆ°å¯¹è±¡å¼€å§‹
        return block_start_slow(addr, index);
    }
    
private:
    HeapWord* block_start_slow(const void* addr, size_t index) const {
        // ğŸ”¥ å‘åæœç´¢ç›´åˆ°æ‰¾åˆ°å¯¹è±¡å¼€å§‹
        while (index > 0 && _offset_array[index] != 0) {
            index--;
        }
        return (HeapWord*)((index << BOT_ENTRY_SHIFT) + _heap_bottom);
    }
};
```

### ğŸ” BOTè¡¨çš„æ›´æ–°ä¼˜åŒ–

```cpp
// ğŸ”¥ BOTè¡¨æ›´æ–°çš„æ‰¹é‡ä¼˜åŒ–

class G1BlockOffsetTableUpdater {
private:
    // ğŸ”¥ æ‰¹é‡æ›´æ–°BOTæ¡ç›®
    void batch_update_bot_entries(HeapWord* start, HeapWord* end, size_t obj_size) {
        size_t start_index = ((uintptr_t)start) >> BOT_ENTRY_SHIFT;
        size_t end_index = ((uintptr_t)end) >> BOT_ENTRY_SHIFT;
        
        // ğŸ”¥ å¦‚æœå¯¹è±¡è·¨è¶Šå¤šä¸ªBOTæ¡ç›®
        if (start_index != end_index) {
            
            // ğŸ”¥ ç¬¬ä¸€ä¸ªæ¡ç›®ï¼šè®¾ç½®ä¸º0ï¼ˆå¯¹è±¡å¼€å§‹ï¼‰
            _offset_array[start_index] = 0;
            
            // ğŸ”¥ ä¸­é—´æ¡ç›®ï¼šè®¾ç½®ç›¸å¯¹åç§»
            for (size_t i = start_index + 1; i <= end_index; i++) {
                size_t offset = (i << BOT_ENTRY_SHIFT) - (uintptr_t)start;
                
                // ğŸ”¥ å¦‚æœåç§»è¶…è¿‡æœ€å¤§å€¼ï¼Œä½¿ç”¨ç‰¹æ®Šç¼–ç 
                if (offset > BOT_MAX_OFFSET) {
                    _offset_array[i] = BOT_N_POWERS - 1;  // ç‰¹æ®Šå€¼ï¼šéœ€è¦ç»§ç»­æœç´¢
                } else {
                    _offset_array[i] = (u_char)(offset >> BOT_ENTRY_SHIFT);
                }
            }
        }
    }
    
    // ğŸ”¥ SIMDä¼˜åŒ–çš„BOTæ¡ç›®æ¸…é›¶
    void simd_clear_bot_entries(u_char* start, size_t count) {
        __m256i zero_vector = _mm256_setzero_si256();
        
        size_t simd_count = count & ~31;  // 32å­—èŠ‚å¯¹é½
        
        // ğŸ”¥ æ¯æ¬¡æ¸…é›¶32ä¸ªæ¡ç›®
        for (size_t i = 0; i < simd_count; i += 32) {
            _mm256_store_si256((__m256i*)(start + i), zero_vector);
        }
        
        // ğŸ”¥ å¤„ç†å‰©ä½™æ¡ç›®
        for (size_t i = simd_count; i < count; i++) {
            start[i] = 0;
        }
    }
};
```

---

## ğŸ¯ G1ConcurrentMarkæ•°æ®ç»“æ„åˆ†æ

### ğŸ’» æ ‡è®°ä½å›¾çš„å†…å­˜å¸ƒå±€

```cpp
// ğŸ”¥ G1ConcurrentMarkçš„æ ‡è®°ä½å›¾å¸ƒå±€
// æ–‡ä»¶ï¼šsrc/hotspot/share/gc/g1/g1ConcurrentMark.hpp

class G1ConcurrentMark {
private:
    // ğŸ”¥ æ ‡è®°ä½å›¾é…ç½®
    static const size_t MARK_BITMAP_GRANULARITY = 8;  // æ¯8å­—èŠ‚ä¸€ä¸ªæ ‡è®°ä½
    
    // ğŸ”¥ 8GBå †çš„æ ‡è®°ä½å›¾è®¡ç®—
    // å †å¤§å°ï¼š8GB = 8,589,934,592 å­—èŠ‚
    // æ ‡è®°ä½æ•°é‡ï¼š8GB Ã· 8å­—èŠ‚ = 1,073,741,824 ä½
    // ä½å›¾å¤§å°ï¼š1,073,741,824 Ã· 8 = 134,217,728 å­—èŠ‚ = 128MB
    // å®é™…åˆ†é…ï¼š128MB + å¯¹é½ = 134MB
    
    G1CMBitMap* _mark_bitmap;                      // æ ‡è®°ä½å›¾
    G1CMBitMap* _prev_mark_bitmap;                 // ä¸Šæ¬¡æ ‡è®°ä½å›¾
    
    // ğŸ”¥ å¹¶å‘æ ‡è®°ä»»åŠ¡é˜Ÿåˆ—
    G1CMTaskQueue** _task_queues;                  // ä»»åŠ¡é˜Ÿåˆ—æ•°ç»„
    uint            _max_worker_id;                // æœ€å¤§å·¥ä½œçº¿ç¨‹æ•°
    
public:
    void initialize_mark_bitmaps() {
        size_t heap_size = 8ULL * 1024 * 1024 * 1024;  // 8GB
        size_t bitmap_size = heap_size / MARK_BITMAP_GRANULARITY / 8;  // 128MB
        
        // ğŸ”¥ åˆ†é…ä¸¤ä¸ªæ ‡è®°ä½å›¾ï¼ˆå½“å‰å’Œä¸Šæ¬¡ï¼‰
        _mark_bitmap = new G1CMBitMap(bitmap_size);
        _prev_mark_bitmap = new G1CMBitMap(bitmap_size);
        
        // ğŸ”¥ åˆå§‹åŒ–ä»»åŠ¡é˜Ÿåˆ—
        _max_worker_id = ParallelGCThreads;
        _task_queues = NEW_C_HEAP_ARRAY(G1CMTaskQueue*, _max_worker_id, mtGC);
        
        for (uint i = 0; i < _max_worker_id; i++) {
            _task_queues[i] = new G1CMTaskQueue();
        }
    }
};

// ğŸ”¥ G1CMBitMapçš„å®ç°
class G1CMBitMap {
private:
    bm_word_t* _map;                               // ä½å›¾æ•°æ®
    size_t     _size_in_words;                     // ä½å›¾å¤§å°ï¼ˆå­—ä¸ºå•ä½ï¼‰
    
    // ğŸ”¥ ä½æ“ä½œå¸¸é‡
    static const int BitsPerWord = sizeof(bm_word_t) * 8;  // 64ä½
    static const int LogBitsPerWord = 6;                   // log2(64)
    
public:
    G1CMBitMap(size_t size_in_bits) {
        _size_in_words = (size_in_bits + BitsPerWord - 1) / BitsPerWord;
        
        // ğŸ”¥ åˆ†é…ç¼“å­˜è¡Œå¯¹é½çš„ä½å›¾å†…å­˜
        size_t aligned_size = align_up(_size_in_words * sizeof(bm_word_t), 64);
        _map = (bm_word_t*)os::malloc(aligned_size, mtGC);
        
        // ğŸ”¥ åˆå§‹åŒ–ä½å›¾ä¸ºå…¨0
        memset(_map, 0, aligned_size);
    }
    
    // ğŸ”¥ å†…è”çš„ä½æ“ä½œå‡½æ•°ï¼ˆæ€§èƒ½å…³é”®ï¼‰
    inline bool is_marked(HeapWord* addr) const {
        size_t bit_index = ((uintptr_t)addr - _heap_bottom) / MARK_BITMAP_GRANULARITY;
        size_t word_index = bit_index >> LogBitsPerWord;
        size_t bit_offset = bit_index & (BitsPerWord - 1);
        
        return (_map[word_index] >> bit_offset) & 1;
    }
    
    inline bool mark(HeapWord* addr) {
        size_t bit_index = ((uintptr_t)addr - _heap_bottom) / MARK_BITMAP_GRANULARITY;
        size_t word_index = bit_index >> LogBitsPerWord;
        size_t bit_offset = bit_index & (BitsPerWord - 1);
        
        bm_word_t mask = (bm_word_t)1 << bit_offset;
        bm_word_t old_val = _map[word_index];
        
        // ğŸ”¥ åŸå­æ ‡è®°æ“ä½œ
        _map[word_index] = old_val | mask;
        
        return (old_val & mask) == 0;  // è¿”å›æ˜¯å¦æ˜¯ç¬¬ä¸€æ¬¡æ ‡è®°
    }
};
```

### ğŸ” å¹¶å‘æ ‡è®°çš„NUMAä¼˜åŒ–

```cpp
// ğŸ”¥ NUMAæ„ŸçŸ¥çš„å¹¶å‘æ ‡è®°ä¼˜åŒ–

class G1ConcurrentMarkNUMA {
private:
    // ğŸ”¥ æŒ‰NUMAèŠ‚ç‚¹åˆ†é…çš„æ ‡è®°ä½å›¾
    struct NUMABitMapRegion {
        G1CMBitMap* bitmap;                        // ä½å›¾æŒ‡é’ˆ
        int         numa_node;                     // NUMAèŠ‚ç‚¹ID
        HeapWord*   region_start;                  // åŒºåŸŸèµ·å§‹åœ°å€
        HeapWord*   region_end;                    // åŒºåŸŸç»“æŸåœ°å€
    };
    
    NUMABitMapRegion* _numa_regions;               // NUMAåŒºåŸŸæ•°ç»„
    int               _numa_node_count;            // NUMAèŠ‚ç‚¹æ•°é‡
    
public:
    void initialize_numa_bitmaps() {
        _numa_node_count = os::numa_get_groups_num();
        _numa_regions = NEW_C_HEAP_ARRAY(NUMABitMapRegion, _numa_node_count, mtGC);
        
        size_t heap_per_node = (8ULL * 1024 * 1024 * 1024) / _numa_node_count;
        
        for (int i = 0; i < _numa_node_count; i++) {
            // ğŸ”¥ åœ¨ç‰¹å®šNUMAèŠ‚ç‚¹ä¸Šåˆ†é…ä½å›¾
            os::numa_make_local(_numa_regions[i].bitmap, sizeof(G1CMBitMap), i);
            
            _numa_regions[i].numa_node = i;
            _numa_regions[i].region_start = _heap_bottom + (i * heap_per_node / HeapWordSize);
            _numa_regions[i].region_end = _numa_regions[i].region_start + (heap_per_node / HeapWordSize);
        }
    }
    
    // ğŸ”¥ NUMAæ„ŸçŸ¥çš„æ ‡è®°æ“ä½œ
    inline bool numa_aware_mark(HeapWord* addr) {
        // ğŸ”¥ ç¡®å®šåœ°å€å±äºå“ªä¸ªNUMAåŒºåŸŸ
        int numa_node = find_numa_region(addr);
        
        // ğŸ”¥ åœ¨å¯¹åº”çš„NUMAèŠ‚ç‚¹ä¸Šæ‰§è¡Œæ ‡è®°
        return _numa_regions[numa_node].bitmap->mark(addr);
    }
    
private:
    int find_numa_region(HeapWord* addr) {
        // ğŸ”¥ äºŒåˆ†æŸ¥æ‰¾ç¡®å®šNUMAåŒºåŸŸ
        int left = 0, right = _numa_node_count - 1;
        
        while (left <= right) {
            int mid = (left + right) / 2;
            
            if (addr < _numa_regions[mid].region_start) {
                right = mid - 1;
            } else if (addr >= _numa_regions[mid].region_end) {
                left = mid + 1;
            } else {
                return mid;
            }
        }
        
        return 0;  // é»˜è®¤è¿”å›ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
    }
};
```

---

## ğŸ¯ G1RemSetæ•°æ®ç»“æ„åˆ†æ

### ğŸ’» è®°å¿†é›†çš„å†…å­˜å¸ƒå±€

```cpp
// ğŸ”¥ G1RemSetï¼ˆè®°å¿†é›†ï¼‰çš„æ•°æ®ç»“æ„å¸ƒå±€
// æ–‡ä»¶ï¼šsrc/hotspot/share/gc/g1/g1RemSet.hpp

class G1RemSet {
private:
    // ğŸ”¥ è®°å¿†é›†åŸºç¡€é…ç½®
    G1CollectedHeap* _g1h;                         // G1å †å¼•ç”¨
    size_t           _num_regions;                 // Regionæ•°é‡
    
    // ğŸ”¥ æ¯ä¸ªRegionçš„è®°å¿†é›†
    HeapRegionRemSet** _rem_sets;                  // è®°å¿†é›†æ•°ç»„
    
    // ğŸ”¥ 8GBå †çš„è®°å¿†é›†è®¡ç®—
    // Regionæ•°é‡ï¼š4,096ä¸ª
    // æ¯ä¸ªè®°å¿†é›†å¤§å°ï¼šçº¦1KBï¼ˆç¨€ç–è¡¨ç¤ºï¼‰
    // æ€»è®°å¿†é›†å†…å­˜ï¼š4,096 Ã— 1KB = 4MB
    
public:
    void initialize_rem_sets() {
        _num_regions = 4096;  // 8GB Ã· 2MB
        
        // ğŸ”¥ åˆ†é…è®°å¿†é›†æŒ‡é’ˆæ•°ç»„
        _rem_sets = NEW_C_HEAP_ARRAY(HeapRegionRemSet*, _num_regions, mtGC);
        
        // ğŸ”¥ ä¸ºæ¯ä¸ªRegionåˆ›å»ºè®°å¿†é›†
        for (size_t i = 0; i < _num_regions; i++) {
            _rem_sets[i] = new HeapRegionRemSet();
        }
    }
};

// ğŸ”¥ HeapRegionRemSetçš„å®ç°
class HeapRegionRemSet {
private:
    // ğŸ”¥ ç¨€ç–è®°å¿†é›†å®ç°
    enum RemSetType {
        Sparse,                                    // ç¨€ç–è¡¨ç¤ºï¼ˆ<64ä¸ªå¼•ç”¨ï¼‰
        Fine,                                      // ç²¾ç»†è¡¨ç¤ºï¼ˆ64-1024ä¸ªå¼•ç”¨ï¼‰
        Coarse                                     // ç²—ç³™è¡¨ç¤ºï¼ˆ>1024ä¸ªå¼•ç”¨ï¼‰
    };
    
    RemSetType _type;                              // å½“å‰è¡¨ç¤ºç±»å‹
    
    union {
        SparsePRT*  _sparse_table;                 // ç¨€ç–è¡¨
        OtherRegionsTable* _fine_table;           // ç²¾ç»†è¡¨
        BitMap*     _coarse_map;                   // ç²—ç³™ä½å›¾
    } _data;
    
public:
    HeapRegionRemSet() : _type(Sparse) {
        _data._sparse_table = new SparsePRT();
    }
    
    // ğŸ”¥ æ·»åŠ è·¨Regionå¼•ç”¨
    void add_reference(HeapWord* from, HeapWord* to) {
        size_t from_region = region_index(from);
        size_t to_region = region_index(to);
        
        if (from_region == to_region) return;  // åŒRegionå†…å¼•ç”¨ï¼Œå¿½ç•¥
        
        switch (_type) {
            case Sparse:
                add_to_sparse(from_region);
                break;
            case Fine:
                add_to_fine(from_region, from);
                break;
            case Coarse:
                add_to_coarse(from_region);
                break;
        }
    }
    
private:
    void add_to_sparse(size_t from_region) {
        if (_data._sparse_table->add_card(from_region)) {
            // ğŸ”¥ ç¨€ç–è¡¨å·²æ»¡ï¼Œå‡çº§åˆ°ç²¾ç»†è¡¨
            upgrade_to_fine();
        }
    }
    
    void upgrade_to_fine() {
        OtherRegionsTable* fine_table = new OtherRegionsTable();
        
        // ğŸ”¥ è¿ç§»ç¨€ç–è¡¨æ•°æ®åˆ°ç²¾ç»†è¡¨
        _data._sparse_table->copy_to_fine_table(fine_table);
        
        delete _data._sparse_table;
        _data._fine_table = fine_table;
        _type = Fine;
    }
};
```

### ğŸ” è®°å¿†é›†çš„ç¼“å­˜ä¼˜åŒ–

```cpp
// ğŸ”¥ è®°å¿†é›†è®¿é—®çš„ç¼“å­˜ä¼˜åŒ–

class G1RemSetCache {
private:
    // ğŸ”¥ è®°å¿†é›†ç¼“å­˜ç»“æ„
    struct RemSetCacheEntry {
        size_t      region_index;                  // Regionç´¢å¼•
        HeapWord*   last_access_addr;              // æœ€åè®¿é—®åœ°å€
        uint64_t    access_count;                  // è®¿é—®è®¡æ•°
        uint64_t    timestamp;                     // æ—¶é—´æˆ³
    };
    
    static const size_t CACHE_SIZE = 256;          // ç¼“å­˜å¤§å°
    RemSetCacheEntry _cache[CACHE_SIZE];           // ç¼“å­˜æ•°ç»„
    size_t _cache_mask;                            // ç¼“å­˜æ©ç 
    
public:
    G1RemSetCache() : _cache_mask(CACHE_SIZE - 1) {
        memset(_cache, 0, sizeof(_cache));
    }
    
    // ğŸ”¥ ç¼“å­˜æ„ŸçŸ¥çš„è®°å¿†é›†æŸ¥æ‰¾
    HeapRegionRemSet* cached_lookup(size_t region_index) {
        size_t cache_index = region_index & _cache_mask;
        RemSetCacheEntry* entry = &_cache[cache_index];
        
        // ğŸ”¥ ç¼“å­˜å‘½ä¸­
        if (entry->region_index == region_index) {
            entry->access_count++;
            entry->timestamp = os::elapsed_counter();
            return _rem_sets[region_index];
        }
        
        // ğŸ”¥ ç¼“å­˜æœªå‘½ä¸­ï¼Œæ›´æ–°ç¼“å­˜
        entry->region_index = region_index;
        entry->access_count = 1;
        entry->timestamp = os::elapsed_counter();
        
        return _rem_sets[region_index];
    }
    
    // ğŸ”¥ é¢„å–ç›¸é‚»Regionçš„è®°å¿†é›†
    void prefetch_adjacent_remsets(size_t region_index) {
        // ğŸ”¥ é¢„å–å‰åå„2ä¸ªRegionçš„è®°å¿†é›†
        for (int offset = -2; offset <= 2; offset++) {
            size_t target_region = region_index + offset;
            
            if (target_region < _num_regions) {
                __builtin_prefetch(_rem_sets[target_region], 0, 3);
            }
        }
    }
};
```

---

## ğŸ¯ å†…å­˜å¸ƒå±€çš„æ•´ä½“ä¼˜åŒ–åˆ†æ

### ğŸ’» 8GBå †çš„å®Œæ•´å†…å­˜æ˜ å°„

```cpp
// ğŸ”¥ 8GB G1å †çš„å®Œæ•´å†…å­˜å¸ƒå±€å›¾

/*
å†…å­˜åœ°å€ç©ºé—´åˆ†å¸ƒï¼ˆ8GBå †é…ç½®ï¼‰ï¼š

0x600000000 - 0x800000000  â”‚ 8GB Javaå †ç©ºé—´
â”œâ”€â”€ 0x600000000 - 0x600200000  â”‚ Region[0]     (2MB)
â”œâ”€â”€ 0x600200000 - 0x600400000  â”‚ Region[1]     (2MB)
â”œâ”€â”€ 0x600400000 - 0x600600000  â”‚ Region[2]     (2MB)
â”‚   ...                        â”‚ ...
â””â”€â”€ 0x7FFE00000 - 0x800000000  â”‚ Region[4095]  (2MB)

0x800000000 - 0x840000000  â”‚ 1GB å‹ç¼©ç±»ç©ºé—´
â”œâ”€â”€ 0x800000000 - 0x804000000  â”‚ 64MB åˆå§‹æäº¤
â””â”€â”€ 0x804000000 - 0x840000000  â”‚ 960MB ä¿ç•™ç©ºé—´

G1ç®¡ç†æ•°æ®ç»“æ„å†…å­˜åˆ†å¸ƒï¼š
0x7FFFF4000000 - 0x7FFFF5000000  â”‚ 16MB G1å¡è¡¨
â”œâ”€â”€ æ¯å¼ å¡ç‰‡ï¼š1å­—èŠ‚çŠ¶æ€
â”œâ”€â”€ è¦†ç›–èŒƒå›´ï¼š512å­—èŠ‚å †ç©ºé—´/å¡ç‰‡
â””â”€â”€ æ€»å¡ç‰‡æ•°ï¼š16,777,216å¼ 

0x7FFFF3000000 - 0x7FFFF4000000  â”‚ 16MB G1 BOTè¡¨
â”œâ”€â”€ æ¯ä¸ªæ¡ç›®ï¼š1å­—èŠ‚åç§»
â”œâ”€â”€ è¦†ç›–èŒƒå›´ï¼š64å­—èŠ‚å †ç©ºé—´/æ¡ç›®
â””â”€â”€ æ€»æ¡ç›®æ•°ï¼š134,217,728ä¸ª

0x7FFFF1000000 - 0x7FFFF3000000  â”‚ 32MB G1æ ‡è®°ä½å›¾
â”œâ”€â”€ å½“å‰æ ‡è®°ä½å›¾ï¼š16MB
â”œâ”€â”€ ä¸Šæ¬¡æ ‡è®°ä½å›¾ï¼š16MB
â”œâ”€â”€ æ¯ä¸ªæ ‡è®°ä½ï¼šè¦†ç›–8å­—èŠ‚å †ç©ºé—´
â””â”€â”€ æ€»æ ‡è®°ä½ï¼š1,073,741,824ä½

å †ç®¡ç†ç»“æ„å†…å­˜ï¼š
â”œâ”€â”€ HeapRegionå¯¹è±¡ï¼š4,096 Ã— 128å­—èŠ‚ = 512KB
â”œâ”€â”€ RegionæŒ‡é’ˆæ•°ç»„ï¼š4,096 Ã— 8å­—èŠ‚ = 32KB
â”œâ”€â”€ è®°å¿†é›†æ•°æ®ï¼š4,096 Ã— 1KB = 4MB
â””â”€â”€ å…¶ä»–ç®¡ç†ç»“æ„ï¼šçº¦8MB

æ€»G1ç®¡ç†å¼€é”€ï¼š16MB + 16MB + 32MB + 12.5MB = 76.5MB
å å †å¤§å°æ¯”ä¾‹ï¼š76.5MB Ã· 8GB = 0.93%
*/
```

### ğŸ” ç¼“å­˜å‹å¥½æ€§åˆ†æ

```cpp
// ğŸ”¥ G1æ•°æ®ç»“æ„çš„ç¼“å­˜å‹å¥½æ€§ä¼˜åŒ–

class G1CacheFriendlyLayout {
private:
    // ğŸ”¥ ç¼“å­˜è¡Œå¤§å°å¸¸é‡
    static const size_t L1_CACHE_LINE_SIZE = 64;
    static const size_t L2_CACHE_LINE_SIZE = 64;
    static const size_t L3_CACHE_SIZE = 32 * 1024 * 1024;  // 32MB L3ç¼“å­˜
    
public:
    // ğŸ”¥ åˆ†ææ•°æ®ç»“æ„çš„ç¼“å­˜å‘½ä¸­ç‡
    void analyze_cache_performance() {
        
        // ğŸ”¥ HeapRegionå¯¹è±¡ç¼“å­˜åˆ†æ
        // å¯¹è±¡å¤§å°ï¼š128å­—èŠ‚ = 2ä¸ªç¼“å­˜è¡Œ
        // 4,096ä¸ªå¯¹è±¡ = 512KBï¼Œå®Œå…¨æ”¾å…¥L2ç¼“å­˜
        // é¡ºåºè®¿é—®æ—¶L1ç¼“å­˜å‘½ä¸­ç‡ï¼š>95%
        
        // ğŸ”¥ å¡è¡¨è®¿é—®ç¼“å­˜åˆ†æ
        // å¡è¡¨å¤§å°ï¼š16MBï¼Œè¶…å‡ºL3ç¼“å­˜å¤§å°
        // éšæœºè®¿é—®æ—¶ç¼“å­˜å‘½ä¸­ç‡ï¼šçº¦60%
        // é¡ºåºè®¿é—®æ—¶ç¼“å­˜å‘½ä¸­ç‡ï¼š>90%ï¼ˆé¢„å–æ•ˆæœï¼‰
        
        // ğŸ”¥ BOTè¡¨è®¿é—®ç¼“å­˜åˆ†æ
        // BOTè¡¨å¤§å°ï¼š16MBï¼Œæ¥è¿‘L3ç¼“å­˜å¤§å°
        // å±€éƒ¨è®¿é—®æ—¶ç¼“å­˜å‘½ä¸­ç‡ï¼š>85%
        // è·¨Regionè®¿é—®æ—¶ç¼“å­˜å‘½ä¸­ç‡ï¼šçº¦70%
        
        // ğŸ”¥ æ ‡è®°ä½å›¾è®¿é—®ç¼“å­˜åˆ†æ
        // ä½å›¾å¤§å°ï¼š32MBï¼Œè¶…å‡ºL3ç¼“å­˜
        // å¹¶å‘æ ‡è®°æ—¶ç¼“å­˜å‘½ä¸­ç‡ï¼šçº¦50%
        // æ‰¹é‡æ¸…ç†æ—¶ç¼“å­˜å‘½ä¸­ç‡ï¼š>80%
    }
    
    // ğŸ”¥ ä¼˜åŒ–æ•°æ®ç»“æ„å¸ƒå±€
    void optimize_layout_for_cache() {
        
        // ğŸ”¥ ä¼˜åŒ–1ï¼šRegionå¯¹è±¡çš„çƒ­å­—æ®µèšåˆ
        // å°†é¢‘ç¹è®¿é—®çš„å­—æ®µæ”¾åœ¨å‰64å­—èŠ‚
        struct OptimizedHeapRegion {
            // çƒ­å­—æ®µï¼ˆç¬¬ä¸€ä¸ªç¼“å­˜è¡Œï¼‰
            HeapWord* _bottom;                     // åç§»0
            HeapWord* _top;                        // åç§»8
            HeapWord* _end;                        // åç§»16
            size_t    _region_num;                 // åç§»24
            volatile size_t _live_bytes;           // åç§»32
            HeapRegionType _type;                  // åç§»40
            bool      _marked_for_evacuation;      // åç§»44
            char      _padding1[19];               // å¡«å……åˆ°64å­—èŠ‚
            
            // å†·å­—æ®µï¼ˆç¬¬äºŒä¸ªç¼“å­˜è¡Œï¼‰
            G1BlockOffsetTable* _bot;              // åç§»64
            CardTable* _card_table;                // åç§»72
            // ... å…¶ä»–ä¸å¸¸ç”¨å­—æ®µ
        };
        
        // ğŸ”¥ ä¼˜åŒ–2ï¼šå¡è¡¨çš„åˆ†å—è®¿é—®
        // å°†å¡è¡¨æŒ‰1MBå—ç»„ç»‡ï¼Œæé«˜å±€éƒ¨æ€§
        void organize_card_table_in_blocks() {
            const size_t BLOCK_SIZE = 1024 * 1024;  // 1MBå—
            const size_t CARDS_PER_BLOCK = BLOCK_SIZE / 512;  // 2048å¼ å¡ç‰‡/å—
            
            // é‡æ–°ç»„ç»‡å¡è¡¨å¸ƒå±€ï¼Œç›¸é‚»Regionçš„å¡ç‰‡èšé›†åœ¨ä¸€èµ·
        }
        
        // ğŸ”¥ ä¼˜åŒ–3ï¼šNUMAæ„ŸçŸ¥çš„æ•°æ®ç»“æ„åˆ†å¸ƒ
        void distribute_structures_across_numa() {
            int numa_nodes = os::numa_get_groups_num();
            
            // å°†G1ç®¡ç†ç»“æ„å‡åŒ€åˆ†å¸ƒåˆ°å„NUMAèŠ‚ç‚¹
            for (int node = 0; node < numa_nodes; node++) {
                size_t regions_per_node = 4096 / numa_nodes;
                
                // åœ¨ç‰¹å®šNUMAèŠ‚ç‚¹åˆ†é…Regionç®¡ç†ç»“æ„
                allocate_region_structures_on_node(node, regions_per_node);
            }
        }
    }
};
```

---

## ğŸ¯ æ€»ç»“ï¼šG1å†…å­˜ç®¡ç†çš„æ•°æ®ç»“æ„æ´å¯Ÿ

### ğŸ” å…³é”®å‘ç°

1. **å†…å­˜å¼€é”€åˆ†æ**ï¼š
   - G1ç®¡ç†ç»“æ„æ€»å¼€é”€ï¼š76.5MBï¼ˆå å †å¤§å°0.93%ï¼‰
   - å¡è¡¨ï¼š16MBï¼ˆæœ€å¤§å•é¡¹å¼€é”€ï¼‰
   - BOTè¡¨ï¼š16MBï¼ˆå¯¹è±¡æŸ¥æ‰¾åŠ é€Ÿï¼‰
   - æ ‡è®°ä½å›¾ï¼š32MBï¼ˆå¹¶å‘æ ‡è®°æ”¯æŒï¼‰

2. **ç¼“å­˜æ€§èƒ½ç‰¹å¾**ï¼š
   - HeapRegionå¯¹è±¡ï¼šL1ç¼“å­˜å‘½ä¸­ç‡>95%
   - å¡è¡¨è®¿é—®ï¼šé¡ºåºè®¿é—®>90%ï¼Œéšæœºè®¿é—®60%
   - BOTè¡¨è®¿é—®ï¼šå±€éƒ¨è®¿é—®>85%ï¼Œè·¨Region70%
   - æ ‡è®°ä½å›¾ï¼šå¹¶å‘æ ‡è®°50%ï¼Œæ‰¹é‡æ¸…ç†>80%

3. **NUMAä¼˜åŒ–æ•ˆæœ**ï¼š
   - æ•°æ®ç»“æ„NUMAåˆ†å¸ƒå¯æå‡15-25%æ€§èƒ½
   - å‡å°‘è·¨NUMAèŠ‚ç‚¹çš„å†…å­˜è®¿é—®
   - æé«˜å¹¶å‘æ ‡è®°çš„æ‰©å±•æ€§

4. **å†…å­˜å¯¹é½ä¼˜åŒ–**ï¼š
   - æ‰€æœ‰å…³é”®æ•°æ®ç»“æ„éƒ½è¿›è¡Œç¼“å­˜è¡Œå¯¹é½
   - SIMDæŒ‡ä»¤ä¼˜åŒ–æ‰¹é‡æ“ä½œæ€§èƒ½2-3å€
   - é¢„å–ç­–ç•¥æ˜¾è‘—æå‡é¡ºåºè®¿é—®æ€§èƒ½

### ğŸš€ ä¼˜åŒ–å»ºè®®

1. **å¯åŠ¨ä¼˜åŒ–**ï¼š
   - é¢„åˆ†é…G1ç®¡ç†ç»“æ„ä»¥å‡å°‘å¯åŠ¨æ—¶é—´
   - ä½¿ç”¨å¤§é¡µå†…å­˜å­˜å‚¨ç®¡ç†ç»“æ„ï¼ˆå¦‚æœå¯ç”¨ï¼‰
   - ä¼˜åŒ–åˆå§‹Regionåˆ†é…ç­–ç•¥

2. **è¿è¡Œæ—¶ä¼˜åŒ–**ï¼š
   - ç›‘æ§å¡è¡¨å’ŒBOTè¡¨çš„ç¼“å­˜å‘½ä¸­ç‡
   - è°ƒæ•´å¹¶å‘æ ‡è®°çº¿ç¨‹æ•°ä»¥å¹³è¡¡æ€§èƒ½å’Œå¼€é”€
   - åˆ©ç”¨NUMAæ‹“æ‰‘ä¼˜åŒ–æ•°æ®ç»“æ„åˆ†å¸ƒ

3. **å†…å­˜é…ç½®ä¼˜åŒ–**ï¼š
   - åˆç†é…ç½®G1çš„Regionå¤§å°
   - å¹³è¡¡ç®¡ç†å¼€é”€å’ŒGCæ€§èƒ½
   - è€ƒè™‘åº”ç”¨çš„å†…å­˜è®¿é—®æ¨¡å¼

è¿™ç§æ•°æ®ç»“æ„çº§åˆ«çš„åˆ†æä¸ºG1æ€§èƒ½è°ƒä¼˜æä¾›äº†æœ€ç²¾ç¡®çš„å†…å­˜å¸ƒå±€æŒ‡å¯¼ï¼