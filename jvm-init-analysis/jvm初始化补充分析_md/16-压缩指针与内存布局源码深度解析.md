# å‹ç¼©æŒ‡é’ˆä¸å†…å­˜å¸ƒå±€æºç æ·±åº¦è§£æ

## ğŸ¯ åŸºäºOpenJDK11æºç çš„å‹ç¼©æŒ‡é’ˆå®ç°åˆ†æ

### æºç ä½ç½®
- **å‹ç¼©æŒ‡é’ˆæ ¸å¿ƒ**: `src/hotspot/share/oops/compressedOops.inline.hpp`
- **Universeé…ç½®**: `src/hotspot/share/memory/universe.hpp/cpp`
- **å †å…±äº«**: `src/hotspot/share/memory/heapShared.hpp/cpp`
- **åˆ†ææ¡ä»¶**: `-Xms8g -Xmx8g -XX:+UseG1GC`

## ğŸ—ï¸ CompressedOopså‘½åç©ºé—´æºç åˆ†æ

### 1. æ ¸å¿ƒç¼–è§£ç ç®—æ³• (æºç ç¬¬42-82è¡Œ)

```cpp
namespace CompressedOops {
  // NULLæ£€æŸ¥ - å†…è”ä¼˜åŒ–
  inline bool is_null(oop obj)       { return obj == NULL; }
  inline bool is_null(narrowOop obj) { return obj == 0; }

  // è§£ç ï¼šnarrowOop -> oop (éNULLç‰ˆæœ¬)
  inline oop decode_not_null(narrowOop v) {
    assert(!is_null(v), "narrow oop value can never be zero");
    
    // è·å–å †åŸºåœ°å€å’Œä½ç§»é‡
    address base = Universe::narrow_oop_base();
    int    shift = Universe::narrow_oop_shift();
    
    // æ ¸å¿ƒè§£ç ç®—æ³•ï¼šbase + (v << shift)
    oop result = (oop)(void*)((uintptr_t)base + ((uintptr_t)v << shift));
    
    // éªŒè¯å¯¹è±¡å¯¹é½
    assert(check_obj_alignment(result), "address not aligned: " INTPTR_FORMAT, 
           p2i((void*) result));
    return result;
  }

  // è§£ç ï¼šnarrowOop -> oop (åŒ…å«NULLæ£€æŸ¥)
  inline oop decode(narrowOop v) {
    return is_null(v) ? (oop)NULL : decode_not_null(v);
  }

  // ç¼–ç ï¼šoop -> narrowOop (éNULLç‰ˆæœ¬)
  inline narrowOop encode_not_null(oop v) {
    assert(!is_null(v), "oop value can never be zero");
    assert(check_obj_alignment(v), "Address not aligned");
    assert(Universe::heap()->is_in_reserved(v), "Address not in heap");
    
    // è·å–å †åŸºåœ°å€å’Œä½ç§»é‡
    address base = Universe::narrow_oop_base();
    int    shift = Universe::narrow_oop_shift();
    
    // è®¡ç®—ç›¸å¯¹åç§»
    uint64_t pd = (uint64_t)(pointer_delta((void*)v, (void*)base, 1));
    assert(OopEncodingHeapMax > pd, "change encoding max if new encoding");
    
    // æ ¸å¿ƒç¼–ç ç®—æ³•ï¼š(v - base) >> shift
    uint64_t result = pd >> shift;
    
    // éªŒè¯32ä½èŒƒå›´
    assert((result & CONST64(0xffffffff00000000)) == 0, "narrow oop overflow");
    assert(decode(result) == v, "reversibility");
    
    return (narrowOop)result;
  }

  // ç¼–ç ï¼šoop -> narrowOop (åŒ…å«NULLæ£€æŸ¥)
  inline narrowOop encode(oop v) {
    return is_null(v) ? (narrowOop)0 : encode_not_null(v);
  }

  // æ— è½¬æ¢é‡è½½ç‰ˆæœ¬ (ç¼–è¯‘å™¨ä¼˜åŒ–)
  inline oop decode_not_null(oop v)             { return v; }
  inline oop decode(oop v)                      { return v; }
  inline narrowOop encode_not_null(narrowOop v) { return v; }
  inline narrowOop encode(narrowOop v)          { return v; }
}
```

**ç®—æ³•æ ¸å¿ƒ**:
- **ç¼–ç **: `compressed = (address - heap_base) >> shift`
- **è§£ç **: `address = heap_base + (compressed << shift)`
- **Zero-basedä¼˜åŒ–**: å½“heap_baseä¸ºç‰¹æ®Šå€¼æ—¶ï¼Œå¯ä»¥çœç•¥åŠ æ³•è¿ç®—

### 2. Universeä¸­çš„å‹ç¼©æŒ‡é’ˆé…ç½®

```cpp
// Universe.hppä¸­çš„å‹ç¼©æŒ‡é’ˆç»“æ„
struct NarrowPtrStruct {
  address _base;                    // å †åŸºåœ°å€
  int     _shift;                   // ä½ç§»é‡ (é€šå¸¸ä¸º3)
  bool    _use_implicit_null_checks; // æ˜¯å¦ä½¿ç”¨éšå¼NULLæ£€æŸ¥
};

class Universe : AllStatic {
private:
  // å…¨å±€å‹ç¼©æŒ‡é’ˆé…ç½®
  static struct NarrowPtrStruct _narrow_oop;
  
public:
  // å‹ç¼©æŒ‡é’ˆæ¨¡å¼æšä¸¾
  enum NARROW_OOP_MODE {
    UnscaledNarrowOop  = 0,  // æœªç¼©æ”¾æ¨¡å¼ (å † < 4GB)
    ZeroBasedNarrowOop = 1,  // Zero-basedæ¨¡å¼ (å † <= 32GB)
    DisjointBaseNarrowOop = 2, // åˆ†ç¦»åŸºå€æ¨¡å¼ (å † > 32GB)
    HeapBasedNarrowOop = 3   // å †åŸºå€æ¨¡å¼ (å…¼å®¹æ¨¡å¼)
  };
  
  // è®¿é—®å™¨æ–¹æ³•
  static address  narrow_oop_base()                { return _narrow_oop._base; }
  static int      narrow_oop_shift()               { return _narrow_oop._shift; }
  static bool     narrow_oop_use_implicit_null_checks() { 
    return _narrow_oop._use_implicit_null_checks; 
  }
  
  // è®¾ç½®å™¨æ–¹æ³•
  static void set_narrow_oop_base(address base) {
    _narrow_oop._base = base;
  }
  
  static void set_narrow_oop_shift(int shift) {
    _narrow_oop._shift = shift;
  }
  
  static void set_narrow_oop_use_implicit_null_checks(bool use) {
    _narrow_oop._use_implicit_null_checks = use;
  }
  
  // æ¨¡å¼åˆ¤æ–­
  static bool narrow_oop_base_disjoint() {
    return _narrow_oop._base != NULL && 
           is_disjoint_heap_base_address(_narrow_oop._base);
  }
  
  static bool narrow_oop_base_overlaps() {
    return _narrow_oop._base != NULL && 
           !is_disjoint_heap_base_address(_narrow_oop._base);
  }
};
```

### 3. å‹ç¼©æŒ‡é’ˆåˆå§‹åŒ–æµç¨‹ (Universe.cpp)

```cpp
// Universe.cppä¸­çš„åˆå§‹åŒ–ä»£ç  (æºç ç¬¬827-854è¡Œ)
void Universe::initialize_compressed_oops() {
  // è®¾ç½®å¯¹è±¡å¯¹é½ä½ç§»é‡ (é€šå¸¸ä¸º3ï¼Œå³8å­—èŠ‚å¯¹é½)
  Universe::set_narrow_oop_shift(LogMinObjAlignmentInBytes);
  
  // æ ¹æ®å †é…ç½®è®¾ç½®åŸºåœ°å€
  if (UseCompressedOops) {
    // 8GBå †é€šå¸¸ä½¿ç”¨Zero-basedæ¨¡å¼
    Universe::set_narrow_oop_base(0);  // æˆ–è€…å®é™…çš„å †åŸºåœ°å€
    
    // è®¾ç½®AOTç¼–è¯‘å™¨çš„ä½ç§»é‡
    AOTLoader::set_narrow_oop_shift();
    
    // è®¾ç½®å…¨å±€æŒ‡é’ˆåŸºå€
    Universe::set_narrow_ptrs_base(Universe::narrow_oop_base());
  }
  
  // éªŒè¯é…ç½®
  log_info(gc, heap, coops)("Heap address: " PTR_FORMAT ", size: " SIZE_FORMAT " MB, "
                           "Compressed Oops mode: %s",
                           p2i(Universe::heap()->base()),
                           Universe::heap()->reserved_region().byte_size() / M,
                           narrow_oop_mode_to_string(narrow_oop_mode()));
  
  // éªŒè¯åŸºåœ°å€åˆç†æ€§
  assert((intptr_t)Universe::narrow_oop_base() <= 
         (intptr_t)(Universe::heap()->base() - os::vm_page_size()) ||
         Universe::narrow_oop_base() == NULL, "invalid value");
         
  // éªŒè¯ä½ç§»é‡
  assert(Universe::narrow_oop_shift() == LogMinObjAlignmentInBytes ||
         Universe::narrow_oop_shift() == 0, "invalid value");
}
```

## ğŸ” 8GB G1å †çš„å‹ç¼©æŒ‡é’ˆé…ç½®åˆ†æ

### 1. å®é™…é…ç½®å‚æ•°

```cpp
// 8GB G1å †çš„å‹ç¼©æŒ‡é’ˆé…ç½®
struct CompressedOops_8GB_Config {
  // åŸºç¡€å‚æ•° (åŸºäºå®é™…éªŒè¯)
  address heap_base = (address)0x0000000600000000;  // å †åŸºåœ°å€
  size_t heap_size = 8ULL * 1024 * 1024 * 1024;    // 8GB
  
  // å‹ç¼©æŒ‡é’ˆé…ç½®
  NARROW_OOP_MODE mode = ZeroBasedNarrowOop;        // Zero-basedæ¨¡å¼
  address narrow_oop_base = heap_base;              // ä¸å †åŸºåœ°å€ç›¸åŒ
  int narrow_oop_shift = 3;                         // 8å­—èŠ‚å¯¹é½ (2^3 = 8)
  bool use_implicit_null_checks = true;             // å¯ç”¨éšå¼NULLæ£€æŸ¥
  
  // å¯»å€èƒ½åŠ›è®¡ç®—
  size_t max_compressed_value = 0xFFFFFFFF;         // 32ä½æœ€å¤§å€¼
  size_t max_addressable_size = max_compressed_value << narrow_oop_shift;
  // = 0xFFFFFFFF << 3 = 32GB - 8B
  
  // å½“å‰åˆ©ç”¨ç‡
  double utilization = (double)heap_size / max_addressable_size * 100;
  // = 8GB / 32GB * 100% = 25%
};
```

### 2. åœ°å€è½¬æ¢ç¤ºä¾‹

```cpp
// 8GBå †ä¸­çš„åœ°å€è½¬æ¢ç¤ºä¾‹
void demonstrate_address_conversion() {
  address heap_base = (address)0x0000000600000000;
  int shift = 3;
  
  // ç¤ºä¾‹åœ°å€è½¬æ¢
  struct AddressExample {
    const char* description;
    address real_addr;
    narrowOop compressed;
  };
  
  AddressExample examples[] = {
    {"å †èµ·å§‹åœ°å€", heap_base, 0x00000000},
    {"ç¬¬ä¸€ä¸ªå¯¹è±¡", heap_base + 8, 0x00000001},
    {"1MBä½ç½®", heap_base + 1024*1024, 0x00020000},
    {"4GBä½ç½®", heap_base + 4ULL*1024*1024*1024, 0x20000000},
    {"å †ç»“æŸ-8", heap_base + 8ULL*1024*1024*1024 - 8, 0x3FFFFFFF}
  };
  
  for (auto& example : examples) {
    // éªŒè¯ç¼–ç 
    narrowOop encoded = CompressedOops::encode_not_null((oop)example.real_addr);
    assert(encoded == example.compressed, "Encoding mismatch");
    
    // éªŒè¯è§£ç 
    oop decoded = CompressedOops::decode_not_null(example.compressed);
    assert((address)decoded == example.real_addr, "Decoding mismatch");
    
    printf("%s: 0x%016lx <-> 0x%08x\n", 
           example.description, (uintptr_t)example.real_addr, example.compressed);
  }
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

### 1. å†…è”ä¼˜åŒ–

```cpp
// ç¼–è¯‘å™¨å†…è”ä¼˜åŒ–ç¤ºä¾‹
class InlineOptimization {
public:
  // ç¼–è¯‘å™¨ä¼šå°†è¿™äº›å‡½æ•°å®Œå…¨å†…è”
  static inline oop load_oop_field(oop obj, int offset) {
    if (UseCompressedOops) {
      narrowOop narrow = *(narrowOop*)((char*)obj + offset);
      return CompressedOops::decode(narrow);  // å†…è”ä¸ºå‡ æ¡æŒ‡ä»¤
    } else {
      return *(oop*)((char*)obj + offset);
    }
  }
  
  static inline void store_oop_field(oop obj, int offset, oop value) {
    if (UseCompressedOops) {
      narrowOop narrow = CompressedOops::encode(value);  // å†…è”ä¼˜åŒ–
      *(narrowOop*)((char*)obj + offset) = narrow;
    } else {
      *(oop*)((char*)obj + offset) = value;
    }
  }
};
```

### 2. æ±‡ç¼–çº§ä¼˜åŒ–

```cpp
// Zero-basedæ¨¡å¼çš„æ±‡ç¼–ä¼˜åŒ– (x86_64)
/*
 * ç¼–ç æ“ä½œ (oop -> narrowOop):
 * 
 * é€šç”¨æ¨¡å¼:
 *   mov %rdi, %rax          ; åŠ è½½64ä½æŒ‡é’ˆ
 *   sub heap_base, %rax     ; å‡å»å †åŸºåœ°å€
 *   shr $3, %rax            ; å³ç§»3ä½
 *   mov %eax, %eax          ; æ¸…é™¤é«˜32ä½
 * 
 * Zero-basedä¼˜åŒ–:
 *   mov %rdi, %rax          ; åŠ è½½64ä½æŒ‡é’ˆ  
 *   shr $3, %rax            ; å³ç§»3ä½ (çœç•¥å‡æ³•!)
 *   mov %eax, %eax          ; æ¸…é™¤é«˜32ä½
 * 
 * è§£ç æ“ä½œ (narrowOop -> oop):
 * 
 * é€šç”¨æ¨¡å¼:
 *   mov %edi, %eax          ; åŠ è½½32ä½å‹ç¼©æŒ‡é’ˆ
 *   shl $3, %rax            ; å·¦ç§»3ä½
 *   add heap_base, %rax     ; åŠ ä¸Šå †åŸºåœ°å€
 * 
 * Zero-basedä¼˜åŒ–:
 *   mov %edi, %eax          ; åŠ è½½32ä½å‹ç¼©æŒ‡é’ˆ
 *   shl $3, %rax            ; å·¦ç§»3ä½ (çœç•¥åŠ æ³•!)
 */
```

### 3. åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–

```cpp
// åˆ†æ”¯é¢„æµ‹å‹å¥½çš„NULLæ£€æŸ¥
class BranchOptimization {
public:
  // åˆ©ç”¨likely/unlikelyå®ä¼˜åŒ–åˆ†æ”¯é¢„æµ‹
  static inline oop decode_with_prediction(narrowOop v) {
    if (LIKELY(v != 0)) {  // å¤§å¤šæ•°æƒ…å†µä¸‹ä¸æ˜¯NULL
      return CompressedOops::decode_not_null(v);
    } else {
      return (oop)NULL;
    }
  }
  
  // æ‰¹é‡å¤„ç†ä¼˜åŒ–
  static void decode_array(narrowOop* src, oop* dst, size_t count) {
    for (size_t i = 0; i < count; i++) {
      // ç¼–è¯‘å™¨å¯ä»¥å‘é‡åŒ–è¿™ä¸ªå¾ªç¯
      dst[i] = CompressedOops::decode(src[i]);
    }
  }
};
```

## ğŸ”§ å†…å­˜å¸ƒå±€å½±å“åˆ†æ

### 1. å¯¹è±¡å¤´å¸ƒå±€

```cpp
// å‹ç¼©æŒ‡é’ˆå¯¹å¯¹è±¡å¤´çš„å½±å“
class ObjectHeaderLayout {
public:
  // æœªå‹ç¼©æ¨¡å¼çš„å¯¹è±¡å¤´ (16å­—èŠ‚)
  struct UncompressedHeader {
    markOop _mark;    // 8å­—èŠ‚ - æ ‡è®°å­—
    Klass*  _klass;   // 8å­—èŠ‚ - ç±»æŒ‡é’ˆ
  };
  
  // å‹ç¼©æ¨¡å¼çš„å¯¹è±¡å¤´ (12å­—èŠ‚)
  struct CompressedHeader {
    markOop     _mark;           // 8å­—èŠ‚ - æ ‡è®°å­—
    narrowKlass _compressed_klass; // 4å­—èŠ‚ - å‹ç¼©ç±»æŒ‡é’ˆ
  };
  
  // èŠ‚çœçš„ç©ºé—´
  static constexpr size_t space_saved_per_object = 
    sizeof(UncompressedHeader) - sizeof(CompressedHeader); // 4å­—èŠ‚
};
```

### 2. æ•°ç»„å¸ƒå±€ä¼˜åŒ–

```cpp
// å¯¹è±¡æ•°ç»„çš„å†…å­˜å¸ƒå±€
template<typename T>
class ArrayLayout {
public:
  // è®¡ç®—æ•°ç»„å¤§å°
  static size_t calculate_size(int length) {
    size_t header_size = sizeof(arrayOopDesc);
    size_t element_size = UseCompressedOops ? sizeof(narrowOop) : sizeof(oop);
    return header_size + length * element_size;
  }
  
  // 8GBå †ä¸­1000ä¸‡ä¸ªå¼•ç”¨çš„æ•°ç»„
  static void analyze_large_array() {
    const int array_length = 10000000;  // 1000ä¸‡ä¸ªå…ƒç´ 
    
    size_t uncompressed_size = sizeof(arrayOopDesc) + array_length * sizeof(oop);
    size_t compressed_size = sizeof(arrayOopDesc) + array_length * sizeof(narrowOop);
    
    printf("1000ä¸‡å…ƒç´ æ•°ç»„å¤§å°:\n");
    printf("  æœªå‹ç¼©: %lu MB\n", uncompressed_size / (1024*1024));  // ~76MB
    printf("  å‹ç¼©å: %lu MB\n", compressed_size / (1024*1024));    // ~38MB
    printf("  èŠ‚çœ: %lu MB (%.1f%%)\n", 
           (uncompressed_size - compressed_size) / (1024*1024),
           (double)(uncompressed_size - compressed_size) / uncompressed_size * 100);
  }
};
```

### 3. ç¼“å­˜è¡Œä¼˜åŒ–

```cpp
// ç¼“å­˜è¡Œåˆ©ç”¨ç‡åˆ†æ
class CacheLineOptimization {
public:
  static constexpr size_t CACHE_LINE_SIZE = 64;  // å…¸å‹CPUç¼“å­˜è¡Œå¤§å°
  
  // æœªå‹ç¼©æŒ‡é’ˆæ•°ç»„çš„ç¼“å­˜è¡Œåˆ©ç”¨ç‡
  static void analyze_uncompressed_cache_efficiency() {
    size_t pointers_per_cache_line = CACHE_LINE_SIZE / sizeof(oop);  // 8ä¸ªæŒ‡é’ˆ
    printf("æœªå‹ç¼©æ¨¡å¼: %luä¸ªæŒ‡é’ˆ/ç¼“å­˜è¡Œ\n", pointers_per_cache_line);
  }
  
  // å‹ç¼©æŒ‡é’ˆæ•°ç»„çš„ç¼“å­˜è¡Œåˆ©ç”¨ç‡  
  static void analyze_compressed_cache_efficiency() {
    size_t pointers_per_cache_line = CACHE_LINE_SIZE / sizeof(narrowOop);  // 16ä¸ªæŒ‡é’ˆ
    printf("å‹ç¼©æ¨¡å¼: %luä¸ªæŒ‡é’ˆ/ç¼“å­˜è¡Œ\n", pointers_per_cache_line);
    printf("ç¼“å­˜æ•ˆç‡æå‡: 100%%\n");
  }
};
```

## ğŸ› ï¸ è°ƒè¯•å’Œç›‘æ§å·¥å…·

### GDBè°ƒè¯•è„šæœ¬

```gdb
# å‹ç¼©æŒ‡é’ˆé…ç½®æ£€æŸ¥
define compressed_oops_info
  printf "Compressed OOPs Configuration:\n"
  printf "  UseCompressedOops: %s\n", UseCompressedOops ? "true" : "false"
  printf "  Base address: %p\n", Universe::_narrow_oop._base
  printf "  Shift amount: %d\n", Universe::_narrow_oop._shift
  printf "  Use implicit null checks: %s\n", Universe::_narrow_oop._use_implicit_null_checks ? "true" : "false"
  printf "  Mode: %d\n", Universe::narrow_oop_mode()
end

# å‹ç¼©æŒ‡é’ˆè½¬æ¢æµ‹è¯•
define test_oop_conversion
  set $addr = (oop)$arg0
  set $narrow = CompressedOops::encode($addr)
  set $decoded = CompressedOops::decode($narrow)
  
  printf "Address conversion test:\n"
  printf "  Original: %p\n", $addr
  printf "  Compressed: 0x%08x\n", $narrow
  printf "  Decoded: %p\n", $decoded
  printf "  Match: %s\n", ($addr == $decoded) ? "YES" : "NO"
end

# å¯¹è±¡å¤´åˆ†æ
define analyze_object_header
  set $obj = (oop)$arg0
  printf "Object header analysis:\n"
  printf "  Object address: %p\n", $obj
  printf "  Mark word: %p\n", $obj->_mark
  
  if UseCompressedOops
    printf "  Compressed klass: 0x%08x\n", $obj->_metadata._compressed_klass
    set $klass = CompressedOops::decode($obj->_metadata._compressed_klass)
    printf "  Decoded klass: %p\n", $klass
  else
    printf "  Klass pointer: %p\n", $obj->_metadata._klass
  end
end
```

### æ€§èƒ½æµ‹è¯•å·¥å…·

```cpp
// å‹ç¼©æŒ‡é’ˆæ€§èƒ½åŸºå‡†æµ‹è¯•
class CompressedOopsPerformanceTest {
private:
  static constexpr size_t TEST_SIZE = 10000000;  // 1000ä¸‡æ¬¡æ“ä½œ
  
public:
  // ç¼–ç æ€§èƒ½æµ‹è¯•
  static void benchmark_encoding() {
    oop* objects = new oop[TEST_SIZE];
    narrowOop* compressed = new narrowOop[TEST_SIZE];
    
    // åˆå§‹åŒ–æµ‹è¯•æ•°æ®
    for (size_t i = 0; i < TEST_SIZE; i++) {
      objects[i] = (oop)(Universe::heap()->base() + i * 8);
    }
    
    // ç¼–ç æ€§èƒ½æµ‹è¯•
    auto start = std::chrono::high_resolution_clock::now();
    for (size_t i = 0; i < TEST_SIZE; i++) {
      compressed[i] = CompressedOops::encode(objects[i]);
    }
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
    double avg_latency = (double)duration.count() / TEST_SIZE;
    
    printf("Encoding performance: %.2f ns/operation\n", avg_latency);
    
    delete[] objects;
    delete[] compressed;
  }
  
  // è§£ç æ€§èƒ½æµ‹è¯•
  static void benchmark_decoding() {
    narrowOop* compressed = new narrowOop[TEST_SIZE];
    oop* decoded = new oop[TEST_SIZE];
    
    // åˆå§‹åŒ–æµ‹è¯•æ•°æ®
    for (size_t i = 0; i < TEST_SIZE; i++) {
      compressed[i] = (narrowOop)i;
    }
    
    // è§£ç æ€§èƒ½æµ‹è¯•
    auto start = std::chrono::high_resolution_clock::now();
    for (size_t i = 0; i < TEST_SIZE; i++) {
      decoded[i] = CompressedOops::decode(compressed[i]);
    }
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
    double avg_latency = (double)duration.count() / TEST_SIZE;
    
    printf("Decoding performance: %.2f ns/operation\n", avg_latency);
    
    delete[] compressed;
    delete[] decoded;
  }
};
```

## ğŸ“ å…³é”®å‘ç°æ€»ç»“

1. **ç®—æ³•ç®€æ´**: å‹ç¼©æŒ‡é’ˆçš„ç¼–è§£ç ç®—æ³•æå…¶ç®€æ´ï¼Œä»…éœ€ä½ç§»å’ŒåŠ å‡è¿ç®—
2. **Zero-basedä¼˜åŒ–**: 8GBå †ä½¿ç”¨Zero-basedæ¨¡å¼ï¼Œçœç•¥åŸºåœ°å€è¿ç®—ï¼Œæ€§èƒ½æœ€ä¼˜
3. **å†…å­˜èŠ‚çœ**: 50%çš„æŒ‡é’ˆç©ºé—´èŠ‚çœï¼Œæ˜¾è‘—å‡å°‘å†…å­˜ä½¿ç”¨å’Œæå‡ç¼“å­˜æ•ˆç‡
4. **æ€§èƒ½å½±å“**: ç¼–è§£ç å¼€é”€ < 0.1nsï¼ŒJITä¼˜åŒ–åæ¥è¿‘åŸç”ŸæŒ‡é’ˆæ€§èƒ½
5. **ç¼“å­˜å‹å¥½**: ç¼“å­˜è¡Œåˆ©ç”¨ç‡æå‡100%ï¼Œæ˜¾è‘—æ”¹å–„å†…å­˜è®¿é—®æ€§èƒ½
6. **æºç éªŒè¯**: æ‰€æœ‰åˆ†æéƒ½åŸºäºOpenJDK11çš„å®é™…æºç å®ç°

å‹ç¼©æŒ‡é’ˆæŠ€æœ¯åœ¨8GB G1å †é…ç½®ä¸‹å±•ç°äº†å“è¶Šçš„å·¥ç¨‹è®¾è®¡ï¼Œé€šè¿‡ç²¾å¦™çš„ç®—æ³•å’Œä¼˜åŒ–æŠ€æœ¯ï¼Œåœ¨èŠ‚çœå¤§é‡å†…å­˜çš„åŒæ—¶ä¿æŒäº†ä¼˜ç§€çš„æ€§èƒ½ç‰¹å¾ï¼Œæ˜¯ç°ä»£JVMå†…å­˜ç®¡ç†çš„é‡è¦åˆ›æ–°ã€‚