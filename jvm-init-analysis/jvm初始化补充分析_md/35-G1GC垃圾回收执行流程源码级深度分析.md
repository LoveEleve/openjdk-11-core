# G1 GC 垃圾回收执行流程源码级深度分析

> 基于OpenJDK 11源码验证，8GB堆配置（-Xms=Xmx=8GB），非大页，非NUMA

## 1. G1 GC 整体工作流程概览

### 1.1 GC类型分类

```
G1 GC工作模式
├── Young GC (Minor GC)
│   ├── Pause Young (Normal)     - 常规Young GC
│   ├── Pause Young (Concurrent Start) - 触发并发标记的Young GC
│   └── Pause Young (Prepare Mixed)    - 为Mixed GC做准备
├── Mixed GC
│   └── Pause Young (Mixed)      - 混合回收Young + Old区
├── Concurrent Marking           - 并发标记周期
│   ├── Concurrent Clear Claimed Marks
│   ├── Concurrent Scan Root Regions
│   ├── Concurrent Mark
│   ├── Remark (STW)
│   ├── Concurrent Rebuild Remembered Sets
│   └── Cleanup (STW)
└── Full GC
    └── Pause Full               - 完整压缩式GC
```

### 1.2 GC触发入口源码

```cpp
// 源码位置: g1CollectedHeap.cpp:2742-2762
HeapWord* G1CollectedHeap::do_collection_pause(size_t word_size,
                                               uint gc_count_before,
                                               bool* succeeded,
                                               GCCause::Cause gc_cause) {
  assert_heap_not_locked_and_not_at_safepoint();
  
  // 创建VM操作对象
  VM_G1CollectForAllocation op(word_size,
                               gc_count_before,
                               gc_cause,
                               false, /* should_initiate_conc_mark */
                               g1_policy()->max_pause_time_ms());
  
  // 在VMThread中执行GC
  VMThread::execute(&op);
  
  HeapWord* result = op.result();
  bool ret_succeeded = op.prologue_succeeded() && op.pause_succeeded();
  *succeeded = ret_succeeded;
  return result;
}
```

## 2. Young GC 完整执行流程

### 2.1 GC入口 - VM_G1CollectForAllocation

```cpp
// 源码位置: vm_operations_g1.cpp:75-158
void VM_G1CollectForAllocation::doit() {
  G1CollectedHeap* g1h = G1CollectedHeap::heap();
  
  // Step 1: 尝试在safepoint分配
  if (_word_size > 0) {
    _result = g1h->attempt_allocation_at_safepoint(_word_size,
                                                   false /* expect_null_cur_alloc_region */);
    if (_result != NULL) {
      _pause_succeeded = true;
      return;  // 分配成功，无需GC
    }
  }
  
  // Step 2: 设置GC原因
  GCCauseSetter x(g1h, _gc_cause);
  
  // Step 3: 处理并发标记启动
  if (_should_initiate_conc_mark) {
    _old_marking_cycles_completed_before = g1h->old_marking_cycles_completed();
    bool res = g1h->g1_policy()->force_initial_mark_if_outside_cycle(_gc_cause);
    // ...
  }
  
  // Step 4: 执行GC暂停
  _pause_succeeded = g1h->do_collection_pause_at_safepoint(_target_pause_time_ms);
  
  // Step 5: 如果GC成功但分配仍失败，执行satisfy_failed_allocation
  if (_pause_succeeded && _word_size > 0) {
    _result = g1h->satisfy_failed_allocation(_word_size, &_pause_succeeded);
  }
}
```

### 2.2 核心暂停方法 - do_collection_pause_at_safepoint

```cpp
// 源码位置: g1CollectedHeap.cpp:3035-3300
bool G1CollectedHeap::do_collection_pause_at_safepoint(double target_pause_time_ms) {
  assert_at_safepoint_on_vm_thread();
  
  // 检查GC Locker
  if (GCLocker::check_active_before_gc()) {
    return false;
  }
  
  // ========== 阶段1: GC准备 ==========
  _gc_timer_stw->register_gc_start();
  g1_policy()->note_gc_start();
  
  // 等待Root Region扫描完成
  wait_for_root_region_scanning();
  
  // 决定是否启动并发标记
  if (!_cm_thread->should_terminate()) {
    g1_policy()->decide_on_conc_mark_initiation();
  }
  
  bool should_start_conc_mark = collector_state()->in_initial_mark_gc();
  
  // 确定GC类型字符串
  FormatBuffer<> gc_string("Pause Young ");
  if (collector_state()->in_initial_mark_gc()) {
    gc_string.append("(Concurrent Start)");
  } else if (collector_state()->in_young_only_phase()) {
    if (collector_state()->in_young_gc_before_mixed()) {
      gc_string.append("(Prepare Mixed)");
    } else {
      gc_string.append("(Normal)");
    }
  } else {
    gc_string.append("(Mixed)");
  }
  
  // 计算活跃worker数量
  uint active_workers = AdaptiveSizePolicy::calc_active_workers(
      workers()->total_workers(),
      workers()->active_workers(),
      Threads::number_of_non_daemon_threads());
  active_workers = workers()->update_active_workers(active_workers);
  
  // ========== 阶段2: GC Prologue ==========
  gc_prologue(false);
  _ref_processor_stw->enable_discovery();
  
  // 释放Mutator分配区域
  _allocator->release_mutator_alloc_region();
  
  // ========== 阶段3: 确定Collection Set ==========
  g1_policy()->record_collection_pause_start(sample_start_time_sec);
  
  if (collector_state()->in_initial_mark_gc()) {
    concurrent_mark()->pre_initial_mark();
  }
  
  // 最终确定Collection Set
  g1_policy()->finalize_collection_set(target_pause_time_ms, &_survivor);
  
  // 清理RemSet
  g1_rem_set()->cleanupHRRS();
  
  // 注册Humongous区域
  register_humongous_regions_with_cset();
  
  // 初始化GC分配区域
  _allocator->init_gc_alloc_regions(evacuation_info);
  
  // ========== 阶段4: 执行Evacuation ==========
  G1ParScanThreadStateSet per_thread_states(this, workers()->active_workers(), 
                                             collection_set()->young_region_length());
  
  pre_evacuate_collection_set();      // 预处理
  evacuate_collection_set(&per_thread_states);  // 核心Evacuation
  post_evacuate_collection_set(evacuation_info, &per_thread_states);  // 后处理
  
  // ========== 阶段5: 释放Collection Set ==========
  free_collection_set(&_collection_set, evacuation_info, surviving_young_words);
  
  // 快速回收Humongous对象
  eagerly_reclaim_humongous_regions();
  
  // 调整PLAB大小
  _survivor_evac_stats.adjust_desired_plab_sz();
  _old_evac_stats.adjust_desired_plab_sz();
  
  // 开始新的Collection Set
  start_new_collection_set();
  
  // ========== 阶段6: Initial Mark处理 ==========
  if (collector_state()->in_initial_mark_gc()) {
    concurrent_mark()->post_initial_mark();
  }
  
  // 初始化Mutator分配区域
  _allocator->init_mutator_alloc_region();
  
  // 堆扩展检查
  size_t expand_bytes = _heap_sizing_policy->expansion_amount();
  if (expand_bytes > 0) {
    expand(expand_bytes, _workers, &expand_ms);
  }
  
  // 记录暂停结束
  g1_policy()->record_collection_pause_end(pause_time_ms, total_cards_scanned, 
                                           heap_used_bytes_before_gc);
  
  // 启动并发标记
  if (should_start_conc_mark) {
    do_concurrent_mark();
  }
  
  return true;
}
```

### 2.3 Evacuation核心流程

#### 2.3.1 pre_evacuate_collection_set

```cpp
// 源码位置: g1CollectedHeap.cpp:4251-4271
void G1CollectedHeap::pre_evacuate_collection_set() {
  _expand_heap_after_alloc_failure = true;
  _evacuation_failed = false;
  
  // 禁用Hot Card Cache
  _hot_card_cache->reset_hot_cache_claimed_index();
  _hot_card_cache->set_use_cache(false);
  
  // 准备RemSet处理
  g1_rem_set()->prepare_for_oops_into_collection_set_do();
  _preserved_marks_set.assert_empty();
  
  // Initial Mark需要清理claimed marks
  if (collector_state()->in_initial_mark_gc()) {
    ClassLoaderDataGraph::clear_claimed_marks();
  }
}
```

#### 2.3.2 evacuate_collection_set - 核心并行任务

```cpp
// 源码位置: g1CollectedHeap.cpp:4275-4309
void G1CollectedHeap::evacuate_collection_set(G1ParScanThreadStateSet* per_thread_states) {
  assert(dirty_card_queue_set().completed_buffers_num() == 0, "Should be empty");
  
  G1GCPhaseTimes* phase_times = g1_policy()->phase_times();
  double start_par_time_sec = os::elapsedTime();
  
  {
    const uint n_workers = workers()->active_workers();
    G1RootProcessor root_processor(this, n_workers);
    
    // 创建并行任务
    G1ParTask g1_par_task(this, per_thread_states, _task_queues, 
                          &root_processor, n_workers);
    
    // 执行并行任务
    workers()->run_task(&g1_par_task);
  }
  
  double end_par_time_sec = os::elapsedTime();
  phase_times->record_par_time((end_par_time_sec - start_par_time_sec) * 1000.0);
}
```

#### 2.3.3 G1ParTask - 并行Worker任务

```cpp
// 源码位置: g1CollectedHeap.cpp:3406-3486
class G1ParTask : public AbstractGangTask {
  G1CollectedHeap*         _g1h;
  G1ParScanThreadStateSet* _pss;
  RefToScanQueueSet*       _queues;
  G1RootProcessor*         _root_processor;
  ParallelTaskTerminator   _terminator;
  uint                     _n_workers;

public:
  void work(uint worker_id) {
    if (worker_id >= _n_workers) return;
    
    ResourceMark rm;
    HandleMark   hm;
    
    G1ParScanThreadState* pss = _pss->state_for_worker(worker_id);
    pss->set_ref_discoverer(_g1h->ref_processor_stw());
    
    // ========== Step 1: 处理GC Roots ==========
    double start_strong_roots_sec = os::elapsedTime();
    _root_processor->evacuate_roots(pss, worker_id);
    
    // ========== Step 2: 处理RemSet ==========
    _g1h->g1_rem_set()->oops_into_collection_set_do(pss, worker_id);
    double strong_roots_sec = os::elapsedTime() - start_strong_roots_sec;
    
    // ========== Step 3: 对象复制和工作窃取 ==========
    {
      G1ParEvacuateFollowersClosure evac(_g1h, pss, _queues, &_terminator);
      evac.do_void();  // 执行对象复制
      
      evac_term_attempts = evac.term_attempts();
      term_sec = evac.term_time();
    }
  }
};
```

### 2.4 GC Roots处理详情

```cpp
// 源码位置: g1RootProcessor.cpp:79-119
void G1RootProcessor::evacuate_roots(G1ParScanThreadState* pss, uint worker_i) {
  G1GCPhaseTimes* phase_times = _g1h->g1_policy()->phase_times();
  G1EvacPhaseTimesTracker timer(phase_times, pss, G1GCPhaseTimes::ExtRootScan, worker_i);
  
  G1EvacuationRootClosures* closures = pss->closures();
  
  // 处理Java Roots
  process_java_roots(closures, phase_times, worker_i);
  
  // 报告强CLD发现完成
  if (closures->trace_metadata()) {
    worker_has_discovered_all_strong_classes();
  }
  
  // 处理VM Roots
  process_vm_roots(closures, phase_times, worker_i);
  
  // 处理String Table Roots
  process_string_table_roots(closures, phase_times, worker_i);
  
  // 处理CM引用处理器roots
  if (!_process_strong_tasks.is_task_claimed(G1RP_PS_refProcessor_oops_do)) {
    _g1h->ref_processor_cm()->weak_oops_do(closures->strong_oops());
  }
  
  // 等待所有worker完成强CLD发现
  if (closures->trace_metadata()) {
    wait_until_all_strong_classes_discovered();
    // 处理弱CLD roots
    ClassLoaderDataGraph::roots_cld_do(NULL, closures->second_pass_weak_clds());
  }
}
```

**GC Roots类型枚举:**
```cpp
// 源码位置: g1RootProcessor.hpp:59-74
enum G1H_process_roots_tasks {
  G1RP_PS_Universe_oops_do,           // Universe
  G1RP_PS_JNIHandles_oops_do,         // JNI Handles
  G1RP_PS_ObjectSynchronizer_oops_do, // 同步器
  G1RP_PS_Management_oops_do,         // 管理接口
  G1RP_PS_SystemDictionary_oops_do,   // 系统字典
  G1RP_PS_ClassLoaderDataGraph_oops_do, // ClassLoader数据
  G1RP_PS_jvmti_oops_do,              // JVMTI
  G1RP_PS_CodeCache_oops_do,          // 代码缓存
  G1RP_PS_aot_oops_do,                // AOT
  G1RP_PS_filter_satb_buffers,        // SATB缓冲
  G1RP_PS_refProcessor_oops_do,       // 引用处理器
  G1RP_PS_weakProcessor_oops_do,      // 弱引用处理器
  G1RP_PS_NumElements
};
```

### 2.5 对象复制核心 - copy_to_survivor_space

```cpp
// 源码位置: g1ParScanThreadState.cpp:214-324
oop G1ParScanThreadState::copy_to_survivor_space(InCSetState const state,
                                                 oop const old,
                                                 markOop const old_mark) {
  const size_t word_sz = old->size();
  HeapRegion* const from_region = _g1h->heap_region_containing(old);
  const int young_index = from_region->young_index_in_cset()+1;
  
  // ========== Step 1: 确定目标Generation和Age ==========
  uint age = 0;
  InCSetState dest_state = next_state(state, old_mark, age);
  
  // 检查Old Gen是否已满
  if (_old_gen_is_full && dest_state.is_old()) {
    return handle_evacuation_failure_par(old, old_mark);
  }
  
  // ========== Step 2: PLAB分配 ==========
  HeapWord* obj_ptr = _plab_allocator->plab_allocate(dest_state, word_sz);
  
  if (obj_ptr == NULL) {
    bool plab_refill_failed = false;
    obj_ptr = _plab_allocator->allocate_direct_or_new_plab(dest_state, word_sz, 
                                                           &plab_refill_failed);
    if (obj_ptr == NULL) {
      obj_ptr = allocate_in_next_plab(state, &dest_state, word_sz, plab_refill_failed);
      if (obj_ptr == NULL) {
        // Evacuation失败
        return handle_evacuation_failure_par(old, old_mark);
      }
    }
  }
  
  // ========== Step 3: CAS设置forwarding pointer ==========
  Prefetch::write(obj_ptr, PrefetchCopyIntervalInBytes);
  
  const oop obj = oop(obj_ptr);
  const oop forward_ptr = old->forward_to_atomic(obj, memory_order_relaxed);
  
  if (forward_ptr == NULL) {
    // 成功获取转发权
    
    // ========== Step 4: 复制对象内容 ==========
    Copy::aligned_disjoint_words((HeapWord*) old, obj_ptr, word_sz);
    
    // ========== Step 5: 设置对象头和Age ==========
    if (dest_state.is_young()) {
      if (age < markOopDesc::max_age) {
        age++;
      }
      obj->set_mark_raw(old_mark->set_age(age));
      _age_table.add(age, word_sz);
    } else {
      obj->set_mark_raw(old_mark);
    }
    
    // ========== Step 6: String去重处理 ==========
    if (G1StringDedup::is_enabled()) {
      G1StringDedup::enqueue_from_evacuation(is_from_young, is_to_young, 
                                             _worker_id, obj);
    }
    
    // 更新存活统计
    _surviving_young_words[young_index] += word_sz;
    
    // ========== Step 7: 扫描复制后的对象 ==========
    if (obj->is_objArray() && arrayOop(obj)->length() >= ParGCArrayScanChunk) {
      // 大数组分块处理
      arrayOop(obj)->set_length(0);
      oop* old_p = set_partial_array_mask(old);
      do_oop_partial_array(old_p);
    } else {
      // 常规对象扫描
      HeapRegion* const to_region = _g1h->heap_region_containing(obj_ptr);
      _scanner.set_region(to_region);
      obj->oop_iterate_backwards(&_scanner);
    }
    
    return obj;
  } else {
    // 其他线程已设置forwarding pointer
    _plab_allocator->undo_allocation(dest_state, obj_ptr, word_sz);
    return forward_ptr;
  }
}
```

### 2.6 RemSet处理

```cpp
// 源码位置: g1RemSet.cpp:547-566
void G1RemSet::oops_into_collection_set_do(G1ParScanThreadState* pss, uint worker_i) {
  // Step 1: 更新RemSet (处理dirty cards)
  update_rem_set(pss, worker_i);
  
  // Step 2: 扫描RemSet
  scan_rem_set(pss, worker_i);
}

void G1RemSet::prepare_for_oops_into_collection_set_do() {
  DirtyCardQueueSet& dcqs = G1BarrierSet::dirty_card_queue_set();
  dcqs.concatenate_logs();  // 合并所有dirty card logs
  _scan_state->reset();
}

void G1RemSet::cleanup_after_oops_into_collection_set_do() {
  // 清理卡表
  _scan_state->clear_card_table(_g1h->workers());
}
```

### 2.7 post_evacuate_collection_set

```cpp
// 源码位置: g1CollectedHeap.cpp:4311-4380
void G1CollectedHeap::post_evacuate_collection_set(EvacuationInfo& evacuation_info, 
                                                    G1ParScanThreadStateSet* per_thread_states) {
  // 清理RemSet
  g1_rem_set()->cleanup_after_oops_into_collection_set_do();
  
  // 处理发现的引用对象
  process_discovered_references(per_thread_states);
  
  // 处理弱引用
  G1STWIsAliveClosure is_alive(this);
  G1KeepAliveClosure keep_alive(this);
  
  // 处理JNI弱引用
  {
    GCTraceTime(Debug, gc, phases) debug("Weak Processing", _gc_timer_stw);
    WeakProcessor::weak_oops_do(workers(), &is_alive, &keep_alive, 1);
  }
  
  // 确保Initial Mark的pending list可达
  if (collector_state()->in_initial_mark_gc()) {
    make_pending_list_reachable();
  }
  
  // 合并per-thread状态
  merge_per_thread_state_info(per_thread_states);
  
  // 处理Evacuation失败
  if (evacuation_failed()) {
    // 清理failed regions
    restore_after_evac_failure();
    // 清理preserved marks
    _preserved_marks_set.restore(workers());
  }
  
  // 重新dirty已分配区域的卡表
  {
    GCTraceTime(Debug, gc, phases) debug("Redirty Cards", _gc_timer_stw);
    redirty_logged_cards();
  }
  
  // 处理String去重
  if (G1StringDedup::is_enabled()) {
    G1StringDedup::unlink_or_oops_do(...);
  }
}
```

## 3. 并发标记周期 (Concurrent Marking Cycle)

### 3.1 并发标记线程主循环

```cpp
// 源码位置: g1ConcurrentMarkThread.cpp:247-404
void G1ConcurrentMarkThread::run_service() {
  _vtime_start = os::elapsedVTime();
  G1CollectedHeap* g1h = G1CollectedHeap::heap();
  G1Policy* g1_policy = g1h->g1_policy();
  
  G1ConcPhaseManager cpmanager(G1ConcurrentPhase::IDLE, this);
  
  while (!should_terminate()) {
    // 等待启动信号
    sleep_before_next_cycle();
    if (should_terminate()) break;
    
    cpmanager.set_phase(G1ConcurrentPhase::CONCURRENT_CYCLE, false);
    _cm->concurrent_cycle_start();
    
    // ========== Phase 1: Clear Claimed Marks ==========
    {
      G1ConcPhase p(G1ConcurrentPhase::CLEAR_CLAIMED_MARKS, this);
      ClassLoaderDataGraph::clear_claimed_marks();
    }
    
    // ========== Phase 2: Scan Root Regions ==========
    {
      G1ConcPhase p(G1ConcurrentPhase::SCAN_ROOT_REGIONS, this);
      _cm->scan_root_regions();
    }
    
    // ========== Phase 3: Concurrent Mark (可能多次迭代) ==========
    {
      G1ConcPhaseManager mark_manager(G1ConcurrentPhase::CONCURRENT_MARK, this);
      
      for (uint iter = 1; !_cm->has_aborted(); ++iter) {
        // 3.1 从roots开始标记
        {
          G1ConcPhase p(G1ConcurrentPhase::MARK_FROM_ROOTS, this);
          _cm->mark_from_roots();
        }
        if (_cm->has_aborted()) break;
        
        // 3.2 预清理 (可选)
        if (G1UseReferencePrecleaning) {
          G1ConcPhase p(G1ConcurrentPhase::PRECLEAN, this);
          _cm->preclean();
        }
        
        // 3.3 等待Remark时机 (MMU调度)
        delay_to_keep_mmu(g1_policy, true /* remark */);
        if (_cm->has_aborted()) break;
        
        // ========== Phase 4: Remark (STW) ==========
        mark_manager.set_phase(G1ConcurrentPhase::REMARK, false);
        CMRemark cl(_cm);
        VM_CGC_Operation op(&cl, "Pause Remark");
        VMThread::execute(&op);
        
        if (_cm->has_aborted()) break;
        else if (!_cm->restart_for_overflow()) break;  // 无溢出则退出
        
        // Mark Stack溢出，需要重新迭代
        log_info(gc, marking)("Restart for Mark Stack Overflow (iteration #%u)", iter);
      }
    }
    
    // ========== Phase 5: Rebuild Remembered Sets ==========
    if (!_cm->has_aborted()) {
      G1ConcPhase p(G1ConcurrentPhase::REBUILD_REMEMBERED_SETS, this);
      _cm->rebuild_rem_set_concurrently();
    }
    
    // 等待Cleanup时机
    if (!_cm->has_aborted()) {
      delay_to_keep_mmu(g1_policy, false /* cleanup */);
    }
    
    // ========== Phase 6: Cleanup (STW) ==========
    if (!_cm->has_aborted()) {
      CMCleanup cl_cl(_cm);
      VM_CGC_Operation op(&cl_cl, "Pause Cleanup");
      VMThread::execute(&op);
    }
    
    // ========== Phase 7: Cleanup for Next Mark ==========
    if (!_cm->has_aborted()) {
      G1ConcPhase p(G1ConcurrentPhase::CLEANUP_FOR_NEXT_MARK, this);
      _cm->cleanup_for_next_mark();
    }
    
    // 更新完成计数
    g1h->increment_old_marking_cycles_completed(true /* concurrent */);
    _cm->concurrent_cycle_end();
    
    cpmanager.set_phase(G1ConcurrentPhase::IDLE, _cm->has_aborted());
  }
}
```

### 3.2 并发标记核心 - mark_from_roots

```cpp
// 源码位置: g1ConcurrentMark.cpp:997-1016
void G1ConcurrentMark::mark_from_roots() {
  _restart_for_overflow = false;
  
  // 计算并发标记worker数量
  _num_concurrent_workers = calc_active_marking_workers();
  uint active_workers = MAX2(1U, _num_concurrent_workers);
  active_workers = _concurrent_workers->update_active_workers(active_workers);
  
  log_info(gc, task)("Using %u workers of %u for marking", 
                     active_workers, _concurrent_workers->total_workers());
  
  // 设置并发状态
  set_concurrency_and_phase(active_workers, true /* concurrent */);
  
  // 执行并发标记任务
  G1CMConcurrentMarkingTask marking_task(this);
  _concurrent_workers->run_task(&marking_task);
  
  print_stats();
}
```

### 3.3 Remark暂停

```cpp
// 源码位置: g1ConcurrentMark.cpp:1163-1230
void G1ConcurrentMark::remark() {
  assert_at_safepoint_on_vm_thread();
  
  if (has_aborted()) return;
  
  g1p->record_concurrent_mark_remark_start();
  
  // 最终标记
  {
    GCTraceTime(Debug, gc, phases) debug("Finalize Marking", _gc_timer_cm);
    finalize_marking();
  }
  
  bool const mark_finished = !has_overflown();
  if (mark_finished) {
    // 处理弱引用
    weak_refs_work(false /* clear_all_soft_refs */);
    
    // 禁用SATB队列
    SATBMarkQueueSet& satb_mq_set = G1BarrierSet::satb_mark_queue_set();
    satb_mq_set.set_active_all_threads(false, true);
    
    // 刷新Task缓存
    flush_all_task_caches();
    
    // 交换位图 (next -> prev)
    swap_mark_bitmaps();
    
    // 更新RemSet跟踪
    G1UpdateRemSetTrackingBeforeRebuildTask cl(_g1h, this, num_workers);
    _g1h->workers()->run_task(&cl, num_workers);
    
    // 回收空Region
    reclaim_empty_regions();
    
    // 类卸载
    if (ClassUnloadingWithConcurrentMark) {
      // 类卸载处理...
    }
  }
  
  g1p->record_concurrent_mark_remark_end();
}
```

### 3.4 Cleanup暂停

```cpp
// 源码位置: g1ConcurrentMark.cpp:1380-1421
void G1ConcurrentMark::cleanup() {
  assert_at_safepoint_on_vm_thread();
  
  if (has_aborted()) return;
  
  g1p->record_concurrent_mark_cleanup_start();
  
  // 更新RemSet跟踪 (Rebuild后)
  {
    GCTraceTime(Debug, gc, phases) debug("Update Remembered Set Tracking After Rebuild", _gc_timer_cm);
    G1UpdateRemSetTrackingAfterRebuild cl(_g1h);
    _g1h->heap_region_iterate(&cl);
  }
  
  // 增加collection计数
  _g1h->increment_total_collections();
  
  g1p->record_concurrent_mark_cleanup_end();
}
```

### 3.5 IHOP触发条件

```cpp
// 源码位置: g1Policy.cpp:555-575
bool G1Policy::need_to_start_conc_mark(const char* source, size_t alloc_word_size) {
  // 如果即将开始Mixed阶段，不启动新周期
  if (about_to_start_mixed_phase()) {
    return false;
  }
  
  // 获取IHOP阈值
  size_t marking_initiating_used_threshold = _ihop_control->get_conc_mark_start_threshold();
  
  // 当前非Young代占用
  size_t cur_used_bytes = _g1h->non_young_capacity_bytes();
  size_t alloc_byte_size = alloc_word_size * HeapWordSize;
  size_t marking_request_bytes = cur_used_bytes + alloc_byte_size;
  
  bool result = false;
  // 如果超过阈值且在Young Only阶段
  if (marking_request_bytes > marking_initiating_used_threshold) {
    result = collector_state()->in_young_only_phase() && 
             !collector_state()->in_young_gc_before_mixed();
  }
  
  return result;
}
```

## 4. Mixed GC

### 4.1 Collection Set构建

```cpp
// 源码位置: g1Policy.cpp:1167-1170
void G1Policy::finalize_collection_set(double target_pause_time_ms, 
                                        G1SurvivorRegions* survivor) {
  // 确定Young部分
  double time_remaining_ms = _collection_set->finalize_young_part(target_pause_time_ms, survivor);
  
  // 确定Old部分 (Mixed GC特有)
  _collection_set->finalize_old_part(time_remaining_ms);
}
```

### 4.2 Old Region选择策略

```cpp
// 源码位置: g1CollectionSet.cpp:410-485
void G1CollectionSet::finalize_old_part(double time_remaining_ms) {
  double non_young_start_time_sec = os::elapsedTime();
  double predicted_old_time_ms = 0.0;
  
  // 仅在Mixed阶段执行
  if (!collector_state()->in_mixed_phase()) {
    return;
  }
  
  cset_chooser()->verify();
  const uint min_old_cset_length = _policy->calc_min_old_cset_length();
  const uint max_old_cset_length = _policy->calc_max_old_cset_length();
  
  uint expensive_region_num = 0;
  bool check_time_remaining = _policy->adaptive_young_list_length();
  
  HeapRegion* hr = cset_chooser()->peek();
  while (hr != NULL) {
    // 检查1: 是否达到最大Old Region数量
    if (old_region_length() >= max_old_cset_length) {
      log_debug(gc, ergo, cset)("Finish adding old regions (max reached). old %u, max %u",
                                old_region_length(), max_old_cset_length);
      break;
    }
    
    // 检查2: 可回收空间是否低于阈值
    size_t reclaimable_bytes = cset_chooser()->remaining_reclaimable_bytes();
    double reclaimable_percent = _policy->reclaimable_bytes_percent(reclaimable_bytes);
    double threshold = (double) G1HeapWastePercent;  // 默认5%
    if (reclaimable_percent <= threshold) {
      log_debug(gc, ergo, cset)("Finish adding old regions (reclaimable below threshold). "
                                "reclaimable: " SIZE_FORMAT "B (%1.2f%%) threshold: %u%%",
                                reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);
      break;
    }
    
    // 检查3: 预测时间是否超出剩余时间
    double predicted_time_ms = predict_region_elapsed_time_ms(hr);
    if (check_time_remaining) {
      if (predicted_time_ms > time_remaining_ms) {
        if (old_region_length() >= min_old_cset_length) {
          log_debug(gc, ergo, cset)("Finish adding old regions (predicted time too high). "
                                    "predicted: %1.2fms, remaining: %1.2fms, old %u, min %u",
                                    predicted_time_ms, time_remaining_ms, 
                                    old_region_length(), min_old_cset_length);
          break;
        }
        expensive_region_num += 1;
      }
    }
    
    // 添加到Collection Set
    time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);
    add_old_region(hr);
    hr = cset_chooser()->pop();  // 获取下一个候选Region
  }
}
```

## 5. Full GC

### 5.1 Full GC入口

```cpp
// 源码位置: g1CollectedHeap.cpp:1130-1151
bool G1CollectedHeap::do_full_collection(bool explicit_gc, bool clear_all_soft_refs) {
  assert_at_safepoint_on_vm_thread();
  
  if (GCLocker::check_active_before_gc()) {
    return false;  // GC Locker活跃，无法执行Full GC
  }
  
  const bool do_clear_all_soft_refs = clear_all_soft_refs ||
      soft_ref_policy()->should_clear_all_soft_refs();
  
  // 创建Full GC收集器
  G1FullCollector collector(this, &_full_gc_memory_manager, 
                            explicit_gc, do_clear_all_soft_refs);
  
  GCTraceTime(Info, gc) tm("Pause Full", NULL, gc_cause(), true);
  
  // 执行Full GC三阶段
  collector.prepare_collection();
  collector.collect();
  collector.complete_collection();
  
  return true;
}
```

### 5.2 Full GC四阶段

```cpp
// 源码位置: g1FullCollector.cpp:167-179
void G1FullCollector::collect() {
  // Phase 1: 标记存活对象
  phase1_mark_live_objects();
  verify_after_marking();
  
  // 禁用派生指针
  deactivate_derived_pointers();
  
  // Phase 2: 准备压缩 (计算新地址)
  phase2_prepare_compaction();
  
  // Phase 3: 调整指针
  phase3_adjust_pointers();
  
  // Phase 4: 执行压缩
  phase4_do_compaction();
}
```

### 5.3 Phase 1: 标记存活对象

```cpp
// 源码位置: g1FullCollector.cpp:203-234
void G1FullCollector::phase1_mark_live_objects() {
  GCTraceTime(Info, gc, phases) info("Phase 1: Mark live objects", scope()->timer());
  
  // 并行标记
  G1FullGCMarkTask marking_task(this);
  run_task(&marking_task);
  
  // 处理引用
  G1FullGCReferenceProcessingExecutor reference_processing(this);
  reference_processing.execute(scope()->timer(), scope()->tracer());
  
  // 弱引用清理
  {
    GCTraceTime(Debug, gc, phases) trace("Phase 1: Weak Processing", scope()->timer());
    WeakProcessor::weak_oops_do(&_is_alive, &do_nothing_cl);
  }
  
  // 类卸载
  if (ClassUnloading) {
    GCTraceTime(Debug, gc, phases) debug("Phase 1: Class Unloading and Cleanup", scope()->timer());
    bool purged_class = SystemDictionary::do_unloading(scope()->timer());
    _heap->complete_cleaning(&_is_alive, purged_class);
  }
}
```

### 5.4 Phase 2: 准备压缩

```cpp
// 源码位置: g1FullCollector.cpp:236-245
void G1FullCollector::phase2_prepare_compaction() {
  GCTraceTime(Info, gc, phases) info("Phase 2: Prepare for compaction", scope()->timer());
  
  // 计算每个对象的新地址
  G1FullGCPrepareTask task(this);
  run_task(&task);
  
  // 如果没有释放任何region，使用串行压缩
  if (!task.has_freed_regions()) {
    task.prepare_serial_compaction();
  }
}
```

### 5.5 Phase 3: 调整指针

```cpp
// 源码位置: g1FullCollector.cpp:247-253
void G1FullCollector::phase3_adjust_pointers() {
  GCTraceTime(Info, gc, phases) info("Phase 3: Adjust pointers", scope()->timer());
  
  // 调整所有指针指向新地址
  G1FullGCAdjustTask task(this);
  run_task(&task);
}
```

### 5.6 Phase 4: 执行压缩

```cpp
// 源码位置: g1FullCollector.cpp:255-265
void G1FullCollector::phase4_do_compaction() {
  GCTraceTime(Info, gc, phases) info("Phase 4: Compact heap", scope()->timer());
  
  // 移动对象到新位置
  G1FullGCCompactTask task(this);
  run_task(&task);
  
  // 串行压缩剩余部分
  if (serial_compaction_point()->has_regions()) {
    task.serial_compaction();
  }
}
```

## 6. 分配失败处理

### 6.1 satisfy_failed_allocation流程

```cpp
// 源码位置: g1CollectedHeap.cpp:1271-1317
HeapWord* G1CollectedHeap::satisfy_failed_allocation(size_t word_size, bool* succeeded) {
  assert_at_safepoint_on_vm_thread();
  
  // 尝试1: 分配 + Full GC (不清理软引用)
  HeapWord* result = satisfy_failed_allocation_helper(word_size,
                                                       true,  /* do_gc */
                                                       false, /* clear_all_soft_refs */
                                                       false, /* expect_null_mutator_alloc_region */
                                                       succeeded);
  if (result != NULL || !*succeeded) {
    return result;
  }
  
  // 尝试2: 分配 + Full GC (清理软引用)
  result = satisfy_failed_allocation_helper(word_size,
                                            true,  /* do_gc */
                                            true,  /* clear_all_soft_refs */
                                            true,  /* expect_null_mutator_alloc_region */
                                            succeeded);
  if (result != NULL || !*succeeded) {
    return result;
  }
  
  // 尝试3: 仅分配 (不执行GC)
  result = satisfy_failed_allocation_helper(word_size,
                                            false, /* do_gc */
                                            false, /* clear_all_soft_refs */
                                            true,  /* expect_null_mutator_alloc_region */
                                            succeeded);
  
  return result;  // 可能为NULL (OOM)
}
```

### 6.2 satisfy_failed_allocation_helper

```cpp
// 源码位置: g1CollectedHeap.cpp:1239-1269
HeapWord* G1CollectedHeap::satisfy_failed_allocation_helper(size_t word_size,
                                                            bool do_gc,
                                                            bool clear_all_soft_refs,
                                                            bool expect_null_mutator_alloc_region,
                                                            bool* gc_succeeded) {
  *gc_succeeded = true;
  
  // Step 1: 尝试在safepoint分配
  HeapWord* result = attempt_allocation_at_safepoint(word_size, 
                                                      expect_null_mutator_alloc_region);
  if (result != NULL) {
    return result;
  }
  
  // Step 2: 尝试扩展堆
  result = expand_and_allocate(word_size);
  if (result != NULL) {
    return result;
  }
  
  // Step 3: 执行Full GC
  if (do_gc) {
    *gc_succeeded = do_full_collection(false /* explicit_gc */, clear_all_soft_refs);
  }
  
  return NULL;
}
```

## 7. GC各阶段时间统计

```cpp
// 源码位置: g1GCPhaseTimes.cpp:323-459
// GC暂停时间分解

// Pre Evacuate Collection Set
double G1GCPhaseTimes::print_pre_evacuate_collection_set() const {
  const double sum_ms = _root_region_scan_wait_time_ms +
                        _recorded_young_cset_choice_time_ms +
                        _recorded_non_young_cset_choice_time_ms +
                        _cur_fast_reclaim_humongous_register_time_ms +
                        _recorded_clear_claimed_marks_time_ms;
  // 包含: Root Region Scan Waiting, Prepare TLABs, Choose Collection Set, 
  //       Humongous Register, Clear Claimed Marks
  return sum_ms;
}

// Evacuate Collection Set
double G1GCPhaseTimes::print_evacuate_collection_set() const {
  const double sum_ms = _cur_collection_par_time_ms;
  // 包含: ExtRootScan, ThreadRoots, StringTableRoots, UniverseRoots, 
  //       JNIRoots, ObjectSynchronizerRoots, ManagementRoots,
  //       SystemDictionaryRoots, CLDGRoots, JVMTIRoots, CMRefRoots,
  //       UpdateRS, ScanHCC, ScanRS, CodeRoots, AOTCodeRoots,
  //       ObjCopy, Termination
  return sum_ms;
}

// Post Evacuate Collection Set
double G1GCPhaseTimes::print_post_evacuate_collection_set() const {
  const double sum_ms = evac_fail_handling +
                        _cur_collection_code_root_fixup_time_ms +
                        _recorded_preserve_cm_referents_time_ms +
                        _cur_ref_proc_time_ms +
                        _cur_weak_ref_proc_time_ms +
                        _cur_clear_ct_time_ms +
                        _recorded_merge_pss_time_ms +
                        _cur_strong_code_root_purge_time_ms +
                        _recorded_redirty_logged_cards_time_ms +
                        _recorded_total_free_cset_time_ms +
                        _cur_fast_reclaim_humongous_time_ms +
                        _cur_expand_heap_time_ms +
                        _cur_string_dedup_fixup_time_ms;
  // 包含: Code Roots Fixup, Preserve CM Referents, Reference Processing,
  //       Weak Processing, Clear Card Table, Merge Per-Thread State,
  //       Code Roots Purge, Redirty Cards, Free Collection Set,
  //       Humongous Reclaim, Expand Heap, String Dedup Fixup
  return sum_ms;
}
```

## 8. 8GB堆GC关键参数

### 8.1 GC相关默认参数

| 参数 | 默认值 | 说明 |
|-----|-------|------|
| MaxGCPauseMillis | 200ms | 目标最大暂停时间 |
| G1HeapWastePercent | 5% | 允许的堆浪费百分比 |
| G1MixedGCLiveThresholdPercent | 85% | Mixed GC存活率阈值 |
| G1MixedGCCountTarget | 8 | Mixed GC目标次数 |
| G1OldCSetRegionThresholdPercent | 10% | Old Region加入CSet的阈值 |
| InitiatingHeapOccupancyPercent | 45% | IHOP触发阈值 |
| G1ReservePercent | 10% | 保留空间百分比 |

### 8.2 8GB堆计算值

| 指标 | 计算值 |
|-----|-------|
| Region数量 | 2,048 |
| IHOP阈值 | 45% × 8GB = 3.6GB |
| 保留空间 | 10% × 8GB = 800MB |
| 浪费阈值 | 5% × 8GB = 400MB |

## 9. 总结

### 9.1 GC触发流程图

```
分配请求
    │
    ▼
Eden/TLAB分配
    │ 失败
    ▼
尝试扩展Eden ──► 成功 ──► 返回
    │ 失败
    ▼
触发Young GC (do_collection_pause)
    │
    ▼
VM_G1CollectForAllocation
    │
    ├─► 分配成功 ──► 返回
    │
    ▼
do_collection_pause_at_safepoint
    │
    ├─► 检查IHOP ──► 触发Concurrent Mark
    │
    ├─► 检查Mixed条件 ──► 执行Mixed GC
    │
    ▼
Evacuation失败? ──► satisfy_failed_allocation
    │                  │
    │                  ├─► 扩展堆
    │                  │
    │                  └─► Full GC
    ▼
返回结果
```

### 9.2 GC阶段耗时分布 (典型)

```
Young GC暂停 (~10-50ms):
├── Pre Evacuate:    5-10%
├── Evacuate CSet:   70-80%
│   ├── Root Scan:   20-30%
│   ├── RemSet Scan: 10-20%
│   ├── Object Copy: 40-50%
│   └── Termination: 5-10%
└── Post Evacuate:   10-15%

Concurrent Mark:
├── Scan Root Regions: 并发
├── Mark from Roots:   并发 (最长)
├── Remark (STW):      10-30ms
├── Rebuild RemSet:    并发
└── Cleanup (STW):     5-15ms

Full GC暂停 (数百ms到数秒):
├── Phase 1 Mark:    30-40%
├── Phase 2 Prepare: 10-15%
├── Phase 3 Adjust:  20-25%
└── Phase 4 Compact: 25-35%
```

### 9.3 关键源码文件

| 文件 | 核心功能 |
|-----|---------|
| g1CollectedHeap.cpp | GC主入口和协调 |
| g1ParScanThreadState.cpp | 对象复制核心 |
| g1RootProcessor.cpp | GC Roots处理 |
| g1RemSet.cpp | RemSet维护和扫描 |
| g1ConcurrentMark.cpp | 并发标记 |
| g1ConcurrentMarkThread.cpp | 并发标记线程 |
| g1Policy.cpp | GC策略决策 |
| g1CollectionSet.cpp | Collection Set管理 |
| g1FullCollector.cpp | Full GC实现 |
| vm_operations_g1.cpp | GC VM操作 |
