# G1辅助数据结构精确内存开销源码级分析

> **目标**: 精确计算8GB G1堆所有辅助数据结构的内存开销
> **环境**: -Xms8g -Xmx8g -XX:+UseG1GC, 64位Linux

## 一、并发标记位图(G1CMBitMap)精确计算

### 1.1 源码定义

**文件**: `src/hotspot/share/gc/g1/g1ConcurrentMarkBitMap.cpp`

```cpp:42:44:src/hotspot/share/gc/g1/g1ConcurrentMarkBitMap.cpp
size_t G1CMBitMap::mark_distance() {
  return MinObjAlignmentInBytes * BitsPerByte;
  // = 8 * 8 = 64 bytes
}
```

```cpp:38:40:src/hotspot/share/gc/g1/g1ConcurrentMarkBitMap.cpp
size_t G1CMBitMap::compute_size(size_t heap_size) {
  return ReservedSpace::allocation_align_size_up(heap_size / mark_distance());
}
```

### 1.2 关键参数

**文件**: `src/hotspot/share/runtime/arguments.cpp`

```cpp:1624:1625:src/hotspot/share/runtime/arguments.cpp
LogMinObjAlignmentInBytes = exact_log2(ObjectAlignmentInBytes);  // log₂(8) = 3
LogMinObjAlignment = LogMinObjAlignmentInBytes - LogHeapWordSize; // 3 - 3 = 0
```

**G1CMBitMap初始化**:
```cpp:91:src/hotspot/share/gc/g1/g1ConcurrentMarkBitMap.hpp
G1CMBitMap() : _covered(), _bm(), _shifter(LogMinObjAlignment), _listener() {}
// _shifter = LogMinObjAlignment = 0 (因为对象8字节对齐，HeapWord也是8字节)
```

### 1.3 精确计算

```
mark_distance计算:
  MinObjAlignmentInBytes = ObjectAlignmentInBytes = 8 bytes
  BitsPerByte = 8
  mark_distance = 8 * 8 = 64 bytes

含义: 每64字节堆内存对应1个标记位

单个位图大小:
  bitmap_size = heap_size / mark_distance
              = 8GB / 64
              = 8,589,934,592 / 64
              = 134,217,728 bits
              = 134,217,728 / 8 bytes
              = 16,777,216 bytes
              = 16 MB

G1使用两个位图(prev和next):
  总位图大小 = 16MB * 2 = 32 MB
```

### 1.4 位图创建源码

**文件**: `src/hotspot/share/gc/g1/g1CollectedHeap.cpp`

```cpp:1774:1782:src/hotspot/share/gc/g1/g1CollectedHeap.cpp
create_aux_memory_mapper("Prev Bitmap", bitmap_size, G1CMBitMap::heap_map_factor());
// ...
create_aux_memory_mapper("Next Bitmap", bitmap_size, G1CMBitMap::heap_map_factor());
```

---

## 二、CardTable精确计算

### 2.1 源码定义

**文件**: `src/hotspot/share/gc/shared/cardTable.hpp`

```cpp:232:237:src/hotspot/share/gc/shared/cardTable.hpp
enum SomePublicConstants {
  card_shift                  = 9,                           // 2^9 = 512
  card_size                   = 1 << card_shift,             // 512 bytes
  card_size_in_words          = card_size / sizeof(HeapWord) // 512/8 = 64 words
};
```

### 2.2 精确计算

```
卡表参数:
  card_size = 512 bytes (每张卡覆盖的堆内存)
  
卡表大小:
  cardtable_size = heap_size / card_size
                 = 8GB / 512
                 = 8,589,934,592 / 512
                 = 16,777,216 bytes
                 = 16 MB
```

### 2.3 卡值定义

**文件**: `src/hotspot/share/gc/shared/cardTable.hpp`

```cpp:96:107:src/hotspot/share/gc/shared/cardTable.hpp
enum CardValues {
  clean_card                  = -1,   // 0xFF - 干净
  clean_card_mask             = clean_card - 31,
  dirty_card                  =  0,   // 脏卡
  precleaned_card             =  1,   // 预清理
  claimed_card                =  2,   // 已认领
  deferred_card               =  4,   // 延迟处理
  last_card                   =  8,   // 最后一张
  CT_MR_BS_last_reserved      = 16
};
```

**G1特有卡值**:
```cpp:53:55:src/hotspot/share/gc/g1/g1CardTable.hpp
enum G1CardValues {
  g1_young_gen = CT_MR_BS_last_reserved << 1  // = 32, 年轻代标记
};
```

---

## 三、BlockOffsetTable(BOT)精确计算

### 3.1 源码定义

**文件**: `src/hotspot/share/gc/shared/blockOffsetTable.hpp`

```cpp:50:76:src/hotspot/share/gc/shared/blockOffsetTable.hpp
class BOTConstants : public AllStatic {
public:
  static const uint LogN = 9;                    // log₂(512)
  static const uint LogN_words = LogN - LogHeapWordSize;  // 9 - 3 = 6
  static const uint N_bytes = 1 << LogN;         // 512 bytes
  static const uint N_words = 1 << LogN_words;   // 64 words
  
  // 跳跃编码
  static const uint LogBase = 4;                 // 跳跃基数的对数
  static const uint Base = (1 << LogBase);       // 16
  static const uint N_powers = 14;               // 最大跳跃级别
};
```

### 3.2 精确计算

```
BOT参数:
  N_bytes = 512 bytes (每个BOT条目覆盖的堆内存)
  每个条目大小 = 1 byte (u_char)

BOT总大小:
  bot_size = heap_size / N_bytes
           = 8GB / 512
           = 16,777,216 bytes
           = 16 MB
```

### 3.3 BOT条目编码规则

```
条目值范围: 0-77 (u_char, 实际使用0到64+13=77)

编码规则:
  value < 64 (N_words):
    - 直接偏移量，单位是words
    - 向前偏移 value 个words
    
  value >= 64:
    - 跳跃编码
    - 向前跳跃 16^(value-64) 张卡
    - 例如: 64 -> 跳1卡, 65 -> 跳16卡, 66 -> 跳256卡
```

---

## 四、RememberedSet(RemSet)精确计算

### 4.1 RemSet结构组成

**文件**: `src/hotspot/share/gc/g1/heapRegionRemSet.hpp`

```cpp:74:103:src/hotspot/share/gc/g1/heapRegionRemSet.hpp
class OtherRegionsTable {
  CHeapBitMap _coarse_map;           // 粗粒度位图
  size_t      _n_coarse_entries;
  
  PerRegionTable** _fine_grain_regions;  // 细粒度表数组
  size_t           _n_fine_entries;
  
  SparsePRT   _sparse_table;         // 稀疏PRT
};
```

### 4.2 RemSet大小计算公式

**文件**: `src/hotspot/share/gc/g1/heapRegionRemSet.cpp`

```cpp:630:642:src/hotspot/share/gc/g1/heapRegionRemSet.cpp
void HeapRegionRemSet::setup_remset_size() {
  // table_size = base * (log(region_size / 1M) + 1)
  const int LOG_M = 20;
  int region_size_log_mb = MAX2(HeapRegion::LogOfHRGrainBytes - LOG_M, 0);
  // 对于4MB region: region_size_log_mb = 22 - 20 = 2
  
  if (FLAG_IS_DEFAULT(G1RSetSparseRegionEntries)) {
    G1RSetSparseRegionEntries = G1RSetSparseRegionEntriesBase * (region_size_log_mb + 1);
    // = base * 3
  }
  if (FLAG_IS_DEFAULT(G1RSetRegionEntries)) {
    G1RSetRegionEntries = G1RSetRegionEntriesBase * (region_size_log_mb + 1);
    // = base * 3
  }
}
```

### 4.3 RemSet三级结构

```
1. Coarse Map (粗粒度位图):
   - 每个Region用1位表示
   - 大小 = num_regions / 8 = 2048 / 8 = 256 bytes/Region
   
2. Fine-Grain Table (细粒度表):
   - 每个PerRegionTable跟踪一个源Region的所有卡
   - 每个PRT大小 ≈ CardsPerRegion / 8 = 8192 / 8 = 1024 bytes
   - 最大条目数受G1RSetRegionEntries限制
   
3. Sparse Table (稀疏表):
   - 存储少量跨Region引用的卡索引
   - 使用哈希表实现
```

### 4.4 8GB堆RemSet估算

```
假设平均每个Region的RemSet使用中等密度:

粗粒度部分: 256 bytes/Region
细粒度部分: ~2KB/Region (变化大)
稀疏部分: ~512 bytes/Region

平均每个Region RemSet: ~3KB
总RemSet开销估算: 2048 * 3KB = 6MB (变化范围: 2MB - 20MB)

注意: RemSet大小高度依赖于应用的引用模式
```

---

## 五、HeapRegionManager精确计算

### 5.1 数据结构

**文件**: `src/hotspot/share/gc/g1/heapRegionManager.hpp`

```cpp
class HeapRegionManager {
  G1RegionToSpaceMapper* _regions;        // Region到空间映射
  G1BiasedMappedArray<HeapRegion*> _regions_biased;  // 偏移数组
  FreeRegionList _free_list;               // 空闲列表
};
```

### 5.2 HeapRegion对象大小

**文件**: `src/hotspot/share/gc/g1/heapRegion.hpp`

HeapRegion类继承自G1ContiguousSpace，包含:
- 指针字段: ~20个 × 8 bytes = 160 bytes
- 整数字段: ~15个 × 4 bytes = 60 bytes
- 其他元数据: ~80 bytes

单个HeapRegion对象大小 ≈ 300-400 bytes (考虑对齐)

```
总HeapRegion对象: 2048个
HeapRegion对象总开销: 2048 * 400 bytes ≈ 800KB
```

### 5.3 管理数组

```
_regions_biased数组: 2048 * 8 bytes = 16KB
其他管理结构: ~20KB

HeapRegionManager总开销: ~100KB
```

---

## 六、精确内存开销汇总表

### 6.1 固定开销

| 数据结构 | 大小 | 计算公式 | 源码位置 |
|----------|------|----------|----------|
| Prev Bitmap | 16 MB | 8GB / 64 | g1ConcurrentMarkBitMap.cpp:38 |
| Next Bitmap | 16 MB | 8GB / 64 | g1ConcurrentMarkBitMap.cpp:38 |
| CardTable | 16 MB | 8GB / 512 | cardTable.hpp:235 |
| BOT | 16 MB | 8GB / 512 | blockOffsetTable.hpp:54 |
| **固定总计** | **64 MB** | | |

### 6.2 可变开销

| 数据结构 | 典型大小 | 范围 | 影响因素 |
|----------|----------|------|----------|
| RemSet | ~6 MB | 2-20 MB | 跨Region引用密度 |
| HeapRegion对象 | ~800 KB | 固定 | Region数量 |
| 管理结构 | ~200 KB | 固定 | - |
| **可变总计** | **~7 MB** | 3-21 MB | |

### 6.3 总开销

```
固定开销: 64 MB (0.78% of 8GB)
可变开销: ~7 MB (0.09% of 8GB)
-----------------------------------
总开销:   ~71 MB (0.87% of 8GB)

堆内存利用率: 99.13%
```

---

## 七、每个Region的辅助结构开销

### 7.1 单Region开销分解

```
CardTable:    4MB / 512 = 8,192 bytes = 8 KB/Region
BOT:          4MB / 512 = 8,192 bytes = 8 KB/Region
Bitmap(×2):   (4MB / 64) × 2 = 131,072 bytes = 128 KB/Region (两个位图)
RemSet:       ~3 KB/Region (平均)
HeapRegion:   ~400 bytes/Region
-------------------------------------------
总计:         ~147.4 KB/Region
```

### 7.2 比例计算

```
单Region辅助结构开销: 147.4 KB
单Region大小: 4 MB = 4,096 KB
辅助结构占比: 147.4 / 4,096 = 3.6%

但位图是全局共享的，按照分摊计算:
  卡表: 8KB, 
  BOT: 8KB
  位图分摊: 16KB
  RemSet: 3KB
  其他: 0.4KB
实际分摊: ~35.4 KB/Region = 0.86%
```

---

## 八、内存映射因子汇总

| 数据结构 | heap_map_factor | 含义 |
|----------|----------------|------|
| CardTable | 512 | 512字节堆 → 1字节卡表 |
| BOT | 512 | 512字节堆 → 1字节BOT |
| CMBitMap | 64 | 64字节堆 → 1位标记 |
| CMBitMap(bytes) | 512 | 512字节堆 → 1字节位图 |

**有趣发现**: CardTable、BOT和CMBitMap的字节映射因子都是512！
- CardTable: 直接使用512字节粒度
- BOT: 直接使用512字节粒度  
- CMBitMap: 64字节/位 × 8位/字节 = 512字节/字节

---

## 九、验证脚本

```java
/**
 * G1辅助数据结构内存开销验证
 * 运行: java -Xms8g -Xmx8g -XX:+UseG1GC G1AuxMemoryTest
 */
public class G1AuxMemoryTest {
    public static void main(String[] args) {
        Runtime rt = Runtime.getRuntime();
        
        // 触发Full GC获取准确信息
        System.gc();
        
        long heapSize = rt.maxMemory();
        System.out.println("=== G1辅助数据结构内存开销计算 ===");
        System.out.printf("堆大小: %,d bytes (%d MB)%n", heapSize, heapSize / 1024 / 1024);
        
        // 理论计算
        long cardTableSize = heapSize / 512;
        long botSize = heapSize / 512;
        long bitmapSize = heapSize / 64;  // bits
        long bitmapBytes = bitmapSize / 8;
        long totalBitmaps = bitmapBytes * 2;  // prev + next
        
        System.out.printf("%nCardTable: %,d bytes (%d MB)%n", cardTableSize, cardTableSize / 1024 / 1024);
        System.out.printf("BOT: %,d bytes (%d MB)%n", botSize, botSize / 1024 / 1024);
        System.out.printf("单个Bitmap: %,d bytes (%d MB)%n", bitmapBytes, bitmapBytes / 1024 / 1024);
        System.out.printf("两个Bitmap: %,d bytes (%d MB)%n", totalBitmaps, totalBitmaps / 1024 / 1024);
        
        long fixedOverhead = cardTableSize + botSize + totalBitmaps;
        System.out.printf("%n固定开销总计: %,d bytes (%d MB)%n", fixedOverhead, fixedOverhead / 1024 / 1024);
        System.out.printf("占堆比例: %.2f%%%n", (fixedOverhead * 100.0) / heapSize);
        
        // Region计算
        long regionSize = 4 * 1024 * 1024;  // 4MB
        long numRegions = heapSize / regionSize;
        long cardsPerRegion = regionSize / 512;
        
        System.out.printf("%nRegion大小: %d MB%n", regionSize / 1024 / 1024);
        System.out.printf("Region数量: %d%n", numRegions);
        System.out.printf("每Region卡数: %d%n", cardsPerRegion);
    }
}
```

---

**文档版本**: v1.0
**基于源码**: OpenJDK 11
**验证条件**: -Xms8g -Xmx8g -XX:+UseG1GC
**最后更新**: 2026-01-16
