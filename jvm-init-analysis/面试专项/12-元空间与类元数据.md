# JVM面试专项：元空间与类元数据

> **面试级别**: JVM技术专家  
> **环境**: Linux, OpenJDK 11, -Xms8g -Xmx8g -XX:+UseG1GC  
> **源码路径**: `/src/hotspot/share/memory/`

---

## 问题1：元空间(Metaspace)与永久代(PermGen)有什么区别？

### 面试官视角
考察对JDK 8内存布局变化的理解。

### 参考答案

#### 历史演变

```
JDK 7及之前:
┌─────────────────────────────────────┐
│              Java Heap              │
├─────────────────┬───────────────────┤
│   Young Gen     │     Old Gen       │
├─────────────────┴───────────────────┤
│         Permanent Generation        │  ← 存储类元数据
│   - Klass                           │
│   - Method                          │
│   - ConstantPool                    │
│   - 字符串常量池(interned strings)   │
└─────────────────────────────────────┘

JDK 8+:
┌─────────────────────────────────────┐
│              Java Heap              │
├─────────────────┬───────────────────┤
│   Young Gen     │     Old Gen       │
│                 │                   │
│        字符串常量池移到这里          │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│           Native Memory             │
├─────────────────────────────────────┤
│            Metaspace                │  ← 类元数据
│   - Klass                           │
│   - Method                          │
│   - ConstantPool                    │
│                                     │
├─────────────────────────────────────┤
│      Compressed Class Space         │  ← 如果启用压缩指针
│   - InstanceKlass                   │
└─────────────────────────────────────┘
```

#### 关键区别

| 特性 | PermGen | Metaspace |
|------|---------|-----------|
| 位置 | Java Heap内 | Native Memory |
| 大小限制 | 固定(-XX:MaxPermSize) | 默认无上限(受系统内存限制) |
| GC | Full GC回收 | 独立回收，有专门的GC |
| OOM错误 | OutOfMemoryError: PermGen | OutOfMemoryError: Metaspace |
| 调优难度 | 较难确定合适大小 | 较少需要调优 |

#### 为什么移除PermGen？

```
1. PermGen大小难以确定，容易OOM
2. 类卸载效率低下
3. 字符串常量池在PermGen中浪费空间
4. 简化HotSpot与JRockit的融合
```

---

## 问题2：Metaspace的内部结构是什么？

### 面试官视角
考察对元空间内存管理的深入理解。

### 参考答案

#### 整体架构

**源码位置**: `memory/metaspace.cpp`

```cpp
// Metaspace类型
enum MetaspaceType {
  StandardMetaspaceType,      // 标准类加载器
  BootMetaspaceType,          // Bootstrap类加载器
  AnonymousMetaspaceType,     // 匿名类/Lambda
  ReflectionMetaspaceType     // 反射生成的类
};
```

#### 内存分配层次

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          VirtualSpaceList                                │
│  管理多个VirtualSpaceNode，负责向OS申请内存                               │
├───────────────────┬──────────────────┬──────────────────────────────────┤
│ VirtualSpaceNode  │ VirtualSpaceNode │ VirtualSpaceNode ...            │
│   (默认2MB)        │    (2MB)         │                                  │
├───────────────────┴──────────────────┴──────────────────────────────────┤
│                          ChunkManager                                    │
│  管理Chunk池，回收和重用Chunk                                             │
├──────────────┬──────────────┬──────────────┬───────────────────────────┤
│ Specialized  │    Small     │    Medium    │     Humongous             │
│  Chunk       │    Chunk     │    Chunk     │     Chunk                 │
│  (128字节)   │   (512字节)   │   (8K字节)   │    (>8K，可变)             │
└──────────────┴──────────────┴──────────────┴───────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                          SpaceManager                                    │
│  每个ClassLoaderData一个，管理该类加载器的内存分配                         │
├─────────────────────────────────────────────────────────────────────────┤
│  current_chunk: 当前分配使用的chunk                                      │
│  chunk_list: 该SpaceManager持有的所有chunk链表                           │
└─────────────────────────────────────────────────────────────────────────┘
```

#### Chunk大小定义

**源码位置**: `memory/metaspace/metaspaceCommon.hpp`

```cpp
enum ChunkSizes {
  SpecializedChunk = 128,           // 小对象
  SmallChunk = 512,                 // 512字节
  MediumChunk = 8 * K,              // 8KB
  // Humongous: > MediumChunk，按需分配
};
```

#### 压缩类空间(Compressed Class Space)

```cpp
// 当使用压缩类指针(-XX:+UseCompressedClassPointers)时
// Klass*存储在专门的Compressed Class Space

class Metaspace {
  static size_t _compressed_class_space_size;  // 默认1GB
  
  // 两种元空间类型
  enum MetadataType {
    ClassType,      // Klass元数据，放入Compressed Class Space
    NonClassType    // 其他元数据，放入普通Metaspace
  };
};
```

---

## 问题3：类元数据包含哪些内容？

### 面试官视角
考察对Klass结构的深入理解。

### 参考答案

#### Klass继承体系

```
                     Metadata
                         │
                      Klass
            ┌───────────┴───────────┐
       ArrayKlass              InstanceKlass
       │       │                    │
ObjArrayKlass  TypeArrayKlass  InstanceMirrorKlass
                                InstanceRefKlass
                                InstanceClassLoaderKlass
```

#### InstanceKlass核心字段

**源码位置**: `oops/instanceKlass.hpp`

```cpp
class InstanceKlass : public Klass {
  // 类名(符号引用)
  Symbol* _name;
  
  // 常量池
  ConstantPool* _constants;
  
  // 类加载器数据
  ClassLoaderData* _class_loader_data;
  
  // 父类
  Klass* _super;
  
  // 接口数组
  Array<Klass*>* _local_interfaces;
  Array<Klass*>* _transitive_interfaces;
  
  // 字段信息
  Array<u2>* _fields;             // 字段描述符
  int _nonstatic_field_size;      // 非静态字段大小
  int _static_field_size;         // 静态字段大小
  
  // 方法数组
  Array<Method*>* _methods;
  Array<Method*>* _default_methods;  // 接口默认方法
  
  // 虚方法表
  int _vtable_len;
  // vtable紧跟在InstanceKlass后面
  
  // 接口方法表
  int _itable_len;
  
  // 访问标志
  AccessFlags _access_flags;
  
  // Java镜像(java.lang.Class对象)
  OopHandle _java_mirror;
  
  // 偏向锁原型头
  markOop _prototype_header;
  
  // 类状态
  // allocated → loaded → linked → being_initialized → fully_initialized
  u1 _init_state;
};
```

#### Method结构

**源码位置**: `oops/method.hpp`

```cpp
class Method : public Metadata {
  // 常量池引用
  ConstMethod* _constMethod;
  
  // 方法数据(Profiling信息)
  MethodData* _method_data;
  
  // 计数器
  MethodCounters* _method_counters;
  
  // 访问标志
  AccessFlags _access_flags;
  
  // 虚表索引
  int _vtable_index;
  
  // 入口点
  address _i2i_entry;           // 解释器入口
  AdapterHandlerEntry* _adapter;
  address _from_compiled_entry; // 从编译代码调用的入口
  address _from_interpreted_entry; // 从解释器调用的入口
};
```

#### ConstantPool结构

**源码位置**: `oops/constantPool.hpp`

```cpp
class ConstantPool : public Metadata {
  Array<u1>* _tags;      // 常量类型标签
  
  // 实际常量数据紧跟在ConstantPool对象后
  // cp[0]: 空
  // cp[1..n]: 各种常量(int, float, utf8, class, methodref等)
  
  // 缓存解析后的引用
  ConstantPoolCache* _cache;
  
  // 类引用
  InstanceKlass* _pool_holder;
};
```

---

## 问题4：Metaspace如何触发GC？

### 面试官视角
考察Metaspace内存管理与GC的关系。

### 参考答案

#### GC触发条件

**源码位置**: `memory/metaspace.cpp`

```cpp
void MetaspaceGC::initialize() {
  // 初始HWM = MetaspaceSize(默认21MB)
  _capacity_until_GC = MetaspaceSize;
}

// 当元空间使用量达到HWM时触发GC
bool MetaspaceGC::should_concurrent_collect() {
  return _should_concurrent_collect;
}

// HWM动态调整
size_t MetaspaceGC::delta_capacity_until_GC(size_t bytes) {
  size_t min_delta = MinMetaspaceExpansion;  // 256K
  size_t max_delta = MaxMetaspaceExpansion;  // 4MB
  
  // 扩展策略...
  return delta;
}
```

#### GC流程

```
Metaspace使用量 → 接近HWM
         │
         ▼
  检查是否需要GC
         │
    ┌────┴────┐
    ▼         ▼
G1: 触发    CMS: 触发
Concurrent  Concurrent
Marking     Mode Failure
         │
         ▼
  Full GC (类卸载)
         │
         ▼
  ClassLoaderDataGraph::purge()
    - 清理不可达的ClassLoaderData
    - 释放对应的Metaspace内存
```

#### 类卸载条件

```cpp
// 类卸载需要满足:
// 1. 该类的所有实例已被回收
// 2. 加载该类的ClassLoader已被回收
// 3. 该类的java.lang.Class对象没有被引用

void ClassLoaderDataGraph::purge() {
  ClassLoaderData* data = _head;
  while (data != NULL) {
    if (data->is_unloading()) {
      // 释放该ClassLoaderData的所有资源
      data->free_deallocate_list();
      data->metaspace_or_null()->deallocate();
      // 从链表移除
    }
    data = data->next();
  }
}
```

---

## 问题5：如何监控和调优Metaspace？

### 面试官视角
考察实际运维能力。

### 参考答案

#### JVM参数

```bash
# 基本参数
-XX:MetaspaceSize=256m          # 初始HWM(触发GC的阈值)
-XX:MaxMetaspaceSize=512m       # 最大限制
-XX:MinMetaspaceFreeRatio=40    # GC后最小空闲比例
-XX:MaxMetaspaceFreeRatio=70    # GC后最大空闲比例

# 压缩类空间
-XX:CompressedClassSpaceSize=256m  # 压缩类空间大小(默认1GB)

# 调试参数
-XX:+PrintMetaspaceStatisticsAtExit
-Xlog:gc+metaspace=debug
```

#### NMT监控

```bash
# 启用NMT
java -XX:NativeMemoryTracking=detail MyApp

# 查看元空间详情
jcmd <pid> VM.native_memory detail | grep -A10 "Class"

# 输出示例:
# -                     Class (reserved=1073872KB, committed=45168KB)
#                             (classes #6608)
#                             (malloc=848KB #11883) 
#                             (mmap: reserved=1073024KB, committed=44320KB)
```

#### 8GB堆场景的元空间统计

```bash
java -Xms8g -Xmx8g -XX:+UseG1GC \
     -XX:NativeMemoryTracking=detail \
     -XX:+UnlockDiagnosticVMOptions \
     -XX:+PrintNMTStatistics -version 2>&1 | grep -A5 "Class"

# 示例输出:
# Class (reserved=1073741824, committed=25165824)
#       - 1GB reserved (Compressed Class Space)
#       - 24MB committed
```

#### JFR事件

```java
// jdk.MetaspaceAllocationFailure
// jdk.MetaspaceGCThreshold
// jdk.MetaspaceChunkFreeListSummary
// jdk.MetaspaceOOM

// 使用JFR记录:
java -XX:StartFlightRecording=filename=metaspace.jfr,duration=60s MyApp
```

---

## 问题6：常见的Metaspace问题及解决方案？

### 面试官视角
考察问题诊断能力。

### 参考答案

#### 问题1: Metaspace OOM

```
java.lang.OutOfMemoryError: Metaspace

原因:
1. 类加载器泄漏(最常见)
2. 动态生成类过多(CGLIB/Javassist)
3. MaxMetaspaceSize设置过小

诊断:
jmap -clstats <pid>  # 查看类加载器统计
jcmd <pid> GC.class_stats  # 查看类统计

解决:
1. 修复类加载器泄漏
2. 增加MaxMetaspaceSize
3. 检查动态代理使用情况
```

#### 问题2: Metaspace碎片化

```
现象: committed >> used，但无法分配新类

原因:
1. 大量小类加载器
2. 频繁加载/卸载类

解决:
1. 合并类加载器
2. 使用-XX:+UseLargePagesInMetaspace(如果支持)
```

#### 问题3: 类加载器泄漏

```java
// 典型泄漏模式
class LeakyClassLoader extends ClassLoader {
    static List<ClassLoader> leaks = new ArrayList<>();
    
    public LeakyClassLoader() {
        leaks.add(this);  // 泄漏：静态引用阻止GC
    }
}

// 诊断
jmap -histo:live <pid> | grep ClassLoader
# 查找数量异常的ClassLoader实例

// MAT分析
// 查找到GC Root的引用路径
```

#### 问题4: 频繁Full GC

```
现象: Full GC频繁，且每次都有Metaspace原因

原因:
1. MetaspaceSize设置过低
2. 类卸载频繁

解决:
# 调大初始阈值
-XX:MetaspaceSize=256m

# 如果类卸载频繁是正常的，考虑:
-XX:MinMetaspaceFreeRatio=20
-XX:MaxMetaspaceFreeRatio=80
```

---

## 总结

### 关键源码文件

| 主题 | 源码文件 | 关键类/方法 |
|------|----------|-------------|
| Metaspace | `memory/metaspace.cpp` | `Metaspace::allocate` |
| ChunkManager | `memory/metaspace/chunkManager.cpp` | `ChunkManager::get_chunk` |
| SpaceManager | `memory/metaspace/spaceManager.cpp` | `SpaceManager::allocate` |
| 类元数据 | `oops/instanceKlass.hpp` | `InstanceKlass` |
| 类加载器数据 | `classfile/classLoaderData.cpp` | `ClassLoaderData` |

### 面试回答要点

1. **PermGen→Metaspace**: JDK 8移除永久代，元数据放入本地内存
2. **Metaspace结构**: VirtualSpaceList→ChunkManager→SpaceManager，多级管理
3. **Chunk大小**: Specialized(128B)、Small(512B)、Medium(8K)、Humongous
4. **GC触发**: 使用量达到HWM(MetaspaceSize)触发，动态扩展
5. **类卸载**: 需要类实例、ClassLoader、Class对象都不可达
6. **常见问题**: OOM(类加载器泄漏)、碎片化、频繁Full GC
