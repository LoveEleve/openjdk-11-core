# 27. 常量池与符号解析

## 一、常量池概述

### 1.1 常量池的作用

常量池(Constant Pool)是Class文件中最重要的数据结构之一，存储类中使用的各种常量（字面量和符号引用）。

**核心源码**（`constantPool.hpp:96-113`）：
```cpp
// 常量池核心数据结构
class ConstantPool : public Metadata {
  friend class VMStructs;
  friend class JVMCIVMStructs;
  friend class BytecodeInterpreter;
  friend class ClassFileParser;

private:
  Array<u1>*           _tags;       // 常量类型标签数组
  ConstantPoolCache*   _cache;      // 常量池缓存
  InstanceKlass*       _pool_holder;// 持有该常量池的类
  Array<jushort>*      _operands;   // invoke dynamic操作数
  Array<Klass*>*       _resolved_klasses; // 已解析的类
  int                  _length;     // 常量池长度
```

### 1.2 常量池类型

**常量类型定义**：
```cpp
// 常量池类型标签
enum {
  JVM_CONSTANT_Invalid                   = 0,    // 无效
  JVM_CONSTANT_Utf8                      = 1,    // UTF-8字符串
  JVM_CONSTANT_Integer                   = 3,    // 整数
  JVM_CONSTANT_Float                     = 4,    // 浮点数
  JVM_CONSTANT_Long                      = 5,    // 长整数
  JVM_CONSTANT_Double                    = 6,    // 双精度浮点
  JVM_CONSTANT_Class                     = 7,    // 类引用
  JVM_CONSTANT_String                    = 8,    // 字符串引用
  JVM_CONSTANT_Fieldref                  = 9,    // 字段引用
  JVM_CONSTANT_Methodref                 = 10,   // 方法引用
  JVM_CONSTANT_InterfaceMethodref        = 11,   // 接口方法引用
  JVM_CONSTANT_NameAndType               = 12,   // 名称和类型
  JVM_CONSTANT_MethodHandle              = 15,   // 方法句柄
  JVM_CONSTANT_MethodType                = 16,   // 方法类型
  JVM_CONSTANT_Dynamic                   = 17,   // 动态常量
  JVM_CONSTANT_InvokeDynamic             = 18    // 动态调用
};
```

---

## 二、常量池内存分配

### 2.1 常量池创建

**源码分析**（`constantPool.cpp:61-65`）：
```cpp
ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, 
                                     int length, TRAPS) {
  // 分配tag数组
  Array<u1>* tags = MetadataFactory::new_array<u1>(loader_data, length, 0, CHECK_NULL);
  int size = ConstantPool::size(length);
  // 在Metaspace中分配常量池
  return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) 
         ConstantPool(tags);
}
```

### 2.2 常量池初始化

```cpp
ConstantPool::ConstantPool(Array<u1>* tags) :
  _tags(tags),
  _length(tags->length()) {
    assert(_tags != NULL, "invariant");
    assert(tags->length() == _length, "invariant");
    assert(tag_array_is_zero_initialized(tags), "invariant");
    assert(0 == flags(), "invariant");
    assert(0 == version(), "invariant");
    assert(NULL == _pool_holder, "invariant");
}
```

---

## 三、符号表(Symbol Table)

### 3.1 Symbol类设计

**核心源码**（`symbol.hpp:91-121`）：
```cpp
// Symbol表示符号（类名、方法名、签名等）
class Symbol : public MetaspaceObj {
  friend class VMStructs;
  friend class SymbolTable;

 private:
  ATOMIC_SHORT_PAIR(
    volatile short _refcount,  // 引用计数（需要原子操作）
    unsigned short _length     // UTF8字符数量
  );
  short _identity_hash;        // 身份哈希
  jbyte _body[2];              // 符号内容

  enum {
    max_symbol_length = (1 << 16) - 1  // 最大符号长度
  };
```

### 3.2 符号表结构

**源码分析**（`symbolTable.hpp:99-116`）：
```cpp
class SymbolTable : public RehashableHashtable<Symbol*, mtSymbol> {
  friend class VMStructs;
  friend class ClassFileParser;

private:
  static SymbolTable* _the_table;         // 全局符号表
  static bool _needs_rehashing;            // 是否需要rehash
  static bool _lookup_shared_first;        // 优先查找共享区

  // 统计信息
  static int _symbols_removed;
  static int _symbols_counted;
```

### 3.3 符号查找与创建

```cpp
// 符号查找（先查共享表，再查主表）
Symbol* SymbolTable::lookup(const char* name, int len, TRAPS) {
  unsigned int hash = hash_symbol(name, len, SymbolTable::_alt_hash);
  
  // 优先查找共享符号表（CDS）
  if (_lookup_shared_first) {
    Symbol* s = lookup_shared(name, len, hash);
    if (s != NULL) {
      return s;
    }
  }
  
  // 查找主符号表
  return lookup_only(name, len, hash);
}

// 符号驻留（创建新符号或返回已有符号）
Symbol* SymbolTable::intern(const char* name, int len, TRAPS) {
  Symbol* sym = lookup(name, len, THREAD);
  if (sym != NULL) {
    return sym;
  }
  // 创建新符号
  return basic_add(name, len, THREAD);
}
```

---

## 四、符号解析流程

### 4.1 类引用解析

**常量池类解析**：
```cpp
// 解析类引用
Klass* ConstantPool::klass_at(int which, TRAPS) {
  constantPoolHandle h_this(THREAD, this);
  return klass_at_impl(h_this, which, THREAD);
}

Klass* ConstantPool::klass_at_impl(const constantPoolHandle& this_cp,
                                   int which, TRAPS) {
  CPKlassSlot kslot = this_cp->klass_slot_at(which);
  int resolved_klass_index = kslot.resolved_klass_index();
  
  // 检查是否已解析
  Klass* klass = this_cp->resolved_klasses()->at(resolved_klass_index);
  if (klass != NULL) {
    return klass;  // 返回已解析的类
  }
  
  // 获取类名
  Symbol* name = this_cp->symbol_at(kslot.name_index());
  
  // 通过SystemDictionary解析类
  Handle loader = Handle(THREAD, this_cp->pool_holder()->class_loader());
  Handle protection_domain = Handle(THREAD, 
         this_cp->pool_holder()->protection_domain());
  
  Klass* k = SystemDictionary::resolve_or_fail(name, loader, 
                                               protection_domain,
                                               true, THREAD);
  // 缓存解析结果
  this_cp->resolved_klasses()->at_put(resolved_klass_index, k);
  return k;
}
```

### 4.2 方法引用解析

**LinkResolver方法解析**（`linkResolver.cpp:723-733`）：
```cpp
methodHandle LinkResolver::resolve_method(const LinkInfo& link_info,
                                          Bytecodes::Code code, TRAPS) {
  Handle nested_exception;
  Klass* resolved_klass = link_info.resolved_klass();
  
  // 1. invokevirtual不能调用接口方法
  if (code == Bytecodes::_invokevirtual && resolved_klass->is_interface()) {
    ResourceMark rm(THREAD);
    char buf[200];
    jio_snprintf(buf, sizeof(buf), 
                 "Found interface %s, but class was expected",
                 resolved_klass->external_name());
    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
  }
  
  // 2. 查找方法
  methodHandle resolved_method = lookup_method_in_klasses(link_info,
                                                          true, false);
  
  // 3. 如果是接口，查找接口方法
  if (resolved_method.is_null() && !resolved_klass->is_interface()) {
    resolved_method = lookup_method_in_interfaces(link_info);
  }
  
  // 4. 检查访问权限
  if (check_access) {
    check_method_accessability(current_klass, resolved_klass,
                               resolved_method, CHECK_NULL);
  }
  
  return resolved_method;
}
```

### 4.3 字段引用解析

```cpp
// 字段解析
void LinkResolver::resolve_field(fieldDescriptor& fd,
                                 const LinkInfo& link_info,
                                 Bytecodes::Code byte, 
                                 bool initialize_class, TRAPS) {
  Klass* resolved_klass = link_info.resolved_klass();
  Symbol* field_name = link_info.name();
  Symbol* field_sig = link_info.signature();
  
  // 1. 在类层次中查找字段
  Klass* sel_klass = NULL;
  if (resolved_klass->is_instance_klass()) {
    sel_klass = InstanceKlass::cast(resolved_klass)
                ->find_field(field_name, field_sig, &fd);
  }
  
  if (sel_klass == NULL) {
    ResourceMark rm(THREAD);
    THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), 
              field_name->as_C_string());
  }
  
  // 2. 检查访问权限
  check_field_accessability(current_klass, resolved_klass, 
                            sel_klass, fd, CHECK);
  
  // 3. 静态字段需要初始化类
  if (initialize_class && fd.is_static()) {
    sel_klass->initialize(CHECK);
  }
}
```

---

## 五、常量池缓存(CP Cache)

### 5.1 缓存结构

```cpp
// 常量池缓存用于加速解析后的访问
class ConstantPoolCache : public MetaspaceObj {
  int             _length;              // 缓存项数量
  ConstantPool*   _constant_pool;       // 关联的常量池
  Array<u2>*      _reference_map;       // 引用映射
  objArrayOop     _resolved_references; // 已解析的引用对象
  // 缓存项数组在对象末尾
};

// 单个缓存项
class ConstantPoolCacheEntry {
  volatile intx     _indices;       // 常量池索引和字节码
  volatile intx     _f1;            // 方法指针或类指针
  volatile intx     _f2;            // vtable索引或字段偏移
  volatile intx     _flags;         // 标志位
};
```

### 5.2 缓存更新流程

```cpp
// 缓存方法调用信息
void ConstantPoolCacheEntry::set_method(Bytecodes::Code invoke_code,
                                        const methodHandle& method,
                                        int vtable_index) {
  // 设置方法指针
  _f1 = (intx)method();
  
  // 设置vtable索引
  _f2 = vtable_index;
  
  // 设置标志（参数大小、返回类型等）
  int parameter_size = method->size_of_parameters();
  TosState tos_state = as_TosState(method->result_type());
  
  // 原子更新indices
  OrderAccess::release_store(&_indices, 
                             make_indices(invoke_code, parameter_size));
}
```

---

## 六、解析触发时机

### 6.1 延迟解析(Lazy Resolution)

```cpp
// 字节码执行时触发解析
void InterpreterRuntime::resolve_invoke(JavaThread* thread, 
                                        Bytecodes::Code bytecode) {
  methodHandle caller_method(thread, method(thread));
  
  // 获取常量池索引
  int constant_pool_index = two_byte_index(thread);
  
  CallInfo info;
  constantPoolHandle pool(thread, caller_method->constants());
  
  // 根据字节码类型解析
  switch (bytecode) {
    case Bytecodes::_invokestatic:
      LinkResolver::resolve_invokestatic(info, pool, 
                                         constant_pool_index, CHECK);
      break;
    case Bytecodes::_invokespecial:
      LinkResolver::resolve_invokespecial(info, pool,
                                          constant_pool_index, CHECK);
      break;
    case Bytecodes::_invokevirtual:
      LinkResolver::resolve_invokevirtual(info, pool,
                                          constant_pool_index, CHECK);
      break;
    case Bytecodes::_invokeinterface:
      LinkResolver::resolve_invokeinterface(info, pool,
                                            constant_pool_index, CHECK);
      break;
  }
  
  // 更新常量池缓存
  cache_entry->set_method_info(info, bytecode);
}
```

### 6.2 解析结果缓存

```cpp
// 已解析的引用数组
objArrayOop ConstantPool::resolved_references() const {
  return (objArrayOop)_cache->resolved_references();
}

// 解析字符串常量
oop ConstantPool::resolve_constant_at_impl(const constantPoolHandle& this_cp,
                                           int index, int cache_index,
                                           bool* status_return, TRAPS) {
  oop result_oop = NULL;
  
  // 先检查缓存
  if (cache_index >= 0) {
    result_oop = this_cp->resolved_references()->obj_at(cache_index);
    if (result_oop != NULL) {
      return result_oop;  // 命中缓存
    }
  }
  
  // 解析常量
  constantTag tag = this_cp->tag_at(index);
  switch (tag.value()) {
    case JVM_CONSTANT_String: {
      Symbol* sym = this_cp->unresolved_string_at(index);
      result_oop = StringTable::intern(sym, CHECK_(NULL));
      break;
    }
    case JVM_CONSTANT_Class: {
      Klass* k = this_cp->klass_at(index, CHECK_(NULL));
      result_oop = k->java_mirror();
      break;
    }
    // ... 其他类型
  }
  
  // 缓存结果
  if (cache_index >= 0) {
    this_cp->resolved_references()->obj_at_put(cache_index, result_oop);
  }
  
  return result_oop;
}
```

---

## 七、InvokeDynamic解析

### 7.1 Bootstrap方法解析

```cpp
// InvokeDynamic解析
oop ConstantPool::resolve_bootstrap_specifier_at_impl(
    const constantPoolHandle& this_cp, int index, TRAPS) {
  
  assert((this_cp->tag_at(index).is_invoke_dynamic() ||
          this_cp->tag_at(index).is_dynamic_constant()), 
         "Corrupted constant pool");
  
  // 获取Bootstrap方法句柄
  int bsm_index = this_cp->invoke_dynamic_bootstrap_method_ref_index_at(index);
  oop bsm = this_cp->resolve_possibly_cached_constant_at(bsm_index, CHECK_NULL);
  
  // 获取参数
  int argc = this_cp->invoke_dynamic_argument_count_at(index);
  objArrayHandle args(THREAD, oopFactory::new_objArray(
                      SystemDictionary::Object_klass(), argc, CHECK_NULL));
  
  for (int i = 0; i < argc; i++) {
    int arg_index = this_cp->invoke_dynamic_argument_index_at(index, i);
    oop arg = this_cp->resolve_possibly_cached_constant_at(arg_index, CHECK_NULL);
    args->obj_at_put(i, arg);
  }
  
  // 返回BootstrapSpecifier
  return bsm;
}
```

---

## 八、面试要点

### 8.1 常见问题

**Q1: 常量池中存储了哪些内容？**
```
A: 常量池存储两大类内容：
1. 字面量：
   - 整数、浮点数、长整数、双精度数
   - 字符串字面量
   
2. 符号引用：
   - 类和接口的全限定名
   - 字段的名称和描述符
   - 方法的名称和描述符
   - 方法句柄和方法类型
   - 动态调用点(InvokeDynamic)
```

**Q2: 符号解析何时发生？**
```
A: JVM采用延迟解析策略：
1. 解析时机：
   - 首次执行引用常量的字节码时
   - 如new、getstatic、invokevirtual等

2. 解析缓存：
   - 解析结果缓存在ConstantPoolCache
   - 后续访问直接使用缓存

3. 预解析场景：
   - -Xcomp强制编译时
   - CDS类共享时
```

**Q3: 常量池缓存(CP Cache)的作用？**
```
A: CP Cache加速解析后的访问：
1. 缓存内容：
   - 已解析的方法指针
   - vtable/itable索引
   - 字段偏移量
   
2. 性能优化：
   - 避免重复解析
   - 快速定位虚方法
```

### 8.2 源码关键点

| 组件 | 源文件 | 核心功能 |
|-----|--------|---------|
| ConstantPool | `constantPool.cpp` | 常量池存储和解析 |
| SymbolTable | `symbolTable.cpp` | 符号表管理 |
| LinkResolver | `linkResolver.cpp` | 符号解析逻辑 |
| CPCache | `cpCache.cpp` | 解析结果缓存 |

### 8.3 调试技巧

```bash
# 打印常量池解析过程
java -XX:+PrintConstantPoolResolving YourClass

# 查看类的常量池
javap -v -c YourClass.class

# 查看符号表统计
jcmd <pid> VM.symboltable
```

---

## 九、常量池与字符串池

### 9.1 字符串驻留

```cpp
// 字符串常量解析
oop ConstantPool::uncached_string_at(int which, TRAPS) {
  // 获取符号
  Symbol* sym = unresolved_string_at(which);
  // 驻留到字符串池
  oop str = StringTable::intern(sym, CHECK_(NULL));
  assert(java_lang_String::is_instance(str), "must be string");
  return str;
}
```

### 9.2 字符串池实现

```cpp
// 字符串驻留
oop StringTable::intern(Symbol* symbol, TRAPS) {
  if (symbol == NULL) return NULL;
  
  ResourceMark rm(THREAD);
  int length = symbol->utf8_length();
  const char* chars = (const char*)symbol->bytes();
  
  // 先查找
  unsigned int hash = hash_string(chars, length, _alt_hash);
  oop found = lookup_shared(chars, length, hash);
  if (found != NULL) {
    return found;
  }
  
  // 创建新字符串
  Handle string = java_lang_String::create_from_symbol(symbol, CHECK_NULL);
  // 加入字符串池
  return intern(string, THREAD);
}
```

---

## 十、总结

### 10.1 常量池层次结构

```
Class文件常量池
      ↓ (类加载)
运行时常量池(ConstantPool)
      ↓ (首次访问)
常量池缓存(ConstantPoolCache)
      ↓ (解析)
实际内存对象(Klass/Method/Field)
```

### 10.2 解析流程

```
字节码执行 → 检查CP Cache → 未命中 → 符号解析
                   ↓                    ↓
               命中返回          SystemDictionary
                                      ↓
                               类加载/方法查找
                                      ↓
                               更新CP Cache
```

常量池是JVM实现动态链接的核心机制，通过延迟解析和缓存优化，实现了高效的符号引用到直接引用的转换。
