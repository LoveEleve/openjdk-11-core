# JVM面试专项：内存模型与屏障

> **面试级别**: JVM技术专家  
> **环境**: Linux, OpenJDK 11, -Xms8g -Xmx8g -XX:+UseG1GC  
> **源码路径**: `/src/hotspot/share/runtime/`

---

## 问题1：JMM(Java Memory Model)的核心是什么？

### 面试官视角
考察对Java内存模型的本质理解，而不是表面概念。

### 参考答案

#### JMM的核心目标

JMM定义了多线程程序中，哪些共享变量的读写可以被其他线程观察到，以及以什么顺序观察到。

```
核心问题: 
Thread1: a = 1; flag = true;
Thread2: if (flag) { assert(a == 1); }

没有JMM保证，Thread2可能看到:
- flag=true, a=0  (重排序)
- flag=false, a=1 (可见性)
```

#### JMM的三大特性

**1. 原子性(Atomicity)**
- 基本类型读写是原子的(除long/double在32位JVM)
- synchronized块内的操作对外原子
- AtomicXxx类的操作

**2. 可见性(Visibility)**
- volatile写对后续volatile读可见
- synchronized退出对后续synchronized进入可见
- final字段构造器初始化对其他线程可见

**3. 有序性(Ordering)**
- 程序顺序(Program Order)
- Happens-Before关系

#### Happens-Before规则

```java
// 1. 程序顺序规则
int a = 1;        // A
int b = a + 1;    // B happens-after A

// 2. 锁规则
synchronized(lock) { x = 1; }  // unlock happens-before lock

// 3. volatile规则
volatile boolean flag;
// volatile写 happens-before 后续volatile读

// 4. 传递性
// A hb B, B hb C => A hb C

// 5. 线程启动规则
thread.start();  // start() happens-before 线程内任何操作

// 6. 线程终止规则
thread.join();   // 线程内操作 happens-before join()返回

// 7. 中断规则
thread.interrupt();  // interrupt() happens-before 检测到中断

// 8. 对象构造规则
// 构造器结束 happens-before finalizer开始
```

---

## 问题2：什么是内存屏障？HotSpot如何实现？

### 面试官视角
考察对底层同步机制的理解。

### 参考答案

#### 内存屏障定义

内存屏障是一种CPU指令，用于控制编译器和处理器的指令重排序，确保内存操作的正确顺序。

**源码位置**: `runtime/orderAccess.hpp`

```cpp
// HotSpot定义的四种基本屏障:

// LoadLoad:   Load1; LoadLoad; Load2
// 确保Load1在Load2之前完成

// StoreStore: Store1; StoreStore; Store2
// 确保Store1在Store2之前完成

// LoadStore:  Load1; LoadStore; Store2
// 确保Load1在Store2之前完成

// StoreLoad:  Store1; StoreLoad; Load2
// 确保Store1在Load2之前完成(最强，也最昂贵)
```

#### HotSpot实现

```cpp
// runtime/orderAccess.hpp

class OrderAccess : AllStatic {
public:
  // 完整屏障(StoreLoad + LoadLoad + LoadStore + StoreStore)
  static void fence();
  
  // 释放语义(LoadStore + StoreStore)
  static void release();
  
  // 获取语义(LoadLoad + LoadStore)  
  static void acquire();
  
  // 带屏障的load/store
  template<typename T>
  static T load_acquire(const volatile T* p);
  
  template<typename T>
  static void release_store(volatile T* p, T v);
};
```

#### x86平台实现

```cpp
// x86是TSO(Total Store Order)架构
// StoreStore, LoadLoad, LoadStore 在x86上是no-op
// 只有StoreLoad需要显式屏障

// orderAccess_linux_x86.hpp
inline void OrderAccess::fence() {
  // x86的fence实现: lock addl $0, 0(%rsp)
  // 或者: mfence
  __asm__ volatile ("lock; addl $0,0(%%rsp)" : : : "cc", "memory");
}

inline void OrderAccess::release() {
  // x86上release是no-op，因为TSO保证了StoreStore顺序
}

inline void OrderAccess::acquire() {
  // x86上acquire是no-op，因为TSO保证了LoadLoad顺序
}
```

#### 不同架构对比

| 架构 | LoadLoad | LoadStore | StoreStore | StoreLoad |
|------|----------|-----------|------------|-----------|
| x86 (TSO) | no-op | no-op | no-op | mfence/lock |
| ARM | dmb ld | dmb ld | dmb st | dmb ish |
| POWER | lwsync | lwsync | lwsync | sync |
| SPARC TSO | no-op | no-op | no-op | membar |

---

## 问题3：volatile是如何实现的？

### 面试官视角
考察volatile的底层实现细节。

### 参考答案

#### volatile的语义

```java
volatile int x;
// 1. 可见性: 写后对其他线程立即可见
// 2. 禁止重排序: 不能与前后操作重排
```

#### HotSpot字节码实现

```java
// volatile读
0: getstatic #2  // getfield标记ACC_VOLATILE
// 编译器在后面插入LoadLoad + LoadStore屏障

// volatile写  
0: putstatic #2  // putfield标记ACC_VOLATILE
// 编译器在前面插入LoadStore + StoreStore屏障
// 在后面插入StoreLoad屏障
```

#### C1/C2编译器处理

**源码位置**: `c1/c1_LIRGenerator.cpp`

```cpp
void LIRGenerator::volatile_field_store(LIR_Opr value, ...) {
  // 写之前的屏障
  // storestore + loadstore
  __ membar_release();
  
  // 实际写操作
  if (is_volatile && os::is_MP()) {
    __ volatile_store_mem_reg(value, address);
  }
  
  // 写之后的屏障
  // storeload
  __ membar_storeload();
}

void LIRGenerator::volatile_field_load(LIR_Opr result, ...) {
  // 实际读操作
  if (is_volatile && os::is_MP()) {
    __ volatile_load_mem_reg(result, address);
  }
  
  // 读之后的屏障
  // loadload + loadstore
  __ membar_acquire();
}
```

#### x86汇编层面

```asm
# volatile写
mov [address], value    ; 普通写
lock addl $0, 0(%rsp)   ; StoreLoad屏障

# volatile读  
mov value, [address]    ; 普通读
# (x86 TSO下无需额外屏障)
```

#### volatile vs synchronized

| 特性 | volatile | synchronized |
|------|----------|--------------|
| 原子性 | 单个读写 | 复合操作 |
| 可见性 | ✓ | ✓ |
| 有序性 | 禁止重排 | 临界区内可重排 |
| 阻塞 | 否 | 是 |
| 适用场景 | 状态标志 | 复合操作 |

---

## 问题4：final字段的内存语义是什么？

### 面试官视角
考察对final字段安全发布的理解。

### 参考答案

#### final的保证

```java
class FinalFieldExample {
    final int x;
    int y;
    
    public FinalFieldExample() {
        x = 1;
        y = 2;
    }
}

// 另一个线程
FinalFieldExample obj = reference;
if (obj != null) {
    int a = obj.x;  // 保证看到1
    int b = obj.y;  // 可能看到0或2(非final)
}
```

#### HotSpot实现

**源码位置**: `opto/memnode.cpp`

```cpp
// final字段写入后，构造器返回前插入StoreStore屏障
// 确保final字段初始化在对象发布前完成

void FinalFieldExample::<init>() {
    this.x = 1;   // final字段写入
    this.y = 2;   // 普通字段写入
    // StoreStore屏障 (隐式)
    // 阻止final字段写与对象发布重排序
}
```

#### 为什么需要特殊处理？

```java
// 没有final保证的危险场景
class UnsafePublication {
    int x;
    static UnsafePublication instance;
    
    public UnsafePublication() {
        x = 42;
    }
    
    public static void main(String[] args) {
        // Thread 1
        instance = new UnsafePublication();
        
        // Thread 2
        if (instance != null) {
            // 可能看到x=0！
            // 因为构造和发布可能重排序
            System.out.println(instance.x);
        }
    }
}
```

---

## 问题5：CAS操作的底层实现？

### 面试官视角
考察对原子操作的深入理解。

### 参考答案

#### CAS定义

Compare-And-Swap: 比较内存值与期望值，相等则更新为新值。

```java
// Java层面
AtomicInteger.compareAndSet(expect, update);

// 伪代码
boolean CAS(address, expect, update) {
    if (*address == expect) {
        *address = update;
        return true;
    }
    return false;
}
```

#### HotSpot实现

**源码位置**: `runtime/atomic.hpp`

```cpp
template<typename T>
inline T Atomic::cmpxchg(T exchange_value, volatile T* dest, T compare_value) {
  // 调用平台特定实现
  return PlatformCmpxchg<sizeof(T)>()(exchange_value, dest, compare_value);
}
```

**x86实现**: `atomic_linux_x86.hpp`

```cpp
template<>
struct Atomic::PlatformCmpxchg<4> {
  int32_t operator()(int32_t exchange_value,
                     volatile int32_t* dest,
                     int32_t compare_value) const {
    __asm__ volatile (
      "lock cmpxchgl %1, (%3)"
      : "=a" (exchange_value)
      : "r" (exchange_value), "a" (compare_value), "r" (dest)
      : "cc", "memory"
    );
    return exchange_value;
  }
};
```

#### lock前缀的作用

```
x86 lock前缀:
1. 锁住内存总线或使用缓存锁
2. 等待之前的读写完成
3. 禁止后续读写越过这条指令
4. 相当于隐含了完整内存屏障
```

#### CAS的ABA问题

```java
// ABA问题示例
AtomicReference<Node> head;

// Thread 1
Node A = head.get();  // A
// 被中断

// Thread 2  
head.compareAndSet(A, B);  // A→B
head.compareAndSet(B, A);  // B→A (新的A对象)

// Thread 1 继续
head.compareAndSet(A, C);  // 成功！但A已经变了

// 解决方案: AtomicStampedReference
AtomicStampedReference<Node> head;
head.compareAndSet(A, C, stamp, stamp+1);
```

---

## 问题6：JVM中的内存屏障使用场景？

### 面试官视角
考察内存屏障在JVM各组件中的实际应用。

### 参考答案

#### 1. 对象初始化

```cpp
// 对象分配后，字段清零
// 需要StoreStore屏障确保初始化完成
void* CollectedHeap::allocate_new_obj(size_t size) {
  HeapWord* obj = allocate(size);
  Copy::fill_to_aligned_words(obj, size, 0);  // 清零
  OrderAccess::storestore();  // 确保清零可见
  return obj;
}
```

#### 2. 偏向锁操作

```cpp
// biasedLocking.cpp
void BiasedLocking::revoke_at_safepoint(oop obj) {
  // 修改Mark Word后需要屏障
  obj->set_mark(new_mark);
  OrderAccess::fence();  // 确保所有线程可见
}
```

#### 3. CardTable写屏障

```cpp
// GC写屏障
void G1BarrierSet::write_ref_field_post(oop* field) {
  // 更新引用后标记card
  jbyte* card = byte_for(field);
  *card = dirty_card;
  // x86上不需要额外屏障(store-store有序)
}
```

#### 4. SATB写屏障

```cpp
// 并发标记期间的写屏障
void G1BarrierSet::write_ref_field_pre(oop* field, oop old_value) {
  if (marking_active) {
    // 保存原值到SATB队列
    satb_enqueue(old_value);
    // 需要屏障确保入队完成后再更新引用
    OrderAccess::storestore();
  }
}
```

#### 5. volatile字段访问

```cpp
// 模板解释器中的volatile处理
void TemplateInterpreterGenerator::generate_putfield(bool is_volatile) {
  if (is_volatile) {
    __ membar(Assembler::StoreStore | Assembler::LoadStore);
    // 写操作
    __ membar(Assembler::StoreLoad);
  }
}
```

---

## 问题7：伪共享(False Sharing)是什么？如何避免？

### 面试官视角
考察对缓存行和性能优化的理解。

### 参考答案

#### 伪共享定义

当多个线程访问位于同一缓存行的不同变量时，会导致缓存行在CPU间频繁失效和传输。

```
CPU0                    CPU1
┌───────────┐          ┌───────────┐
│  Cache    │          │  Cache    │
│ ┌───────┐ │          │ ┌───────┐ │
│ │ A │ B │ │◄────────►│ │ A │ B │ │
│ └───────┘ │  失效     │ └───────┘ │
└───────────┘          └───────────┘

Thread 0 写A → 使CPU1的缓存行失效
Thread 1 写B → 使CPU0的缓存行失效
即使A和B是独立的！
```

#### HotSpot的解决方案

**源码位置**: `memory/padded.hpp`

```cpp
// 填充以避免伪共享
template <class T, size_t alignment = DEFAULT_CACHE_LINE_SIZE>
class PaddedEnd : public T {
  char _pad[alignment - (sizeof(T) % alignment)];
};

// 使用示例
PaddedEnd<volatile jlong> _counter;  // 确保独占缓存行
```

#### Java代码层面

```java
// JDK 8+: @Contended注解
@sun.misc.Contended
class Counter {
    volatile long value;
}

// 需要JVM参数: -XX:-RestrictContended

// 手动填充
class ManualPadding {
    long p1, p2, p3, p4, p5, p6, p7;  // 7个long = 56字节
    volatile long value;
    long p8, p9, p10, p11, p12, p13, p14;
}
```

#### HotSpot内部使用

```cpp
// ObjectMonitor中的填充
class ObjectMonitor {
  // ... 字段
  
  // Padded to avoid false sharing
  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile markOop));
  
  volatile intptr_t _recursions;
  
  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(intptr_t));
};
```

---

## 总结

### 关键源码文件

| 主题 | 源码文件 | 关键类/方法 |
|------|----------|-------------|
| 内存屏障 | `runtime/orderAccess.hpp` | `OrderAccess::fence/acquire/release` |
| 原子操作 | `runtime/atomic.hpp` | `Atomic::cmpxchg/load/store` |
| volatile | `opto/memnode.cpp` | `MemBarNode` |
| 填充 | `memory/padded.hpp` | `PaddedEnd` |

### 面试回答要点

1. **JMM三特性**: 原子性、可见性、有序性，通过volatile/synchronized/final保证
2. **内存屏障**: LoadLoad、StoreStore、LoadStore、StoreLoad四种，x86只需StoreLoad
3. **volatile**: 插入屏障禁止重排序，写后StoreLoad保证可见性
4. **final**: 构造器返回前StoreStore屏障，保证安全发布
5. **CAS**: x86使用lock cmpxchg，隐含完整内存屏障
6. **伪共享**: 使用@Contended或手动填充，确保变量独占缓存行
