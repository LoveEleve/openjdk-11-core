# JVM技术专家面试 - 偏向锁与锁升级

## 面试题1：Mark Word的结构在不同锁状态下是怎样变化的？

**难度**：⭐⭐⭐⭐⭐

### 面试官问：

Java对象头的Mark Word在无锁、偏向锁、轻量级锁、重量级锁这四种状态下，其位布局是如何组织的？

### 答题要点：

#### 1. Mark Word基本结构（64位JVM）

从 `markOop.hpp` 可以看到完整定义：

```cpp
//  64 bits:
//  --------
//  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)
//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
//  PromotedObject*:62 --------------------->| promo_bits:2 (during GC)
//  size:64 ----------------------------------------------------->| (for CMS)
//
//  - hash contains the identity hash value: largest value is 31 bits
//  - the biased_lock:1 and lock:2 bits are used to describe three states
//  - the two lock bits are used to describe four states:
//     00 - lightweight locked (轻量级锁)
//     01 - unlocked or biased (无锁或偏向锁)
//     10 - heavyweight locked (重量级锁)
//     11 - marked for gc (GC标记)
```

#### 2. 各状态下的位布局

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          64位 Mark Word 布局                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  无锁状态 (lock=01, biased_lock=0):                                          │
│  ┌──────────────┬────────────┬────────┬──────┬───────────────┬──────┐      │
│  │  unused:25   │  hashcode  │unused:1│ age:4│ biased_lock:1 │lock:2│      │
│  │              │    :31     │        │      │      0        │  01  │      │
│  └──────────────┴────────────┴────────┴──────┴───────────────┴──────┘      │
│                                                                              │
│  偏向锁状态 (lock=01, biased_lock=1):                                        │
│  ┌──────────────────────────┬────────┬────────┬──────┬─────────────┬──────┐│
│  │     JavaThread*:54       │epoch:2 │unused:1│ age:4│biased_lock:1│lock:2││
│  │   (偏向线程的指针)         │        │        │      │     1       │  01  ││
│  └──────────────────────────┴────────┴────────┴──────┴─────────────┴──────┘│
│                                                                              │
│  轻量级锁状态 (lock=00):                                                     │
│  ┌───────────────────────────────────────────────────────────────────┬──────┐
│  │              指向线程栈中Lock Record的指针:62                      │lock:2│
│  │                                                                   │  00  │
│  └───────────────────────────────────────────────────────────────────┴──────┘
│                                                                              │
│  重量级锁状态 (lock=10):                                                     │
│  ┌───────────────────────────────────────────────────────────────────┬──────┐
│  │              指向ObjectMonitor的指针:62                            │lock:2│
│  │                                                                   │  10  │
│  └───────────────────────────────────────────────────────────────────┴──────┘
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 3. 源码中的常量定义

```cpp
// markOop.hpp
enum { 
  locked_value             = 0,  // 00 = 轻量级锁
  unlocked_value           = 1,  // 01 = 无锁
  monitor_value            = 2,  // 10 = 重量级锁
  marked_value             = 3,  // 11 = GC标记
  biased_lock_pattern      = 5   // 101 = 偏向锁 (biased_lock=1, lock=01)
};

// 位移量
lock_shift        = 0,
biased_lock_shift = lock_shift + 2,  // 2
age_shift         = biased_lock_shift + 1,  // 3
epoch_shift       = age_shift + 4,   // 7
hash_shift        = age_shift + 4    // 7 (对于无锁状态)
```

#### 4. 判断方法

```cpp
// markOop.hpp
bool has_bias_pattern() const {
  return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern);
}

bool has_locker() const {  // 轻量级锁
  return ((value() & lock_mask_in_place) == locked_value);
}

bool has_monitor() const {  // 重量级锁
  return ((value() & monitor_value) != 0);
}

bool is_neutral() const {  // 无锁
  return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value);
}
```

---

## 面试题2：偏向锁是如何工作的？为什么JDK 15默认禁用？

**难度**：⭐⭐⭐⭐⭐

### 面试官问：

偏向锁的加锁和撤销过程是什么样的？JDK 15为什么要废弃偏向锁？

### 答题要点：

#### 1. 偏向锁的设计目标

偏向锁针对**无竞争场景**优化：如果一个对象总是被同一个线程锁定，可以避免CAS操作。

#### 2. 偏向锁的延迟启动

```cpp
// biasedLocking.cpp
void BiasedLocking::init() {
  if (UseBiasedLocking) {
    if (BiasedLockingStartupDelay > 0) {
      // 默认延迟4秒启动偏向锁
      EnableBiasedLockingTask* task = new EnableBiasedLockingTask(BiasedLockingStartupDelay);
      task->enroll();
    }
  }
}
```

**延迟原因**：JVM启动时有大量同步操作（类加载等），此时偏向锁会导致大量撤销操作。

#### 3. 偏向锁的获取

```cpp
// 解释器/JIT编译的快速路径（伪代码）
void fast_enter_biased(Handle obj, JavaThread* thread) {
  markOop mark = obj->mark();
  
  // 检查是否可偏向
  if (mark->has_bias_pattern()) {
    // 检查是否偏向当前线程
    if (mark->biased_locker() == thread) {
      // 已偏向当前线程，直接返回（无需任何操作！）
      return;
    }
    
    // 检查epoch是否过期
    if (mark->bias_epoch() != klass->prototype_header()->bias_epoch()) {
      // epoch过期，尝试重偏向
      markOop new_mark = markOopDesc::encode(thread, mark->age(), new_epoch);
      if (CAS(&obj->_mark, mark, new_mark) == mark) {
        return;  // 重偏向成功
      }
    }
    
    // 需要撤销偏向 → 进入慢路径
  }
}
```

#### 4. 偏向锁的撤销

**撤销是偏向锁最大的开销**，需要在SafePoint进行：

```cpp
// biasedLocking.cpp
static BiasedLocking::Condition revoke_bias(oop obj, ...) {
  markOop mark = obj->mark();
  
  // 找到偏向的线程
  JavaThread* biased_thread = mark->biased_locker();
  
  if (biased_thread == NULL) {
    // 匿名偏向，直接CAS撤销
    markOop unbiased = markOopDesc::prototype()->set_age(mark->age());
    obj->cas_set_mark(unbiased, mark);
    return BIAS_REVOKED;
  }
  
  // 需要暂停偏向线程，检查是否还持有锁
  // 这就是为什么偏向锁撤销很昂贵！
  
  // 遍历偏向线程的所有栈帧
  GrowableArray<MonitorInfo*>* cached = get_or_compute_monitor_info(biased_thread);
  
  bool still_owns_lock = false;
  for (MonitorInfo* mon : cached) {
    if (mon->owner() == obj) {
      still_owns_lock = true;
      break;
    }
  }
  
  if (still_owns_lock) {
    // 线程还持有锁，升级为轻量级锁
    // 在偏向线程的栈上创建Lock Record
    // 修改mark word指向Lock Record
  } else {
    // 线程不再持有锁，直接撤销
    obj->set_mark(markOopDesc::prototype()->set_age(mark->age()));
  }
  
  return BIAS_REVOKED;
}
```

#### 5. 批量撤销与批量重偏向

```cpp
// Klass中的计数器
class Klass {
  jint _biased_lock_revocation_count;
  jlong _last_biased_lock_bulk_revocation_time;
  markOop _prototype_header;  // 类的原型header
};

// 当撤销次数超过阈值
if (revocation_count >= BiasedLockingBulkRebiasThreshold) {
  // 批量重偏向：增加epoch，让所有旧偏向失效
  klass->set_prototype_header(prototype->incr_bias_epoch());
}

if (revocation_count >= BiasedLockingBulkRevokeThreshold) {
  // 批量撤销：禁用该类的偏向锁
  klass->set_prototype_header(markOopDesc::prototype());
}
```

#### 6. 为什么JDK 15默认禁用？

**问题1：撤销代价太高**
- 需要SafePoint全局停顿
- 需要遍历线程栈
- 在多线程竞争场景下反而更慢

**问题2：现代应用特点变化**
- 微服务架构，大量线程
- 短生命周期的同步块
- 竞争更频繁

**问题3：维护成本**
- 代码复杂度高
- 与其他优化（如Loom）交互困难

```bash
# JDK 15+默认禁用
-XX:-UseBiasedLocking  # 默认
-XX:+UseBiasedLocking  # 需要显式启用
```

---

## 面试题3：轻量级锁的工作原理是什么？

**难度**：⭐⭐⭐⭐

### 面试官问：

轻量级锁使用CAS和Lock Record，具体是如何实现加锁和解锁的？

### 答题要点：

#### 1. Lock Record结构

```cpp
// basicLock.hpp
class BasicLock {
  volatile markOop _displaced_header;  // 保存对象原来的mark word
};

// 栈帧中的Lock Record布局
struct LockRecord {
  BasicLock _lock;   // 保存displaced mark word
  oop _obj;          // 指向锁对象（用于GC）
};
```

#### 2. 轻量级锁加锁流程

```cpp
// synchronizer.cpp
void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {
  markOop mark = obj->mark();
  
  // 检查是否是无锁状态
  if (mark->is_neutral()) {
    // 1. 保存原mark word到Lock Record
    lock->set_displaced_header(mark);
    
    // 2. CAS尝试将对象的mark word替换为指向Lock Record的指针
    if (mark == obj()->cas_set_mark((markOop)lock, mark)) {
      // CAS成功，获得轻量级锁
      return;
    }
    // CAS失败，继续下面的逻辑
  }
  
  // 检查是否是当前线程的重入
  else if (mark->has_locker() &&
           THREAD->is_lock_owned((address)mark->locker())) {
    // 重入情况：Lock Record的displaced header设为NULL
    lock->set_displaced_header(NULL);
    return;
  }
  
  // 竞争情况：需要膨胀为重量级锁
  lock->set_displaced_header(markOopDesc::unused_mark());
  ObjectSynchronizer::inflate(THREAD, obj, inflate_cause_monitor_enter)->enter(THREAD);
}
```

#### 3. 轻量级锁解锁流程

```cpp
void ObjectSynchronizer::slow_exit(oop object, BasicLock* lock, TRAPS) {
  markOop dhw = lock->displaced_header();
  
  if (dhw == NULL) {
    // 重入的解锁，直接返回
    return;
  }
  
  // CAS尝试恢复原来的mark word
  markOop header = object->mark();
  if (header == (markOop)lock) {
    // 没有竞争，CAS恢复
    if (object->cas_set_mark(dhw, (markOop)lock) == (markOop)lock) {
      return;  // 解锁成功
    }
  }
  
  // CAS失败或已膨胀，通过重量级锁退出
  ObjectSynchronizer::inflate(THREAD, object, inflate_cause_vm_internal)->exit(true, THREAD);
}
```

#### 4. 轻量级锁状态图

```
┌────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   Object Mark Word                    Thread Stack (Lock Record)            │
│                                                                             │
│   加锁前 (无锁状态):                                                         │
│   ┌──────────────┬────────┬──────┐                                         │
│   │  hashcode    │  age   │  01  │                                         │
│   └──────────────┴────────┴──────┘                                         │
│                                                                             │
│                                      ┌─────────────────────────┐            │
│   加锁后 (轻量级锁):                   │ Lock Record:            │            │
│   ┌───────────────────────────┬────┐ │ ┌─────────────────────┐ │            │
│   │ ptr to Lock Record        │ 00 │◄┼─┤ displaced: hashcode │ │            │
│   └───────────────────────────┴────┘ │ │             age, 01 │ │            │
│                                      │ └─────────────────────┘ │            │
│                                      │ obj: ──────────────────►│            │
│                                      └─────────────────────────┘            │
│                                                                             │
│   解锁: CAS(ptr, displaced) → 恢复原mark word                               │
│                                                                             │
└────────────────────────────────────────────────────────────────────────────┘
```

---

## 面试题4：锁膨胀的过程是怎样的？ObjectMonitor的结构？

**难度**：⭐⭐⭐⭐⭐

### 面试官问：

当发生锁竞争时，轻量级锁如何膨胀为重量级锁？ObjectMonitor的内部结构是什么？

### 答题要点：

#### 1. ObjectMonitor结构

```cpp
// objectMonitor.hpp
class ObjectMonitor {
  // 与对象关联
  volatile markOop _header;      // displaced object header
  void* volatile _object;        // 关联的对象
  
  // 所有者
  void* volatile _owner;         // 持有锁的线程
  
  // 递归计数
  volatile jint _recursions;
  
  // 等待队列（调用wait()的线程）
  ObjectWaiter* volatile _WaitSet;
  
  // 竞争队列（尝试获取锁的线程）
  ObjectWaiter* volatile _cxq;        // 最近竞争的线程
  ObjectWaiter* volatile _EntryList;  // 等待队列
  
  // 统计信息
  volatile jint _count;          // 竞争者数量
  volatile jint _waiters;        // wait()的线程数
};
```

#### 2. 锁膨胀流程

```cpp
// synchronizer.cpp
ObjectMonitor* ObjectSynchronizer::inflate(Thread* self, oop object, inflate_cause cause) {
  for (;;) {
    const markOop mark = object->mark();
    
    // CASE 1: 已经是重量级锁
    if (mark->has_monitor()) {
      ObjectMonitor* inf = mark->monitor();
      return inf;
    }
    
    // CASE 2: 正在膨胀中（其他线程正在膨胀）
    if (mark == markOopDesc::INFLATING()) {
      // 自旋等待膨胀完成
      ReadStableMark(object);
      continue;
    }
    
    // CASE 3: 轻量级锁状态
    if (mark->has_locker()) {
      // 分配ObjectMonitor
      ObjectMonitor* m = omAlloc(self);
      m->_header = markOopDesc::INFLATING();  // 标记正在膨胀
      
      // CAS设置为INFLATING状态
      if (object->cas_set_mark(markOopDesc::INFLATING(), mark) != mark) {
        omRelease(self, m, true);
        continue;  // CAS失败，重试
      }
      
      // 设置monitor
      m->_header = mark->displaced_mark_helper();  // 保存原mark
      m->_object = object;
      m->_owner = mark->locker();  // 当前持有轻量级锁的线程
      
      // 设置对象的mark word指向monitor
      object->release_set_mark(markOopDesc::encode(m));
      return m;
    }
    
    // CASE 4: 无锁状态
    ObjectMonitor* m = omAlloc(self);
    m->_header = mark;
    m->_object = object;
    m->_owner = NULL;
    
    if (object->cas_set_mark(markOopDesc::encode(m), mark) != mark) {
      omRelease(self, m, true);
      continue;  // CAS失败，重试
    }
    
    return m;
  }
}
```

#### 3. 膨胀状态转换

```
┌─────────────────────────────────────────────────────────────────┐
│                        锁膨胀过程                                │
│                                                                  │
│  轻量级锁 (lock=00)                                              │
│       │                                                          │
│       │ 另一个线程尝试获取锁                                     │
│       ▼                                                          │
│  CAS设置为INFLATING状态                                          │
│       │                                                          │
│       │ 分配ObjectMonitor                                        │
│       │ 设置monitor的owner为当前持有者                           │
│       ▼                                                          │
│  设置mark word指向ObjectMonitor                                  │
│       │                                                          │
│       ▼                                                          │
│  重量级锁 (lock=10)                                              │
│                                                                  │
│  竞争者进入EntryList等待                                         │
└─────────────────────────────────────────────────────────────────┘
```

#### 4. 重量级锁的enter/exit

```cpp
// objectMonitor.cpp
void ObjectMonitor::enter(TRAPS) {
  // 快速路径：尝试CAS获取
  if (Atomic::cmpxchg(self, &_owner, (void*)NULL) == NULL) {
    return;  // 成功获取
  }
  
  // 检查重入
  if (_owner == self) {
    _recursions++;
    return;
  }
  
  // 慢路径：需要排队
  // 1. 先自旋尝试
  for (int i = 0; i < Knob_SpinLimit; i++) {
    if (TryLock(self) > 0) return;
    SpinPause();
  }
  
  // 2. 加入cxq队列
  ObjectWaiter node(self);
  enqueue_in_cxq(&node);
  
  // 3. 阻塞等待
  for (;;) {
    if (TryLock(self) > 0) break;
    park(self);  // 系统调用，阻塞线程
  }
  
  // 获得锁后从队列中移除
}

void ObjectMonitor::exit(bool not_suspended, TRAPS) {
  // 处理递归
  if (_recursions > 0) {
    _recursions--;
    return;
  }
  
  // 释放锁
  OrderAccess::release_store(&_owner, (void*)NULL);
  
  // 唤醒等待者
  ObjectWaiter* w = NULL;
  if (_EntryList != NULL) {
    w = _EntryList;
    // ...移除w
  } else if (_cxq != NULL) {
    w = _cxq;
    // ...
  }
  
  if (w != NULL) {
    unpark(w->_thread);  // 唤醒等待线程
  }
}
```

---

## 面试题5：自旋锁优化和自适应自旋是什么？

**难度**：⭐⭐⭐⭐

### 面试官问：

JVM在获取重量级锁之前会先自旋，自适应自旋是如何工作的？

### 答题要点：

#### 1. 为什么需要自旋

```
线程阻塞的代价：
1. 用户态 → 内核态切换
2. 线程上下文保存
3. 调度器介入
4. 唤醒时再次切换

如果锁很快就会被释放，自旋等待比阻塞更高效
```

#### 2. 自旋实现

```cpp
// objectMonitor.cpp
int ObjectMonitor::TrySpin(Thread* self) {
  int ctr = Knob_SpinLimit;  // 自旋次数上限
  
  for (;;) {
    // 尝试获取锁
    if (TryLock(self) > 0) return 1;
    
    if (--ctr <= 0) return 0;  // 自旋次数用尽
    
    SpinPause();  // CPU暂停指令（减少功耗和总线竞争）
  }
}
```

#### 3. 自适应自旋

JVM会根据历史数据动态调整自旋次数：

```cpp
// 伪代码，说明自适应原理
void adaptive_spin(ObjectMonitor* monitor) {
  // 如果上次在这个锁上自旋成功获得锁
  if (monitor->_last_spin_success) {
    spin_limit = MIN(spin_limit * 2, MAX_SPIN_LIMIT);  // 增加自旋
  } else {
    spin_limit = MAX(spin_limit / 2, MIN_SPIN_LIMIT);  // 减少自旋
  }
  
  // 如果持有锁的线程正在运行（在CPU上）
  if (owner_thread->is_on_cpu()) {
    // 值得自旋，因为锁很快会被释放
  } else {
    // 不值得自旋，直接阻塞
    spin_limit = 0;
  }
}
```

#### 4. 相关参数

```bash
# 是否使用自旋
-XX:+UseSpinning  # JDK 6默认开启

# 自旋次数（自适应会覆盖）
-XX:PreBlockSpin=10

# 自适应自旋
-XX:+UseAdaptiveSpinning  # 默认开启
```

---

## 面试题6：锁消除和锁粗化是什么？

**难度**：⭐⭐⭐

### 面试官问：

JIT编译器如何优化不必要的同步操作？

### 答题要点：

#### 1. 锁消除（Lock Elision）

当JIT检测到锁对象不可能被其他线程访问时，会消除同步：

```java
// 原始代码
public String concat(String s1, String s2) {
    StringBuffer sb = new StringBuffer();  // sb是局部变量
    sb.append(s1);  // StringBuffer的append是synchronized
    sb.append(s2);
    return sb.toString();
}

// 逃逸分析后：sb不会逃逸出方法
// JIT优化后（等效）：
public String concat(String s1, String s2) {
    char[] chars = new char[s1.length() + s2.length()];
    // 直接操作，无同步
}
```

#### 2. 锁粗化（Lock Coarsening）

将多个连续的小同步块合并为一个大同步块：

```java
// 原始代码
for (int i = 0; i < 1000; i++) {
    synchronized(lock) {
        // 操作
    }
}

// 优化后
synchronized(lock) {
    for (int i = 0; i < 1000; i++) {
        // 操作
    }
}
```

#### 3. 相关参数

```bash
# 逃逸分析（锁消除的前提）
-XX:+DoEscapeAnalysis  # 默认开启

# 锁消除
-XX:+EliminateLocks    # 默认开启

# 查看锁优化
-XX:+PrintEliminateLocks
```

---

## 总结：锁状态转换全景图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          Java对象锁状态转换                              │
│                                                                          │
│                        ┌─────────────────┐                               │
│                        │   无锁状态       │                               │
│                        │  (normal)       │                               │
│                        └────────┬────────┘                               │
│                                 │                                        │
│          ┌──────────────────────┼──────────────────────┐                │
│          │ (启用偏向锁)          │                      │                │
│          ▼                      │                      │                │
│  ┌───────────────┐              │                      │                │
│  │   偏向锁       │              │                      │                │
│  │  (biased)     │              │                      │                │
│  └───────┬───────┘              │                      │                │
│          │                      │                      │                │
│          │ (竞争发生)            │ (直接竞争)            │                │
│          │ (需要SafePoint)       │                      │                │
│          ▼                      ▼                      │                │
│  ┌───────────────────────────────────────┐             │                │
│  │           轻量级锁                     │             │                │
│  │         (thin lock)                   │             │                │
│  │      使用CAS + Lock Record            │             │                │
│  └───────────────────┬───────────────────┘             │                │
│                      │                                 │                │
│                      │ (竞争激烈/自旋失败)               │                │
│                      ▼                                 │                │
│  ┌───────────────────────────────────────────────────────────────┐      │
│  │                     重量级锁                                   │      │
│  │                   (fat lock)                                  │      │
│  │          使用ObjectMonitor + 操作系统互斥量                     │      │
│  │                                                               │      │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐                    │      │
│  │  │   cxq    │  │EntryList │  │ WaitSet  │                    │      │
│  │  │(竞争队列) │  │(就绪队列) │  │(等待队列)│                    │      │
│  │  └──────────┘  └──────────┘  └──────────┘                    │      │
│  └───────────────────────────────────────────────────────────────┘      │
│                                                                          │
│  注意：锁只能升级，不能降级（除非GC时重置）                               │
└─────────────────────────────────────────────────────────────────────────┘
```

### 关键参数速查

| 参数 | 作用 | 默认值 |
|------|------|--------|
| -XX:+UseBiasedLocking | 启用偏向锁 | JDK15前true |
| -XX:BiasedLockingStartupDelay | 偏向锁启动延迟 | 4000ms |
| -XX:BiasedLockingBulkRebiasThreshold | 批量重偏向阈值 | 20 |
| -XX:BiasedLockingBulkRevokeThreshold | 批量撤销阈值 | 40 |
| -XX:+UseSpinning | 使用自旋 | true |
| -XX:+UseAdaptiveSpinning | 自适应自旋 | true |
