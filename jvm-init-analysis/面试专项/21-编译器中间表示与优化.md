# 21-编译器中间表示与优化

## 面试官：C2编译器使用什么中间表示(IR)？

### 答案

#### 1. Sea-of-Nodes IR

C2编译器使用**Sea-of-Nodes**（节点海）中间表示：

```
特点：
1. 数据流和控制流统一表示
2. 无固定指令顺序（直到调度阶段）
3. 每个节点代表一个操作
4. 边表示数据依赖和控制依赖
```

#### 2. Node类定义

```cpp:200:209:openjdk11-core/src/hotspot/share/opto/node.hpp
// They are both vertices in a directed graph and program primitives.  Nodes
// are labeled; the label is the "opcode", the primitive function in the lambda
// calculus sense that gives meaning to the Node.  Node inputs are ordered (so
// that "a-b" is different from "b-a").  The inputs to a Node are the inputs to
// the Node's function.  These inputs also define a Type equation for the Node.
// Solving these Type equations amounts to doing dataflow analysis.
// Control and data are uniformly represented in the graph.  Finally, Nodes
// have a unique dense integer index which is used to index into side arrays
// whenever I have phase-specific information.
```

#### 3. Node结构

```cpp:210:239:openjdk11-core/src/hotspot/share/opto/node.hpp
class Node {
  friend class VMStructs;

  // Lots of restrictions on cloning Nodes
  Node(const Node&);            // not defined; linker error to use these
  Node &operator=(const Node &rhs);

public:
  friend class Compile;
  
  // Because Nodes come and go, I define an Arena of Node structures to pull
  // from.  This should allow fast access to node creation & deletion.
  inline void* operator new(size_t x) throw() {
    Compile* C = Compile::current();
    Node* n = (Node*)C->node_arena()->Amalloc_D(x);
    return (void*)n;
  }

  // Delete is a NOP
  void operator delete( void *ptr ) {}
  // Fancy destructor; eagerly attempt to reclaim Node numberings and storage
  void destruct();
```

#### 4. Node的边结构

```cpp:279:301:openjdk11-core/src/hotspot/share/opto/node.hpp
protected:
  friend class PhaseCFG;        // Access to address of _in array elements
  Node **_in;                   // Array of use-def references to Nodes
  Node **_out;                  // Array of def-use references to Nodes

  // Input edges are split into two categories.  Required edges are required
  // for semantic correctness; order is important and NULLs are allowed.
  // Precedence edges are used to help determine execution order and are
  // added, e.g., for scheduling purposes.  They are unordered and not
  // duplicated; they have no embedded NULLs.  Edges from 0 to _cnt-1
  // are required, from _cnt to _max-1 are precedence edges.
  node_idx_t _cnt;              // Total number of required Node inputs.

  node_idx_t _max;              // Actual length of input array.

  // Output edges are an unordered list of def-use edges which exactly
  // correspond to required input edges which point from other nodes
  // to this one.  Thus the count of the output edges is the number of
  // users of this node.
  node_idx_t _outcnt;           // Total number of Node outputs.

  node_idx_t _outmax;           // Actual length of output array.
```

---

## 面试官：C2编译的主要阶段有哪些？

### 答案

#### 1. C2编译流程

```
字节码 → Parse → Ideal Graph → 优化 → Match → 寄存器分配 → 代码生成

详细流程：
┌─────────────────────────────────────────────────────────────────────┐
│ 1. Parse阶段                                                        │
│    字节码 → Ideal Graph (高级IR)                                    │
└─────────────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────────────┐
│ 2. 优化阶段                                                         │
│    - Iterative GVN (全局值编号)                                     │
│    - Loop优化 (循环展开、分离、向量化)                               │
│    - Escape Analysis (逃逸分析)                                      │
│    - Null Check Elimination                                          │
│    - Dead Code Elimination                                           │
│    - Constant Folding                                                │
└─────────────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────────────┐
│ 3. Match阶段                                                        │
│    Ideal Graph → Machine Graph (低级IR)                             │
│    选择机器指令                                                      │
└─────────────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────────────┐
│ 4. 寄存器分配                                                        │
│    Chaitin-Briggs Graph Coloring                                     │
└─────────────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────────────┐
│ 5. 代码生成                                                         │
│    Machine Graph → 机器码                                           │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2. 主要Phase类

```cpp
// opto/phase.hpp
class Phase : public StackObj {
    // 所有优化阶段的基类
};

class PhaseTransform : public Phase {
    // 节点转换基类
};

class PhaseGVN : public PhaseTransform {
    // 全局值编号
};

class PhaseIterGVN : public PhaseGVN {
    // 迭代全局值编号
};

class PhaseCFG : public Phase {
    // 控制流图构建
};

class PhaseChaitin : public PhaseRegAlloc {
    // 寄存器分配
};
```

---

## 面试官：什么是GVN（全局值编号）？

### 答案

#### 1. GVN概念

GVN (Global Value Numbering) 是一种发现和消除冗余计算的优化技术：

```
// 优化前
a = x + y
b = x + y  // 冗余计算

// 优化后
a = x + y
b = a      // 复用已计算的值
```

#### 2. PhaseIterGVN

```cpp:448:461:openjdk11-core/src/hotspot/share/opto/phaseX.hpp
//------------------------------PhaseIterGVN-----------------------------------
// Phase for iteratively performing local, pessimistic GVN-style optimizations.
// and ideal transformations on the graph.
class PhaseIterGVN : public PhaseGVN {
private:
  bool _delay_transform;  // When true simply register the node when calling transform
                          // instead of actually optimizing it

  // Idealize old Node 'n' with respect to its inputs and its value
  virtual Node *transform_old( Node *a_node );

  // Subsume users of node 'old' into node 'nn'
  void subsume_node( Node *old, Node *nn );
```

#### 3. GVN工作原理

```
GVN使用哈希表识别等价表达式:

1. 对每个节点计算哈希值
   hash(node) = f(opcode, input0, input1, ...)

2. 检查哈希表是否存在等价节点
   - 存在: 用已存在节点替换
   - 不存在: 加入哈希表

3. 递归处理直到不动点
```

#### 4. 示例

```
原始图:
    Add
   /   \
  x     y
  
    Add        (冗余)
   /   \
  x     y

优化后:
    Add ←──────┐
   /   \       │
  x     y      │
               │
   (第二个Add被替换为指向第一个)
```

---

## 面试官：C2的Node有哪些主要类型？

### 答案

#### 1. Node类型层次

```
Node (基类)
  │
  ├── TypeNode           // 带类型的节点
  │     ├── ConNode      // 常量节点
  │     └── ...
  │
  ├── RegionNode         // 控制流合并
  ├── PhiNode            // φ函数
  ├── IfNode             // 条件分支
  ├── CallNode           // 调用
  │
  ├── LoadNode           // 内存读
  ├── StoreNode          // 内存写
  │
  ├── AddNode            // 加法
  ├── SubNode            // 减法
  ├── MulNode            // 乘法
  │
  └── MachNode           // 机器指令节点
```

#### 2. 控制流节点

```
StartNode → 方法入口
RootNode → IR图的根
RegionNode → 控制流合并点
IfNode → 条件分支
GotoNode → 无条件跳转
ReturnNode → 方法返回
```

#### 3. 数据流节点

```
ConNode → 常量
ParmNode → 参数
LoadNode → 加载
StoreNode → 存储
AddNode → 加法
CmpNode → 比较
PhiNode → SSA φ函数
```

---

## 面试官：什么是Ideal和Identity转换？

### 答案

#### 1. Ideal转换

```cpp
// 每个Node可以定义Ideal方法进行优化
virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);

// 例如: AddNode的Ideal转换
Node* AddNode::Ideal(PhaseGVN* phase, bool can_reshape) {
    // (x + 0) => x
    if (in(2)->is_Con() && in(2)->get_int() == 0) {
        return in(1);
    }
    // (x + (-y)) => (x - y)
    if (in(2)->is_Sub() && in(2)->in(1)->is_Con(0)) {
        return new SubNode(in(1), in(2)->in(2));
    }
    return NULL;  // 无转换
}
```

#### 2. Identity转换

```cpp
// Identity方法返回等价的现有节点
virtual Node* Identity(PhaseGVN* phase);

// 例如:
Node* AddNode::Identity(PhaseGVN* phase) {
    // (x + 0) => x
    if (phase->type(in(2))->is_zero()) {
        return in(1);
    }
    return this;  // 无等价节点
}
```

#### 3. 区别

```
Ideal: 创建新节点进行转换
   (a + b) + c => a + (b + c)  // 重结合

Identity: 返回已存在的等价节点
   (a + 0) => a  // 返回已存在的a节点
```

---

## 面试官：C2的类型系统是怎样的？

### 答案

#### 1. Type类层次

```
Type (基类)
  │
  ├── TypeInt         // 整数类型
  │     ├── TypeLong  // 长整数
  │     └── TypeF     // 浮点
  │
  ├── TypePtr         // 指针类型
  │     ├── TypeRawPtr    // 原始指针
  │     ├── TypeOopPtr    // 对象指针
  │     └── TypeKlassPtr  // Klass指针
  │
  ├── TypeTuple       // 元组类型
  ├── TypeFunc        // 函数类型
  └── TypeMemory      // 内存类型
```

#### 2. 类型格

```
类型系统形成一个格(Lattice):

      ⊤ (Top/Any)
     /|\
    / | \
   /  |  \
  T1  T2  T3   (具体类型)
   \  |  /
    \ | /
     \|/
      ⊥ (Bottom/Undefined)

meet(T1, T2) = 两者的最大下界
join(T1, T2) = 两者的最小上界
```

#### 3. 类型推断

```cpp
// 每个Node都有关联的类型
const Type* Node::Value(PhaseGVN* phase) const {
    // 根据输入类型计算输出类型
}

// 例如AddNode
const Type* AddNode::Value(PhaseGVN* phase) const {
    const Type* t1 = phase->type(in(1));
    const Type* t2 = phase->type(in(2));
    return t1->meet(t2);  // 结果类型是输入类型的meet
}
```

---

## 面试官：循环优化有哪些主要技术？

### 答案

#### 1. 循环展开 (Loop Unrolling)

```java
// 原始循环
for (int i = 0; i < n; i++) {
    a[i] = b[i] + c[i];
}

// 展开后
for (int i = 0; i < n; i += 4) {
    a[i] = b[i] + c[i];
    a[i+1] = b[i+1] + c[i+1];
    a[i+2] = b[i+2] + c[i+2];
    a[i+3] = b[i+3] + c[i+3];
}
```

#### 2. 循环分离 (Loop Peeling)

```java
// 原始：带边界检查的循环
for (int i = 0; i < n; i++) {
    if (i < limit) {
        a[i] = ...
    }
}

// 分离后：条件移到循环外
for (int i = 0; i < min(n, limit); i++) {
    a[i] = ...  // 无需检查
}
for (int i = limit; i < n; i++) {
    // 另一分支
}
```

#### 3. 循环向量化 (Vectorization)

```java
// 标量循环
for (int i = 0; i < n; i++) {
    a[i] = b[i] + c[i];
}

// 向量化后 (使用SIMD指令)
for (int i = 0; i < n; i += 4) {
    // 一条指令处理4个元素
    a[i:i+4] = b[i:i+4] + c[i:i+4];
}
```

#### 4. 循环不变量外提 (Loop Invariant Code Motion)

```java
// 原始
for (int i = 0; i < n; i++) {
    a[i] = x * y + i;  // x*y在循环中不变
}

// 外提后
int tmp = x * y;
for (int i = 0; i < n; i++) {
    a[i] = tmp + i;
}
```

---

## 面试官：Match阶段做什么？

### 答案

#### 1. Match阶段目标

将**理想图(Ideal Graph)**转换为**机器图(Machine Graph)**：
- 选择具体的机器指令
- 考虑目标平台的特性
- 进行指令合并

#### 2. Matcher类

```cpp:41:49:openjdk11-core/src/hotspot/share/opto/matcher.hpp
class Matcher : public PhaseTransform {
  friend class VMStructs;

public:

  // State and MStack class used in xform() and find_shared() iterative methods.
  enum Node_State { Pre_Visit,  // node has to be pre-visited
                    Visit,  // visit node
                    Post_Visit,  // post-visit node
```

#### 3. 指令选择示例

```
Ideal Graph:               Machine Graph:
                           
   AddI                       addl (x86)
   /  \           →          /    \
  x    y                    reg1  reg2

   LoadI                      movl (x86)
    |              →           |
   addr                      [addr]
```

#### 4. 指令合并

```
// 两个操作可以合并为一条指令

   AddI                    
   /  \                    →     leal reg, [base + index * scale]
base  MulI
      /  \
   index  4
```

---

## 面试官：寄存器分配是如何进行的？

### 答案

#### 1. Chaitin-Briggs算法

C2使用图着色(Graph Coloring)算法进行寄存器分配：

```
1. Build: 构建干涉图
   - 节点 = 变量
   - 边 = 同时活跃的变量

2. Simplify: 简化图
   - 移除度数 < K的节点 (K = 寄存器数)

3. Potential Spill: 标记可能溢出的节点
   - 度数 >= K的节点

4. Select: 选择颜色(寄存器)
   - 逆序处理节点
   - 分配不冲突的寄存器

5. Actual Spill: 处理实际溢出
   - 无法分配寄存器的变量存到栈上
```

#### 2. 干涉图示例

```
变量: a, b, c, d
活跃范围:
  a: [1, 5]
  b: [2, 4]
  c: [3, 7]
  d: [6, 8]

干涉图:
  a ── b    (同时活跃在[2,4])
  │    │
  │    c    (b,c同时活跃在[3,4])
  │   /
  └──┘
      d    (d不与a,b冲突)
```

#### 3. 溢出处理

```
当寄存器不够时:
1. 选择代价最低的变量溢出到栈
2. 插入Load/Store指令
3. 重新运行分配算法
```

---

## 知识图谱

```
                    ┌─────────────────────────────────────────────────┐
                    │              C2 编译器架构                       │
                    └─────────────────────────────────────────────────┘
                                          │
       ┌──────────────────────────────────┼──────────────────────────────────┐
       ▼                                  ▼                                  ▼
┌─────────────────┐            ┌─────────────────┐            ┌─────────────────┐
│  中间表示 (IR)   │            │    优化阶段     │            │   代码生成      │
├─────────────────┤            ├─────────────────┤            ├─────────────────┤
│ Sea-of-Nodes    │            │ PhaseIterGVN    │            │ Matcher         │
│ Node图结构      │            │ 循环优化        │            │ PhaseChaitin    │
│ 数据流+控制流   │            │ 逃逸分析        │            │ 图着色分配      │
└─────────────────┘            └─────────────────┘            └─────────────────┘

编译流程:
┌────────────────────────────────────────────────────────────────────────────────┐
│                                                                                │
│  字节码 → Parse → Ideal Graph → GVN → Loop Opts → Match → RegAlloc → CodeGen  │
│                                                                                │
│    ↓         ↓          ↓          ↓        ↓         ↓         ↓        ↓    │
│  输入     构建IR      高级IR    值编号    循环     指令选择  寄存器   机器码   │
│                               公共子      优化                分配            │
│                               表达式                                          │
│                               消除                                            │
└────────────────────────────────────────────────────────────────────────────────┘

Node类型:
┌─────────────────────────────────────────┐
│ 控制流: Region, If, Goto, Return        │
│ 数据流: Add, Sub, Mul, Load, Store      │
│ φ函数:  Phi                             │
│ 调用:   Call, CallStaticJava            │
│ 机器:   MachNode子类                    │
└─────────────────────────────────────────┘
```
