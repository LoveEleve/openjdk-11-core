# 28. 垃圾收集器比较

## 一、概述

JDK 11提供了多种垃圾收集器，各有特点和适用场景。本文从源码角度深入对比各收集器的实现差异。

### 1.1 收集器分类

```
┌─────────────────────────────────────────────────────────────┐
│                      垃圾收集器分类                           │
├─────────────┬──────────────┬────────────────────────────────┤
│   Serial    │   Parallel   │         Concurrent            │
│ (单线程STW) │  (多线程STW) │       (并发+低延迟)            │
├─────────────┼──────────────┼────────────────────────────────┤
│ SerialGC    │ ParallelGC   │  CMS / G1 / ZGC / Shenandoah  │
│ DefNew+     │ PSScavenge+  │                                │
│ SerialOld   │ PSMarkSweep  │                                │
└─────────────┴──────────────┴────────────────────────────────┘
```

---

## 二、Serial GC

### 2.1 设计特点

Serial GC是最简单的垃圾收集器，采用单线程执行所有GC工作。

**核心类**（`serialHeap.hpp:38-48`）：
```cpp
class SerialHeap : public GenCollectedHeap {
private:
  MemoryPool* _eden_pool;
  MemoryPool* _survivor_pool;
  MemoryPool* _old_pool;

  virtual void initialize_serviceability();

public:
  static SerialHeap* heap();
```

### 2.2 年轻代收集器 - DefNew

**源码**（`defNewGeneration.hpp:44-52`）：
```cpp
// DefNewGeneration是包含eden、from和to空间的年轻代
class DefNewGeneration: public Generation {
  friend class VMStructs;

protected:
  Generation* _old_gen;
  uint        _tenuring_threshold;  // 晋升阈值
```

**收集流程**：
```cpp
void DefNewGeneration::collect(bool   full,
                               bool   clear_all_soft_refs,
                               size_t size,
                               bool   is_tlab) {
  // 1. 标记阶段 - 从root开始扫描
  gch->gen_process_roots(Generation::Young,
                         true,   // Process younger gens
                         true,   // Same-named classes
                         SharedHeap::SO_ScavengeCodeCache,
                         GenCollectedHeap::StrongAndWeakRoots,
                         &cl,    // ScanClosure
                         &cl);   // Same closure
  
  // 2. 复制存活对象到to空间
  evacuate_followers.do_void();
  
  // 3. 交换from和to空间
  from()->set_top(from()->bottom());
  swap_spaces();
}
```

### 2.3 老年代收集器 - SerialOld

采用标记-压缩(Mark-Compact)算法：
```cpp
// Mark-Sweep-Compact收集
void GenMarkSweep::invoke_at_safepoint(ReferenceProcessor* rp,
                                       bool clear_all_softrefs) {
  // Phase 1: Mark all live objects
  mark_sweep_phase1(clear_all_softrefs);
  
  // Phase 2: Calculate new addresses
  mark_sweep_phase2();
  
  // Phase 3: Adjust pointers
  mark_sweep_phase3();
  
  // Phase 4: Compact heap
  mark_sweep_phase4();
}
```

---

## 三、Parallel GC

### 3.1 设计特点

Parallel GC（吞吐量优先收集器）使用多线程执行GC，适合多核环境。

**核心类**（`parallelScavengeHeap.hpp:55-83`）：
```cpp
class ParallelScavengeHeap : public CollectedHeap {
  friend class VMStructs;
 private:
  static PSYoungGen* _young_gen;         // 年轻代
  static PSOldGen*   _old_gen;           // 老年代

  // 整个堆的自适应策略
  static PSAdaptiveSizePolicy*       _size_policy;
  static PSGCAdaptivePolicyCounters* _gc_policy_counters;

  GenerationSizer* _collector_policy;
  SoftRefPolicy _soft_ref_policy;

  // 相邻代管理
  AdjoiningGenerations* _gens;
  unsigned int _death_march_count;

  // 任务管理器
  static GCTaskManager* _gc_task_manager;

  // 内存管理器
  GCMemoryManager* _young_manager;
  GCMemoryManager* _old_manager;

  // 内存池
  MemoryPool* _eden_pool;
  MemoryPool* _survivor_pool;
  MemoryPool* _old_pool;
```

### 3.2 年轻代收集器 - PSScavenge

**并行扫描实现**：
```cpp
class PSScavenge: AllStatic {
  // 使用GCTask实现并行
  static bool invoke();
  
  // 任务分发
  static void parallel_scavenge() {
    ResourceMark rm;
    HandleMark hm;
    
    GCTaskQueue* q = GCTaskQueue::create();
    
    // 为每个GC线程创建任务
    uint active_workers = ParallelScavengeHeap::heap()->workers().active_workers();
    for (uint i = 0; i < active_workers; i++) {
      q->enqueue(new ScavengeRootsTask(i, active_workers));
    }
    
    // 执行任务
    gc_task_manager()->execute_and_wait(q);
  }
};
```

### 3.3 老年代收集器 - PSMarkSweep/PSCompact

**Parallel Compact**：
```cpp
// 并行压缩实现
class PSParallelCompact : AllStatic {
  // 分区压缩
  static void compact_perm(ParCompactionManager* cm);
  static void compact();
  
  // 并行标记
  static void marking_phase(ParCompactionManager* cm,
                            bool maximum_heap_compaction,
                            ParallelTaskTerminator* terminator);
};
```

---

## 四、CMS收集器

### 4.1 设计特点

CMS(Concurrent Mark Sweep)以低延迟为目标，大部分GC工作与应用线程并发执行。

**核心类**（`concurrentMarkSweepGeneration.hpp:495-628`）：
```cpp
class CMSCollector: public CHeapObj<mtGC> {
  friend class VMStructs;
  friend class ConcurrentMarkSweepThread;
  
 private:
  jlong _time_of_last_gc;
  OopTaskQueueSet* _task_queues;
  
  // 溢出列表（用于并发标记）
  oopDesc* volatile _overflow_list;
  Stack<oop, mtGC>     _preserved_oop_stack;
  Stack<markOop, mtGC> _preserved_mark_stack;

  // 并发工作线程
  YieldingFlexibleWorkGang* _conc_workers;
  
  // 是否卸载类
  bool _should_unload_classes;
  unsigned int _concurrent_cycles_since_last_unload;

 protected:
  ConcurrentMarkSweepGeneration* _cmsGen;  // 老年代
  MemRegion                      _span;     // 内存范围
  CardTableRS*                   _ct;       // 卡表
  
  // CMS标记支持结构
  CMSBitMap     _markBitMap;       // 标记位图
  CMSBitMap     _modUnionTable;    // Mod Union表
  CMSMarkStack  _markStack;        // 标记栈
};
```

### 4.2 CMS收集阶段

```
┌────────────────────────────────────────────────────────────┐
│                    CMS收集阶段                              │
├────────────────┬──────────────┬────────────────────────────┤
│  Initial Mark  │   Remark     │        Concurrent          │
│    (STW)       │    (STW)     │       (与应用并发)          │
├────────────────┼──────────────┼────────────────────────────┤
│ 标记GC Roots   │ 重新标记     │ 并发标记 / 预清理 / 清除   │
│ 直接可达对象   │ 处理引用变化 │                            │
└────────────────┴──────────────┴────────────────────────────┘
```

**收集流程实现**：
```cpp
void CMSCollector::collect_in_background(GCCause::Cause cause) {
  // Phase 1: Initial Mark (STW)
  VM_CMS_Initial_Mark initial_mark_op(this);
  VMThread::execute(&initial_mark_op);
  
  // Phase 2: Concurrent Mark
  markFromRoots();  // 并发标记
  
  // Phase 3: Concurrent Preclean
  preclean();       // 预清理
  
  // Phase 4: Final Remark (STW)
  VM_CMS_Final_Remark final_remark_op(this);
  VMThread::execute(&final_remark_op);
  
  // Phase 5: Concurrent Sweep
  sweep();          // 并发清除
  
  // Phase 6: Reset
  reset();
}
```

---

## 五、G1收集器

### 5.1 设计特点

G1(Garbage First)收集器面向大堆设计，支持可预测的停顿时间。

**核心类**（`g1CollectedHeap.hpp:130-145`）：
```cpp
class G1CollectedHeap : public CollectedHeap {
  friend class G1FreeCollectionSetTask;
  friend class VM_CollectForMetadataAllocation;
  friend class VM_G1CollectForAllocation;
  friend class VM_G1CollectFull;
  friend class VMStructs;
  friend class MutatorAllocRegion;
  friend class G1FullCollector;
  friend class G1GCAllocRegion;
  friend class G1HeapVerifier;

  // 闭包
  friend class G1ParScanThreadState;
  friend class G1ParScanThreadStateSet;
  friend class G1ParTask;
  friend class G1PLABAllocator;
```

### 5.2 Region布局

```cpp
// G1内存划分为大小相等的Region
class HeapRegion : public G1ContiguousSpace {
  // Region类型
  HeapRegionType _type;
  
  // Remember Set - 跨Region引用
  HeapRegionRemSet* _rem_set;
  
  // 分代信息
  bool _is_young;
  bool _is_survivor;
  
  // GC效率预测
  double _gc_efficiency;
};
```

### 5.3 G1收集模式

```
┌────────────────────────────────────────────────────────────┐
│                    G1收集模式                               │
├─────────────────┬──────────────────────────────────────────┤
│  Young GC       │ 收集所有Young Region                     │
├─────────────────┼──────────────────────────────────────────┤
│  Mixed GC       │ 收集Young Region + 部分Old Region        │
├─────────────────┼──────────────────────────────────────────┤
│  Full GC        │ 单线程Mark-Compact整个堆                  │
└─────────────────┴──────────────────────────────────────────┘
```

---

## 六、收集器对比

### 6.1 特性对比

| 特性 | Serial | Parallel | CMS | G1 |
|-----|--------|----------|-----|-----|
| 线程模型 | 单线程 | 多线程 | 并发+多线程 | 并发+多线程 |
| 算法 | 复制+标记压缩 | 复制+标记压缩 | 复制+标记清除 | 复制+标记整理 |
| 内存布局 | 连续分代 | 连续分代 | 连续分代 | Region分区 |
| 停顿目标 | 无 | 无 | 低延迟 | 可预测停顿 |
| 适用场景 | 小堆/客户端 | 吞吐量优先 | 低延迟 | 大堆/平衡 |

### 6.2 内存结构对比

**传统分代（Serial/Parallel/CMS）**：
```
┌─────────────────────────────────────────────────────────┐
│                        堆内存                            │
├───────────────────────────┬─────────────────────────────┤
│      Young Generation     │      Old Generation         │
├─────┬─────────┬───────────┤                             │
│Eden │Survivor0│Survivor1  │        Tenured              │
└─────┴─────────┴───────────┴─────────────────────────────┘
```

**G1 Region布局**：
```
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
│E │E │S │S │O │O │O │H │H │O │E │E │S │O │O │F │
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
 E=Eden S=Survivor O=Old H=Humongous F=Free
```

### 6.3 GC日志特征

**Serial GC**：
```
[GC (Allocation Failure) [DefNew: 8192K->1024K(9216K), 0.0123456 secs] ...]
```

**Parallel GC**：
```
[GC (Allocation Failure) [PSYoungGen: 65536K->8192K(76288K)] ...]
```

**CMS**：
```
[GC (CMS Initial Mark) [1 CMS-initial-mark: 1234K(5678K)] ...]
[CMS-concurrent-mark-start]
[CMS-concurrent-mark: 0.123/0.125 secs]
```

**G1**：
```
[GC pause (G1 Evacuation Pause) (young), 0.0234567 secs]
   [Parallel Time: 12.3 ms, GC Workers: 8]
```

---

## 七、源码关键类对比

### 7.1 堆实现类

| 收集器 | 堆实现类 | 源文件 |
|--------|----------|--------|
| Serial | SerialHeap | `serialHeap.hpp` |
| Parallel | ParallelScavengeHeap | `parallelScavengeHeap.hpp` |
| CMS | GenCollectedHeap | `genCollectedHeap.hpp` |
| G1 | G1CollectedHeap | `g1CollectedHeap.hpp` |

### 7.2 年轻代实现

| 收集器 | 年轻代类 | 算法 |
|--------|----------|------|
| Serial | DefNewGeneration | 复制 |
| Parallel | PSYoungGen | 并行复制 |
| CMS | ParNewGeneration | 并行复制 |
| G1 | G1YoungGen | 并行复制 |

### 7.3 老年代实现

| 收集器 | 老年代类 | 算法 |
|--------|----------|------|
| Serial | TenuredGeneration | Mark-Compact |
| Parallel | PSOldGen | Parallel Compact |
| CMS | ConcurrentMarkSweepGeneration | Mark-Sweep |
| G1 | G1OldGen | Mark-Compact |

---

## 八、面试要点

### 8.1 常见问题

**Q1: Serial和Parallel的主要区别？**
```
A: 核心区别是并行度：
1. Serial: 单线程执行所有GC
2. Parallel: 多线程并行执行GC

相同点：
- 都是STW收集器
- 都使用传统分代模型
- 都使用复制算法处理年轻代
```

**Q2: CMS和G1如何实现低延迟？**
```
A: 主要通过并发执行：

CMS:
1. 初始标记(STW): 只标记GC Roots直接可达对象
2. 并发标记: 与应用并发
3. 重新标记(STW): 处理并发期间引用变化
4. 并发清除: 与应用并发

G1:
1. 初始标记(STW): 随Young GC执行
2. 并发标记: 与应用并发，使用SATB
3. 最终标记(STW): 处理SATB buffer
4. 筛选回收(STW): 只回收收益最高的Region
```

**Q3: G1相比CMS的优势？**
```
A: G1改进点：
1. 可预测停顿: -XX:MaxGCPauseMillis
2. 避免内存碎片: 基于复制的回收
3. 大堆支持: Region化设计
4. 统一收集: 不需要配合其他收集器
5. 没有浮动垃圾: CMS有此问题
```

### 8.2 JVM参数

```bash
# Serial GC
-XX:+UseSerialGC

# Parallel GC (JDK8默认)
-XX:+UseParallelGC
-XX:ParallelGCThreads=N

# CMS (JDK9废弃)
-XX:+UseConcMarkSweepGC
-XX:CMSInitiatingOccupancyFraction=70

# G1 (JDK9+默认)
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:G1HeapRegionSize=N
```

---

## 九、收集器选择建议

### 9.1 场景推荐

```
┌────────────────────────────────────────────────────────────┐
│   场景                │ 推荐收集器    │ 关键参数            │
├───────────────────────┼──────────────┼────────────────────┤
│ 小堆(<100MB)          │ Serial       │ -XX:+UseSerialGC   │
│ 多核+吞吐量优先       │ Parallel     │ -XX:+UseParallelGC │
│ 大堆+低延迟           │ G1           │ MaxGCPauseMillis   │
│ 超大堆(TB级)+极低延迟 │ ZGC          │ -XX:+UseZGC        │
└───────────────────────┴──────────────┴────────────────────┘
```

### 9.2 版本建议

- **JDK 8**: Parallel GC默认，可选G1
- **JDK 11**: G1默认，ZGC预览
- **JDK 17+**: G1默认，ZGC生产可用

---

## 十、总结

### 10.1 演进历程

```
Serial → Parallel → CMS → G1 → ZGC/Shenandoah
  │         │        │      │         │
单线程   吞吐量    低延迟  可预测   亚毫秒
```

### 10.2 核心设计思想

1. **Serial**: 简单可靠
2. **Parallel**: 充分利用多核
3. **CMS**: 并发减少停顿
4. **G1**: Region化+增量回收
5. **ZGC**: 染色指针+并发整理
