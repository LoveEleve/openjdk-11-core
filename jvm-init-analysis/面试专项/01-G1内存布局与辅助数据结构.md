# JVM技术专家面试专项 - G1内存布局与辅助数据结构

> **环境**: Linux, -Xms8g -Xmx8g, G1GC, Region=4MB, 非大页, 非NUMA
> **难度**: ⭐⭐⭐⭐⭐ JVM技术专家级

---

## 面试问题 1：G1的Region大小是如何确定的？

### 👨‍💼 面试官提问

> "在8GB堆配置下，G1的Region大小是如何确定的？如果不指定`-XX:G1HeapRegionSize`参数会怎样？请从源码层面解释。"

### 👨‍🎓 面试者回答

**结论**：8GB堆不指定参数时，G1会自动计算Region大小为2MB；显式指定`-XX:G1HeapRegionSize=4m`后为4MB。

**源码分析** (`heapRegion.cpp`):

```cpp
// 文件: src/hotspot/share/gc/g1/heapRegion.cpp
void HeapRegion::setup_heap_region_size(size_t initial_heap_size, 
                                        size_t max_heap_size) {
  // 默认目标：2048个Region
  size_t region_size = MAX2(initial_heap_size / TARGET_REGION_NUMBER,
                            MIN_REGION_SIZE);  // MIN_REGION_SIZE = 1MB
  
  // 向上取整到2的幂次
  region_size = clamp(region_size, MIN_REGION_SIZE, MAX_REGION_SIZE); // MAX = 32MB
  
  // 实际计算：8GB / 2048 = 4MB，但会向下取最近的2^n = 4MB
  GrainBytes = region_size;
}
```

**验证结果**：

| 参数 | 计算过程 | 结果 |
|------|----------|------|
| 不指定 | 8GB ÷ 2048 = 4MB → 向下取2^n | 4MB (自动) |
| `-XX:G1HeapRegionSize=4m` | 直接使用指定值 | 4MB (显式) |

**关键常量** (`heapRegionBounds.hpp`):

```cpp
static const size_t MIN_REGION_SIZE = 1 * M;    // 1MB
static const size_t MAX_REGION_SIZE = 32 * M;   // 32MB
static const size_t TARGET_REGION_NUMBER = 2048;
```

---

## 面试问题 2：G1的辅助数据结构有哪些？各占多少内存？

### 👨‍💼 面试官提问

> "8GB堆配置下，G1的辅助数据结构总共占用多少内存？请逐一分析每个数据结构的作用、粒度和大小计算公式。"

### 👨‍🎓 面试者回答

#### 1. 辅助数据结构总览

| 数据结构 | 作用 | 粒度 | 计算公式 | 8GB堆大小 |
|---------|------|------|----------|-----------|
| **CardTable** | 跨Region引用跟踪 | 512B→1B | heap/512 | 16MB |
| **BOT** | 对象起始地址定位 | 512B→1B | heap/512 | 16MB |
| **Prev Bitmap** | 上轮并发标记结果 | 64B→1B | heap/64 | 128MB |
| **Next Bitmap** | 当前并发标记结果 | 64B→1B | heap/64 | 128MB |
| **Card Counts** | 热卡缓存优化 | 512B→1B | heap/512 | 16MB |
| **mmap总计** | - | - | - | **304MB** |

#### 2. 源码级分析

**CardTable计算** (`g1CardTable.hpp:108`):

```cpp
static size_t compute_size(size_t mem_region_size_in_words) {
  size_t number_of_slots = (mem_region_size_in_words / card_size_in_words);
  return ReservedSpace::allocation_align_size_up(number_of_slots);
}
// card_size = 512B, card_size_in_words = 512/8 = 64
// 8GB / 512B = 16,777,216 = 16MB
```

**CMBitMap计算** (`g1ConcurrentMarkBitMap.cpp:38`):

```cpp
size_t G1CMBitMap::compute_size(size_t heap_size) {
  return ReservedSpace::allocation_align_size_up(heap_size / mark_distance());
}

size_t G1CMBitMap::mark_distance() {
  return MinObjAlignmentInBytes * BitsPerByte;  // 8 * 8 = 64
}
// 8GB / 64 = 128MB (每个位图)
// 两个位图 = 256MB
```

#### 3. NMT实测验证

```bash
java -Xms8g -Xmx8g -XX:+UseG1GC -XX:G1HeapRegionSize=4m \
     -XX:NativeMemoryTracking=detail -XX:+PrintNMTStatistics -version
```

**NMT输出**:

```
-                        GC (reserved=392627663, committed=392627663)
                            (malloc=39499215 #14819)
                            (mmap: reserved=353128448, committed=353128448)
```

**对比分析**:

| 项目 | 理论值 | NMT实测 | 差异 |
|------|--------|---------|------|
| mmap总计 | 304MB | 336.8MB | +32.8MB (对齐) |
| malloc | - | 37.7MB | - |
| **GC总计** | - | **374.4MB** | **占堆4.57%** |

---

## 面试问题 3：CMBitMap为什么是128MB而不是16MB？

### 👨‍💼 面试官提问（陷阱题）

> "我看到网上很多文章说CMBitMap是'64B堆对应1bit'，按这个计算8GB堆应该是16MB。但你说是128MB，这是怎么回事？"

### 👨‍🎓 面试者回答

**这是一个常见误区！**

#### 1. 网上错误说法

```
错误: 64B堆 → 1bit  →  8GB / 64 / 8 = 16MB (错误!)
```

#### 2. 源码真相

```cpp
// g1ConcurrentMarkBitMap.cpp
size_t G1CMBitMap::compute_size(size_t heap_size) {
  // 直接返回字节数，不是位数！
  return ReservedSpace::allocation_align_size_up(heap_size / mark_distance());
}

size_t G1CMBitMap::mark_distance() {
  return MinObjAlignmentInBytes * BitsPerByte;  // 8 * 8 = 64
}
```

**关键点**：`compute_size()`返回的是**字节数**，不需要再除以8！

#### 3. 正确计算

```
正确: 64B堆 → 1字节(8位)  →  8GB / 64 = 128MB ✓
```

#### 4. 位图含义

- **每1字节位图可标记8个对象**
- **最小对象大小 = 8字节**（MinObjAlignmentInBytes）
- **64字节堆对应1字节位图 = 8个可能的对象位置**

#### 5. GDB验证

```gdb
(gdb) p G1CMBitMap::mark_distance()
$1 = 64

(gdb) p 8589934592 / 64  # 8GB / 64
$2 = 134217728           # = 128MB ✓
```

---

## 面试问题 4：CardTable和BOT的作用有什么区别？

### 👨‍💼 面试官提问

> "CardTable和BOT都是512字节粒度，它们的作用有什么区别？为什么需要两个数据结构？"

### 👨‍🎓 面试者回答

#### 1. 核心区别

| 特性 | CardTable | BOT (Block Offset Table) |
|------|-----------|--------------------------|
| **主要作用** | 记录跨代/跨Region引用 | 快速定位对象起始地址 |
| **使用场景** | GC时扫描脏卡 | 对象遍历、堆遍历 |
| **数据内容** | 卡片状态标记 | 对象偏移量 |
| **更新时机** | 写屏障触发 | 对象分配时 |

#### 2. CardTable源码

```cpp
// g1CardTable.hpp
enum CardValue {
  clean_card = 0,        // 干净卡（无跨Region引用）
  dirty_card = 1,        // 脏卡（有跨Region引用）
  deferred_card = 2,     // 延迟处理
  young_card = 3         // 年轻代卡
};
```

**写屏障伪代码**:

```cpp
void post_write_barrier(oop* field, oop value) {
  // 获取field所在的卡片
  jbyte* card = card_table + ((uintptr_t)field >> 9);  // 9 = log2(512)
  *card = dirty_card;  // 标记为脏卡
}
```

#### 3. BOT源码

```cpp
// g1BlockOffsetTable.hpp
class G1BlockOffsetTable {
  // 每个卡片对应的偏移量数组
  u_char* _offset_array;
  
  // 通过地址快速找到对象起始
  HeapWord* block_start(const void* addr) {
    size_t card_idx = (addr - bottom) >> BOTConstants::LogN;
    // 根据偏移量回溯找到对象头
    return bottom + _offset_array[card_idx] * N_words;
  }
};
```

#### 4. 协同工作示例

```
                    CardTable            BOT
                    ┌───────┐         ┌───────┐
Card 0 (0-512B):    │ dirty │         │ 偏移=0│
                    ├───────┤         ├───────┤
Card 1 (512-1024B): │ clean │         │ 偏移=2│
                    ├───────┤         ├───────┤
Card 2 (1024-1536B):│ dirty │         │ 偏移=1│
                    └───────┘         └───────┘
                        ↓                 ↓
                  GC扫描脏卡         定位对象起始
```

---

## 面试问题 5：Prev Bitmap和Next Bitmap为什么需要两个？

### 👨‍💼 面试官提问

> "G1为什么需要维护两个并发标记位图？只用一个不行吗？"

### 👨‍🎓 面试者回答

#### 1. 双位图设计原因

**核心原因**：支持**增量并发标记**和**SATB（Snapshot-At-The-Beginning）**算法。

#### 2. 工作流程

```
┌─────────────────────────────────────────────────────────────┐
│                    并发标记周期                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  并发标记开始                并发标记结束                      │
│       ↓                         ↓                           │
│  ┌─────────┐               ┌─────────┐                      │
│  │  Next   │   标记中...    │  Next   │                      │
│  │ Bitmap  │  ──────────→  │ Bitmap  │ (完成标记)            │
│  └─────────┘               └─────────┘                      │
│       ↓                         ↓                           │
│  ┌─────────┐               ┌─────────┐                      │
│  │  Prev   │               │ 交换指针 │                      │
│  │ Bitmap  │               │  swap   │                      │
│  └─────────┘               └─────────┘                      │
│                                 ↓                           │
│                            Prev ← Next                      │
│                            Next 清空                        │
└─────────────────────────────────────────────────────────────┘
```

#### 3. 两个位图的作用

| 位图 | 作用 | 使用时机 |
|------|------|----------|
| **Prev Bitmap** | 存储上一轮完成的标记结果 | Mixed GC选择Region |
| **Next Bitmap** | 存储当前正在进行的标记 | 并发标记过程中 |

#### 4. 源码验证

```cpp
// g1ConcurrentMark.hpp
class G1ConcurrentMark {
  G1CMBitMap  _prev_mark_bitmap;  // 上一轮标记结果
  G1CMBitMap  _next_mark_bitmap;  // 当前标记结果
  
  void swap_mark_bitmaps() {
    G1CMBitMap* tmp = _prev_mark_bitmap;
    _prev_mark_bitmap = _next_mark_bitmap;
    _next_mark_bitmap = tmp;
    // 清空next准备下次使用
    _next_mark_bitmap->clear();
  }
};
```

#### 5. 为什么不能只用一个？

1. **并发安全**：标记过程中，应用线程可能修改对象引用
2. **SATB保证**：需要保持标记开始时的对象图快照
3. **增量回收**：Mixed GC需要已完成的标记结果，而新标记可能正在进行

---

## 面试问题 6：8GB堆的G1辅助结构内存开销是否可接受？

### 👨‍💼 面试官提问

> "G1的辅助数据结构占用374MB，约4.57%的堆空间，这个开销是否可接受？有优化空间吗？"

### 👨‍🎓 面试者回答

#### 1. 开销分析

| 项目 | 大小 | 占比 | 分析 |
|------|------|------|------|
| 主要辅助结构(mmap) | 304MB | 3.7% | 固定开销 |
| 管理结构(malloc) | 37.7MB | 0.46% | 动态开销 |
| 对齐填充 | 32.8MB | 0.4% | 不可避免 |
| **总计** | **374.4MB** | **4.57%** | - |

#### 2. 是否可接受？

**答案：完全可接受**

理由：
1. **相比优势**：G1提供可预测的停顿时间，4.57%的内存换取亚毫秒级GC控制
2. **与其他GC对比**：
   - CMS: 约2-3%（但没有Region化管理优势）
   - ZGC: 约3%（但支持TB级堆）
   - G1: 约4-5%

#### 3. 优化建议

| 优化方向 | 方法 | 效果 |
|----------|------|------|
| **增大Region** | `-XX:G1HeapRegionSize=8m` | 减少Region数量，降低管理开销 |
| **调整堆大小** | 更大的堆 | 固定开销占比更低 |
| **使用大页** | `-XX:+UseLargePages` | 减少页表开销 |

#### 4. 不同堆大小对比

```
堆大小    CMBitMap×2   其他mmap   malloc   总计      占比
4GB       128MB        24MB       ~20MB    172MB     4.3%
8GB       256MB        48MB       ~38MB    374MB     4.6%
16GB      512MB        96MB       ~75MB    683MB     4.2%
32GB      1GB          192MB      ~150MB   1.34GB    4.2%
```

**结论**：占比相对稳定在4-5%，大堆反而更划算。

---

## 实战验证：NMT完整输出

### 验证命令

```bash
java -Xms8g -Xmx8g -XX:+UseG1GC -XX:G1HeapRegionSize=4m \
     -XX:NativeMemoryTracking=detail \
     -XX:+UnlockDiagnosticVMOptions \
     -XX:+PrintNMTStatistics -version
```

### 关键输出解读

```
-                        GC (reserved=392627663, committed=392627663)
                            (malloc=39499215 #14819)     ← 38MB动态结构
                            (mmap: reserved=353128448)   ← 337MB固定结构

堆地址: [0x0000000600000000 - 0x0000000800000000]
        = 0x600000000 到 0x800000000
        = 24GB 到 32GB (虚拟地址空间)
```

### 堆地址解读

- **基址0x600000000 = 24GB**：JVM选择在24GB处开始分配堆
- **原因**：压缩指针(Compressed OOPs)优化，Zero-based模式
- **shift=3**：每个压缩指针实际地址 = 压缩值 << 3

---

## 总结：高频考点

| 考点 | 答案要点 |
|------|----------|
| Region大小计算 | 堆÷2048，取2^n，范围1-32MB |
| CMBitMap大小 | 64B堆→1字节位图，非1位！8GB=128MB |
| 双位图原因 | SATB算法、增量标记、并发安全 |
| CardTable作用 | 跨Region引用跟踪，写屏障维护 |
| BOT作用 | 对象起始地址定位，遍历优化 |
| 总开销占比 | 约4-5%，大堆更划算 |

---

**下一篇**: [02-G1 GC执行流程与调优](./02-G1垃圾回收执行流程.md)
