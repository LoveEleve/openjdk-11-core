# 17-线程启动与生命周期

## 面试官：JVM中线程的分类有哪些？它们有什么区别？

### 答案

#### 1. JVM线程体系结构

```
                        Thread (C++基类)
                            │
         ┌──────────────────┴──────────────────┐
         │                                      │
   NonJavaThread                            JavaThread
         │                                      │
    ┌────┴────┐                     ┌──────────┼──────────┐
    │         │                     │          │          │
 VMThread  WatcherThread    CompilerThread  ServiceThread  普通Java线程
           │                       │
     ┌─────┴─────┐           C1Thread/C2Thread
     │           │
GCThread   G1ConcurrentRefine
```

#### 2. 主要线程类型

| 线程类型 | 继承关系 | 作用 |
|----------|----------|------|
| VMThread | NonJavaThread | 执行VM Operation（如GC） |
| CompilerThread | JavaThread | JIT编译 |
| GC Worker | NonJavaThread | 并行GC工作线程 |
| ConcurrentGCThread | NonJavaThread | 并发GC线程 |
| WatcherThread | NonJavaThread | 定时任务（采样分析） |
| ServiceThread | JavaThread | 服务线程（引用处理等） |

#### 3. 源码定义

```cpp:240:244:openjdk11-core/src/hotspot/share/runtime/thread.cpp
Thread::Thread() {
    // stack and get_thread
    set_stack_base(NULL);
    set_stack_size(0);
    set_self_raw_id(0);
```

---

## 面试官：详细描述Java线程的状态及其转换

### 答案

#### 1. JavaThreadState定义

```cpp:890:903:openjdk11-core/src/hotspot/share/utilities/globalDefinitions.hpp
enum JavaThreadState {
  _thread_uninitialized     =  0, // should never happen (missing initialization)
  _thread_new               =  2, // just starting up, i.e., in process of being initialized
  _thread_new_trans         =  3, // corresponding transition state (not used, included for completness)
  _thread_in_native         =  4, // running in native code
  _thread_in_native_trans   =  5, // corresponding transition state
  _thread_in_vm             =  6, // running in VM
  _thread_in_vm_trans       =  7, // corresponding transition state
  _thread_in_Java           =  8, // running in Java or in stub code
  _thread_in_Java_trans     =  9, // corresponding transition state (not used, included for completness)
  _thread_blocked           = 10, // blocked in vm
  _thread_blocked_trans     = 11, // corresponding transition state
  _thread_max_state         = 12  // maximum thread state+1 - used for statistics allocation
};
```

#### 2. 状态说明

| 状态 | 值 | 描述 | SafePoint安全 |
|------|----|----|--------------|
| _thread_new | 2 | 刚创建，未执行初始化代码 | 安全 |
| _thread_in_native | 4 | 执行Native代码 | 安全 |
| _thread_in_vm | 6 | 执行VM代码 | 不安全 |
| _thread_in_Java | 8 | 执行Java/Stub代码 | 不安全 |
| _thread_blocked | 10 | VM内阻塞 | 安全 |

#### 3. 转换状态（_trans）的作用

```
_trans状态用于SafePoint协调：
- 线程从一个状态转换到另一个状态时，先进入_trans状态
- _trans状态表示线程正在"过渡中"
- SafePoint机制可以在_trans状态时拦截线程

示例：_thread_in_Java -> _thread_in_Java_trans -> _thread_in_native
```

#### 4. 状态转换图

```
                    ┌─────────────────────────────────────────┐
                    │           _thread_new (创建)            │
                    └───────────────────┬─────────────────────┘
                                        │ 初始化完成
                                        ▼
    ┌───────────────────────────────────────────────────────────────────┐
    │                                                                   │
    │    ┌──────────────┐       ┌──────────────┐      ┌──────────────┐ │
    │    │_thread_in_Java│ ←──→ │ _thread_in_vm │ ←──→│_thread_in_   │ │
    │    │  (执行Java)   │       │  (执行VM)    │      │  native      │ │
    │    └──────────────┘       └──────────────┘      └──────────────┘ │
    │           │                      │                     │         │
    │           │                      ▼                     │         │
    │           │              ┌──────────────┐              │         │
    │           └────────────→ │_thread_blocked│ ←───────────┘         │
    │                          │  (阻塞)       │                       │
    │                          └──────────────┘                        │
    └───────────────────────────────────────────────────────────────────┘
```

---

## 面试官：一个Java线程从new Thread()到线程运行，底层经历了哪些步骤？

### 答案

#### 1. Java层创建

```java
// java.lang.Thread.java
public synchronized void start() {
    // 检查状态
    if (threadStatus != 0)
        throw new IllegalThreadStateException();
    
    // 添加到线程组
    group.add(this);
    
    // 调用native方法
    start0();  // -> JVM_StartThread
}
```

#### 2. JVM层处理流程

```
start0() 
  ↓
JVM_StartThread (jvm.cpp)
  ↓
new JavaThread(thread_entry, sz)  // 创建C++ JavaThread对象
  ↓
os::create_thread()  // 创建OS原生线程
  ↓
Thread::start()
  ↓
os::start_thread()  // 启动线程
```

#### 3. JavaThread构造函数

```cpp:1849:1871:openjdk11-core/src/hotspot/share/runtime/thread.cpp
JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :
        Thread() {
    initialize(); // 初始化成员变量
    _jni_attach_state = _not_attaching_via_jni;
    set_entry_point(entry_point); // 保存入口函数指针(_entry_point)
    // Create the native thread itself.
    // %note runtime_23
    os::ThreadType thr_type = os::java_thread;
    thr_type = entry_point == &compiler_thread_entry ? os::compiler_thread :
               os::java_thread;
    // 调用os层创建线程，传入了当前JavaThread对象和线程类型：os::java_thread
    os::create_thread(this, thr_type, stack_sz);
    // The _osthread may be NULL here because we ran out of memory (too many threads active).
    // We need to throw and OutOfMemoryError - however we cannot do this here because the caller
    // may hold a lock and all locks must be unlocked before throwing the exception (throwing
    // the exception consists of creating the exception object & initializing it, initialization
    // will leave the VM via a JavaCall and then all locks must be unlocked).
    //
    // The thread is still suspended when we reach here. Thread must be explicit started
    // by creator! Furthermore, the thread must also explicitly be added to the Threads list
    // by calling Threads:add. The reason why this is not done here, is because the thread
    // object must be fully initialized (take a look at JVM_Start)
}
```

#### 4. OS层线程创建 (Linux)

```cpp
// os_linux.cpp - os::create_thread
bool os::create_thread(Thread* thread, ThreadType thr_type, size_t req_stack_size) {
    // 1. 创建OSThread对象
    OSThread* osthread = new OSThread(NULL, NULL);
    thread->set_osthread(osthread);
    
    // 2. 设置线程属性
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    pthread_attr_setstacksize(&attr, stack_size);
    
    // 3. 创建pthread
    int ret = pthread_create(&tid, 
                             &attr, 
                             thread_native_entry,  // 线程入口函数
                             thread);              // 传递Thread对象
    
    return ret == 0;
}
```

#### 5. 线程入口函数

```cpp
// os_linux.cpp
static void *thread_native_entry(Thread *thread) {
    // 1. 初始化线程本地存储
    thread->initialize_thread_current();
    
    // 2. 记录栈信息
    thread->record_stack_base_and_size();
    
    // 3. 设置线程状态
    osthread->set_state(INITIALIZED);
    
    // 4. 等待创建者释放
    {
      MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);
      while (osthread->get_state() == INITIALIZED) {
        sync->wait(Mutex::_no_safepoint_check_flag);
      }
    }
    
    // 5. 调用Thread::call_run()
    thread->call_run();
    
    return 0;
}
```

#### 6. call_run调用链

```cpp:426:464:openjdk11-core/src/hotspot/share/runtime/thread.cpp
void Thread::call_run() {
    // At this point, Thread object should be fully initialized and
    // Thread::current() should be set.

    register_thread_stack_with_NMT();

    MACOS_AARCH64_ONLY(this->init_wx());

    JFR_ONLY(Jfr::on_thread_start(this);)

    log_debug(os, thread)("Thread "
    UINTX_FORMAT
    " stack dimensions: "
    PTR_FORMAT
    "-"
    PTR_FORMAT
    " ("
    SIZE_FORMAT
    "k).",
            os::current_thread_id(), p2i(stack_base() - stack_size()),
            p2i(stack_base()), stack_size() / 1024);

    // Invoke <ChildClass>::run()
    this->run();
    // Returned from <ChildClass>::run(). Thread finished.
```

---

## 面试官：线程栈布局是怎样的？栈溢出检测机制是什么？

### 答案

#### 1. 线程栈布局

```
高地址
   │
   ▼
┌─────────────────────┐ ← stack_base (栈顶/起始地址)
│                     │
│    可用栈空间        │
│    (向下增长)        │
│         ↓           │
│                     │
├─────────────────────┤ ← stack_overflow_limit (黄区)
│   Yellow Zone       │   触发可恢复的 StackOverflowError
├─────────────────────┤ ← (红区)
│   Red Zone          │   触发不可恢复的崩溃
├─────────────────────┤
│   Guard Page        │   操作系统保护页 (不可访问)
└─────────────────────┘ ← stack_end / bottom (栈底)
   │
   ▼
低地址
```

#### 2. 源码注释

```cpp:363:384:openjdk11-core/src/hotspot/share/runtime/thread.cpp
/**
 * pthread库基础知识：
 *  - int pthread_getattr_np(pthread_t thread, pthread_attr_t *attr); // 获取线程属性
 *  - int pthread_attr_getstack(pthread_attr_t *attr, void **stackaddr, size_t *stacksize);  // 从属性中获取栈地址和大小
 *    {这个返回的是栈底地址，不是栈顶地址,而jvm需要的是stack_base,也就是栈顶}
    - int pthread_attr_getguardsize(pthread_attr_t *attr, size_t *guardsize); // 获取 guard page 大小
      {guard page - os在栈顶设置的不可访问的内存页面,访问时触发SIGSEGV,防止栈溢出破坏其他内存区域}
 */
void Thread::record_stack_base_and_size() {
    set_stack_base(os::current_stack_base()); // forcus-1 获取栈顶地址(高地址端)
    set_stack_size(os::current_stack_size()); // forcus-2 获取栈总大小
    ...
    // forcus 为JavaThread对象设置栈溢出限制
    if (is_Java_thread()) {
        ((JavaThread * ) this)->set_stack_overflow_limit();
        ((JavaThread * ) this)->set_reserved_stack_activation(stack_base());
    }
}
```

#### 3. 保护区域大小

```cpp
// 默认值 (Linux x86_64)
StackYellowPages = 2    // 8KB (2 * 4KB页)
StackRedPages = 1       // 4KB
StackShadowPages = 20   // 用于检测栈溢出的影子空间

// 总保护区大小
guard_size = (StackYellowPages + StackRedPages + StackShadowPages) * page_size
           = (2 + 1 + 20) * 4KB = 92KB
```

#### 4. 栈溢出检测机制

```
1. Yellow Zone触发:
   - 访问黄区时触发SIGSEGV
   - JVM捕获信号，抛出StackOverflowError
   - 可恢复，线程可继续执行

2. Red Zone触发:
   - 黄区被消耗后访问红区
   - 触发不可恢复的错误
   - 线程必须终止

3. Guard Page:
   - OS级别的保护
   - 访问时直接crash
```

---

## 面试官：VMThread是做什么的？它和SafePoint有什么关系？

### 答案

#### 1. VMThread职责

VMThread是JVM中唯一负责执行VM Operation的线程：

```cpp
// VM Operation类型
enum VMOp_Type {
    VMOp_G1CollectForAllocation,     // G1 GC
    VMOp_G1CollectFull,              // G1 Full GC
    VMOp_ParallelGCSystemGC,         // Parallel GC
    VMOp_Deoptimize,                 // 反优化
    VMOp_RedefineClasses,            // 热替换
    VMOp_ThreadDump,                 // 线程转储
    VMOp_HeapDumper,                 // 堆转储
    VMOp_RevokeBias,                 // 撤销偏向锁
    // ...
};
```

#### 2. VMThread创建

```cpp:4083:4104:openjdk11-core/src/hotspot/share/runtime/thread.cpp
    // Create the VMThread
    {
        TraceTime timer("Start VMThread", TRACETIME_LOG(Info, startuptime));

        VMThread::create();
        Thread * vmthread = VMThread::vm_thread();

        if (!os::create_thread(vmthread, os::vm_thread)) {
            vm_exit_during_initialization("Cannot create VM thread. "
                                          "Out of system resources.");
        }

        // Wait for the VM thread to become ready, and VMThread::run to initialize
        // Monitors can have spurious returns, must always check another state flag
        {
            MutexLocker ml(Notify_lock);
            os::start_thread(vmthread);
            while (vmthread->active_handles() == NULL) {
                Notify_lock->wait();
            }
        }
    }
```

#### 3. VMThread与SafePoint的关系

```
请求VM Operation的流程:

1. 应用线程提交VM_Operation到队列
   ↓
2. VMThread从队列取出操作
   ↓
3. VMThread发起SafePoint请求
   ↓
4. 所有Java线程到达SafePoint
   ↓
5. VMThread执行VM_Operation
   ↓
6. VMThread结束SafePoint
   ↓
7. 所有线程恢复执行
```

#### 4. VMThread主循环

```cpp
void VMThread::run() {
    // 初始化
    this->initialize_thread_current();
    
    // 主循环
    while (!should_terminate()) {
        // 等待VM Operation
        VM_Operation* op = VMOperationQueue::take();
        
        if (op->evaluate_at_safepoint()) {
            // 需要SafePoint的操作
            SafepointSynchronize::begin();
            op->evaluate();
            SafepointSynchronize::end();
        } else {
            // 不需要SafePoint
            op->evaluate();
        }
    }
}
```

---

## 面试官：线程的attach和detach机制是什么？

### 答案

#### 1. Attach场景

当Native代码需要调用Java方法时，必须先attach到JVM：

```cpp
// JNI_AttachCurrentThread
jint AttachCurrentThread(JavaVM *vm, void **penv, void *args) {
    // 1. 检查是否已经attach
    if (Thread::current_or_null() != NULL) {
        return JNI_OK;
    }
    
    // 2. 创建JavaThread对象
    JavaThread* thread = new JavaThread(true /* is_attaching_via_jni */);
    
    // 3. 设置thread local
    thread->initialize_thread_current();
    
    // 4. 添加到Threads列表
    Threads::add(thread);
    
    // 5. 返回JNIEnv
    *penv = thread->jni_environment();
    
    return JNI_OK;
}
```

#### 2. Detach场景

```cpp
// JNI_DetachCurrentThread
jint DetachCurrentThread(JavaVM *vm) {
    JavaThread* thread = JavaThread::current();
    
    // 1. 释放所有monitors
    thread->exit(false);
    
    // 2. 从Threads列表移除
    Threads::remove(thread);
    
    // 3. 清理thread local
    Thread::clear_thread_current();
    
    // 4. 删除JavaThread对象
    delete thread;
    
    return JNI_OK;
}
```

#### 3. 三种attach状态

```cpp:1786:1795:openjdk11-core/src/hotspot/share/runtime/thread.cpp
JavaThread::JavaThread(bool is_attaching_via_jni) :
        Thread() {
    initialize();
    if (is_attaching_via_jni) {
        _jni_attach_state = _attaching_via_jni;
    } else {
        _jni_attach_state = _not_attaching_via_jni;
    }
    assert(deferred_card_mark().is_empty(), "Default MemRegion ctor");
}
```

---

## 面试官：线程的优先级是如何映射到OS的？

### 答案

#### 1. Java优先级范围

```java
public class Thread {
    public final static int MIN_PRIORITY = 1;
    public final static int NORM_PRIORITY = 5;
    public final static int MAX_PRIORITY = 10;
}
```

#### 2. Linux优先级映射

```cpp
// os_linux.cpp
OSReturn os::set_native_priority(Thread* thread, int priority) {
    // Linux使用nice值: -20 (最高) 到 19 (最低)
    // 普通进程默认nice = 0
    
    // Java 1-10 映射到 Linux nice值
    // Java 10 -> nice -5
    // Java 5  -> nice 0  
    // Java 1  -> nice 4
    
    if (!UseThreadPriorities) return OS_OK;
    
    int native_priority;
    if (priority == MaxPriority) {
        native_priority = -5;
    } else if (priority == MinPriority) {
        native_priority = 4;
    } else {
        native_priority = (NormPriority - priority) * 2;
    }
    
    setpriority(PRIO_PROCESS, 0, native_priority);
}
```

#### 3. 优先级映射表

| Java优先级 | Linux nice值 | 说明 |
|------------|-------------|------|
| 10 (MAX) | -5 | 最高 |
| 9 | -3 | |
| 8 | -1 | |
| 7 | 0 | |
| 6 | 1 | |
| 5 (NORM) | 2 | 默认 |
| 4 | 3 | |
| 3 | 4 | |
| 2 | 5 | |
| 1 (MIN) | 6 | 最低 |

---

## 面试官：CompilerThread是如何工作的？

### 答案

#### 1. 编译器线程类型

```cpp
// 两种编译器线程
os::ThreadType thr_type = entry_point == &compiler_thread_entry ? 
                          os::compiler_thread : os::java_thread;

// 实际的编译器线程
- C1CompilerThread: 客户端编译器，快速编译
- C2CompilerThread: 服务端编译器，优化编译
```

#### 2. 编译器线程创建

```cpp
void CompileBroker::init_compiler_threads(int c1_count, int c2_count) {
    // 创建C1编译线程
    for (int i = 0; i < c1_count; i++) {
        CompilerThread* t = new CompilerThread(...);
        _c1_method_queue->add_compiler_thread(t);
    }
    
    // 创建C2编译线程
    for (int i = 0; i < c2_count; i++) {
        CompilerThread* t = new CompilerThread(...);
        _c2_method_queue->add_compiler_thread(t);
    }
}
```

#### 3. 编译器线程工作流程

```
1. 从编译队列获取编译任务
   ↓
2. 编译方法生成机器码
   ↓
3. 安装到CodeCache
   ↓
4. 更新方法入口点
   ↓
5. 继续处理下一个任务
```

---

## 知识图谱

```
                    ┌─────────────────────────────────────────────────┐
                    │                 JVM线程体系                      │
                    └─────────────────────────────────────────────────┘
                                          │
        ┌─────────────────────────────────┼─────────────────────────────────┐
        ▼                                 ▼                                 ▼
┌───────────────┐               ┌───────────────┐               ┌───────────────┐
│  创建流程      │               │  生命周期状态  │               │  栈管理        │
├───────────────┤               ├───────────────┤               ├───────────────┤
│Thread.start() │               │ _thread_new   │               │ stack_base    │
│     ↓         │               │     ↓         │               │ (栈顶/高地址) │
│JVM_StartThread│               │ _thread_in_   │               │     ↓         │
│     ↓         │               │ Java/VM/native│               │ Yellow Zone   │
│JavaThread构造 │               │     ↓         │               │ Red Zone      │
│     ↓         │               │ _thread_      │               │ Guard Page    │
│os::create_    │               │ blocked       │               │     ↓         │
│thread         │               │     ↓         │               │ stack_end     │
│     ↓         │               │ terminated    │               │ (栈底/低地址) │
│os::start_     │               │               │               │               │
│thread         │               │               │               │               │
└───────────────┘               └───────────────┘               └───────────────┘
        │                                 │                                 │
        └─────────────────────────────────┴─────────────────────────────────┘
                                          │
                    ┌─────────────────────┴─────────────────────┐
                    ▼                                           ▼
           ┌───────────────┐                          ┌───────────────┐
           │   VMThread    │                          │ CompilerThread│
           ├───────────────┤                          ├───────────────┤
           │ VM Operation  │                          │ C1/C2 编译    │
           │ SafePoint协调 │                          │ 队列任务处理   │
           │ GC触发点      │                          │ CodeCache管理  │
           └───────────────┘                          └───────────────┘
```
