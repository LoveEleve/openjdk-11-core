# 19-GC屏障与写屏障

## 面试官：什么是GC屏障？为什么GC需要屏障？

### 答案

#### 1. GC屏障定义

GC屏障是在**对象引用读写操作**前后插入的代码片段，用于：
- 维护GC所需的数据结构（卡表、SATB队列等）
- 保证并发GC的正确性
- 追踪对象之间的引用关系变化

#### 2. 为什么需要GC屏障

```
并发GC面临的问题：

应用线程A                     GC线程
    │                           │
    ├─ 修改引用 X.f = Y ────────┼─── 可能导致:
    │                           │    1. 漏标：存活对象被错误回收
    │                           │    2. 跨代引用丢失
    │                           │    3. RSet信息过时
    ▼                           ▼
```

#### 3. 屏障类型

| 屏障类型 | 插入位置 | 作用 |
|----------|----------|------|
| 写前屏障 (Pre-barrier) | 引用修改前 | 记录旧值（SATB） |
| 写后屏障 (Post-barrier) | 引用修改后 | 更新卡表/RSet |
| 读屏障 (Load-barrier) | 引用读取后 | 对象重定位(ZGC) |

---

## 面试官：G1的写前屏障（SATB屏障）是如何工作的？

### 答案

#### 1. SATB原理回顾

SATB = Snapshot-At-The-Beginning
- 并发标记开始时，对堆状态做"逻辑快照"
- 标记期间，所有被覆盖的旧引用值都要记录
- 确保快照时刻存活的对象不会被漏标

#### 2. 写前屏障源码

```cpp:36:46:openjdk11-core/src/hotspot/share/gc/g1/g1BarrierSet.inline.hpp
template <DecoratorSet decorators, typename T>
inline void G1BarrierSet::write_ref_field_pre(T* field) {
  if (HasDecorator<decorators, IS_DEST_UNINITIALIZED>::value ||
      HasDecorator<decorators, AS_NO_KEEPALIVE>::value) {
    return;
  }

  T heap_oop = RawAccess<MO_VOLATILE>::oop_load(field);
  if (!CompressedOops::is_null(heap_oop)) {
    enqueue(CompressedOops::decode_not_null(heap_oop));
  }
}
```

#### 3. enqueue操作

```cpp:118:130:openjdk11-core/src/hotspot/share/gc/g1/g1BarrierSet.cpp
void G1BarrierSet::enqueue(oop pre_val) {
  // Nulls should have been already filtered.
  assert(oopDesc::is_oop(pre_val, true), "Error");

  if (!_satb_mark_queue_set.is_active()) return;
  Thread* thr = Thread::current();
  if (thr->is_Java_thread()) {
    G1ThreadLocalData::satb_mark_queue(thr).enqueue(pre_val);
  } else {
    MutexLockerEx x(Shared_SATB_Q_lock, Mutex::_no_safepoint_check_flag);
    _satb_mark_queue_set.shared_satb_queue()->enqueue(pre_val);
  }
}
```

#### 4. 写前屏障伪代码

```cpp
// 应用代码: obj.field = new_value
void putfield(Object obj, int offset, Object new_value) {
    // === 写前屏障 (Pre-barrier) ===
    if (SATB_marking_active) {
        Object old_value = obj.field;  // 读取旧值
        if (old_value != null) {
            satb_queue.enqueue(old_value);  // 记录旧值
        }
    }
    
    // === 实际写操作 ===
    obj.field = new_value;
    
    // === 写后屏障 (Post-barrier) ===
    // ...
}
```

#### 5. SATB队列结构

```
每个线程有一个本地SATB队列:

Thread Local SATB Queue
┌─────────────────────────┐
│ [old_ref_1]             │
│ [old_ref_2]             │
│ [old_ref_3]             │
│ ...                     │
│ [index] ←─ 当前位置      │
└─────────────────────────┘
         │ 队列满时
         ▼
┌─────────────────────────┐
│  Global SATB Queue Set  │
│  ┌──────────────────┐   │
│  │ Completed Buffer │   │
│  │ Completed Buffer │   │
│  │ ...              │   │
│  └──────────────────┘   │
└─────────────────────────┘
         │ GC线程处理
         ▼
    标记这些对象为存活
```

---

## 面试官：G1的写后屏障是如何更新卡表的？

### 答案

#### 1. 写后屏障源码

```cpp:48:55:openjdk11-core/src/hotspot/share/gc/g1/g1BarrierSet.inline.hpp
template <DecoratorSet decorators, typename T>
inline void G1BarrierSet::write_ref_field_post(T* field, oop new_val) {
  volatile jbyte* byte = _card_table->byte_for(field);
  if (*byte != G1CardTable::g1_young_card_val()) {
    // Take a slow path for cards in old
    write_ref_field_post_slow(byte);
  }
}
```

#### 2. 慢路径处理

```cpp:156:171:openjdk11-core/src/hotspot/share/gc/g1/g1BarrierSet.cpp
void G1BarrierSet::write_ref_field_post_slow(volatile jbyte* byte) {
  // In the slow path, we know a card is not young
  assert(*byte != G1CardTable::g1_young_card_val(), "slow path invoked without filtering");
  OrderAccess::storeload();
  if (*byte != G1CardTable::dirty_card_val()) {
    *byte = G1CardTable::dirty_card_val();
    Thread* thr = Thread::current();
    if (thr->is_Java_thread()) {
      G1ThreadLocalData::dirty_card_queue(thr).enqueue(byte);
    } else {
      MutexLockerEx x(Shared_DirtyCardQ_lock,
                      Mutex::_no_safepoint_check_flag);
      _dirty_card_queue_set.shared_dirty_card_queue()->enqueue(byte);
    }
  }
}
```

#### 3. 写后屏障伪代码

```cpp
// 写后屏障 (Post-barrier)
void post_write_barrier(Object* field, Object new_val) {
    // 1. 计算卡表地址
    jbyte* card = card_table + ((address)field >> 9);  // 每512字节一个卡
    
    // 2. 快速路径：年轻代卡不需要处理
    if (*card == g1_young_card_val) {
        return;  // Young region的卡跳过
    }
    
    // 3. 慢路径：老年代卡
    memory_barrier();  // StoreLoad屏障
    if (*card != dirty_card_val) {
        *card = dirty_card_val;           // 标记为脏
        dirty_card_queue.enqueue(card);   // 入队等待处理
    }
}
```

#### 4. 卡表状态

```cpp
// G1卡表特有的状态
enum CardValues {
    clean_card               = -1,  // 干净卡
    dirty_card               = 0,   // 脏卡（需要扫描）
    precleaned_card          = 1,   // 预清理卡
    
    // G1特有
    g1_young_card_val        = -2,  // 属于年轻代的卡
    g1_card_already_scanned  = -3,  // 已扫描
};
```

---

## 面试官：G1屏障在JIT编译代码中是如何实现的？

### 答案

#### 1. 三种执行模式

```
Java代码执行的三种方式:
1. 解释执行: 由解释器调用屏障
2. C1编译:   屏障代码内联到生成的机器码
3. C2编译:   屏障代码高度优化后内联
```

#### 2. C2编译器屏障代码生成

```cpp:39:50:openjdk11-core/src/hotspot/share/gc/g1/c2/g1BarrierSetC2.cpp
const TypeFunc *G1BarrierSetC2::write_ref_field_pre_entry_Type() {
  const Type **fields = TypeTuple::fields(2);
  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value
  fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; // thread
  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);

  // create result type (range)
  fields = TypeTuple::fields(0);
  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);

  return TypeFunc::make(domain, range);
}
```

#### 3. 运行时入口函数

```cpp:47:56:openjdk11-core/src/hotspot/share/gc/g1/g1BarrierSetRuntime.cpp
// G1 pre write barrier slowpath
JRT_LEAF(void, G1BarrierSetRuntime::write_ref_field_pre_entry(oopDesc* orig, JavaThread *thread))
  if (orig == NULL) {
    assert(false, "should be optimized out");
    return;
  }
  assert(oopDesc::is_oop(orig, true /* ignore mark word */), "Error");
  // store the original value that was in the field reference
  G1ThreadLocalData::satb_mark_queue(thread).enqueue(orig);
JRT_END

// G1 post write barrier slowpath
JRT_LEAF(void, G1BarrierSetRuntime::write_ref_field_post_entry(void* card_addr, JavaThread* thread))
  G1ThreadLocalData::dirty_card_queue(thread).enqueue(card_addr);
JRT_END
```

#### 4. 快慢路径分离

```
JIT生成的屏障代码结构:

┌─────────────────────────────────────────────────────────────┐
│  快速路径（内联到生成代码）                                   │
│  ┌───────────────────────────────────────────────────────┐  │
│  │ if (!marking_active) goto skip;  // 检查标记是否活跃   │  │
│  │ if (old_val == NULL) goto skip;  // 空值跳过          │  │
│  │ if (queue_index > 0) {           // 队列有空间        │  │
│  │     queue[--index] = old_val;    // 直接入队          │  │
│  │     goto skip;                                        │  │
│  │ }                                                     │  │
│  └───────────────────────────────────────────────────────┘  │
│           │ 队列满                                          │
│           ▼                                                 │
│  ┌───────────────────────────────────────────────────────┐  │
│  │ call write_ref_field_pre_entry   // 慢路径：调用运行时 │  │
│  └───────────────────────────────────────────────────────┘  │
│                                                             │
│  skip:                                                      │
│       // 继续执行                                           │
└─────────────────────────────────────────────────────────────┘
```

---

## 面试官：写屏障的性能开销有多大？如何优化？

### 答案

#### 1. 性能开销来源

```
写屏障开销组成:
1. 条件检查: ~2-5个条件分支
2. 内存访问: 读卡表/队列状态
3. 内存写入: 更新卡表/队列
4. 内存屏障: StoreLoad屏障（最昂贵）
```

#### 2. 典型开销

```
写屏障对应用吞吐量的影响:
- 无屏障(Serial GC): 基准 100%
- G1屏障:            约 95-98%
- ZGC读屏障:         约 90-95%
```

#### 3. G1的优化策略

**优化1: 年轻代过滤**
```cpp
// 年轻代引用不需要后屏障（因为整个年轻代都会被扫描）
if (*byte == g1_young_card_val()) {
    return;  // 快速返回
}
```

**优化2: 脏卡检查**
```cpp
// 已经是脏卡则无需重复标记
if (*byte != dirty_card_val()) {
    *byte = dirty_card_val();
    // 才需要入队
}
```

**优化3: 本地队列缓冲**
```cpp
// 本地队列避免全局同步
if (local_queue_has_space()) {
    local_queue.enqueue(value);  // 无锁操作
} else {
    // 仅在队列满时才需要同步
    flush_to_global_queue();
}
```

**优化4: 屏障消除**
```cpp
// JIT编译器可以消除一些不必要的屏障
// 例如：新对象初始化时不需要写前屏障
if (IS_DEST_UNINITIALIZED) {
    return;  // 跳过屏障
}
```

---

## 面试官：不同GC的屏障实现有什么区别？

### 答案

#### 1. 屏障对比

| GC | 写前屏障 | 写后屏障 | 读屏障 |
|----|----------|----------|--------|
| Serial/Parallel | 无 | 卡表更新 | 无 |
| CMS | 增量更新(IU) | 卡表更新 | 无 |
| G1 | SATB | 卡表+RSet更新 | 无 |
| ZGC | 无 | 无 | 对象重定位 |
| Shenandoah | SATB | 无 | 对象重定位 |

#### 2. 各GC屏障源码位置

```
Serial/Parallel GC:
  src/hotspot/share/gc/shared/cardTableBarrierSet.cpp

G1 GC:
  src/hotspot/share/gc/g1/g1BarrierSet.cpp

ZGC:
  src/hotspot/share/gc/z/zBarrier.cpp

Shenandoah:
  src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.cpp
```

#### 3. G1 BarrierSet类型标签

```cpp:73:116:openjdk11-core/src/hotspot/share/gc/g1/g1BarrierSet.cpp
/*
 * note 知识拓展：类型标签机制
 *  在 C++ 中，判断一个对象的实际类型通常用 dynamic_cast，但这需要开启 RTTI（运行时类型信息），会带来性能开销
 *  HotSpot JVM 选择自己实现一套轻量级的类型识别机制，就是 FakeRtti（Fake Runtime Type Information，伪运行时类型信息）。
 *   每种屏障集都有一个唯一的枚举值作为标签。
 *  FakeRtti 内部使用一个位掩码（bitmask） 来存储标签 { uint32_t _tag_set;  // 位掩码，每个bit代表一个标签 }
 *   {
         // G1BarrierSet 构造
         G1BarrierSet(...) :
           CardTableBarrierSet(..., FakeRtti(G1BarrierSet))  // 初始标签: G1BarrierSet
                                                              // _tag_set = 0b0100

         // CardTableBarrierSet 构造
         CardTableBarrierSet(...) :
           ModRefBarrierSet(..., fake_rtti.add_tag(CardTableBarrierSet))  // 添加标签
                                                                           // _tag_set = 0b0110

         // ModRefBarrierSet 构造
         ModRefBarrierSet(...) :
           BarrierSet(..., fake_rtti.add_tag(ModRef))  // 添加标签
                                                        // _tag_set = 0b0111
         note 最终 _tag_set = 0b0111，包含了三个标签。
         note 通过is_a()来使用标签
             bool is_a(BarrierSet::Name bsn) const {
                   return _fake_rtti.has_tag(bsn);
                 }
         note 对于 G1BarrierSet（_tag_set = 0b0111）：
             bs->is_a(G1BarrierSet)         // 检查 bit 2: 0b0111 & 0b0100 = 0b0100 ≠ 0 → true
             bs->is_a(CardTableBarrierSet)  // 检查 bit 1: 0b0111 & 0b0010 = 0b0010 ≠ 0 → true
             bs->is_a(ModRef)               // 检查 bit 0: 0b0111 & 0b0001 = 0b0001 ≠ 0 → true
             bs->is_a(ShenandoahBarrierSet) // 检查 bit 3: 0b0111 & 0b1000 = 0b0000 = 0  → false
*   }
*/
```

---

## 面试官：线程Attach/Detach时屏障如何处理？

### 答案

#### 1. 线程创建时

```cpp:212:216:openjdk11-core/src/hotspot/share/gc/g1/g1BarrierSet.cpp
void G1BarrierSet::on_thread_create(Thread* thread) {
  // Create thread local data
  // forcus G1ThreadLocalData：每个线程的本地数据
  G1ThreadLocalData::create(thread);
}
```

#### 2. 线程Attach时

```cpp:223:251:openjdk11-core/src/hotspot/share/gc/g1/g1BarrierSet.cpp
void G1BarrierSet::on_thread_attach(JavaThread* thread) {
  // This method initializes the SATB and dirty card queues before a
  // JavaThread is added to the Java thread list. Right now, we don't
  // have to do anything to the dirty card queue (it should have been
  // activated when the thread was created), but we have to activate
  // the SATB queue if the thread is created while a marking cycle is
  // in progress. The activation / de-activation of the SATB queues at
  // the beginning / end of a marking cycle is done during safepoints
  // so we have to make sure this method is called outside one to be
  // able to safely read the active field of the SATB queue set.
  
  assert(!SafepointSynchronize::is_at_safepoint(), "We should not be at a safepoint");
  assert(!G1ThreadLocalData::satb_mark_queue(thread).is_active(), "SATB queue should not be active");
  assert(G1ThreadLocalData::satb_mark_queue(thread).is_empty(), "SATB queue should be empty");
  assert(G1ThreadLocalData::dirty_card_queue(thread).is_active(), "Dirty card queue should be active");

  // If we are creating the thread during a marking cycle, we should
  // set the active field of the SATB queue to true.
  if (_satb_mark_queue_set.is_active()) {
    G1ThreadLocalData::satb_mark_queue(thread).set_active(true);
  }
}
```

#### 3. 线程Detach时

```cpp:253:258:openjdk11-core/src/hotspot/share/gc/g1/g1BarrierSet.cpp
void G1BarrierSet::on_thread_detach(JavaThread* thread) {
  // Flush any deferred card marks, SATB buffers and dirty card queue buffers
  CardTableBarrierSet::on_thread_detach(thread);
  G1ThreadLocalData::satb_mark_queue(thread).flush();
  G1ThreadLocalData::dirty_card_queue(thread).flush();
}
```

---

## 知识图谱

```
                    ┌─────────────────────────────────────────────────┐
                    │                  G1 GC屏障体系                   │
                    └─────────────────────────────────────────────────┘
                                          │
              ┌───────────────────────────┼───────────────────────────┐
              ▼                           ▼                           ▼
     ┌─────────────────┐        ┌─────────────────┐        ┌─────────────────┐
     │  写前屏障(SATB)  │        │  写后屏障        │        │  线程本地数据    │
     ├─────────────────┤        ├─────────────────┤        ├─────────────────┤
     │ 记录旧值         │        │ 更新卡表         │        │ SATB Queue      │
     │ 防止漏标         │        │ 入队脏卡         │        │ Dirty Card Queue│
     │ satb_queue      │        │ RSet更新         │        │ G1ThreadLocalData│
     └─────────────────┘        └─────────────────┘        └─────────────────┘

屏障执行流程:
┌─────────────────────────────────────────────────────────────────────────────┐
│  obj.field = new_value                                                       │
│       │                                                                      │
│       ├──────────────────────────────────────────────────────────┐          │
│       ▼                                                          ▼          │
│  ┌─────────────────┐                                  ┌─────────────────┐   │
│  │ Pre-barrier:    │                                  │ Post-barrier:   │   │
│  │                 │                                  │                 │   │
│  │ if(marking) {   │         实际写操作                │ card = byte_for │   │
│  │   old = load    │  ─────────────────────→         │ if(card!=young){│   │
│  │   if(old!=null) │         obj.field =              │   if(card!=dirty│   │
│  │     enqueue(old)│         new_value                │     card=dirty  │   │
│  │ }               │                                  │     enqueue(card│   │
│  │                 │                                  │ }               │   │
│  └─────────────────┘                                  └─────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```
