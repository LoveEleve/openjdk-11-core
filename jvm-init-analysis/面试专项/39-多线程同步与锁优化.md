# 39-多线程同步与锁优化

## 面试官提问：多线程同步与锁优化

**面试官**：作为JVM并发专家，你能详细解释HotSpot的多线程同步机制吗？特别是偏向锁、轻量级锁、重量级锁的实现原理，以及在8GB堆内存、多核环境下的锁优化策略？

**面试者**：这是一个非常核心的问题，涉及JVM并发性能的关键技术。让我基于OpenJDK11源码来详细分析HotSpot的锁优化机制。

## 1. 对象头与锁状态表示

### 1.1 Mark Word结构

```cpp
// src/hotspot/share/oops/markOop.hpp
class markOopDesc: public oopDesc {
public:
  // 位域分配
  enum { 
    age_bits                 = 4,   // 分代年龄位数
    lock_bits                = 2,   // 锁状态位数
    biased_lock_bits         = 1,   // 偏向锁标志位数
    max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,
    hash_bits                = max_hash_bits > 31 ? 31 : max_hash_bits,
    epoch_bits               = 2    // 偏向锁时代位数
  };

  // 锁状态枚举
  enum { 
    locked_value             = 0,   // 00 - 轻量级锁
    unlocked_value           = 1,   // 01 - 无锁状态
    monitor_value            = 2,   // 10 - 重量级锁
    marked_value             = 3,   // 11 - GC标记
    biased_lock_pattern      = 5    // 101 - 偏向锁
  };

  // 锁状态检查方法
  bool is_locked()   const {
    return (mask_bits(value(), lock_mask_in_place) != unlocked_value);
  }
  
  bool is_unlocked() const {
    return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value);
  }
  
  bool has_bias_pattern() const {
    return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern);
  }
  
  bool has_monitor() const {
    return ((value() & monitor_value) != 0);
  }
};
```

### 1.2 锁状态转换图

```
无锁状态 (001)
    ↓ 线程首次访问
偏向锁 (101)
    ↓ 竞争发生
轻量级锁 (000)
    ↓ 竞争激烈/自旋失败
重量级锁 (010)
```

## 2. 偏向锁机制

### 2.1 偏向锁获取

```cpp
// src/hotspot/share/runtime/biasedLocking.cpp
BiasedLocking::Condition BiasedLocking::revoke_and_rebias(Handle obj, 
                                                         bool attempt_rebias, 
                                                         TRAPS) {
  markOop mark = obj->mark();
  
  if (mark->is_biased_anonymously() && !attempt_rebias) {
    // 匿名偏向，尝试偏向当前线程
    markOop biased_prototype = markOopDesc::encode((JavaThread*) THREAD, 
                                                  mark->age(), 
                                                  mark->bias_epoch());
    markOop res_mark = obj->cas_set_mark(biased_prototype, mark);
    if (res_mark == mark) {
      return BIAS_REVOKED_AND_REBIASED;
    }
  } else if (mark->has_bias_pattern()) {
    Klass* k = obj->klass();
    markOop prototype_header = k->prototype_header();
    
    if (!prototype_header->has_bias_pattern()) {
      // 类已禁用偏向锁
      markOop biasless_mark = mark->set_unlocked();
      markOop res_mark = obj->cas_set_mark(biasless_mark, mark);
      if (res_mark == mark) {
        return BIAS_REVOKED;
      }
    } else if (prototype_header->bias_epoch() != mark->bias_epoch()) {
      // 时代不匹配，需要重偏向
      if (attempt_rebias) {
        markOop new_mark = markOopDesc::encode((JavaThread*) THREAD,
                                              mark->age(),
                                              prototype_header->bias_epoch());
        markOop res_mark = obj->cas_set_mark(new_mark, mark);
        if (res_mark == mark) {
          return BIAS_REVOKED_AND_REBIASED;
        }
      }
    }
  }
  
  // 需要撤销偏向锁
  return revoke_bias(obj(), false, false, (JavaThread*) THREAD, NULL);
}
```

### 2.2 偏向锁撤销

```cpp
// 偏向锁撤销核心逻辑
static BiasedLocking::Condition revoke_bias(oop obj, bool allow_rebias, 
                                           bool is_bulk, JavaThread* requesting_thread,
                                           JavaThread** biased_locker) {
  markOop mark = obj->mark();
  
  if (!mark->has_bias_pattern()) {
    return BiasedLocking::NOT_BIASED;
  }
  
  uint age = mark->age();
  markOop unbiased_prototype = markOopDesc::prototype()->set_age(age);
  markOop biased_prototype = unbiased_prototype->set_biased_locking();
  
  JavaThread* biased_thread = mark->biased_locker();
  if (biased_thread == NULL) {
    // 匿名偏向，直接撤销
    if (!allow_rebias) {
      obj->set_mark(unbiased_prototype);
    }
    return BiasedLocking::BIAS_REVOKED;
  }
  
  // 检查偏向线程是否还活着
  bool thread_is_alive = false;
  if (requesting_thread == biased_thread) {
    thread_is_alive = true;
  } else {
    ThreadsListHandle tlh;
    thread_is_alive = tlh.includes(biased_thread);
  }
  
  if (!thread_is_alive) {
    // 线程已死，直接撤销
    if (allow_rebias) {
      obj->set_mark(biased_prototype);
    } else {
      obj->set_mark(unbiased_prototype);
    }
    return BiasedLocking::BIAS_REVOKED;
  }
  
  // 需要在安全点撤销
  VM_RevokeBias vm_op(obj, requesting_thread);
  VMThread::execute(&vm_op);
  return vm_op.status_code();
}
```

## 3. 轻量级锁机制

### 3.1 轻量级锁获取

```cpp
// src/hotspot/share/runtime/synchronizer.cpp
void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {
  markOop mark = obj->mark();
  
  if (mark->is_neutral()) {
    // 无锁状态，尝试CAS获取轻量级锁
    lock->set_displaced_header(mark);
    if (mark == obj()->cas_set_mark((markOop) lock, mark)) {
      TEVENT(slow_enter: release stacklock);
      return;
    }
    // CAS失败，可能发生竞争
  } else if (mark->has_locker() && 
             THREAD->is_lock_owned((address)mark->locker())) {
    // 重入锁
    assert(lock != mark->locker(), "must not re-lock the same lock");
    assert(lock != (BasicLock*)obj->mark(), "don't relock with same BasicLock");
    lock->set_displaced_header(NULL);
    return;
  }

  // 轻量级锁获取失败，膨胀为重量级锁
  lock->set_displaced_header(markOopDesc::unused_mark());
  ObjectSynchronizer::inflate(THREAD, obj(), inflate_cause_monitor_enter)->enter(THREAD);
}
```

### 3.2 轻量级锁释放

```cpp
void ObjectSynchronizer::fast_exit(oop object, BasicLock* lock, TRAPS) {
  markOop mark = object->mark();
  
  // 检查是否为轻量级锁
  if (mark == (markOop) lock) {
    // 是轻量级锁，尝试CAS释放
    markOop dhw = lock->displaced_header();
    if (dhw == NULL) {
      // 重入锁，直接返回
      return;
    }
    
    if (object->cas_set_mark(dhw, mark) == mark) {
      TEVENT(fast_exit: release stacklock);
      return;
    }
  }
  
  // CAS失败或已膨胀，使用重量级锁释放
  ObjectSynchronizer::inflate(THREAD, object, inflate_cause_monitor_enter)->exit(true, THREAD);
}
```

## 4. 重量级锁机制

### 4.1 ObjectMonitor结构

```cpp
// src/hotspot/share/runtime/objectMonitor.hpp
class ObjectMonitor {
private:
  friend class ObjectSynchronizer;
  
  volatile markOop   _header;       // 被替换的对象头
  void*     volatile _owner;        // 锁拥有者线程
  volatile uintptr_t _recursions;   // 重入次数
  ObjectWaiter * volatile _EntryList; // 等待获取锁的线程队列
  ObjectWaiter * volatile _cxq;       // 竞争队列
  ObjectWaiter * volatile _succ;      // 继承者线程
  ObjectWaiter * volatile _WaitSet;   // wait()等待的线程集合
  
  volatile jint  _waiters;          // wait()线程数量
  volatile jint  _count;            // 引用计数
  
public:
  // 锁获取
  void enter(TRAPS);
  void exit(bool not_suspended, TRAPS);
  
  // 等待/通知
  void wait(jlong millis, bool interruptable, TRAPS);
  void notify(TRAPS);
  void notifyAll(TRAPS);
};
```

### 4.2 重量级锁获取

```cpp
void ObjectMonitor::enter(TRAPS) {
  Thread * const Self = THREAD;
  void * cur = Atomic::cmpxchg(Self, &_owner, (void*)NULL);
  
  if (cur == NULL) {
    // 成功获取锁
    assert(_recursions == 0, "invariant");
    assert(_owner == Self, "invariant");
    return;
  }
  
  if (cur == Self) {
    // 重入锁
    _recursions++;
    return;
  }
  
  // 锁被其他线程持有，需要等待
  if (Self->is_lock_owned((address)cur)) {
    assert(_recursions == 0, "internal state error");
    _recursions = 1;
    _owner = Self;
    return;
  }
  
  // 进入竞争状态
  Self->_Stalled = intptr_t(this);
  
  // 尝试自旋获取锁
  if (Knob_SpinEarly && TrySpin(Self) > 0) {
    assert(_owner == Self, "invariant");
    assert(_recursions == 0, "invariant");
    Self->_Stalled = 0;
    return;
  }
  
  // 自旋失败，进入等待队列
  EnterI(THREAD);
}
```

### 4.3 等待队列管理

```cpp
void ObjectMonitor::EnterI(TRAPS) {
  Thread * const Self = THREAD;
  
  // 再次尝试获取锁
  if (TryLock(Self) > 0) {
    return;
  }
  
  // 尝试自旋
  if (TrySpin(Self) > 0) {
    return;
  }
  
  // 创建等待节点
  ObjectWaiter node(Self);
  Self->_ParkEvent->reset();
  node._prev   = (ObjectWaiter *) 0xBAD;
  node.TState  = ObjectWaiter::TS_CXQ;
  
  // 加入竞争队列
  ObjectWaiter * nxt;
  for (;;) {
    node._next = nxt = _cxq;
    if (Atomic::cmpxchg(&node, &_cxq, nxt) == nxt) break;
  }
  
  // 检查是否可以避免park
  if ((SyncFlags & 16) == 0 && nxt == NULL && _EntryList == NULL) {
    Atomic::replace_if_null(Self, &_Responsible);
  }
  
  // 进入阻塞状态
  for (;;) {
    jt->set_suspend_equivalent();
    
    if (TryLock(Self) > 0) break;
    
    if (Self->is_suspended()) {
      Self->java_suspend_self();
      continue;
    }
    
    // park等待唤醒
    Self->_ParkEvent->park();
  }
}
```

## 5. 自旋锁优化

### 5.1 自适应自旋

```cpp
int ObjectMonitor::TrySpin(Thread * Self) {
  // 自旋计数器
  int ctr = Knob_SpinLimit;
  int Yields = 0;
  
  for (;;) {
    void * owner = _owner;
    if (owner == NULL) {
      // 锁已释放，尝试获取
      if (Atomic::replace_if_null(Self, &_owner)) {
        return 1;  // 获取成功
      }
      continue;
    }
    
    // 检查拥有者线程状态
    if (NotRunnable(Self, (JavaThread*)owner)) {
      return -1;  // 拥有者不在运行，停止自旋
    }
    
    // 自旋计数递减
    if (--ctr < 0) {
      return -1;  // 自旋次数用完
    }
    
    // 自适应延迟
    if ((ctr & 0xFF) == 0) {
      if (SafepointSynchronize::do_call_back()) {
        return -1;  // 需要安全点检查
      }
      
      // 让出CPU时间片
      if (Yields > 5) {
        os::naked_yield();
      } else {
        SpinPause();  // CPU pause指令
      }
      Yields++;
    }
  }
}
```

### 5.2 自旋参数调优

```cpp
// 自旋相关参数
class SpinLockTuning {
public:
  // 基础自旋次数
  static int base_spin_count() {
    if (FLAG_IS_DEFAULT(PreBlockSpin)) {
      return Arguments::is_server_jvm() ? 100 : 40;
    }
    return PreBlockSpin;
  }
  
  // 自适应调整
  static int adaptive_spin_count(JavaThread* thread, ObjectMonitor* monitor) {
    int spin_count = base_spin_count();
    
    // 根据历史成功率调整
    if (monitor->_SpinFreq > 0) {
      spin_count = (spin_count * monitor->_SpinFreq) / 100;
    }
    
    // 根据CPU核心数调整
    int ncpus = os::processor_count();
    if (ncpus <= 1) {
      spin_count = 0;  // 单核不自旋
    } else if (ncpus > 8) {
      spin_count *= 2;  // 多核增加自旋
    }
    
    return spin_count;
  }
};
```

## 6. 锁消除与锁粗化

### 6.1 逃逸分析锁消除

```cpp
// C2编译器锁消除
class EliminateLocks : public Phase {
public:
  void eliminate_lock(AbstractLockNode* alock) {
    Node* obj = alock->obj_node();
    
    // 检查对象是否逃逸
    if (!obj->is_eliminated()) {
      return;  // 对象逃逸，不能消除锁
    }
    
    // 消除锁节点
    alock->set_eliminated();
    
    // 替换为无操作
    Node* mem = alock->in(TypeFunc::Memory);
    igvn->replace_node(alock, mem);
    
    if (PrintEliminateLocks) {
      tty->print_cr("Eliminated lock on non-escaping object");
    }
  }
  
  // 检查嵌套锁
  bool is_nested_lock_region(AbstractLockNode* lock) {
    Node* obj = lock->obj_node();
    
    // 查找相同对象的其他锁
    for (uint i = 0; i < C->macro_count(); i++) {
      Node* n = C->macro_node(i);
      if (n->is_AbstractLock() && n != lock) {
        AbstractLockNode* other = n->as_AbstractLock();
        if (other->obj_node() == obj) {
          return true;  // 发现嵌套锁
        }
      }
    }
    return false;
  }
};
```

### 6.2 锁粗化优化

```cpp
// 锁粗化实现
class LockCoarsening : public Phase {
public:
  void coarsen_locks() {
    // 查找可以粗化的锁序列
    GrowableArray<AbstractLockNode*> lock_sequence;
    
    for (uint i = 0; i < C->macro_count(); i++) {
      Node* n = C->macro_node(i);
      if (n->is_Lock()) {
        LockNode* lock = n->as_Lock();
        
        // 检查是否可以与前面的锁合并
        if (can_coarsen_with_previous(lock, &lock_sequence)) {
          lock_sequence.append(lock);
        } else {
          // 处理之前收集的锁序列
          if (lock_sequence.length() > 1) {
            perform_coarsening(&lock_sequence);
          }
          lock_sequence.clear();
          lock_sequence.append(lock);
        }
      }
    }
    
    // 处理最后的锁序列
    if (lock_sequence.length() > 1) {
      perform_coarsening(&lock_sequence);
    }
  }
  
private:
  bool can_coarsen_with_previous(LockNode* lock, 
                                GrowableArray<AbstractLockNode*>* sequence) {
    if (sequence->length() == 0) return true;
    
    AbstractLockNode* prev = sequence->at(sequence->length() - 1);
    
    // 检查是否为相同对象
    if (lock->obj_node() != prev->obj_node()) {
      return false;
    }
    
    // 检查控制流是否连续
    if (!is_control_flow_continuous(prev, lock)) {
      return false;
    }
    
    // 检查中间是否有可能抛异常的操作
    if (has_exception_between(prev, lock)) {
      return false;
    }
    
    return true;
  }
};
```

## 7. 8GB堆内存多核环境优化

### 7.1 锁参数调优

```bash
# 8GB堆内存锁优化参数
-XX:+UseBiasedLocking              # 启用偏向锁
-XX:BiasedLockingStartupDelay=0    # 立即启用偏向锁
-XX:+UseHeavyMonitors=false        # 优先使用轻量级锁
-XX:+EliminateLocks                # 启用锁消除
-XX:+EliminateNestedLocks          # 启用嵌套锁消除
-XX:+DoEscapeAnalysis              # 启用逃逸分析

# 自旋锁优化
-XX:PreBlockSpin=200               # 增加自旋次数(多核环境)
-XX:+UseSpinning                   # 启用自旋锁
-XX:SpinLimit=2000                 # 自旋限制

# 多核环境特定优化
-XX:+UseLargePages                 # 使用大页内存
-XX:+UseTransparentHugePages       # 透明大页
-XX:+OptimizeStringConcat          # 字符串连接优化
```

### 7.2 监控与诊断

```cpp
// 锁竞争监控
class LockContentionMonitor {
private:
  static volatile jlong _total_contentions;
  static volatile jlong _total_wait_time;
  
public:
  // 记录锁竞争
  static void record_contention(ObjectMonitor* monitor, jlong wait_time) {
    Atomic::inc(&_total_contentions);
    Atomic::add(wait_time, &_total_wait_time);
    
    // 8GB堆环境阈值检查
    if (MaxHeapSize >= 8 * G) {
      // 大堆环境下的特殊处理
      if (_total_contentions > 10000 && 
          average_wait_time() > 10) {  // 10ms
        
        // 触发锁优化建议
        suggest_lock_optimization(monitor);
      }
    }
  }
  
  // 平均等待时间
  static double average_wait_time() {
    return _total_contentions > 0 ? 
           (double)_total_wait_time / _total_contentions : 0.0;
  }
  
  // 锁优化建议
  static void suggest_lock_optimization(ObjectMonitor* monitor) {
    // 分析锁竞争模式
    if (monitor->_contentions > 1000) {
      warning("High lock contention detected on %p, consider lock-free alternatives", 
              monitor->object());
    }
    
    if (monitor->_SpinFreq < 10) {
      warning("Low spin success rate on %p, consider reducing spin count", 
              monitor->object());
    }
  }
};
```

### 7.3 NUMA感知优化

```cpp
// NUMA感知的锁分配
class NUMALockAllocator {
public:
  static ObjectMonitor* allocate_monitor(Thread* thread) {
    // 获取线程所在NUMA节点
    int numa_node = os::numa_get_group_id_for_address((address)thread);
    
    // 在相同NUMA节点分配监视器
    ObjectMonitor* monitor = NULL;
    if (numa_node >= 0) {
      monitor = allocate_on_numa_node(numa_node);
    }
    
    if (monitor == NULL) {
      // 回退到默认分配
      monitor = ObjectSynchronizer::omAlloc(thread);
    }
    
    return monitor;
  }
  
private:
  static ObjectMonitor* allocate_on_numa_node(int node) {
    // NUMA节点特定的内存池
    static ObjectMonitor* numa_pools[MAX_NUMA_NODES];
    
    if (numa_pools[node] != NULL) {
      ObjectMonitor* result = numa_pools[node];
      numa_pools[node] = result->_next_om;
      return result;
    }
    
    // 在指定NUMA节点分配新的监视器
    void* mem = os::numa_malloc(sizeof(ObjectMonitor), node);
    if (mem != NULL) {
      return new(mem) ObjectMonitor();
    }
    
    return NULL;
  }
};
```

## 8. 性能优化实践

### 8.1 锁竞争热点分析

```java
// 使用JFR分析锁竞争
// -XX:+FlightRecorder 
// -XX:StartFlightRecording=duration=60s,filename=locks.jfr
// -XX:FlightRecorderOptions=settings=profile

public class LockAnalysis {
    // 高竞争场景
    private final Object hotLock = new Object();
    
    public void highContentionMethod() {
        synchronized(hotLock) {  // 热点锁
            // 关键区代码
            processData();
        }
    }
    
    // 优化方案1：锁分段
    private final Object[] segmentLocks = new Object[16];
    
    public void optimizedMethod(int key) {
        int segment = key % segmentLocks.length;
        synchronized(segmentLocks[segment]) {
            processData();
        }
    }
    
    // 优化方案2：无锁数据结构
    private final AtomicReference<Node> head = new AtomicReference<>();
    
    public void lockFreeMethod(Object data) {
        Node newNode = new Node(data);
        Node current;
        do {
            current = head.get();
            newNode.next = current;
        } while (!head.compareAndSet(current, newNode));
    }
}
```

### 8.2 锁优化最佳实践

```java
public class LockOptimizationBestPractices {
    
    // 1. 减少锁粒度
    private final Object dateLock = new Object();
    private final Object counterLock = new Object();
    
    public void finegrainedLocking() {
        synchronized(dateLock) {
            updateDate();
        }
        synchronized(counterLock) {
            incrementCounter();
        }
    }
    
    // 2. 使用读写锁
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    
    public void readOperation() {
        rwLock.readLock().lock();
        try {
            // 读操作
        } finally {
            rwLock.readLock().unlock();
        }
    }
    
    // 3. 锁排序避免死锁
    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();
    
    public void orderedLocking() {
        // 按照固定顺序获取锁
        synchronized(lock1) {
            synchronized(lock2) {
                // 临界区代码
            }
        }
    }
    
    // 4. 使用ThreadLocal避免同步
    private final ThreadLocal<StringBuilder> localBuffer = 
        ThreadLocal.withInitial(() -> new StringBuilder(1024));
    
    public String buildString() {
        StringBuilder sb = localBuffer.get();
        sb.setLength(0);  // 重置缓冲区
        // 构建字符串
        return sb.toString();
    }
}
```

## 9. 总结

HotSpot的多线程同步机制体现了现代JVM的精密设计：

1. **分层锁策略**：偏向锁→轻量级锁→重量级锁的渐进式优化
2. **自适应优化**：根据运行时特征动态调整自旋参数
3. **编译器优化**：逃逸分析实现锁消除和锁粗化
4. **NUMA感知**：在大内存多核环境下的性能优化

在8GB堆内存、多核环境下，关键是：
- 合理配置锁相关参数
- 使用JFR等工具监控锁竞争
- 应用锁优化最佳实践
- 考虑无锁数据结构替代方案

理解这些机制有助于编写高性能的并发Java应用程序。