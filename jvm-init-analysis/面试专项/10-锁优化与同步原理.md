# JVM面试专项：锁优化与同步原理

> **面试级别**: JVM技术专家  
> **环境**: Linux, OpenJDK 11, -Xms8g -Xmx8g -XX:+UseG1GC  
> **源码路径**: `/src/hotspot/share/runtime/`, `/src/hotspot/share/oops/`

---

## 问题1：对象头(Mark Word)的结构是什么？不同锁状态如何表示？

### 面试官视角
Mark Word是理解Java锁机制的基础，需要精确到bit级别的理解。

### 参考答案

#### 64位JVM Mark Word结构

**源码位置**: `oops/markOop.hpp`

```cpp
//  64 bits:
//  --------
//  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)
//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
//  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)
//  size:64 ----------------------------------------------------->| (CMS free block)

// 位定义
enum {
  age_bits                 = 4,    // GC年龄
  lock_bits                = 2,    // 锁标志位
  biased_lock_bits         = 1,    // 偏向锁标志
  hash_bits                = 31,   // identity hash code
  epoch_bits               = 2     // 偏向时间戳
};

// 锁状态
enum {
  locked_value             = 0,    // 00 - 轻量级锁
  unlocked_value           = 1,    // 01 - 无锁
  monitor_value            = 2,    // 10 - 重量级锁
  marked_value             = 3,    // 11 - GC标记
  biased_lock_pattern      = 5     // 101 - 偏向锁
};
```

#### Mark Word布局图

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              64-bit Mark Word                                   │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  无锁状态 (Unlocked):                                                            │
│  ┌─────────────┬───────────────┬────────┬───────┬───────────────┬───────┐       │
│  │  unused:25  │   hash:31     │unused:1│ age:4 │ biased_lock:0 │lock:01│       │
│  └─────────────┴───────────────┴────────┴───────┴───────────────┴───────┘       │
│                                                                                 │
│  偏向锁状态 (Biased):                                                            │
│  ┌───────────────────────────────┬─────────┬────────┬───────┬───────────┬─────┐ │
│  │       JavaThread*:54          │ epoch:2 │unused:1│ age:4 │biased_lock:1│lock:01│
│  └───────────────────────────────┴─────────┴────────┴───────┴───────────┴─────┘ │
│                                                                                 │
│  轻量级锁状态 (Lightweight Locked):                                              │
│  ┌─────────────────────────────────────────────────────────────────────┬───────┐│
│  │               ptr to Lock Record:62                                 │lock:00││
│  └─────────────────────────────────────────────────────────────────────┴───────┘│
│                                                                                 │
│  重量级锁状态 (Heavyweight Locked):                                              │
│  ┌─────────────────────────────────────────────────────────────────────┬───────┐│
│  │               ptr to ObjectMonitor:62                               │lock:10││
│  └─────────────────────────────────────────────────────────────────────┴───────┘│
│                                                                                 │
│  GC标记状态 (Marked for GC):                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┬───────┐│
│  │               ptr to forwarding address:62                          │lock:11││
│  └─────────────────────────────────────────────────────────────────────┴───────┘│
└─────────────────────────────────────────────────────────────────────────────────┘
```

#### 源码中的关键方法

```cpp
// markOop.hpp
class markOopDesc: public oopDesc {
  // 检查是否是偏向锁
  bool has_bias_pattern() const {
    return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern);
  }
  
  // 获取偏向的线程
  JavaThread* biased_locker() const {
    return (JavaThread*) ((intptr_t) (mask_bits(value(), ~(biased_lock_mask_in_place | age_mask_in_place | epoch_mask_in_place))));
  }
  
  // 检查是否被锁定
  bool is_locked() const {
    return (mask_bits(value(), lock_mask_in_place) != unlocked_value);
  }
  
  // 检查是否是轻量级锁
  bool has_locker() const {
    return ((value() & lock_mask_in_place) == locked_value);
  }
  
  // 检查是否是重量级锁
  bool has_monitor() const {
    return ((value() & monitor_value) != 0);
  }
};
```

---

## 问题2：偏向锁的原理和实现是什么？

### 面试官视角
偏向锁是HotSpot的重要优化，需要理解其优化场景和撤销代价。

### 参考答案

#### 偏向锁设计目标

偏向锁假设：大多数锁在整个生命周期内只被一个线程访问。

```
场景: 单线程循环同步
for (int i = 0; i < 1000000; i++) {
    synchronized(obj) {
        // 没有竞争，传统方式每次都要CAS
        // 偏向锁：只需第一次CAS，后续直接比较ThreadID
    }
}
```

#### 偏向锁获取流程

**源码位置**: `runtime/synchronizer.cpp`

```cpp
// 快速路径 - 检查是否已偏向当前线程
void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, bool attempt_rebias, TRAPS) {
  if (UseBiasedLocking) {
    BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);
    if (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) {
      return;  // 成功获取偏向锁
    }
  }
  slow_enter(obj, lock, THREAD);  // 进入轻量级锁路径
}
```

#### 偏向锁状态转换

```
        ┌─────────────────────────────────────────────────────────────┐
        │                      无锁状态                                │
        │    [0 | epoch | age | 1 | 01]  (可偏向，未偏向)               │
        └─────────────────────────┬───────────────────────────────────┘
                                  │ 第一次获取锁
                                  │ CAS设置ThreadID
                                  ▼
        ┌─────────────────────────────────────────────────────────────┐
        │                     偏向锁状态                                │
        │    [ThreadID | epoch | age | 1 | 01]                        │
        └───────────────┬──────────────────────────┬──────────────────┘
                        │ 同一线程再次获取           │ 其他线程尝试获取
                        │ (只比较ThreadID)          │ (触发撤销)
                        ▼                          ▼
        ┌─────────────────────────────┐   ┌─────────────────────────────┐
        │ 无需任何操作                 │   │ 偏向锁撤销                   │
        │ (快速路径)                   │   │ (STW SafePoint)             │
        └─────────────────────────────┘   └───────────────┬─────────────┘
                                                          │
                                                          ▼
                                          ┌─────────────────────────────┐
                                          │ 升级为轻量级锁               │
                                          │ [ptr to LockRecord | 00]    │
                                          └─────────────────────────────┘
```

#### 偏向锁撤销

**源码位置**: `runtime/biasedLocking.cpp`

```cpp
static BiasedLocking::Condition revoke_bias(oop obj, bool allow_rebias, 
                                             bool is_bulk, 
                                             JavaThread* requesting_thread,
                                             JavaThread** biased_locker) {
  markOop mark = obj->mark();
  
  if (!mark->has_bias_pattern()) {
    return BiasedLocking::NOT_BIASED;
  }
  
  uint age = mark->age();
  markOop biased_prototype = markOopDesc::biased_locking_prototype()->set_age(age);
  markOop unbiased_prototype = markOopDesc::prototype()->set_age(age);
  
  JavaThread* biased_thread = mark->biased_locker();
  
  if (biased_thread == NULL) {
    // 匿名偏向 - 未偏向任何线程
    if (allow_rebias) {
      // 允许重偏向
      obj->set_mark(biased_prototype);
    } else {
      obj->set_mark(unbiased_prototype);
    }
    return BiasedLocking::BIAS_REVOKED;
  }
  
  // 需要检查偏向线程是否存活
  // 需要遍历偏向线程的栈，查找锁记录
  // 这需要在SafePoint执行！
  
  bool thread_is_alive = false;
  if (requesting_thread == biased_thread) {
    thread_is_alive = true;
  } else {
    // 检查线程是否存活...
  }
  
  if (!thread_is_alive) {
    // 线程已死，直接撤销
    obj->set_mark(allow_rebias ? biased_prototype : unbiased_prototype);
  } else {
    // 线程存活，需要遍历栈
    // 撤销并升级为轻量级锁或重量级锁
  }
  
  return BiasedLocking::BIAS_REVOKED;
}
```

#### 批量重偏向和批量撤销

```cpp
// 当某个类的对象频繁发生偏向锁撤销时
// 执行批量操作以降低开销

// BiasedLockingBulkRebiasThreshold = 20  (默认)
// 达到阈值时，执行批量重偏向

// BiasedLockingBulkRevokeThreshold = 40  (默认)
// 达到阈值时，执行批量撤销，该类不再使用偏向锁
```

#### 为什么JDK 15默认禁用偏向锁？

```
1. 偏向锁撤销需要STW SafePoint，代价高
2. 现代应用多线程访问锁对象很常见
3. 轻量级锁的CAS操作已经很高效
4. 维护偏向锁增加了JVM复杂度
```

---

## 问题3：轻量级锁的实现原理？

### 面试官视角
轻量级锁是无竞争场景下的高效锁实现。

### 参考答案

#### 轻量级锁结构 - Lock Record

**源码位置**: `runtime/basicLock.hpp`

```cpp
class BasicLock {
  volatile markOop _displaced_header;  // 存储对象原始Mark Word
  
public:
  markOop displaced_header() const { return _displaced_header; }
  void set_displaced_header(markOop header) { _displaced_header = header; }
};

class BasicObjectLock {
  BasicLock _lock;    // Lock Record
  oop _obj;           // 锁定的对象
  
public:
  BasicLock* lock() { return &_lock; }
  oop obj() const { return _obj; }
};
```

#### 轻量级锁获取流程

```cpp
// 源码位置: runtime/synchronizer.cpp
void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {
  markOop mark = obj->mark();
  
  if (mark->is_neutral()) {
    // 无锁状态，尝试CAS
    lock->set_displaced_header(mark);  // 保存原始Mark Word
    if (obj()->cas_set_mark((markOop) lock, mark) == mark) {
      // CAS成功，获取轻量级锁
      return;
    }
    // CAS失败，说明有竞争
  } else if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {
    // 锁重入
    lock->set_displaced_header(NULL);  // displaced header = NULL表示重入
    return;
  }
  
  // CAS失败或已是重量级锁，膨胀
  lock->set_displaced_header(markOopDesc::unused_mark());
  ObjectSynchronizer::inflate(THREAD, obj())->enter(THREAD);
}
```

#### 轻量级锁释放流程

```cpp
void ObjectSynchronizer::slow_exit(oop object, BasicLock* lock, TRAPS) {
  markOop dhw = lock->displaced_header();
  
  if (dhw == NULL) {
    // 锁重入退出，无需操作
    return;
  }
  
  markOop mark = object->mark();
  
  if (mark == (markOop) lock) {
    // 轻量级锁退出，CAS恢复Mark Word
    if (object->cas_set_mark(dhw, mark) == mark) {
      return;  // 成功释放
    }
  }
  
  // CAS失败，说明锁已膨胀
  ObjectSynchronizer::inflate(THREAD, object)->exit(THREAD);
}
```

#### 轻量级锁流程图

```
线程栈                              对象头
┌─────────────────┐                ┌─────────────────┐
│   Lock Record   │                │    Mark Word    │
├─────────────────┤    CAS成功      ├─────────────────┤
│ displaced_header│ ◄────────────── │ [hash|age|0|01] │
│   = 原始Mark    │                │       ↓         │
├─────────────────┤                │ [ptr to LR |00] │
│      obj        │ ──────────────► │                 │
└─────────────────┘                └─────────────────┘

释放锁时:
┌─────────────────┐                ┌─────────────────┐
│   Lock Record   │                │    Mark Word    │
├─────────────────┤    CAS还原      ├─────────────────┤
│ displaced_header│ ──────────────► │ [hash|age|0|01] │
│   = 原始Mark    │                │                 │
└─────────────────┘                └─────────────────┘
```

---

## 问题4：重量级锁(ObjectMonitor)的实现？

### 面试官视角
重量级锁是最完整的锁实现，涉及线程阻塞和唤醒。

### 参考答案

#### ObjectMonitor结构

**源码位置**: `runtime/objectMonitor.hpp`

```cpp
class ObjectMonitor {
  // Mark Word备份
  volatile markOop _header;
  
  // 指向锁定的对象
  void* volatile _object;
  
  // 持有锁的线程
  void* volatile _owner;
  
  // 递归计数
  volatile intptr_t _recursions;
  
  // 等待队列(用于wait/notify)
  ObjectWaiter* volatile _WaitSet;
  volatile int _WaitSetLock;
  
  // 竞争队列
  volatile int _contentions;     // 竞争者数量
  ObjectWaiter* volatile _cxq;   // 最近的竞争者
  ObjectWaiter* volatile _EntryList; // 等待获取锁的线程
  
  // 自旋相关
  volatile int _spinFreq;
  volatile int _spinClock;
  
protected:
  // 锁获取入口
  void enter(TRAPS);
  // 锁释放入口  
  void exit(TRAPS);
  // wait实现
  void wait(jlong millis, bool interruptable, TRAPS);
  // notify实现
  void notify(TRAPS);
  void notifyAll(TRAPS);
};
```

#### 重量级锁获取流程

```cpp
// 源码位置: runtime/objectMonitor.cpp
void ObjectMonitor::enter(TRAPS) {
  Thread* const Self = THREAD;
  void* cur = Atomic::cmpxchg(Self, &_owner, (void*)NULL);
  
  if (cur == NULL) {
    // CAS成功，获取锁
    return;
  }
  
  if (cur == Self) {
    // 锁重入
    _recursions++;
    return;
  }
  
  // 获取失败，进入竞争
  // 先自旋尝试
  if (TrySpin(Self) > 0) {
    return;  // 自旋成功
  }
  
  // 自旋失败，加入等待队列
  for (;;) {
    // 1. 先自适应自旋
    if (TrySpin(Self) > 0) break;
    
    // 2. 加入cxq队列头部
    ObjectWaiter node(Self);
    node._next = _cxq;
    if (Atomic::cmpxchg(&node, &_cxq, node._next) == node._next) {
      // 成功加入队列
    }
    
    // 3. 挂起线程
    Self->_ParkEvent->park();
    
    // 4. 被唤醒后重新尝试获取
    if (TryLock(Self) > 0) break;
  }
}
```

#### 重量级锁释放流程

```cpp
void ObjectMonitor::exit(TRAPS) {
  Thread* const Self = THREAD;
  
  if (_recursions != 0) {
    // 递归退出
    _recursions--;
    return;
  }
  
  // 真正释放锁
  _owner = NULL;
  OrderAccess::storeload();  // 内存屏障
  
  // 检查是否有等待线程
  if (_EntryList == NULL && _cxq == NULL) {
    return;  // 没有等待者
  }
  
  // 唤醒策略
  ObjectWaiter* w = NULL;
  if (_EntryList != NULL) {
    // 从EntryList唤醒
    w = _EntryList;
    _EntryList = w->_next;
  } else {
    // 从cxq迁移到EntryList
    w = _cxq;
    _cxq = NULL;
    _EntryList = w;
    // ... 反转链表等操作
  }
  
  // 唤醒选中的线程
  w->_thread->_ParkEvent->unpark();
}
```

#### 锁膨胀过程

```cpp
// 源码位置: runtime/synchronizer.cpp
ObjectMonitor* ObjectSynchronizer::inflate(Thread* Self, oop object) {
  for (;;) {
    const markOop mark = object->mark();
    
    // 已经是重量级锁
    if (mark->has_monitor()) {
      return mark->monitor();
    }
    
    // 正在膨胀中(被其他线程)
    if (mark == markOopDesc::INFLATING()) {
      continue;  // 自旋等待
    }
    
    // 轻量级锁膨胀
    if (mark->has_locker()) {
      ObjectMonitor* m = new ObjectMonitor();
      m->_header = markOopDesc::INFLATING();  // 占位
      
      // CAS设置膨胀标记
      if (object->cas_set_mark((markOop) INFLATING(), mark) != mark) {
        delete m;
        continue;
      }
      
      // 复制displaced header
      m->set_header(mark->displaced_mark_helper());
      m->set_owner(mark->locker());  // 原持有者
      
      // 设置monitor指针
      object->set_mark(markOopDesc::encode(m));
      return m;
    }
    
    // 无锁状态膨胀
    ObjectMonitor* m = new ObjectMonitor();
    m->_header = mark;  // 保存原始mark
    
    if (object->cas_set_mark(markOopDesc::encode(m), mark) != mark) {
      delete m;
      continue;
    }
    
    return m;
  }
}
```

---

## 问题5：锁升级的完整流程是什么？

### 面试官视角
需要完整描述从偏向锁到重量级锁的升级过程。

### 参考答案

#### 锁升级状态图

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                              无锁状态                                         │
│                         (可偏向: biased=1)                                    │
└──────────────────────────────────┬───────────────────────────────────────────┘
                                   │ 第一次获取锁
                                   │ CAS写入ThreadID
                                   ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                              偏向锁                                           │
│                    [ThreadID | epoch | age | 1 | 01]                         │
└───────────┬──────────────────────┬───────────────────────────────┬───────────┘
            │ 同一线程              │ 其他线程请求                   │ 调用hashCode
            │ 无操作               │                               │
            ▼                      ▼                               ▼
┌───────────────────┐   ┌───────────────────────────────┐   ┌──────────────────┐
│  仍是偏向锁        │   │ 偏向锁撤销(SafePoint)          │   │ 偏向锁撤销        │
│  (快速路径)        │   │  1. 检查原线程是否存活          │   │  撤销并设置hash  │
└───────────────────┘   │  2. 遍历栈找Lock Record        │   │                  │
                        │  3. 升级为轻量级锁              │   └──────────────────┘
                        └───────────────┬───────────────┘
                                        │
                                        ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                             轻量级锁                                          │
│                    [ptr to Lock Record | 00]                                 │
└───────────┬──────────────────────┬───────────────────────────────────────────┘
            │ 无竞争                │ CAS失败(有竞争)
            │ CAS释放成功          │
            ▼                      ▼
┌───────────────────┐   ┌───────────────────────────────────────────────────────┐
│  释放锁            │   │ 锁膨胀(Lock Inflation)                                │
│  恢复Mark Word     │   │  1. 分配ObjectMonitor                                │
│                    │   │  2. CAS设置INFLATING标记                             │
└───────────────────┘   │  3. 设置monitor指针                                   │
                        │  4. 竞争线程进入等待队列                               │
                        └───────────────────────────┬───────────────────────────┘
                                                    │
                                                    ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                            重量级锁                                           │
│                    [ptr to ObjectMonitor | 10]                               │
├──────────────────────────────────────────────────────────────────────────────┤
│  ObjectMonitor:                                                              │
│  - _owner: 当前持有者                                                         │
│  - _recursions: 递归计数                                                      │
│  - _cxq: 最近竞争者队列                                                       │
│  - _EntryList: 等待获取锁队列                                                 │
│  - _WaitSet: wait()等待队列                                                  │
└──────────────────────────────────────────────────────────────────────────────┘
```

#### 锁降级

```
重量级锁 → 轻量级锁 → 偏向锁?

实际上: 锁只能升级，不能降级！

原因:
1. 降级需要检查所有引用该对象的代码
2. 代价太高，收益不明显
3. 一旦发生竞争，再次竞争的概率很高
```

---

## 问题6：synchronized与Lock的底层区别？

### 面试官视角
考察对两种锁实现方式的深入理解。

### 参考答案

#### 实现层面对比

| 特性 | synchronized | ReentrantLock |
|------|-------------|---------------|
| 实现层 | JVM内置 | JDK库(AQS) |
| 锁获取 | monitorenter | lock() |
| 锁释放 | monitorexit | unlock() |
| 底层机制 | ObjectMonitor | CLH队列 + CAS |
| 可中断 | 不支持 | lockInterruptibly() |
| 超时获取 | 不支持 | tryLock(timeout) |
| 公平性 | 非公平 | 可选 |
| 条件变量 | 单一(wait/notify) | 多个Condition |

#### synchronized字节码

```java
synchronized(obj) {
    // ...
}

// 字节码:
0: aload_0
1: monitorenter        // 获取锁
2: ...                 // 同步代码
5: aload_0
6: monitorexit         // 正常退出释放锁
7: goto 15
10: aload_0
11: monitorexit        // 异常退出释放锁
12: athrow
```

#### ReentrantLock实现核心

```java
// AbstractQueuedSynchronizer
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

// tryAcquire - 尝试CAS获取
// addWaiter - 加入CLH队列
// acquireQueued - 自旋+挂起
```

#### 性能对比

```
JDK 6之前: ReentrantLock明显优于synchronized
JDK 6之后: synchronized优化后(偏向锁、轻量级锁)，性能相当

现代建议:
- 简单同步使用synchronized (代码简洁，JVM优化)
- 需要高级功能时使用Lock (可中断、超时、多条件)
```

---

## 总结

### 关键源码文件

| 主题 | 源码文件 | 关键类/方法 |
|------|----------|-------------|
| Mark Word | `oops/markOop.hpp` | `markOopDesc` |
| 偏向锁 | `runtime/biasedLocking.cpp` | `BiasedLocking::revoke_bias` |
| 轻量级锁 | `runtime/synchronizer.cpp` | `slow_enter/slow_exit` |
| 重量级锁 | `runtime/objectMonitor.cpp` | `ObjectMonitor::enter/exit` |
| 锁膨胀 | `runtime/synchronizer.cpp` | `ObjectSynchronizer::inflate` |

### 面试回答要点

1. **Mark Word**: 64位中包含hash、age、锁标志，不同锁状态布局不同
2. **偏向锁**: 适用于单线程，记录ThreadID，撤销需要SafePoint
3. **轻量级锁**: CAS竞争，Lock Record存储displaced header
4. **重量级锁**: ObjectMonitor管理等待队列，涉及线程挂起/唤醒
5. **锁升级**: 偏向→轻量级→重量级，只升不降
6. **JDK 15**: 默认禁用偏向锁，因为撤销代价高
