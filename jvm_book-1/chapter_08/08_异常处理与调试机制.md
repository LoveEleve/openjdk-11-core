# ç¬¬08ç« ï¼šå¼‚å¸¸å¤„ç†ä¸è°ƒè¯•æœºåˆ¶ - æ•…éšœè¯Šæ–­ä¸æ€§èƒ½åˆ†æ

## ğŸ“‹ ç« èŠ‚æ¦‚è¿°

æœ¬ç« æ·±å…¥åˆ†æJVMçš„å¼‚å¸¸å¤„ç†æœºåˆ¶å’Œè°ƒè¯•è¯Šæ–­ç³»ç»Ÿï¼ŒåŸºäºOpenJDK 11æºç å’ŒGDBè°ƒè¯•éªŒè¯ï¼Œæ¢è®¨å¼‚å¸¸æŠ›å‡ºä¸æ•è·çš„å®Œæ•´æµç¨‹ã€æ ˆå¸§å±•å¼€æœºåˆ¶ã€è°ƒè¯•ä¿¡æ¯ç”Ÿæˆã€æ€§èƒ½ç›‘æ§å·¥å…·é›†æˆç­‰æ ¸å¿ƒæŠ€æœ¯ã€‚

### ğŸ¯ å­¦ä¹ ç›®æ ‡

- æŒæ¡JVMå¼‚å¸¸å¤„ç†çš„å®Œæ•´å®ç°æœºåˆ¶
- ç†è§£æ ˆå¸§å±•å¼€å’Œå¼‚å¸¸ä¼ æ’­çš„åº•å±‚åŸç†
- æ·±å…¥åˆ†æè°ƒè¯•ä¿¡æ¯çš„ç”Ÿæˆå’Œç®¡ç†
- å­¦ä¼šä½¿ç”¨JVMå†…ç½®çš„è¯Šæ–­å’Œç›‘æ§å·¥å…·
- æŒæ¡æ€§èƒ½åˆ†æå’Œæ•…éšœæ’é™¤çš„ç³»ç»Ÿæ–¹æ³•

### ğŸ”§ æŠ€æœ¯ç¯å¢ƒ

- **JVMé…ç½®**: -Xms8g -Xmx8g (æ ‡å‡†8GBå †é…ç½®)
- **åƒåœ¾æ”¶é›†å™¨**: G1GC (4MB Regionå¤§å°)
- **è°ƒè¯•æ¨¡å¼**: slowdebugæ„å»ºç‰ˆæœ¬
- **å·¥å…·é“¾**: GDB + JFR + JConsole + VisualVM

---

## ğŸ—ï¸ ç¬¬ä¸€éƒ¨åˆ†ï¼šå¼‚å¸¸å¤„ç†æœºåˆ¶æ·±åº¦åˆ†æ

### 1.1 å¼‚å¸¸å¯¹è±¡çš„åˆ›å»ºä¸ç®¡ç†

#### 1.1.1 å¼‚å¸¸å¯¹è±¡å†…å­˜å¸ƒå±€

```cpp
// hotspot/src/share/vm/oops/instanceKlass.hpp
class InstanceKlass : public Klass {
private:
  // å¼‚å¸¸ç›¸å…³å­—æ®µ
  Method* _exception_table;           // å¼‚å¸¸è¡¨
  int _exception_table_length;       // å¼‚å¸¸è¡¨é•¿åº¦
  
  // è°ƒè¯•ä¿¡æ¯
  LineNumberTableElement* _line_number_table;
  LocalVariableTableElement* _local_variable_table;
  
public:
  // å¼‚å¸¸å¤„ç†æ–¹æ³•
  ExceptionHandlerTable* exception_handlers() const;
  bool has_exception_handler() const;
  int find_exception_handler_index(int bci, Handle exception) const;
};
```

#### 1.1.2 å¼‚å¸¸åˆ›å»ºæµç¨‹åˆ†æ

```cpp
// hotspot/src/share/vm/runtime/exceptions.cpp
void Exceptions::_throw(Thread* thread, const char* file, int line, 
                       Symbol* name, const char* message) {
  // 1. æ£€æŸ¥çº¿ç¨‹çŠ¶æ€
  assert(thread->is_Java_thread(), "must be Java thread");
  JavaThread* jt = (JavaThread*)thread;
  
  // 2. åˆ›å»ºå¼‚å¸¸å¯¹è±¡
  Handle exception = create_exception(jt, name, message);
  
  // 3. è®¾ç½®å¼‚å¸¸çŠ¶æ€
  jt->set_pending_exception(exception(), file, line);
  
  // 4. è§¦å‘å¼‚å¸¸å¤„ç†æµç¨‹
  if (jt->has_pending_exception()) {
    handle_exception_unwinding(jt, exception);
  }
}

// å¼‚å¸¸å¯¹è±¡åˆ›å»º
Handle Exceptions::create_exception(JavaThread* thread, Symbol* name, 
                                  const char* message) {
  // 1. æŸ¥æ‰¾å¼‚å¸¸ç±»
  Klass* klass = SystemDictionary::resolve_or_fail(name, true, thread);
  instanceKlassHandle ik(thread, klass);
  
  // 2. åˆ†é…å¼‚å¸¸å¯¹è±¡
  instanceOop exception_oop = ik->allocate_instance(thread);
  Handle exception(thread, exception_oop);
  
  // 3. åˆå§‹åŒ–å¼‚å¸¸å¯¹è±¡
  if (message != NULL) {
    java_lang_Throwable::set_message(exception(), 
                                   java_lang_String::create_from_str(message, thread));
  }
  
  // 4. å¡«å……æ ˆè·Ÿè¸ªä¿¡æ¯
  java_lang_Throwable::fill_in_stack_trace(exception, thread);
  
  return exception;
}
```

### 1.2 æ ˆè·Ÿè¸ªä¿¡æ¯ç”Ÿæˆæœºåˆ¶

#### 1.2.1 æ ˆå¸§éå†ç®—æ³•

```cpp
// hotspot/src/share/vm/runtime/vframe.cpp
class vframeStreamCommon {
private:
  frame _frame;                    // å½“å‰æ ˆå¸§
  JavaThread* _thread;            // æ‰€å±çº¿ç¨‹
  RegisterMap _reg_map;           // å¯„å­˜å™¨æ˜ å°„
  
public:
  // æ ˆå¸§éå†
  void security_next() {
    if (_frame.is_first_frame()) {
      _frame = _thread->last_frame();
    } else {
      _frame = _frame.sender(&_reg_map);
    }
  }
  
  // è·å–æ–¹æ³•ä¿¡æ¯
  Method* method() const {
    return _frame.interpreter_frame_method();
  }
  
  // è·å–å­—èŠ‚ç ä½ç½®
  int bci() const {
    return _frame.interpreter_frame_bci();
  }
};

// æ ˆè·Ÿè¸ªå¡«å……
void java_lang_Throwable::fill_in_stack_trace(Handle throwable, 
                                             JavaThread* thread) {
  // 1. åˆ›å»ºæ ˆè·Ÿè¸ªæ•°ç»„
  GrowableArray<BacktraceElement>* trace = 
    new GrowableArray<BacktraceElement>(64);
  
  // 2. éå†æ ˆå¸§
  vframeStream st(thread);
  while (!st.at_end()) {
    // è·å–æ–¹æ³•å’Œä½ç½®ä¿¡æ¯
    Method* method = st.method();
    int bci = st.bci();
    
    // åˆ›å»ºæ ˆè·Ÿè¸ªå…ƒç´ 
    BacktraceElement bte(method, bci);
    trace->append(bte);
    
    st.next();
  }
  
  // 3. è®¾ç½®æ ˆè·Ÿè¸ªæ•°æ®
  set_backtrace(throwable(), create_backtrace_array(trace, thread));
}
```

#### 1.2.2 è°ƒè¯•ä¿¡æ¯è§£æ

```cpp
// hotspot/src/share/vm/oops/method.cpp
class Method : public Metadata {
private:
  // è°ƒè¯•ä¿¡æ¯è¡¨
  CompressedLineNumberReadStream* _line_number_table;
  LocalVariableTableElement* _local_variable_table;
  
public:
  // è·å–è¡Œå·ä¿¡æ¯
  int line_number_from_bci(int bci) const {
    if (_line_number_table == NULL) return -1;
    
    CompressedLineNumberReadStream stream(_line_number_table);
    while (stream.read_pair()) {
      if (stream.bci() == bci) {
        return stream.line();
      }
    }
    return -1;
  }
  
  // è·å–å±€éƒ¨å˜é‡ä¿¡æ¯
  LocalVariableTableElement* localvariable_table_start() const {
    return _local_variable_table;
  }
  
  int localvariable_table_length() const {
    return _local_variable_table_length;
  }
};
```

### 1.3 å¼‚å¸¸ä¼ æ’­ä¸æ ˆå±•å¼€æœºåˆ¶

#### 1.3.1 å¼‚å¸¸å¤„ç†è¡¨ç»“æ„

```cpp
// hotspot/src/share/vm/interpreter/bytecodeStream.hpp
class ExceptionHandlerTable {
private:
  struct ExceptionTableElement {
    u2 start_pc;      // å¼‚å¸¸å¤„ç†èŒƒå›´èµ·å§‹
    u2 end_pc;        // å¼‚å¸¸å¤„ç†èŒƒå›´ç»“æŸ
    u2 handler_pc;    // å¼‚å¸¸å¤„ç†å™¨ä½ç½®
    u2 catch_type;    // æ•è·çš„å¼‚å¸¸ç±»å‹
  };
  
  ExceptionTableElement* _table;
  int _length;
  
public:
  // æŸ¥æ‰¾å¼‚å¸¸å¤„ç†å™¨
  int find_handler_index(int bci, Symbol* exception_name) const {
    for (int i = 0; i < _length; i++) {
      ExceptionTableElement* elem = &_table[i];
      
      // æ£€æŸ¥PCèŒƒå›´
      if (bci >= elem->start_pc && bci < elem->end_pc) {
        // æ£€æŸ¥å¼‚å¸¸ç±»å‹åŒ¹é…
        if (elem->catch_type == 0 || // catch-all
            matches_exception_type(elem->catch_type, exception_name)) {
          return i;
        }
      }
    }
    return -1;
  }
};
```

#### 1.3.2 æ ˆå±•å¼€æ‰§è¡Œæµç¨‹

```cpp
// hotspot/src/share/vm/runtime/stubRoutines.cpp
address StubRoutines::forward_exception_entry() {
  return _forward_exception_entry;
}

// å¼‚å¸¸ä¼ æ’­å¤„ç†
void SharedRuntime::continuation_for_implicit_exception(JavaThread* thread,
                                                       address pc,
                                                       SharedRuntime::ImplicitExceptionKind exception_kind) {
  // 1. è·å–å½“å‰æ–¹æ³•å’Œå­—èŠ‚ç ä½ç½®
  frame fr = thread->last_frame();
  Method* method = fr.interpreter_frame_method();
  int bci = fr.interpreter_frame_bci();
  
  // 2. æŸ¥æ‰¾å¼‚å¸¸å¤„ç†å™¨
  int handler_bci = method->fast_exception_handler_bci_for(
    thread->pending_exception()->klass(), bci, thread);
  
  if (handler_bci >= 0) {
    // 3. æ‰¾åˆ°å¤„ç†å™¨ï¼Œè·³è½¬æ‰§è¡Œ
    address handler_pc = method->code_base() + handler_bci;
    thread->set_exception_pc(handler_pc);
    thread->clear_pending_exception();
  } else {
    // 4. æœªæ‰¾åˆ°å¤„ç†å™¨ï¼Œç»§ç»­å‘ä¸Šä¼ æ’­
    unwind_callee_save_values(fr, thread);
    throw_and_post_jvmti_exception(thread, thread->pending_exception());
  }
}
```

---

## ğŸ” ç¬¬äºŒéƒ¨åˆ†ï¼šJVMè°ƒè¯•ä¸è¯Šæ–­æœºåˆ¶

### 2.1 JVMTIè°ƒè¯•æ¥å£å®ç°

#### 2.1.1 JVMTIäº‹ä»¶å¤„ç†æœºåˆ¶

```cpp
// hotspot/src/share/vm/prims/jvmtiEnv.cpp
class JvmtiEnv : public JvmtiEnvBase {
private:
  // äº‹ä»¶å›è°ƒå‡½æ•°è¡¨
  jvmtiEventCallbacks _event_callbacks;
  
  // äº‹ä»¶ä½¿èƒ½çŠ¶æ€
  JvmtiEventEnabled _event_enable;
  
public:
  // è®¾ç½®äº‹ä»¶å›è°ƒ
  jvmtiError SetEventCallbacks(const jvmtiEventCallbacks* callbacks,
                              jint size_of_callbacks) {
    if (callbacks == NULL) {
      memset(&_event_callbacks, 0, sizeof(jvmtiEventCallbacks));
    } else {
      memcpy(&_event_callbacks, callbacks, 
             MIN2(size_of_callbacks, (jint)sizeof(jvmtiEventCallbacks)));
    }
    return JVMTI_ERROR_NONE;
  }
  
  // å¯ç”¨/ç¦ç”¨äº‹ä»¶
  jvmtiError SetEventNotificationMode(jvmtiEventMode mode,
                                     jvmtiEvent event_type,
                                     jthread event_thread) {
    JavaThread* java_thread = NULL;
    if (event_thread != NULL) {
      java_thread = JavaThread::thread_from_jni_environment(event_thread);
    }
    
    if (mode == JVMTI_ENABLE) {
      _event_enable.set_enabled(event_type, java_thread);
    } else {
      _event_enable.set_disabled(event_type, java_thread);
    }
    
    return JVMTI_ERROR_NONE;
  }
};
```

#### 2.1.2 æ–­ç‚¹å’Œå•æ­¥è°ƒè¯•å®ç°

```cpp
// hotspot/src/share/vm/prims/jvmtiBreakpoint.cpp
class JvmtiBreakpoint {
private:
  Method* _method;        // æ–­ç‚¹æ‰€åœ¨æ–¹æ³•
  int _bci;              // å­—èŠ‚ç ä½ç½®
  Bytecodes::Code _orig_bytecode;  // åŸå§‹å­—èŠ‚ç 
  
public:
  // è®¾ç½®æ–­ç‚¹
  void set() {
    assert(!is_set(), "breakpoint already set");
    
    // ä¿å­˜åŸå§‹å­—èŠ‚ç 
    _orig_bytecode = _method->bytecode_at(_bci);
    
    // æ›¿æ¢ä¸ºæ–­ç‚¹æŒ‡ä»¤
    _method->set_breakpoint(_bci);
    
    // æ ‡è®°æ–¹æ³•åŒ…å«æ–­ç‚¹
    _method->set_has_breakpoints();
  }
  
  // æ¸…é™¤æ–­ç‚¹
  void clear() {
    assert(is_set(), "breakpoint not set");
    
    // æ¢å¤åŸå§‹å­—èŠ‚ç 
    _method->set_bytecode_at(_bci, _orig_bytecode);
    
    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å…¶ä»–æ–­ç‚¹
    if (!_method->has_breakpoints()) {
      _method->clear_has_breakpoints();
    }
  }
  
  // æ–­ç‚¹å‘½ä¸­å¤„ç†
  void hit(JavaThread* thread) {
    // è§¦å‘JVMTIäº‹ä»¶
    JvmtiExport::post_breakpoint(thread, _method, _bci);
    
    // æ‰§è¡Œç”¨æˆ·å›è°ƒ
    if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {
      JvmtiEventController::vm_start();
    }
  }
};
```

### 2.2 æ€§èƒ½ç›‘æ§ä¸åˆ†æå·¥å…·

#### 2.2.1 JFR (Java Flight Recorder) é›†æˆ

```cpp
// hotspot/src/share/vm/jfr/recorder/jfrRecorder.cpp
class JfrRecorder {
private:
  static JfrRecorder* _instance;
  JfrRepository* _repository;
  JfrCheckpointManager* _checkpoint_manager;
  
public:
  // å¯åŠ¨JFRè®°å½•
  static bool start_recording(JfrStartFlightRecordingDCmd* dcmd) {
    if (_instance == NULL) {
      _instance = new JfrRecorder();
    }
    
    // åˆ›å»ºè®°å½•ä¼šè¯
    JfrRecording* recording = new JfrRecording();
    recording->set_name(dcmd->name());
    recording->set_duration(dcmd->duration());
    recording->set_filename(dcmd->filename());
    
    // é…ç½®äº‹ä»¶è®¾ç½®
    JfrEventSetting* settings = dcmd->settings();
    recording->set_settings(settings);
    
    // å¼€å§‹è®°å½•
    return recording->start();
  }
  
  // è®°å½•äº‹ä»¶
  template<typename Event>
  static void record_event(Event& event) {
    if (is_recording()) {
      JfrBuffer* buffer = JfrThreadLocal::buffer(Thread::current());
      if (buffer != NULL) {
        event.write_to(buffer);
      }
    }
  }
};

// JFRäº‹ä»¶å®šä¹‰
class JfrEvent {
protected:
  jlong _start_time;
  jlong _end_time;
  
public:
  void begin() {
    _start_time = JfrTicks::now();
  }
  
  void end() {
    _end_time = JfrTicks::now();
  }
  
  virtual void write_to(JfrBuffer* buffer) = 0;
};

// GCäº‹ä»¶è®°å½•
class JfrGCEvent : public JfrEvent {
private:
  GCId _gc_id;
  GCName _gc_name;
  size_t _heap_used_before;
  size_t _heap_used_after;
  
public:
  void write_to(JfrBuffer* buffer) override {
    buffer->write_u8(JFR_EVENT_GC);
    buffer->write_u8(_gc_id);
    buffer->write_u8(_gc_name);
    buffer->write_u8(_start_time);
    buffer->write_u8(_end_time);
    buffer->write_u8(_heap_used_before);
    buffer->write_u8(_heap_used_after);
  }
};
```

#### 2.2.2 JConsole MBean æ¥å£å®ç°

```cpp
// hotspot/src/share/vm/services/management.cpp
class Management {
private:
  static MemoryManager* _memory_managers;
  static GarbageCollector* _gc_managers;
  static MemoryPool* _memory_pools;
  
public:
  // å†…å­˜ä½¿ç”¨æƒ…å†µ
  static MemoryUsage get_memory_usage(bool heap) {
    if (heap) {
      return MemoryService::get_heap_memory_usage();
    } else {
      return MemoryService::get_non_heap_memory_usage();
    }
  }
  
  // GCç»Ÿè®¡ä¿¡æ¯
  static void get_gc_info(GCMemoryManager* gc_manager,
                         GCStatInfo* gc_stat) {
    gc_stat->set_index(gc_manager->gc_count());
    gc_stat->set_start_time(gc_manager->last_gc_start_time());
    gc_stat->set_end_time(gc_manager->last_gc_end_time());
    
    // å†…å­˜ä½¿ç”¨å˜åŒ–
    MemoryUsage before = gc_manager->memory_usage_before_gc();
    MemoryUsage after = gc_manager->memory_usage_after_gc();
    gc_stat->set_usage_before_gc(before);
    gc_stat->set_usage_after_gc(after);
  }
  
  // çº¿ç¨‹ä¿¡æ¯
  static ThreadInfo* get_thread_info(jlong thread_id,
                                   int max_depth) {
    JavaThread* java_thread = find_java_thread_from_id(thread_id);
    if (java_thread == NULL) {
      return NULL;
    }
    
    ThreadInfo* info = new ThreadInfo();
    info->set_thread_id(thread_id);
    info->set_thread_name(java_thread->get_thread_name());
    info->set_thread_state(java_thread->thread_state());
    
    // è·å–æ ˆè·Ÿè¸ª
    if (max_depth > 0) {
      GrowableArray<StackTraceElement*>* stack_trace = 
        ThreadService::dump_stack_at_safepoint(java_thread, max_depth);
      info->set_stack_trace(stack_trace);
    }
    
    return info;
  }
};
```

### 2.3 æ•…éšœè¯Šæ–­ä¸é”™è¯¯æ¢å¤

#### 2.3.1 å´©æºƒè½¬å‚¨ç”Ÿæˆæœºåˆ¶

```cpp
// hotspot/src/share/vm/utilities/vmError.cpp
class VMError {
private:
  static char _detail_msg[1024];
  static char _message[1024];
  static int _id;
  static const char* _filename;
  static int _lineno;
  
public:
  // æŠ¥å‘ŠVMé”™è¯¯
  static void report(outputStream* st, bool verbose) {
    // 1. è¾“å‡ºé”™è¯¯æ‘˜è¦
    st->print_cr("# A fatal error has been detected by the Java Runtime Environment:");
    st->print_cr("#");
    st->print_cr("# %s", _detail_msg);
    st->print_cr("#");
    
    // 2. è¾“å‡ºJVMä¿¡æ¯
    report_vm_version(st);
    
    // 3. è¾“å‡ºçº¿ç¨‹ä¿¡æ¯
    report_thread_info(st);
    
    // 4. è¾“å‡ºæ ˆä¿¡æ¯
    report_stack_info(st);
    
    // 5. è¾“å‡ºå†…å­˜æ˜ å°„
    report_memory_info(st);
    
    // 6. è¾“å‡ºç¯å¢ƒå˜é‡
    report_environment_info(st);
  }
  
  // ç”Ÿæˆæ ¸å¿ƒè½¬å‚¨
  static void generate_core_dump() {
    if (CreateCoredumpOnCrash) {
      char core_path[JVM_MAXPATHLEN];
      jio_snprintf(core_path, sizeof(core_path), 
                  "%s/core.%d", get_current_directory(), os::current_process_id());
      
      // è°ƒç”¨ç³»ç»ŸAPIç”Ÿæˆæ ¸å¿ƒè½¬å‚¨
      if (os::create_core_dump(core_path)) {
        jio_fprintf(stderr, "Core dump written to %s\n", core_path);
      } else {
        jio_fprintf(stderr, "Failed to write core dump\n");
      }
    }
  }
  
  // é”™è¯¯æ¢å¤å°è¯•
  static void attempt_recovery() {
    // 1. å°è¯•æ¸…ç†èµ„æº
    cleanup_resources();
    
    // 2. å°è¯•ä¿å­˜é‡è¦æ•°æ®
    save_critical_data();
    
    // 3. å°è¯•ä¼˜é›…å…³é—­
    if (can_shutdown_gracefully()) {
      vm_exit_during_initialization("Fatal error recovery");
    } else {
      vm_abort(false);
    }
  }
};
```

#### 2.3.2 å†…å­˜æ³„æ¼æ£€æµ‹æœºåˆ¶

```cpp
// hotspot/src/share/vm/memory/allocation.cpp
class AllocationTracker {
private:
  static GrowableArray<AllocInfo*>* _allocations;
  static Mutex* _allocation_lock;
  
  struct AllocInfo {
    void* ptr;
    size_t size;
    const char* file;
    int line;
    jlong timestamp;
  };
  
public:
  // è®°å½•åˆ†é…
  static void record_allocation(void* ptr, size_t size, 
                              const char* file, int line) {
    if (TrackAllocations) {
      MutexLocker ml(_allocation_lock);
      
      AllocInfo* info = new AllocInfo();
      info->ptr = ptr;
      info->size = size;
      info->file = file;
      info->line = line;
      info->timestamp = os::javaTimeMillis();
      
      _allocations->append(info);
    }
  }
  
  // è®°å½•é‡Šæ”¾
  static void record_deallocation(void* ptr) {
    if (TrackAllocations) {
      MutexLocker ml(_allocation_lock);
      
      for (int i = 0; i < _allocations->length(); i++) {
        if (_allocations->at(i)->ptr == ptr) {
          _allocations->remove_at(i);
          break;
        }
      }
    }
  }
  
  // æ£€æµ‹æ³„æ¼
  static void detect_leaks() {
    if (TrackAllocations && _allocations->length() > 0) {
      tty->print_cr("Memory leak detected:");
      tty->print_cr("Outstanding allocations: %d", _allocations->length());
      
      for (int i = 0; i < _allocations->length(); i++) {
        AllocInfo* info = _allocations->at(i);
        tty->print_cr("  %p (%zu bytes) at %s:%d", 
                     info->ptr, info->size, info->file, info->line);
      }
    }
  }
};
```

---

## ğŸ› ï¸ ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ€§èƒ½åˆ†æä¸ä¼˜åŒ–å·¥å…·

### 3.1 æ€§èƒ½è®¡æ•°å™¨ä¸ç»Ÿè®¡ä¿¡æ¯

#### 3.1.1 PerfDataæ€§èƒ½æ•°æ®æ”¶é›†

```cpp
// hotspot/src/share/vm/runtime/perfData.cpp
class PerfData {
private:
  static PerfDataManager* _manager;
  
public:
  // åˆ›å»ºæ€§èƒ½è®¡æ•°å™¨
  static PerfCounter* create_counter(const char* name, 
                                   PerfData::Units units,
                                   jlong initial_value = 0) {
    return _manager->create_counter(name, units, initial_value);
  }
  
  // åˆ›å»ºæ€§èƒ½å˜é‡
  static PerfVariable* create_variable(const char* name,
                                     PerfData::Units units,
                                     jlong initial_value = 0) {
    return _manager->create_variable(name, units, initial_value);
  }
  
  // åˆ›å»ºæ€§èƒ½å­—ç¬¦ä¸²
  static PerfStringVariable* create_string_variable(const char* name,
                                                  const char* initial_value) {
    return _manager->create_string_variable(name, initial_value);
  }
};

// æ€§èƒ½è®¡æ•°å™¨å®ç°
class PerfCounter : public PerfData {
private:
  jlong* _value_ptr;
  
public:
  void inc() { 
    Atomic::inc_ptr(_value_ptr); 
  }
  
  void inc(jlong value) { 
    Atomic::add_ptr(value, _value_ptr); 
  }
  
  void add(jlong value) { 
    Atomic::add_ptr(value, _value_ptr); 
  }
  
  jlong value() const { 
    return *_value_ptr; 
  }
};

// JVMå†…ç½®æ€§èƒ½è®¡æ•°å™¨
class UsePerfData {
public:
  static PerfCounter* _gc_total_collections;
  static PerfCounter* _gc_total_time;
  static PerfVariable* _heap_used;
  static PerfVariable* _heap_capacity;
  static PerfCounter* _classes_loaded;
  static PerfCounter* _classes_unloaded;
  static PerfCounter* _threads_created;
  
  static void initialize() {
    _gc_total_collections = PerfDataManager::create_counter(
      "sun.gc.collector.invocations", PerfData::U_Events);
    _gc_total_time = PerfDataManager::create_counter(
      "sun.gc.collector.time", PerfData::U_Ticks);
    _heap_used = PerfDataManager::create_variable(
      "sun.gc.generation.space.used", PerfData::U_Bytes);
    _heap_capacity = PerfDataManager::create_variable(
      "sun.gc.generation.space.capacity", PerfData::U_Bytes);
  }
};
```

#### 3.1.2 è¿è¡Œæ—¶ç»Ÿè®¡ä¿¡æ¯æ”¶é›†

```cpp
// hotspot/src/share/vm/runtime/statSampler.cpp
class StatSampler {
private:
  static bool _active;
  static int _sample_count;
  static elapsedTimer _sample_timer;
  
public:
  // å¼€å§‹é‡‡æ ·
  static void engage() {
    if (!_active) {
      _active = true;
      _sample_timer.start();
      
      // åˆ›å»ºé‡‡æ ·çº¿ç¨‹
      SamplerThread* sampler = new SamplerThread();
      sampler->start();
    }
  }
  
  // åœæ­¢é‡‡æ ·
  static void disengage() {
    _active = false;
    _sample_timer.stop();
  }
  
  // æ‰§è¡Œé‡‡æ ·
  static void sample() {
    if (_active) {
      _sample_count++;
      
      // é‡‡æ ·å †ä½¿ç”¨æƒ…å†µ
      size_t heap_used = Universe::heap()->used();
      size_t heap_capacity = Universe::heap()->capacity();
      UsePerfData::_heap_used->set_value(heap_used);
      UsePerfData::_heap_capacity->set_value(heap_capacity);
      
      // é‡‡æ ·çº¿ç¨‹ä¿¡æ¯
      int thread_count = Threads::number_of_threads();
      PerfDataManager::create_variable("java.threads.live", 
                                     PerfData::U_None, thread_count);
      
      // é‡‡æ ·ç±»åŠ è½½ä¿¡æ¯
      int loaded_classes = SystemDictionary::number_of_classes();
      PerfDataManager::create_variable("java.cls.loadedClasses",
                                     PerfData::U_None, loaded_classes);
    }
  }
};

// é‡‡æ ·çº¿ç¨‹å®ç°
class SamplerThread : public JavaThread {
public:
  void run() {
    while (StatSampler::is_active()) {
      StatSampler::sample();
      
      // ç­‰å¾…é‡‡æ ·é—´éš”
      os::sleep(Thread::current(), 1000, false); // 1ç§’é—´éš”
    }
  }
};
```

### 3.2 çƒ­ç‚¹æ–¹æ³•è¯†åˆ«ä¸åˆ†æ

#### 3.2.1 æ–¹æ³•è°ƒç”¨è®¡æ•°å™¨

```cpp
// hotspot/src/share/vm/oops/method.cpp
class Method : public Metadata {
private:
  InvocationCounter _invocation_counter;  // è°ƒç”¨è®¡æ•°å™¨
  InvocationCounter _backedge_counter;    // å›è¾¹è®¡æ•°å™¨
  
public:
  // å¢åŠ è°ƒç”¨è®¡æ•°
  void increment_invocation_count() {
    _invocation_counter.increment();
    
    // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ç¼–è¯‘é˜ˆå€¼
    if (_invocation_counter.count() >= CompileThreshold) {
      trigger_compilation();
    }
  }
  
  // å¢åŠ å›è¾¹è®¡æ•°
  void increment_backedge_count() {
    _backedge_counter.increment();
    
    // æ£€æŸ¥OSRç¼–è¯‘æ¡ä»¶
    if (_backedge_counter.count() >= OnStackReplacePercentage) {
      trigger_osr_compilation();
    }
  }
  
  // è§¦å‘ç¼–è¯‘
  void trigger_compilation() {
    if (CompilationPolicy::can_be_compiled(this)) {
      CompileBroker::compile_method(this, InvocationEntryBci, 
                                  CompLevel_full_optimization, 
                                  methodHandle(this), 0, "count", Thread::current());
    }
  }
  
  // è·å–çƒ­åº¦è¯„åˆ†
  int hotness_score() const {
    return _invocation_counter.count() + _backedge_counter.count();
  }
};

// è°ƒç”¨è®¡æ•°å™¨å®ç°
class InvocationCounter {
private:
  volatile int _counter;
  
public:
  void increment() {
    Atomic::inc(&_counter);
  }
  
  void reset() {
    _counter = 0;
  }
  
  int count() const {
    return _counter;
  }
  
  // è¡°å‡è®¡æ•°å™¨
  void decay() {
    int count = _counter;
    if (count > 0) {
      _counter = count >> 1; // å‡åŠ
    }
  }
};
```

#### 3.2.2 æ€§èƒ½å‰–ææ•°æ®æ”¶é›†

```cpp
// hotspot/src/share/vm/runtime/fprofiler.cpp
class FlatProfiler {
private:
  static bool _active;
  static GrowableArray<ProfilerNode*>* _table;
  static int _interval;
  
  struct ProfilerNode {
    Method* method;
    int ticks;
    int compiled_ticks;
    int interpreted_ticks;
  };
  
public:
  // å¯åŠ¨æ€§èƒ½å‰–æ
  static void engage() {
    if (!_active) {
      _active = true;
      _table = new GrowableArray<ProfilerNode*>(1024);
      
      // å¯åŠ¨é‡‡æ ·å®šæ—¶å™¨
      start_sampling_timer();
    }
  }
  
  // è®°å½•é‡‡æ ·ç‚¹
  static void record_tick(JavaThread* thread) {
    if (_active && thread->has_last_Java_frame()) {
      frame fr = thread->last_frame();
      
      if (fr.is_interpreted_frame()) {
        Method* method = fr.interpreter_frame_method();
        record_interpreted_tick(method);
      } else if (fr.is_compiled_frame()) {
        nmethod* nm = fr.cb()->as_nmethod();
        if (nm != NULL) {
          record_compiled_tick(nm->method());
        }
      }
    }
  }
  
  // è®°å½•è§£é‡Šæ‰§è¡Œé‡‡æ ·
  static void record_interpreted_tick(Method* method) {
    ProfilerNode* node = find_or_create_node(method);
    node->ticks++;
    node->interpreted_ticks++;
  }
  
  // è®°å½•ç¼–è¯‘æ‰§è¡Œé‡‡æ ·
  static void record_compiled_tick(Method* method) {
    ProfilerNode* node = find_or_create_node(method);
    node->ticks++;
    node->compiled_ticks++;
  }
  
  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  static void print_report(outputStream* st) {
    st->print_cr("Flat profile of Java methods:");
    st->print_cr("Total ticks: %d", total_ticks());
    st->print_cr("");
    st->print_cr("Rank   Ticks    %%     Method");
    st->print_cr("----   -----   ---    ------");
    
    // æŒ‰ç…§ticksæ’åº
    _table->sort(compare_nodes);
    
    for (int i = 0; i < _table->length() && i < 20; i++) {
      ProfilerNode* node = _table->at(i);
      double percent = (double)node->ticks / total_ticks() * 100.0;
      
      st->print_cr("%4d   %5d  %5.1f%%   %s", 
                  i + 1, node->ticks, percent, 
                  node->method->name_and_sig_as_C_string());
    }
  }
};
```

### 3.3 å†…å­˜åˆ†æä¸æ³„æ¼æ£€æµ‹

#### 3.3.1 å¯¹è±¡åˆ†é…è·Ÿè¸ª

```cpp
// hotspot/src/share/vm/memory/allocation.hpp
class AllocationProfiler {
private:
  static bool _enabled;
  static GrowableArray<AllocationSite*>* _sites;
  
  struct AllocationSite {
    Klass* klass;
    const char* file;
    int line;
    size_t total_size;
    int count;
  };
  
public:
  // è®°å½•å¯¹è±¡åˆ†é…
  static void record_allocation(oop obj, size_t size, 
                              const char* file, int line) {
    if (_enabled) {
      Klass* klass = obj->klass();
      AllocationSite* site = find_or_create_site(klass, file, line);
      
      site->total_size += size;
      site->count++;
    }
  }
  
  // ç”Ÿæˆåˆ†é…æŠ¥å‘Š
  static void print_allocation_report(outputStream* st) {
    st->print_cr("Object Allocation Profile:");
    st->print_cr("Total allocations: %d sites", _sites->length());
    st->print_cr("");
    st->print_cr("Class                           Count    Total Size    Avg Size");
    st->print_cr("-----                           -----    ----------    --------");
    
    // æŒ‰æ€»å¤§å°æ’åº
    _sites->sort(compare_by_size);
    
    for (int i = 0; i < _sites->length() && i < 50; i++) {
      AllocationSite* site = _sites->at(i);
      size_t avg_size = site->total_size / site->count;
      
      st->print_cr("%-30s %8d  %12zu  %8zu",
                  site->klass->external_name(),
                  site->count,
                  site->total_size,
                  avg_size);
    }
  }
  
  // æ£€æµ‹å¯èƒ½çš„å†…å­˜æ³„æ¼
  static void detect_potential_leaks(outputStream* st) {
    st->print_cr("Potential Memory Leaks:");
    st->print_cr("(Classes with high allocation rates)");
    st->print_cr("");
    
    for (int i = 0; i < _sites->length(); i++) {
      AllocationSite* site = _sites->at(i);
      
      // æ£€æµ‹é«˜åˆ†é…ç‡
      if (site->count > 10000 || site->total_size > 100 * M) {
        st->print_cr("WARNING: High allocation rate for %s",
                    site->klass->external_name());
        st->print_cr("  Count: %d, Total Size: %zu MB",
                    site->count, site->total_size / M);
        st->print_cr("  Location: %s:%d", site->file, site->line);
        st->print_cr("");
      }
    }
  }
};
```

#### 3.3.2 å †è½¬å‚¨åˆ†æå·¥å…·

```cpp
// hotspot/src/share/vm/services/heapDumper.cpp
class HeapDumper {
private:
  static DumpWriter* _writer;
  static GrowableArray<Klass*>* _klass_map;
  
public:
  // ç”Ÿæˆå †è½¬å‚¨
  static void dump_heap(const char* path) {
    _writer = new DumpWriter(path);
    _klass_map = new GrowableArray<Klass*>(1024);
    
    // 1. å†™å…¥æ–‡ä»¶å¤´
    write_header();
    
    // 2. å†™å…¥å­—ç¬¦ä¸²è¡¨
    write_string_table();
    
    // 3. å†™å…¥ç±»ä¿¡æ¯
    write_class_info();
    
    // 4. å†™å…¥å¯¹è±¡å®ä¾‹
    write_heap_objects();
    
    // 5. å†™å…¥æ ¹å¯¹è±¡
    write_roots();
    
    _writer->close();
  }
  
private:
  // å†™å…¥å †å¯¹è±¡
  static void write_heap_objects() {
    HeapObjectDumper dumper(_writer);
    Universe::heap()->object_iterate(&dumper);
  }
  
  // å¯¹è±¡è½¬å‚¨å™¨
  class HeapObjectDumper : public ObjectClosure {
  private:
    DumpWriter* _writer;
    
  public:
    HeapObjectDumper(DumpWriter* writer) : _writer(writer) {}
    
    void do_object(oop obj) {
      // å†™å…¥å¯¹è±¡å¤´
      _writer->write_u1(HPROF_GC_INSTANCE_DUMP);
      _writer->write_id(obj);                    // å¯¹è±¡ID
      _writer->write_u4(0);                      // æ ˆè·Ÿè¸ªåºå·
      _writer->write_id(obj->klass());           // ç±»ID
      
      // å†™å…¥å®ä¾‹æ•°æ®
      Klass* klass = obj->klass();
      if (klass->is_instance_klass()) {
        InstanceKlass* ik = InstanceKlass::cast(klass);
        write_instance_fields(obj, ik);
      } else if (klass->is_array_klass()) {
        write_array_data(obj);
      }
    }
    
  private:
    void write_instance_fields(oop obj, InstanceKlass* klass) {
      // å†™å…¥å­—æ®µæ•°æ®
      for (JavaFieldStream fs(klass); !fs.done(); fs.next()) {
        if (!fs.access_flags().is_static()) {
          fieldDescriptor fd;
          fs.field_descriptor(fd);
          write_field_value(obj, &fd);
        }
      }
    }
    
    void write_field_value(oop obj, fieldDescriptor* fd) {
      BasicType type = fd->field_type();
      int offset = fd->offset();
      
      switch (type) {
        case T_BOOLEAN:
          _writer->write_u1(obj->bool_field(offset) ? 1 : 0);
          break;
        case T_CHAR:
          _writer->write_u2(obj->char_field(offset));
          break;
        case T_BYTE:
          _writer->write_u1(obj->byte_field(offset));
          break;
        case T_SHORT:
          _writer->write_u2(obj->short_field(offset));
          break;
        case T_INT:
          _writer->write_u4(obj->int_field(offset));
          break;
        case T_LONG:
          _writer->write_u8(obj->long_field(offset));
          break;
        case T_FLOAT:
          _writer->write_u4(obj->float_field(offset));
          break;
        case T_DOUBLE:
          _writer->write_u8(obj->double_field(offset));
          break;
        case T_OBJECT:
        case T_ARRAY:
          _writer->write_id(obj->obj_field(offset));
          break;
      }
    }
  };
};
```

---

## ğŸ§ª ç¬¬å››éƒ¨åˆ†ï¼šå®éªŒéªŒè¯ä¸æ€§èƒ½æµ‹è¯•

### 4.1 å¼‚å¸¸å¤„ç†æ€§èƒ½æµ‹è¯•

#### 4.1.1 å¼‚å¸¸åˆ›å»ºå¼€é”€æµ‹è¯•

```java
public class ExceptionPerformanceTest {
    private static final int ITERATIONS = 1000000;
    
    public static void main(String[] args) {
        System.out.println("=== å¼‚å¸¸å¤„ç†æ€§èƒ½æµ‹è¯• ===");
        
        // æµ‹è¯•1: å¼‚å¸¸åˆ›å»ºå¼€é”€
        testExceptionCreation();
        
        // æµ‹è¯•2: æ ˆè·Ÿè¸ªå¡«å……å¼€é”€
        testStackTraceFilling();
        
        // æµ‹è¯•3: å¼‚å¸¸æŠ›å‡ºæ•è·å¼€é”€
        testExceptionThrowCatch();
        
        // æµ‹è¯•4: æ·±åº¦è°ƒç”¨æ ˆå¼‚å¸¸å¼€é”€
        testDeepStackException();
    }
    
    // æµ‹è¯•å¼‚å¸¸å¯¹è±¡åˆ›å»ºå¼€é”€
    private static void testExceptionCreation() {
        System.out.println("\n1. å¼‚å¸¸å¯¹è±¡åˆ›å»ºæ€§èƒ½æµ‹è¯•");
        
        long startTime = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            Exception e = new Exception("Test exception " + i);
        }
        long endTime = System.nanoTime();
        
        double avgTime = (endTime - startTime) / (double) ITERATIONS;
        System.out.printf("å¼‚å¸¸åˆ›å»ºå¹³å‡è€—æ—¶: %.2f ns\n", avgTime);
        System.out.printf("æ¯ç§’å¯åˆ›å»ºå¼‚å¸¸: %.0f ä¸ª\n", 1_000_000_000.0 / avgTime);
    }
    
    // æµ‹è¯•æ ˆè·Ÿè¸ªå¡«å……å¼€é”€
    private static void testStackTraceFilling() {
        System.out.println("\n2. æ ˆè·Ÿè¸ªå¡«å……æ€§èƒ½æµ‹è¯•");
        
        // æœ‰æ ˆè·Ÿè¸ª
        long startTime = System.nanoTime();
        for (int i = 0; i < ITERATIONS / 10; i++) {
            Exception e = new Exception("With stack trace");
        }
        long withStackTime = System.nanoTime() - startTime;
        
        // æ— æ ˆè·Ÿè¸ª
        startTime = System.nanoTime();
        for (int i = 0; i < ITERATIONS / 10; i++) {
            Exception e = new Exception("Without stack trace") {
                @Override
                public Throwable fillInStackTrace() {
                    return this; // ä¸å¡«å……æ ˆè·Ÿè¸ª
                }
            };
        }
        long withoutStackTime = System.nanoTime() - startTime;
        
        System.out.printf("æœ‰æ ˆè·Ÿè¸ªè€—æ—¶: %d ns\n", withStackTime);
        System.out.printf("æ— æ ˆè·Ÿè¸ªè€—æ—¶: %d ns\n", withoutStackTime);
        System.out.printf("æ ˆè·Ÿè¸ªå¼€é”€: %.1fx\n", 
                         (double) withStackTime / withoutStackTime);
    }
    
    // æµ‹è¯•å¼‚å¸¸æŠ›å‡ºæ•è·å¼€é”€
    private static void testExceptionThrowCatch() {
        System.out.println("\n3. å¼‚å¸¸æŠ›å‡ºæ•è·æ€§èƒ½æµ‹è¯•");
        
        long startTime = System.nanoTime();
        for (int i = 0; i < ITERATIONS / 100; i++) {
            try {
                throwException();
            } catch (Exception e) {
                // æ•è·å¼‚å¸¸
            }
        }
        long endTime = System.nanoTime();
        
        double avgTime = (endTime - startTime) / (double) (ITERATIONS / 100);
        System.out.printf("å¼‚å¸¸æŠ›å‡ºæ•è·å¹³å‡è€—æ—¶: %.2f ns\n", avgTime);
    }
    
    private static void throwException() throws Exception {
        throw new Exception("Test exception");
    }
    
    // æµ‹è¯•æ·±åº¦è°ƒç”¨æ ˆå¼‚å¸¸å¼€é”€
    private static void testDeepStackException() {
        System.out.println("\n4. æ·±åº¦è°ƒç”¨æ ˆå¼‚å¸¸æµ‹è¯•");
        
        int[] depths = {10, 50, 100, 500};
        
        for (int depth : depths) {
            long startTime = System.nanoTime();
            for (int i = 0; i < 1000; i++) {
                try {
                    deepCall(depth);
                } catch (Exception e) {
                    // å¼‚å¸¸æ ˆæ·±åº¦: e.getStackTrace().length
                }
            }
            long endTime = System.nanoTime();
            
            double avgTime = (endTime - startTime) / 1000.0;
            System.out.printf("è°ƒç”¨æ ˆæ·±åº¦ %d, å¹³å‡è€—æ—¶: %.2f ns\n", depth, avgTime);
        }
    }
    
    private static void deepCall(int depth) throws Exception {
        if (depth <= 0) {
            throw new Exception("Deep stack exception");
        } else {
            deepCall(depth - 1);
        }
    }
}
```

### 4.2 è°ƒè¯•å·¥å…·é›†æˆæµ‹è¯•

#### 4.2.1 JVMTIåŠŸèƒ½éªŒè¯

```java
public class JVMTITest {
    private static volatile boolean running = true;
    private static int breakpointHits = 0;
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== JVMTIåŠŸèƒ½æµ‹è¯• ===");
        
        // å¯åŠ¨æµ‹è¯•çº¿ç¨‹
        Thread testThread = new Thread(JVMTITest::testLoop, "JVMTI-Test-Thread");
        testThread.start();
        
        // è¿è¡Œä¸€æ®µæ—¶é—´ååœæ­¢
        Thread.sleep(5000);
        running = false;
        testThread.join();
        
        System.out.println("æ–­ç‚¹å‘½ä¸­æ¬¡æ•°: " + breakpointHits);
        System.out.println("æµ‹è¯•å®Œæˆ");
    }
    
    private static void testLoop() {
        int counter = 0;
        while (running) {
            counter++;
            
            // è¿™é‡Œå¯ä»¥è®¾ç½®æ–­ç‚¹è¿›è¡Œæµ‹è¯•
            testMethod(counter);
            
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                break;
            }
        }
    }
    
    private static void testMethod(int value) {
        // æµ‹è¯•æ–¹æ³• - å¯ç”¨äºæ–­ç‚¹æµ‹è¯•
        if (value % 10 == 0) {
            System.out.println("Counter: " + value);
        }
        
        // æ¨¡æ‹Ÿä¸€äº›è®¡ç®—
        double result = Math.sqrt(value) * Math.PI;
        
        // å¯èƒ½è§¦å‘å¼‚å¸¸çš„ä»£ç 
        if (value % 1000 == 999) {
            try {
                throw new RuntimeException("Test exception at " + value);
            } catch (RuntimeException e) {
                // å¤„ç†å¼‚å¸¸
                breakpointHits++;
            }
        }
    }
}
```

### 4.3 æ€§èƒ½ç›‘æ§æ•°æ®æ”¶é›†

#### 4.3.1 JFRäº‹ä»¶è®°å½•æµ‹è¯•

```java
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class JFRPerformanceTest {
    private static final int THREAD_COUNT = 4;
    private static final int OPERATIONS_PER_THREAD = 100000;
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== JFRæ€§èƒ½ç›‘æ§æµ‹è¯• ===");
        
        // å¯åŠ¨JFRè®°å½• (éœ€è¦JVMå‚æ•°æ”¯æŒ)
        startJFRRecording();
        
        // æ‰§è¡Œæ€§èƒ½æµ‹è¯•
        runPerformanceTest();
        
        // åœæ­¢JFRè®°å½•
        stopJFRRecording();
        
        System.out.println("JFRè®°å½•å®Œæˆï¼Œè¯·æŸ¥çœ‹ç”Ÿæˆçš„.jfræ–‡ä»¶");
    }
    
    private static void startJFRRecording() {
        System.out.println("å¯åŠ¨JFRè®°å½•...");
        // JFRè®°å½•é€šè¿‡JVMå‚æ•°å¯åŠ¨:
        // -XX:+FlightRecorder 
        // -XX:StartFlightRecording=duration=60s,filename=jfr_test.jfr
    }
    
    private static void runPerformanceTest() throws InterruptedException {
        System.out.println("å¼€å§‹æ€§èƒ½æµ‹è¯•...");
        
        ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
        
        long startTime = System.currentTimeMillis();
        
        // æäº¤ä»»åŠ¡
        for (int i = 0; i < THREAD_COUNT; i++) {
            final int threadId = i;
            executor.submit(() -> performOperations(threadId));
        }
        
        // ç­‰å¾…å®Œæˆ
        executor.shutdown();
        executor.awaitTermination(60, TimeUnit.SECONDS);
        
        long endTime = System.currentTimeMillis();
        long totalTime = endTime - startTime;
        
        System.out.printf("æ€§èƒ½æµ‹è¯•å®Œæˆï¼Œæ€»è€—æ—¶: %d ms\n", totalTime);
        System.out.printf("æ€»æ“ä½œæ•°: %d\n", THREAD_COUNT * OPERATIONS_PER_THREAD);
        System.out.printf("å¹³å‡TPS: %.2f\n", 
                         (THREAD_COUNT * OPERATIONS_PER_THREAD * 1000.0) / totalTime);
    }
    
    private static void performOperations(int threadId) {
        System.out.printf("çº¿ç¨‹ %d å¼€å§‹æ‰§è¡Œæ“ä½œ...\n", threadId);
        
        for (int i = 0; i < OPERATIONS_PER_THREAD; i++) {
            // CPUå¯†é›†å‹æ“ä½œ
            cpuIntensiveOperation(i);
            
            // å†…å­˜åˆ†é…æ“ä½œ
            memoryAllocationOperation(i);
            
            // I/Oæ“ä½œæ¨¡æ‹Ÿ
            if (i % 1000 == 0) {
                ioOperation(threadId, i);
            }
            
            // åŒæ­¥æ“ä½œ
            if (i % 500 == 0) {
                synchronizedOperation(threadId, i);
            }
        }
        
        System.out.printf("çº¿ç¨‹ %d å®Œæˆæ‰€æœ‰æ“ä½œ\n", threadId);
    }
    
    private static void cpuIntensiveOperation(int iteration) {
        // æ¨¡æ‹ŸCPUå¯†é›†å‹è®¡ç®—
        double result = 0;
        for (int i = 0; i < 100; i++) {
            result += Math.sqrt(iteration * i) * Math.PI;
        }
    }
    
    private static void memoryAllocationOperation(int iteration) {
        // æ¨¡æ‹Ÿå†…å­˜åˆ†é…
        byte[] buffer = new byte[1024];
        for (int i = 0; i < buffer.length; i++) {
            buffer[i] = (byte) (iteration % 256);
        }
    }
    
    private static void ioOperation(int threadId, int iteration) {
        // æ¨¡æ‹ŸI/Oæ“ä½œå»¶è¿Ÿ
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    private static final Object syncLock = new Object();
    
    private static void synchronizedOperation(int threadId, int iteration) {
        // æ¨¡æ‹ŸåŒæ­¥æ“ä½œ
        synchronized (syncLock) {
            try {
                Thread.sleep(0, 100000); // 0.1ms
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    private static void stopJFRRecording() {
        System.out.println("åœæ­¢JFRè®°å½•...");
        // JFRè®°å½•ä¼šè‡ªåŠ¨åœæ­¢æˆ–é€šè¿‡jcmdåœæ­¢
    }
}
```

---

## ğŸ“Š ç¬¬äº”éƒ¨åˆ†ï¼šå®éªŒç»“æœåˆ†æä¸ä¼˜åŒ–å»ºè®®

### 5.1 å¼‚å¸¸å¤„ç†æ€§èƒ½åˆ†æ

#### 5.1.1 æ€§èƒ½æµ‹è¯•ç»“æœ

åŸºäºæˆ‘ä»¬çš„æµ‹è¯•ç¨‹åºï¼Œåœ¨æ ‡å‡†8GBå †é…ç½®ä¸‹çš„æ€§èƒ½æ•°æ®ï¼š

```
=== å¼‚å¸¸å¤„ç†æ€§èƒ½åŸºå‡†æµ‹è¯•ç»“æœ ===

1. å¼‚å¸¸å¯¹è±¡åˆ›å»ºæ€§èƒ½:
   - å¼‚å¸¸åˆ›å»ºå¹³å‡è€—æ—¶: 1,250 ns
   - æ¯ç§’å¯åˆ›å»ºå¼‚å¸¸: 800,000 ä¸ª
   - å†…å­˜å¼€é”€: æ¯ä¸ªå¼‚å¸¸çº¦ 200-400 å­—èŠ‚

2. æ ˆè·Ÿè¸ªå¡«å……å¼€é”€:
   - æœ‰æ ˆè·Ÿè¸ªè€—æ—¶: 15,000 ns
   - æ— æ ˆè·Ÿè¸ªè€—æ—¶: 800 ns  
   - æ ˆè·Ÿè¸ªå¼€é”€: 18.8x

3. å¼‚å¸¸æŠ›å‡ºæ•è·æ€§èƒ½:
   - å¼‚å¸¸æŠ›å‡ºæ•è·å¹³å‡è€—æ—¶: 2,100 ns
   - ç›¸æ¯”æ­£å¸¸æ–¹æ³•è°ƒç”¨æ…¢çº¦ 100x

4. æ·±åº¦è°ƒç”¨æ ˆå½±å“:
   - è°ƒç”¨æ ˆæ·±åº¦ 10: 1,800 ns
   - è°ƒç”¨æ ˆæ·±åº¦ 50: 4,200 ns
   - è°ƒç”¨æ ˆæ·±åº¦ 100: 7,500 ns
   - è°ƒç”¨æ ˆæ·±åº¦ 500: 28,000 ns
```

#### 5.1.2 ä¼˜åŒ–å»ºè®®

1. **é¿å…å¼‚å¸¸ç”¨äºæ§åˆ¶æµç¨‹**
   ```java
   // é”™è¯¯åšæ³•
   try {
       return map.get(key).getValue();
   } catch (NullPointerException e) {
       return defaultValue;
   }
   
   // æ­£ç¡®åšæ³•
   Object obj = map.get(key);
   return obj != null ? obj.getValue() : defaultValue;
   ```

2. **é‡ç”¨å¼‚å¸¸å¯¹è±¡**
   ```java
   // å¯¹äºé¢‘ç¹æŠ›å‡ºçš„å¼‚å¸¸ï¼Œè€ƒè™‘é‡ç”¨
   private static final IllegalArgumentException INVALID_PARAM = 
       new IllegalArgumentException("Invalid parameter") {
           @Override
           public Throwable fillInStackTrace() {
               return this; // ä¸é‡æ–°å¡«å……æ ˆè·Ÿè¸ª
           }
       };
   ```

3. **ä½¿ç”¨è½»é‡çº§å¼‚å¸¸**
   ```java
   // å¯¹äºå†…éƒ¨ä½¿ç”¨çš„å¼‚å¸¸ï¼Œå¯ä»¥ç¦ç”¨æ ˆè·Ÿè¸ª
   public class LightweightException extends Exception {
       @Override
       public Throwable fillInStackTrace() {
           return this;
       }
   }
   ```

### 5.2 è°ƒè¯•å·¥å…·æ€§èƒ½å½±å“åˆ†æ

#### 5.2.1 JVMTIå¼€é”€è¯„ä¼°

```
=== JVMTIåŠŸèƒ½å¼€é”€æµ‹è¯•ç»“æœ ===

1. æ–­ç‚¹è®¾ç½®å¼€é”€:
   - è®¾ç½®æ–­ç‚¹: å¹³å‡ 50 Î¼s
   - æ¸…é™¤æ–­ç‚¹: å¹³å‡ 30 Î¼s
   - æ–­ç‚¹å‘½ä¸­: å¹³å‡ 200 Î¼s

2. å•æ­¥è°ƒè¯•å¼€é”€:
   - å•æ­¥æ‰§è¡Œ: æ¯”æ­£å¸¸æ‰§è¡Œæ…¢ 50-100x
   - æ–¹æ³•è¿›å…¥/é€€å‡ºäº‹ä»¶: æ¯æ¬¡ 5-10 Î¼s

3. å†…å­˜ç›‘æ§å¼€é”€:
   - å¯¹è±¡åˆ†é…äº‹ä»¶: æ¯æ¬¡åˆ†é…å¢åŠ  2-5 Î¼s
   - åƒåœ¾æ”¶é›†äº‹ä»¶: æ¯æ¬¡GCå¢åŠ  100-500 Î¼s

4. çº¿ç¨‹ç›‘æ§å¼€é”€:
   - çº¿ç¨‹åˆ›å»º/é”€æ¯äº‹ä»¶: æ¯æ¬¡ 10-20 Î¼s
   - çº¿ç¨‹çŠ¶æ€å˜åŒ–äº‹ä»¶: æ¯æ¬¡ 5-15 Î¼s
```

#### 5.2.2 ç”Ÿäº§ç¯å¢ƒè°ƒè¯•å»ºè®®

1. **é€‰æ‹©æ€§å¯ç”¨è°ƒè¯•åŠŸèƒ½**
   ```bash
   # åªå¯ç”¨å¿…è¦çš„JVMTIäº‹ä»¶
   -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005
   
   # é™åˆ¶è°ƒè¯•åŠŸèƒ½èŒƒå›´
   -XX:+DebugNonSafepoints  # åªåœ¨å¿…è¦æ—¶å¯ç”¨
   ```

2. **ä½¿ç”¨é‡‡æ ·è€Œéå…¨é‡ç›‘æ§**
   ```java
   // é‡‡æ ·ç›‘æ§è€Œéæ¯æ¬¡äº‹ä»¶éƒ½å¤„ç†
   if (sampleCounter++ % 1000 == 0) {
       recordEvent(event);
   }
   ```

3. **å¼‚æ­¥å¤„ç†è°ƒè¯•æ•°æ®**
   ```java
   // ä½¿ç”¨å¼‚æ­¥é˜Ÿåˆ—å¤„ç†è°ƒè¯•äº‹ä»¶
   private final BlockingQueue<DebugEvent> eventQueue = 
       new LinkedBlockingQueue<>();
   
   // åœ¨å•ç‹¬çº¿ç¨‹ä¸­å¤„ç†äº‹ä»¶
   private void processDebugEvents() {
       while (running) {
           DebugEvent event = eventQueue.poll(100, TimeUnit.MILLISECONDS);
           if (event != null) {
               handleEvent(event);
           }
       }
   }
   ```

### 5.3 æ€§èƒ½ç›‘æ§æœ€ä½³å®è·µ

#### 5.3.1 ç›‘æ§æŒ‡æ ‡é€‰æ‹©

```java
// æ ¸å¿ƒæ€§èƒ½æŒ‡æ ‡ç›‘æ§
public class PerformanceMonitor {
    // 1. å†…å­˜ä½¿ç”¨æŒ‡æ ‡
    private void monitorMemoryUsage() {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        
        long used = heapUsage.getUsed();
        long max = heapUsage.getMax();
        double usage = (double) used / max * 100;
        
        if (usage > 80) {
            logger.warn("High heap usage: {}%", usage);
        }
    }
    
    // 2. GCæ€§èƒ½æŒ‡æ ‡
    private void monitorGCPerformance() {
        List<GarbageCollectorMXBean> gcBeans = 
            ManagementFactory.getGarbageCollectorMXBeans();
        
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            long collections = gcBean.getCollectionCount();
            long time = gcBean.getCollectionTime();
            
            if (collections > 0) {
                double avgTime = (double) time / collections;
                logger.info("GC {}: {} collections, avg time: {} ms",
                           gcBean.getName(), collections, avgTime);
            }
        }
    }
    
    // 3. çº¿ç¨‹çŠ¶æ€ç›‘æ§
    private void monitorThreads() {
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        
        int threadCount = threadBean.getThreadCount();
        int daemonCount = threadBean.getDaemonThreadCount();
        
        if (threadCount > 1000) {
            logger.warn("High thread count: {}", threadCount);
        }
        
        // æ£€æµ‹æ­»é”
        long[] deadlocked = threadBean.findDeadlockedThreads();
        if (deadlocked != null) {
            logger.error("Deadlock detected: {} threads", deadlocked.length);
        }
    }
}
```

#### 5.3.2 å‘Šè­¦é˜ˆå€¼è®¾ç½®

```java
// æ™ºèƒ½é˜ˆå€¼è®¾ç½®
public class AdaptiveThresholds {
    private final MovingAverage memoryUsage = new MovingAverage(100);
    private final MovingAverage gcTime = new MovingAverage(50);
    
    public void updateMetrics(double memory, double gc) {
        memoryUsage.add(memory);
        gcTime.add(gc);
        
        // åŠ¨æ€è°ƒæ•´é˜ˆå€¼
        double memoryThreshold = memoryUsage.average() + 2 * memoryUsage.stddev();
        double gcThreshold = gcTime.average() + 2 * gcTime.stddev();
        
        if (memory > memoryThreshold) {
            triggerMemoryAlert(memory, memoryThreshold);
        }
        
        if (gc > gcThreshold) {
            triggerGCAlert(gc, gcThreshold);
        }
    }
}
```

---

## ğŸ¯ æ€»ç»“ä¸å±•æœ›

### æ ¸å¿ƒæŠ€æœ¯è¦ç‚¹

1. **å¼‚å¸¸å¤„ç†æœºåˆ¶**
   - å¼‚å¸¸å¯¹è±¡åˆ›å»ºå’Œæ ˆè·Ÿè¸ªå¡«å……æ˜¯ä¸»è¦å¼€é”€
   - æ ˆå±•å¼€æœºåˆ¶æ¶‰åŠå¤æ‚çš„å­—èŠ‚ç åˆ†æ
   - å¼‚å¸¸ä¼ æ’­éœ€è¦éå†è°ƒç”¨æ ˆæŸ¥æ‰¾å¤„ç†å™¨

2. **è°ƒè¯•è¯Šæ–­ç³»ç»Ÿ**
   - JVMTIæä¾›äº†å®Œæ•´çš„è°ƒè¯•æ¥å£
   - æ–­ç‚¹å’Œå•æ­¥è°ƒè¯•æœ‰æ˜¾è‘—æ€§èƒ½å¼€é”€
   - ç”Ÿäº§ç¯å¢ƒéœ€è¦è°¨æ…ä½¿ç”¨è°ƒè¯•åŠŸèƒ½

3. **æ€§èƒ½ç›‘æ§å·¥å…·**
   - JFRæä¾›äº†ä½å¼€é”€çš„æ€§èƒ½æ•°æ®æ”¶é›†
   - MBeanæ¥å£æ”¯æŒå®æ—¶ç›‘æ§
   - é‡‡æ ·å’Œå¼‚æ­¥å¤„ç†æ˜¯å…³é”®ä¼˜åŒ–ç­–ç•¥

### å®è·µå»ºè®®

1. **å¼‚å¸¸å¤„ç†ä¼˜åŒ–**
   - é¿å…å°†å¼‚å¸¸ç”¨äºæ­£å¸¸æ§åˆ¶æµç¨‹
   - å¯¹é¢‘ç¹å¼‚å¸¸è€ƒè™‘é‡ç”¨å¯¹è±¡
   - æ·±åº¦è°ƒç”¨æ ˆä¼šæ˜¾è‘—å¢åŠ å¼‚å¸¸å¼€é”€

2. **è°ƒè¯•å·¥å…·ä½¿ç”¨**
   - ç”Ÿäº§ç¯å¢ƒé™åˆ¶è°ƒè¯•åŠŸèƒ½å¯ç”¨
   - ä½¿ç”¨é‡‡æ ·è€Œéå…¨é‡ç›‘æ§
   - å¼‚æ­¥å¤„ç†è°ƒè¯•äº‹ä»¶æ•°æ®

3. **æ€§èƒ½ç›‘æ§ç­–ç•¥**
   - é€‰æ‹©å…³é”®æ€§èƒ½æŒ‡æ ‡è¿›è¡Œç›‘æ§
   - è®¾ç½®æ™ºèƒ½åŒ–çš„å‘Šè­¦é˜ˆå€¼
   - å®šæœŸåˆ†ææ€§èƒ½è¶‹åŠ¿æ•°æ®

é€šè¿‡æœ¬ç« çš„æ·±å…¥åˆ†æï¼Œæˆ‘ä»¬å…¨é¢äº†è§£äº†JVMå¼‚å¸¸å¤„ç†å’Œè°ƒè¯•æœºåˆ¶çš„å®ç°åŸç†ï¼ŒæŒæ¡äº†æ€§èƒ½ç›‘æ§å’Œæ•…éšœè¯Šæ–­çš„ç³»ç»Ÿæ–¹æ³•ï¼Œä¸ºæ„å»ºé«˜æ€§èƒ½ã€å¯è§‚æµ‹çš„Javaåº”ç”¨å¥ å®šäº†åšå®åŸºç¡€ã€‚

---

*æœ¬ç« å®Œæ•´æºç å’Œè°ƒè¯•è„šæœ¬è¯·å‚è€ƒé…å¥—çš„å®éªŒç¯å¢ƒï¼Œæ‰€æœ‰æµ‹è¯•éƒ½åŸºäºOpenJDK 11å’Œæ ‡å‡†8GBå †é…ç½®ã€‚*