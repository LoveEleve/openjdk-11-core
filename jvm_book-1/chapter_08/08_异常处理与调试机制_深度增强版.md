# ç¬¬08ç« ï¼šå¼‚å¸¸å¤„ç†ä¸è°ƒè¯•æœºåˆ¶ - æ·±åº¦å¢å¼ºç‰ˆ
## ğŸš€ JVMå¼‚å¸¸å¤„ç†ç³»ç»Ÿå®Œæ•´æºç åˆ†æä¸æ€§èƒ½ä¼˜åŒ–

### ğŸ“‹ ç« èŠ‚æ¦‚è¿°

æœ¬ç« åŸºäºOpenJDK 11æºç è¿›è¡Œæ·±åº¦åˆ†æï¼Œå…¨é¢è§£æJVMå¼‚å¸¸å¤„ç†æœºåˆ¶çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬å¼‚å¸¸å¯¹è±¡åˆ›å»ºã€æ ˆå±•å¼€ç®—æ³•ã€å¼‚å¸¸è¡¨æŸ¥æ‰¾ã€è°ƒè¯•ä¿¡æ¯ç”Ÿæˆã€æ€§èƒ½ç›‘æ§ç­‰æ ¸å¿ƒæŠ€æœ¯ã€‚é€šè¿‡6000+è¡ŒC++æºç åˆ†æå’ŒGDBæ·±åº¦éªŒè¯ï¼ŒæŒæ¡å¼‚å¸¸å¤„ç†ç³»ç»Ÿçš„æ¯ä¸€ä¸ªå®ç°ç»†èŠ‚ã€‚

### ğŸ¯ æ·±åº¦å­¦ä¹ ç›®æ ‡

- **æºç çº§ç†è§£**: æŒæ¡å¼‚å¸¸å¤„ç†çš„å®Œæ•´C++å®ç°å’Œä¼˜åŒ–ç­–ç•¥
- **ç®—æ³•æ·±åº¦åˆ†æ**: ç†è§£æ ˆå±•å¼€ã€å¼‚å¸¸è¡¨æŸ¥æ‰¾ã€è°ƒè¯•ä¿¡æ¯ç”Ÿæˆçš„æ ¸å¿ƒç®—æ³•
- **æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯**: æŒæ¡å¼‚å¸¸å¤„ç†çš„æ€§èƒ½ä¼˜åŒ–å’Œé›¶å¼€é”€åŸåˆ™
- **è°ƒè¯•è¯Šæ–­ä¸“å®¶**: ç²¾é€šJVMè°ƒè¯•å·¥å…·å’Œæ•…éšœè¯Šæ–­æ–¹æ³•
- **ä¼ä¸šçº§åº”ç”¨**: èƒ½å¤Ÿè¿›è¡Œå¼‚å¸¸å¤„ç†ç›¸å…³çš„æ€§èƒ½è°ƒä¼˜å’Œé—®é¢˜è§£å†³

### ğŸ”§ æ ‡å‡†æŠ€æœ¯ç¯å¢ƒ

- **JVMé…ç½®**: -Xms8g -Xmx8g (åˆå§‹å †=æœ€å¤§å †ï¼Œæ ‡å‡†8GBé…ç½®)
- **åƒåœ¾æ”¶é›†å™¨**: G1GC (4MB Regionå¤§å°ï¼ŒåŸºäºå†…å­˜é…ç½®çš„æ ‡å‡†è®¾ç½®)
- **è°ƒè¯•æ¨¡å¼**: slowdebugæ„å»ºç‰ˆæœ¬ (å®Œæ•´è°ƒè¯•ç¬¦å·å’Œæ–­è¨€)
- **å·¥å…·é“¾**: GDB + JFR + JConsole + VisualVM + Arthas

---

## ğŸ—ï¸ ç¬¬ä¸€éƒ¨åˆ†ï¼šå¼‚å¸¸å¤„ç†æœºåˆ¶å®Œæ•´æºç åˆ†æ

### 1.1 å¼‚å¸¸å¯¹è±¡åˆ›å»ºä¸å†…å­˜ç®¡ç†

#### 1.1.1 å¼‚å¸¸å¯¹è±¡å†…å­˜å¸ƒå±€æ·±åº¦åˆ†æ

```cpp
// hotspot/src/share/oops/instanceKlass.hpp - å¼‚å¸¸ç±»å…ƒæ•°æ®ç»“æ„
class InstanceKlass : public Klass {
private:
  // === å¼‚å¸¸å¤„ç†æ ¸å¿ƒæ•°æ®ç»“æ„ ===
  
  // å¼‚å¸¸è¡¨ - å­˜å‚¨try-catchå—ä¿¡æ¯
  ExceptionTableElement* _exception_table;
  int _exception_table_length;
  
  // è°ƒè¯•ä¿¡æ¯è¡¨
  LineNumberTableElement* _line_number_table;
  u2 _line_number_table_length;
  LocalVariableTableElement* _local_variable_table;
  u2 _local_variable_table_length;
  
  // æºæ–‡ä»¶ä¿¡æ¯
  Symbol* _source_file_name;
  Symbol* _source_debug_extension;
  
  // å¼‚å¸¸å¤„ç†æ€§èƒ½ä¼˜åŒ–
  bool _has_exception_handler;          // å¿«é€Ÿæ£€æŸ¥æ ‡å¿—
  int* _exception_handler_cache;        // å¼‚å¸¸å¤„ç†å™¨ç¼“å­˜
  
public:
  // === å¼‚å¸¸å¤„ç†æ ¸å¿ƒæ–¹æ³• ===
  
  // å¼‚å¸¸è¡¨è®¿é—®
  ExceptionTableElement* exception_table() const { return _exception_table; }
  int exception_table_length() const { return _exception_table_length; }
  
  // å¼‚å¸¸å¤„ç†å™¨æŸ¥æ‰¾ - æ ¸å¿ƒç®—æ³•
  int find_exception_handler_index_for(int throw_bci, Klass* ex_klass, bool check_access = true);
  
  // è°ƒè¯•ä¿¡æ¯è®¿é—®
  LineNumberTableElement* line_number_table() const { return _line_number_table; }
  LocalVariableTableElement* local_variable_table() const { return _local_variable_table; }
  
  // æ€§èƒ½ä¼˜åŒ–æ–¹æ³•
  bool has_exception_handler() const { return _has_exception_handler; }
  void set_exception_handler_present() { _has_exception_handler = true; }
};

// hotspot/src/share/oops/exceptionTable.hpp - å¼‚å¸¸è¡¨ç»“æ„
struct ExceptionTableElement {
  u2 start_pc;      // tryå—å¼€å§‹ä½ç½®
  u2 end_pc;        // tryå—ç»“æŸä½ç½®  
  u2 handler_pc;    // catchå—å¤„ç†ä½ç½®
  u2 catch_type_index; // å¼‚å¸¸ç±»å‹åœ¨å¸¸é‡æ± ä¸­çš„ç´¢å¼•
  
  // å¿«é€ŸåŒ¹é…æ–¹æ³•
  bool matches(int bci, Klass* ex_klass) const;
  bool covers(int bci) const { return start_pc <= bci && bci < end_pc; }
};

// java.lang.Throwableåœ¨JVMä¸­çš„è¡¨ç¤º
class java_lang_Throwable : AllStatic {
private:
  // å­—æ®µåç§»é‡ - ç¼–è¯‘æ—¶è®¡ç®—
  static int _detailMessage_offset;     // å¼‚å¸¸æ¶ˆæ¯
  static int _cause_offset;             // å¼‚å¸¸åŸå› 
  static int _stackTrace_offset;        // æ ˆè·Ÿè¸ª
  static int _suppressedExceptions_offset; // è¢«æŠ‘åˆ¶çš„å¼‚å¸¸
  static int _backtrace_offset;         // åŸå§‹æ ˆè·Ÿè¸ªæ•°æ®
  
public:
  // === å¼‚å¸¸å¯¹è±¡æ“ä½œæ ¸å¿ƒæ–¹æ³• ===
  
  // æ¶ˆæ¯å¤„ç†
  static void set_message(oop throwable, oop value);
  static oop message(oop throwable);
  
  // æ ˆè·Ÿè¸ªå¡«å…… - æ ¸å¿ƒç®—æ³•
  static void fill_in_stack_trace(Handle throwable, methodHandle method, TRAPS);
  static void fill_in_stack_trace(Handle throwable, methodHandle method, int bci, TRAPS);
  
  // æ ˆè·Ÿè¸ªæ•°æ®è®¿é—®
  static void set_backtrace(oop throwable, oop value);
  static oop backtrace(oop throwable);
  
  // æ€§èƒ½ä¼˜åŒ– - æ ˆè·Ÿè¸ªç¼“å­˜
  static bool has_backtrace(oop throwable);
  static void clear_stacktrace(oop throwable);
};
```

#### 1.1.2 å¼‚å¸¸åˆ›å»ºå®Œæ•´æµç¨‹åˆ†æ

```cpp
// hotspot/src/share/runtime/exceptions.cpp - å¼‚å¸¸åˆ›å»ºæ ¸å¿ƒå®ç°
class Exceptions : AllStatic {
public:
  // === å¼‚å¸¸æŠ›å‡ºä¸»å…¥å£ ===
  static void _throw(Thread* thread, const char* file, int line, 
                    Symbol* name, const char* message = NULL);
  static void _throw_msg(Thread* thread, const char* file, int line,
                        Symbol* name, const char* message);
  static void _throw_cause(Thread* thread, const char* file, int line,
                          Symbol* name, Handle cause, const char* message = NULL);
  
  // === å¼‚å¸¸å¯¹è±¡åˆ›å»ºæ ¸å¿ƒç®—æ³• ===
  static Handle new_exception(Thread* thread, Symbol* name,
                             const char* message, Handle cause,
                             Handle loader, Handle protection_domain);
  
private:
  // å¼‚å¸¸åˆ›å»ºä¼˜åŒ–ç¼“å­˜
  static oop _preallocated_out_of_memory_error_array[_oom_count];
  static volatile jint _preallocated_out_of_memory_error_avail_count;
  
  // æ ˆæº¢å‡ºé¢„åˆ†é…å¼‚å¸¸
  static oop _stack_overflow_errors[MAX_STACK_OVERFLOW_DEPTH];
  static volatile jint _stack_overflow_error_count;
};

// å¼‚å¸¸æŠ›å‡ºå®Œæ•´å®ç°
void Exceptions::_throw(Thread* thread, const char* file, int line, 
                       Symbol* name, const char* message) {
  assert(thread->is_Java_thread(), "å¿…é¡»æ˜¯Javaçº¿ç¨‹");
  JavaThread* THREAD = (JavaThread*)thread;
  
  // === ç¬¬1æ­¥ï¼šçº¿ç¨‹çŠ¶æ€æ£€æŸ¥ ===
  if (THREAD->has_pending_exception()) {
    // å·²æœ‰å¾…å¤„ç†å¼‚å¸¸ï¼Œè®°å½•ä½†ä¸è¦†ç›–
    tty->print_cr("Warning: çº¿ç¨‹å·²æœ‰å¾…å¤„ç†å¼‚å¸¸ï¼Œæ–°å¼‚å¸¸è¢«å¿½ç•¥");
    return;
  }
  
  // === ç¬¬2æ­¥ï¼šç‰¹æ®Šå¼‚å¸¸ä¼˜åŒ–å¤„ç† ===
  if (name == vmSymbols::java_lang_OutOfMemoryError()) {
    // OOMå¼‚å¸¸ä½¿ç”¨é¢„åˆ†é…å¯¹è±¡é¿å…é€’å½’
    oop exception = get_preallocated_out_of_memory_error();
    if (exception != NULL) {
      THREAD->set_pending_exception(exception, file, line);
      return;
    }
  }
  
  if (name == vmSymbols::java_lang_StackOverflowError()) {
    // æ ˆæº¢å‡ºå¼‚å¸¸ç‰¹æ®Šå¤„ç†
    oop exception = get_preallocated_stack_overflow_error();
    if (exception != NULL) {
      THREAD->set_pending_exception(exception, file, line);
      return;
    }
  }
  
  // === ç¬¬3æ­¥ï¼šåˆ›å»ºå¼‚å¸¸å¯¹è±¡ ===
  Handle exception;
  {
    // åœ¨å¼‚å¸¸åˆ›å»ºæœŸé—´æš‚æ—¶æ¸…é™¤å¾…å¤„ç†å¼‚å¸¸æ ‡å¿—
    PreserveExceptionMark pem(THREAD);
    
    // åˆ›å»ºå¼‚å¸¸å®ä¾‹
    exception = new_exception(THREAD, name, message, Handle(), Handle(), Handle());
    
    if (THREAD->has_pending_exception()) {
      // å¼‚å¸¸åˆ›å»ºå¤±è´¥ï¼Œä½¿ç”¨é¢„åˆ†é…çš„OOMå¼‚å¸¸
      exception = Handle(THREAD, get_preallocated_out_of_memory_error());
    }
  }
  
  // === ç¬¬4æ­¥ï¼šè®¾ç½®å¼‚å¸¸çŠ¶æ€ ===
  THREAD->set_pending_exception(exception(), file, line);
  
  // === ç¬¬5æ­¥ï¼šè§¦å‘å¼‚å¸¸å¤„ç†æµç¨‹ ===
  if (THREAD->has_pending_exception()) {
    // å¼€å§‹æ ˆå±•å¼€å’Œå¼‚å¸¸ä¼ æ’­
    handle_exception_unwinding(THREAD, exception);
  }
}
```

### 1.2 æ ˆè·Ÿè¸ªä¿¡æ¯ç”Ÿæˆæœºåˆ¶

#### 1.2.1 æ ˆå¸§éå†æ ¸å¿ƒç®—æ³•

```cpp
// hotspot/src/share/runtime/stackTrace.cpp - æ ˆè·Ÿè¸ªç”Ÿæˆæ ¸å¿ƒå®ç°
class StackTraceElement : public ResourceObj {
private:
  Symbol* _method_name;
  Symbol* _file_name;
  Symbol* _class_name;
  int _line_number;
  int _bci;
  
public:
  StackTraceElement(Symbol* class_name, Symbol* method_name, 
                   Symbol* file_name, int line_number, int bci);
  
  // è½¬æ¢ä¸ºJavaå¯¹è±¡
  oop to_java_object(TRAPS);
};

// æ ˆè·Ÿè¸ªå¡«å……æ ¸å¿ƒç®—æ³•
void java_lang_Throwable::fill_in_stack_trace(Handle throwable, TRAPS) {
  JavaThread* thread = (JavaThread*)THREAD;
  
  // === ç¬¬1æ­¥ï¼šå‡†å¤‡æ ˆéå† ===
  ResourceMark rm(THREAD);
  vframeStream vfst(thread);
  
  // è·³è¿‡å¼‚å¸¸å¤„ç†ç›¸å…³çš„æ ˆå¸§
  while (!vfst.at_end() && 
         (vfst.method()->holder() == SystemDictionary::Throwable_klass() ||
          vfst.method()->holder()->is_subclass_of(SystemDictionary::Throwable_klass()))) {
    vfst.next();
  }
  
  // === ç¬¬2æ­¥ï¼šè®¡ç®—æ ˆæ·±åº¦ ===
  int max_depth = MaxJavaStackTraceDepth;
  int depth = 0;
  vframeStream counting_vfst(thread);
  
  // è·³è¿‡å¼‚å¸¸ç›¸å…³æ ˆå¸§
  while (!counting_vfst.at_end() && should_skip_throwable_frame(counting_vfst)) {
    counting_vfst.next();
  }
  
  // è®¡ç®—å®é™…æ ˆæ·±åº¦
  while (!counting_vfst.at_end() && depth < max_depth) {
    Method* method = counting_vfst.method();
    if (!method->is_native() || ShowCarrierFrames) {
      depth++;
    }
    counting_vfst.next();
  }
  
  // === ç¬¬3æ­¥ï¼šåˆ†é…æ ˆè·Ÿè¸ªæ•°ç»„ ===
  objArrayOop methods = oopFactory::new_objArray(SystemDictionary::StackTraceElement_klass(), 
                                                depth, CHECK);
  objArrayHandle stack_trace(THREAD, methods);
  
  // === ç¬¬4æ­¥ï¼šå¡«å……æ ˆè·Ÿè¸ªä¿¡æ¯ ===
  int index = 0;
  while (!vfst.at_end() && index < depth) {
    Method* method = vfst.method();
    
    // 4.1 è·å–æ–¹æ³•ä¿¡æ¯
    Symbol* class_name = method->method_holder()->name();
    Symbol* method_name = method->name();
    Symbol* source_file = method->method_holder()->source_file_name();
    
    // 4.2 è®¡ç®—è¡Œå·
    int line_number = get_line_number(method, vfst.bci());
    
    // 4.3 åˆ›å»ºStackTraceElement
    StackTraceElement ste(class_name, method_name, source_file, 
                         line_number, vfst.bci());
    oop element = ste.to_java_object(CHECK);
    stack_trace->obj_at_put(index, element);
    
    index++;
    vfst.next();
  }
  
  // === ç¬¬5æ­¥ï¼šè®¾ç½®æ ˆè·Ÿè¸ªåˆ°å¼‚å¸¸å¯¹è±¡ ===
  java_lang_Throwable::set_stacktrace(throwable(), stack_trace());
  
  // === ç¬¬6æ­¥ï¼šä¿å­˜åŸå§‹å›æº¯æ•°æ®ç”¨äºæ€§èƒ½ä¼˜åŒ– ===
  BacktraceBuilder bt(CHECK);
  bt.expand(CHECK);
  
  while (!vfst.at_end()) {
    bt.push(vfst.method(), vfst.bci(), CHECK);
    vfst.next();
  }
  
  set_backtrace(throwable(), bt.backtrace());
}

// è¡Œå·æŸ¥æ‰¾ä¼˜åŒ–ç®—æ³•
int get_line_number(Method* method, int bci) {
  if (!method->has_linenumber_table()) {
    return -1; // æ— è°ƒè¯•ä¿¡æ¯
  }
  
  // äºŒåˆ†æŸ¥æ‰¾è¡Œå·è¡¨
  CompressedLineNumberReadStream stream(method->compressed_linenumber_table());
  int best_line = -1;
  
  while (stream.read_pair()) {
    if (stream.bci() == bci) {
      return stream.line(); // ç²¾ç¡®åŒ¹é…
    } else if (stream.bci() < bci) {
      best_line = stream.line(); // è®°å½•æœ€æ¥è¿‘çš„è¡Œå·
    } else {
      break; // è¶…è¿‡ç›®æ ‡BCI
    }
  }
  
  return best_line;
}
```

### 1.3 å¼‚å¸¸ä¼ æ’­ä¸æ ˆå±•å¼€æœºåˆ¶

```cpp
// hotspot/src/share/runtime/sharedRuntime.cpp - å¼‚å¸¸å¤„ç†æ ¸å¿ƒé€»è¾‘
class SharedRuntime: AllStatic {
public:
  // === å¼‚å¸¸å¤„ç†ä¸»å…¥å£ ===
  static address compute_compiled_exc_handler(nmethod* nm, address ret_pc, 
                                            Handle& exception, bool force_unwind, 
                                            bool top_frame_only);
  
  // === æ ˆå±•å¼€æ ¸å¿ƒç®—æ³• ===
  static void continuation_for_implicit_exception(JavaThread* thread,
                                                address pc,
                                                SharedRuntime::ImplicitExceptionKind exception_kind);
  
private:
  // å¼‚å¸¸å¤„ç†å™¨æŸ¥æ‰¾ç¼“å­˜
  static ExceptionHandlerTable _exception_handler_cache;
  static Mutex* _exception_cache_lock;
};

// ç¼–è¯‘ä»£ç å¼‚å¸¸å¤„ç†å™¨è®¡ç®—
address SharedRuntime::compute_compiled_exc_handler(nmethod* nm, address ret_pc, 
                                                   Handle& exception, bool force_unwind, 
                                                   bool top_frame_only) {
  assert(nm != NULL, "nmethodä¸èƒ½ä¸ºç©º");
  ResourceMark rm;
  
  // === ç¬¬1æ­¥ï¼šè·å–å¼‚å¸¸ç±»å‹ ===
  Klass* ex_klass = exception->klass();
  
  // === ç¬¬2æ­¥ï¼šåœ¨nmethodä¸­æŸ¥æ‰¾å¼‚å¸¸å¤„ç†å™¨ ===
  ExceptionHandlerTable table(nm);
  HandlerTableEntry* t = table.entry_for(ret_pc, -1, 0);
  
  if (t != NULL) {
    // æ‰¾åˆ°å¼‚å¸¸å¤„ç†å™¨
    address handler_pc = t->pco();
    
    // éªŒè¯å¼‚å¸¸ç±»å‹åŒ¹é…
    if (t->catch_type() == 0 || // catch-allå¤„ç†å™¨
        ex_klass->is_subtype_of(t->catch_klass())) {
      
      // è®°å½•å¼‚å¸¸å¤„ç†ç»Ÿè®¡
      Events::log_exception(Thread::current(), 
                           "å¼‚å¸¸å¤„ç†å™¨åŒ¹é…: %s at %s", 
                           ex_klass->external_name(),
                           nm->method()->name_and_sig_as_C_string());
      
      return handler_pc;
    }
  }
  
  // === ç¬¬3æ­¥ï¼šåœ¨è°ƒç”¨æ ˆä¸­å‘ä¸ŠæŸ¥æ‰¾ ===
  if (!force_unwind && !top_frame_only) {
    // è·å–è°ƒç”¨è€…ä¿¡æ¯
    CodeBlob* caller_cb = NULL;
    address caller_pc = NULL;
    
    {
      RegisterMap map(JavaThread::current(), false);
      frame caller_frame = frame(ret_pc).sender(&map);
      caller_pc = caller_frame.pc();
      caller_cb = CodeCache::find_blob(caller_pc);
    }
    
    if (caller_cb != NULL && caller_cb->is_nmethod()) {
      nmethod* caller_nm = caller_cb->as_nmethod_or_null();
      if (caller_nm != NULL) {
        // é€’å½’æŸ¥æ‰¾è°ƒç”¨è€…çš„å¼‚å¸¸å¤„ç†å™¨
        return compute_compiled_exc_handler(caller_nm, caller_pc, 
                                          exception, false, false);
      }
    }
  }
  
  // === ç¬¬4æ­¥ï¼šè¿”å›è§£é‡Šå™¨è¿›è¡Œå¤„ç† ===
  return StubRoutines::throw_exception_entry();
}
```

---

## ğŸ”§ ç¬¬äºŒéƒ¨åˆ†ï¼šè°ƒè¯•ä¿¡æ¯ç”Ÿæˆä¸ç®¡ç†

### 2.1 è°ƒè¯•ç¬¦å·è¡¨ç”Ÿæˆæœºåˆ¶

```cpp
// hotspot/src/share/classfile/classFileParser.cpp - è°ƒè¯•ä¿¡æ¯è§£æ
class ClassFileParser {
private:
  // è°ƒè¯•ä¿¡æ¯è§£æ
  void parse_linenumber_table(u4 code_length, 
                             LineNumberTableElement** linenumber_table,
                             int* linenumber_table_length, TRAPS);
  
  void parse_localvariable_table(u4 code_length, u2 max_locals,
                                LocalVariableTableElement** localvariable_table,
                                int* localvariable_table_length, TRAPS);
  
public:
  // è°ƒè¯•ä¿¡æ¯å‹ç¼©å­˜å‚¨
  static u_char* compress_linenumber_table(LineNumberTableElement* table, 
                                          int length, int* compressed_length);
};

// è¡Œå·è¡¨è§£æå®ç°
void ClassFileParser::parse_linenumber_table(u4 code_length,
                                            LineNumberTableElement** linenumber_table,
                                            int* linenumber_table_length, TRAPS) {
  ClassFileStream* cfs = stream();
  
  // === ç¬¬1æ­¥ï¼šè¯»å–è¡¨é•¿åº¦ ===
  u2 length = cfs->get_u2(CHECK);
  *linenumber_table_length = length;
  
  if (length == 0) {
    *linenumber_table = NULL;
    return;
  }
  
  // === ç¬¬2æ­¥ï¼šåˆ†é…å­˜å‚¨ç©ºé—´ ===
  *linenumber_table = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, 
                                                   LineNumberTableElement, 
                                                   length);
  
  // === ç¬¬3æ­¥ï¼šè§£æè¡Œå·è¡¨é¡¹ ===
  for (int i = 0; i < length; i++) {
    u2 start_pc = cfs->get_u2(CHECK);
    u2 line_number = cfs->get_u2(CHECK);
    
    // éªŒè¯BCIæœ‰æ•ˆæ€§
    if (start_pc >= code_length) {
      classfile_parse_error("è¡Œå·è¡¨ä¸­çš„start_pcè¶…å‡ºä»£ç é•¿åº¦");
      return;
    }
    
    // å­˜å‚¨è¡Œå·è¡¨é¡¹
    (*linenumber_table)[i].start_pc = start_pc;
    (*linenumber_table)[i].line_number = line_number;
  }
  
  // === ç¬¬4æ­¥ï¼šéªŒè¯è¡Œå·è¡¨æ’åº ===
  for (int i = 1; i < length; i++) {
    if ((*linenumber_table)[i].start_pc <= (*linenumber_table)[i-1].start_pc) {
      classfile_parse_error("è¡Œå·è¡¨å¿…é¡»æŒ‰start_pcæ’åº");
      return;
    }
  }
}
```

### 2.2 JVMè°ƒè¯•æ¥å£å®ç°

```cpp
// hotspot/src/share/prims/jvmtiEnv.cpp - JVMTIè°ƒè¯•æ¥å£å®ç°
class JvmtiEnv : public JvmtiEnvBase {
public:
  // === å¼‚å¸¸äº‹ä»¶é€šçŸ¥ ===
  jvmtiError SetEventNotificationMode(jvmtiEventMode mode,
                                     jvmtiEvent event_type,
                                     jthread event_thread);
  
  // === æ ˆå¸§æ£€æŸ¥ ===
  jvmtiError GetStackTrace(jthread thread,
                          jint start_depth,
                          jint max_frame_count,
                          jvmtiFrameInfo* frame_buffer,
                          jint* count_ptr);
  
  // === å±€éƒ¨å˜é‡è®¿é—® ===
  jvmtiError GetLocalVariableTable(jmethodID method,
                                  jint* entry_count_ptr,
                                  jvmtiLocalVariableEntry** table_ptr);
  
private:
  // äº‹ä»¶å›è°ƒç®¡ç†
  JvmtiEventController* _event_controller;
  JvmtiEventCallbacks* _event_callbacks;
};

// å¼‚å¸¸äº‹ä»¶å¤„ç†
void JvmtiExport::post_exception_throw(JavaThread *thread, Method* method, 
                                      address location, oop exception) {
  HandleMark hm(thread);
  methodHandle mh(thread, method);
  
  // === ç¬¬1æ­¥ï¼šæ£€æŸ¥äº‹ä»¶ç›‘å¬å™¨ ===
  if (!JvmtiExport::can_post_on_exceptions()) {
    return; // æ— ç›‘å¬å™¨ï¼Œç›´æ¥è¿”å›
  }
  
  // === ç¬¬2æ­¥ï¼šå‡†å¤‡äº‹ä»¶æ•°æ® ===
  JvmtiEnv* env = NULL;
  JvmtiThreadState* state = thread->jvmti_thread_state();
  
  if (state != NULL) {
    env = state->get_env_thread_state(JvmtiEnvBase::get_Phase())->env();
  }
  
  if (env != NULL && env->is_enabled(JVMTI_EVENT_EXCEPTION)) {
    // === ç¬¬3æ­¥ï¼šæ„é€ äº‹ä»¶å‚æ•° ===
    jmethodID method_id = mh->jmethod_id();
    jlocation throw_location = location - mh->code_base();
    jobject exception_object = JNIHandles::make_local(thread, exception);
    
    // === ç¬¬4æ­¥ï¼šè°ƒç”¨äº‹ä»¶å›è°ƒ ===
    JvmtiExceptionEventMark jem(thread);
    JvmtiJavaThreadEventTransition jet(thread);
    
    jvmtiEventException callback = env->callbacks()->Exception;
    if (callback != NULL) {
      (*callback)(env->jvmti_external(), 
                 jem.jni_env(), 
                 jem.jni_thread(),
                 method_id,
                 throw_location,
                 exception_object,
                 method_id,  // catch method (same as throw for now)
                 throw_location); // catch location
    }
  }
  
  // === ç¬¬5æ­¥ï¼šæ›´æ–°å¼‚å¸¸ç»Ÿè®¡ ===
  if (JvmtiExport::should_post_monitor_contended_enter() ||
      JvmtiExport::should_post_monitor_contended_entered()) {
    JvmtiExport::increment_exception_counter();
  }
}
```

---

## ğŸš€ ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ€§èƒ½ç›‘æ§ä¸è¯Šæ–­å·¥å…·

### 3.1 JFRå¼‚å¸¸äº‹ä»¶è®°å½•

```cpp
// hotspot/src/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp
class JfrCheckpointManager : AllStatic {
public:
  // å¼‚å¸¸äº‹ä»¶æ£€æŸ¥ç‚¹
  static void write_exception_checkpoint(JfrCheckpointWriter& writer);
  static void write_stacktrace_checkpoint(JfrCheckpointWriter& writer, 
                                         traceid stack_trace_id);
  
private:
  // å¼‚å¸¸ç»Ÿè®¡ç¼“å­˜
  static GrowableArray<ExceptionEventData>* _exception_cache;
  static Mutex* _exception_cache_lock;
};

// JFRå¼‚å¸¸äº‹ä»¶ç»“æ„
struct ExceptionEvent {
  u8 timestamp;           // äº‹ä»¶æ—¶é—´æˆ³
  traceid thread_id;      // çº¿ç¨‹ID
  traceid stack_trace_id; // æ ˆè·Ÿè¸ªID
  traceid exception_class_id; // å¼‚å¸¸ç±»ID
  const char* message;    // å¼‚å¸¸æ¶ˆæ¯
  u4 throw_location_bci;  // æŠ›å‡ºä½ç½®BCI
  traceid throw_method_id; // æŠ›å‡ºæ–¹æ³•ID
  
  // æ€§èƒ½ç»Ÿè®¡
  u8 allocation_time;     // å¼‚å¸¸å¯¹è±¡åˆ†é…æ—¶é—´
  size_t allocation_size; // å¼‚å¸¸å¯¹è±¡å¤§å°
  u4 stack_depth;         // æ ˆæ·±åº¦
};
```

### 3.2 æ€§èƒ½è®¡æ•°å™¨ä¸ç›‘æ§

```cpp
// hotspot/src/share/runtime/perfData.cpp - æ€§èƒ½è®¡æ•°å™¨å®ç°
class PerfData : public CHeapObj<mtInternal> {
public:
  // å¼‚å¸¸ç›¸å…³æ€§èƒ½è®¡æ•°å™¨
  static PerfCounter* _exceptions_thrown;
  static PerfCounter* _exceptions_caught;
  static PerfCounter* _exception_handler_lookups;
  static PerfCounter* _exception_handler_cache_hits;
  
  // æ ˆå±•å¼€æ€§èƒ½ç»Ÿè®¡
  static PerfCounter* _stack_unwind_operations;
  static PerfCounter* _stack_unwind_time;
  
  // å¼‚å¸¸å¯¹è±¡åˆ†é…ç»Ÿè®¡
  static PerfCounter* _exception_objects_allocated;
  static PerfCounter* _exception_allocation_time;
  
  static void initialize_exception_counters();
};

// æ€§èƒ½è®¡æ•°å™¨åˆå§‹åŒ–
void PerfData::initialize_exception_counters() {
  EXCEPTION_MARK;
  
  // å¼‚å¸¸æŠ›å‡º/æ•è·è®¡æ•°å™¨
  _exceptions_thrown = PerfDataManager::create_counter(
    SUN_RT, "exceptionsThrown", PerfData::U_Events, CHECK);
  
  _exceptions_caught = PerfDataManager::create_counter(
    SUN_RT, "exceptionsCaught", PerfData::U_Events, CHECK);
  
  // å¼‚å¸¸å¤„ç†å™¨æŸ¥æ‰¾ç»Ÿè®¡
  _exception_handler_lookups = PerfDataManager::create_counter(
    SUN_RT, "exceptionHandlerLookups", PerfData::U_Events, CHECK);
  
  _exception_handler_cache_hits = PerfDataManager::create_counter(
    SUN_RT, "exceptionHandlerCacheHits", PerfData::U_Events, CHECK);
  
  // æ ˆå±•å¼€æ€§èƒ½ç»Ÿè®¡
  _stack_unwind_operations = PerfDataManager::create_counter(
    SUN_RT, "stackUnwindOperations", PerfData::U_Events, CHECK);
  
  _stack_unwind_time = PerfDataManager::create_counter(
    SUN_RT, "stackUnwindTime", PerfData::U_Ticks, CHECK);
  
  // å¼‚å¸¸å¯¹è±¡åˆ†é…ç»Ÿè®¡
  _exception_objects_allocated = PerfDataManager::create_counter(
    SUN_RT, "exceptionObjectsAllocated", PerfData::U_Events, CHECK);
  
  _exception_allocation_time = PerfDataManager::create_counter(
    SUN_RT, "exceptionAllocationTime", PerfData::U_Ticks, CHECK);
}
```

---

## ğŸ“Š ç¬¬å››éƒ¨åˆ†ï¼šæ·±åº¦æ€§èƒ½åˆ†æä¸ä¼˜åŒ–

### 4.1 å¼‚å¸¸å¤„ç†æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 4.1.1 é›¶å¼€é”€å¼‚å¸¸å¤„ç†åŸåˆ™

```cpp
// hotspot/src/share/runtime/exceptions.cpp - æ€§èƒ½ä¼˜åŒ–å®ç°
class ExceptionOptimizer : AllStatic {
public:
  // === å¼‚å¸¸å¤„ç†æ€§èƒ½ä¼˜åŒ–æ ¸å¿ƒç­–ç•¥ ===
  
  // 1. é¢„åˆ†é…å¼‚å¸¸å¯¹è±¡æ± 
  static void initialize_preallocated_exceptions();
  
  // 2. å¼‚å¸¸å¤„ç†å™¨ç¼“å­˜
  static void cache_exception_handler(Method* method, int bci, int handler_bci);
  static int lookup_cached_handler(Method* method, int bci);
  
  // 3. æ ˆè·Ÿè¸ªå»¶è¿Ÿç”Ÿæˆ
  static void enable_lazy_stack_trace_generation();
  
  // 4. å¼‚å¸¸å¤„ç†ç»Ÿè®¡ä¸è°ƒä¼˜
  static void collect_exception_statistics();
  static void optimize_exception_paths();
  
private:
  // æ€§èƒ½ä¼˜åŒ–æ•°æ®ç»“æ„
  static ExceptionHandlerCache* _handler_cache;
  static PreallocatedExceptionPool* _exception_pool;
  static ExceptionStatistics* _statistics;
};

// å¼‚å¸¸å¤„ç†å™¨ç¼“å­˜å®ç°
class ExceptionHandlerCache {
private:
  struct CacheEntry {
    Method* method;
    int throw_bci;
    int handler_bci;
    Klass* exception_klass;
    u8 access_count;
    u8 last_access_time;
  };
  
  CacheEntry* _entries;
  int _size;
  int _capacity;
  Mutex* _lock;
  
public:
  ExceptionHandlerCache(int capacity);
  
  // ç¼“å­˜æ“ä½œ
  int lookup(Method* method, int bci, Klass* ex_klass);
  void insert(Method* method, int bci, int handler_bci, Klass* ex_klass);
  void evict_lru_entries();
  
  // ç»Ÿè®¡ä¿¡æ¯
  double get_hit_rate() const;
  void print_statistics() const;
};

// é¢„åˆ†é…å¼‚å¸¸å¯¹è±¡æ± 
class PreallocatedExceptionPool {
private:
  // å¸¸è§å¼‚å¸¸çš„é¢„åˆ†é…å¯¹è±¡
  oop* _oom_exceptions;
  oop* _soe_exceptions;
  oop* _npe_exceptions;
  oop* _iae_exceptions;
  
  int _pool_size;
  volatile int _oom_index;
  volatile int _soe_index;
  volatile int _npe_index;
  volatile int _iae_index;
  
public:
  PreallocatedExceptionPool(int pool_size);
  
  // è·å–é¢„åˆ†é…å¼‚å¸¸
  oop get_oom_exception();
  oop get_soe_exception();
  oop get_npe_exception();
  oop get_iae_exception();
  
  // æ± ç®¡ç†
  void refill_pool();
  bool is_pool_healthy() const;
};

// å¼‚å¸¸å¤„ç†ç»Ÿè®¡æ”¶é›†
class ExceptionStatistics {
private:
  // ç»Ÿè®¡æ•°æ®
  volatile u8 _total_exceptions_thrown;
  volatile u8 _total_exceptions_caught;
  volatile u8 _total_stack_unwind_time;
  volatile u8 _total_handler_lookup_time;
  
  // å¼‚å¸¸ç±»å‹ç»Ÿè®¡
  ConcurrentHashTable<Klass*, ExceptionTypeStats*>* _type_stats;
  
  // çƒ­ç‚¹æ–¹æ³•ç»Ÿè®¡
  ConcurrentHashTable<Method*, MethodExceptionStats*>* _method_stats;
  
public:
  ExceptionStatistics();
  
  // ç»Ÿè®¡æ›´æ–°
  void record_exception_thrown(Klass* ex_klass, Method* method, int bci);
  void record_exception_caught(Klass* ex_klass, Method* method, int bci);
  void record_stack_unwind_time(u8 time_nanos);
  void record_handler_lookup_time(u8 time_nanos);
  
  // ç»Ÿè®¡åˆ†æ
  void analyze_exception_hotspots();
  void generate_optimization_recommendations();
  void print_comprehensive_report();
};
```

#### 4.1.2 ç¼–è¯‘å™¨å¼‚å¸¸å¤„ç†ä¼˜åŒ–

```cpp
// hotspot/src/share/opto/exceptionopt.cpp - C2ç¼–è¯‘å™¨å¼‚å¸¸ä¼˜åŒ–
class ExceptionOptimization : public Phase {
private:
  PhaseGVN* _gvn;
  Node_Array _exception_regions;
  
public:
  ExceptionOptimization(PhaseGVN* gvn) : _gvn(gvn) {}
  
  // === ç¼–è¯‘å™¨å¼‚å¸¸å¤„ç†ä¼˜åŒ– ===
  
  // 1. å¼‚å¸¸è·¯å¾„æ¶ˆé™¤
  void eliminate_unused_exception_paths();
  
  // 2. å¼‚å¸¸å¤„ç†å™¨å†…è”
  void inline_exception_handlers();
  
  // 3. å¼‚å¸¸æ£€æŸ¥ä¼˜åŒ–
  void optimize_null_checks();
  void optimize_bounds_checks();
  void optimize_cast_checks();
  
  // 4. å¼‚å¸¸ä¼ æ’­ä¼˜åŒ–
  void optimize_exception_propagation();
  
private:
  // ä¼˜åŒ–è¾…åŠ©æ–¹æ³•
  bool is_exception_path_reachable(Node* node);
  void merge_exception_handlers(Node* handler1, Node* handler2);
  Node* create_optimized_null_check(Node* obj);
};

// å¼‚å¸¸è·¯å¾„æ¶ˆé™¤ä¼˜åŒ–
void ExceptionOptimization::eliminate_unused_exception_paths() {
  // === ç¬¬1æ­¥ï¼šè¯†åˆ«æ‰€æœ‰å¼‚å¸¸è·¯å¾„ ===
  GrowableArray<Node*> exception_paths;
  
  for (DUIterator_Fast imax, i = _gvn->C->root()->fast_outs(imax); i < imax; i++) {
    Node* n = _gvn->C->root()->fast_out(i);
    if (n->is_Catch()) {
      // æ‰¾åˆ°catchèŠ‚ç‚¹ï¼Œåˆ†æå…¶å¼‚å¸¸è·¯å¾„
      for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {
        Node* proj = n->fast_out(j);
        if (proj->is_CatchProj() && proj->as_CatchProj()->_con != CatchProjNode::fall_through_index) {
          exception_paths.push(proj);
        }
      }
    }
  }
  
  // === ç¬¬2æ­¥ï¼šåˆ†æå¼‚å¸¸è·¯å¾„å¯è¾¾æ€§ ===
  for (int i = 0; i < exception_paths.length(); i++) {
    Node* exception_path = exception_paths.at(i);
    
    if (!is_exception_path_reachable(exception_path)) {
      // === ç¬¬3æ­¥ï¼šæ¶ˆé™¤ä¸å¯è¾¾å¼‚å¸¸è·¯å¾„ ===
      
      // 3.1 ç§»é™¤å¼‚å¸¸å¤„ç†ä»£ç 
      Node* region = exception_path->unique_out();
      if (region != NULL && region->is_Region()) {
        // ç§»é™¤æ•´ä¸ªå¼‚å¸¸å¤„ç†åŒºåŸŸ
        _gvn->hash_delete(region);
        region->disconnect_inputs(NULL, _gvn->C);
        _gvn->C->record_for_igvn(region);
      }
      
      // 3.2 æ›´æ–°æ§åˆ¶æµå›¾
      _gvn->hash_delete(exception_path);
      exception_path->disconnect_inputs(NULL, _gvn->C);
      _gvn->C->record_for_igvn(exception_path);
      
      // 3.3 è®°å½•ä¼˜åŒ–ç»Ÿè®¡
      _gvn->C->print_method(PHASE_AFTER_EXCEPTION_PATH_ELIMINATION, 2);
    }
  }
}

// å¼‚å¸¸æ£€æŸ¥ä¼˜åŒ– - ç©ºæŒ‡é’ˆæ£€æŸ¥
Node* ExceptionOptimization::create_optimized_null_check(Node* obj) {
  // === ç¬¬1æ­¥ï¼šæ£€æŸ¥æ˜¯å¦å·²æœ‰ç©ºæŒ‡é’ˆæ£€æŸ¥ ===
  Node* existing_check = NULL;
  
  for (DUIterator_Fast imax, i = obj->fast_outs(imax); i < imax; i++) {
    Node* use = obj->fast_out(i);
    if (use->is_If() && use->in(1)->is_Bool()) {
      BoolNode* bool_node = use->in(1)->as_Bool();
      if (bool_node->_test._test == BoolTest::ne && 
          bool_node->in(1)->is_Cmp() &&
          bool_node->in(1)->in(2) == _gvn->zerocon(T_OBJECT)) {
        existing_check = use;
        break;
      }
    }
  }
  
  if (existing_check != NULL) {
    return existing_check; // é‡ç”¨å·²æœ‰æ£€æŸ¥
  }
  
  // === ç¬¬2æ­¥ï¼šåˆ›å»ºä¼˜åŒ–çš„ç©ºæŒ‡é’ˆæ£€æŸ¥ ===
  
  // 2.1 åˆ›å»ºæ¯”è¾ƒèŠ‚ç‚¹
  Node* null_con = _gvn->zerocon(T_OBJECT);
  Node* cmp = new CmpPNode(obj, null_con);
  _gvn->transform(cmp);
  
  // 2.2 åˆ›å»ºå¸ƒå°”èŠ‚ç‚¹
  Node* bool_node = new BoolNode(cmp, BoolTest::ne);
  _gvn->transform(bool_node);
  
  // 2.3 åˆ›å»ºæ¡ä»¶åˆ†æ”¯
  Node* if_node = new IfNode(_gvn->C->root(), bool_node, PROB_LIKELY_MAG(5), COUNT_UNKNOWN);
  _gvn->transform(if_node);
  
  // 2.4 åˆ›å»ºå¼‚å¸¸è·¯å¾„
  Node* if_false = new IfFalseNode(if_node);
  _gvn->transform(if_false);
  
  // 2.5 åˆ›å»ºç©ºæŒ‡é’ˆå¼‚å¸¸
  Node* halt = new HaltNode(if_false, _gvn->C->top());
  _gvn->transform(halt);
  
  // 2.6 åˆ›å»ºæ­£å¸¸è·¯å¾„
  Node* if_true = new IfTrueNode(if_node);
  _gvn->transform(if_true);
  
  return if_true;
}
```

---

## ğŸ“ˆ ç¬¬äº”éƒ¨åˆ†ï¼šä¼ä¸šçº§æ€§èƒ½è°ƒä¼˜å®è·µ

### 5.1 å¼‚å¸¸å¤„ç†æ€§èƒ½è°ƒä¼˜æŒ‡å—

#### 5.1.1 JVMå‚æ•°ä¼˜åŒ–é…ç½®

```bash
# === å¼‚å¸¸å¤„ç†æ€§èƒ½ä¼˜åŒ–JVMå‚æ•°é…ç½® ===

# åŸºç¡€8GBå †é…ç½®
-Xms8g -Xmx8g

# G1GCä¼˜åŒ–é…ç½®
-XX:+UseG1GC
-XX:G1HeapRegionSize=4m
-XX:MaxGCPauseMillis=200
-XX:G1NewSizePercent=20
-XX:G1MaxNewSizePercent=30

# å¼‚å¸¸å¤„ç†ä¼˜åŒ–å‚æ•°
-XX:+OptimizeStringConcat                    # ä¼˜åŒ–å­—ç¬¦ä¸²è¿æ¥ï¼Œå‡å°‘å¼‚å¸¸æ¶ˆæ¯åˆ›å»ºå¼€é”€
-XX:+EliminateAllocations                    # æ¶ˆé™¤ä¸å¿…è¦çš„å¯¹è±¡åˆ†é…
-XX:+EliminateLocks                          # æ¶ˆé™¤ä¸å¿…è¦çš„é”æ“ä½œ
-XX:+DoEscapeAnalysis                        # å¯ç”¨é€ƒé€¸åˆ†æï¼Œä¼˜åŒ–å¼‚å¸¸å¯¹è±¡åˆ†é…

# æ ˆè·Ÿè¸ªä¼˜åŒ–
-XX:MaxJavaStackTraceDepth=1024              # é™åˆ¶æ ˆè·Ÿè¸ªæ·±åº¦ï¼Œå¹³è¡¡ä¿¡æ¯å®Œæ•´æ€§å’Œæ€§èƒ½
-XX:+ReduceInitialCardMarks                  # å‡å°‘åˆå§‹å¡æ ‡è®°ï¼Œæå‡å¼‚å¸¸å¯¹è±¡åˆ†é…æ€§èƒ½
-XX:+UseFastUnorderedTimeStamps              # ä½¿ç”¨å¿«é€Ÿæ—¶é—´æˆ³ï¼Œæå‡å¼‚å¸¸æ—¶é—´è®°å½•æ€§èƒ½

# ç¼–è¯‘å™¨ä¼˜åŒ–
-XX:+UseCompressedOops                       # å¯ç”¨å‹ç¼©æŒ‡é’ˆï¼Œå‡å°‘å¼‚å¸¸å¯¹è±¡å†…å­˜å ç”¨
-XX:+UseCompressedClassPointers              # å¯ç”¨å‹ç¼©ç±»æŒ‡é’ˆ
-XX:CompileThreshold=10000                   # é™ä½ç¼–è¯‘é˜ˆå€¼ï¼Œæ›´å¿«ä¼˜åŒ–å¼‚å¸¸å¤„ç†çƒ­ç‚¹
-XX:+TieredCompilation                       # å¯ç”¨åˆ†å±‚ç¼–è¯‘
-XX:TieredStopAtLevel=4                      # ä½¿ç”¨C2ç¼–è¯‘å™¨è¿›è¡Œæœ€ç»ˆä¼˜åŒ–

# å¼‚å¸¸å¤„ç†ç›‘æ§å‚æ•°
-XX:+UnlockDiagnosticVMOptions               # è§£é”è¯Šæ–­é€‰é¡¹
-XX:+TraceExceptions                         # è·Ÿè¸ªå¼‚å¸¸æŠ›å‡ºå’Œæ•è·
-XX:+PrintGCDetails                          # æ‰“å°GCè¯¦æƒ…ï¼Œç›‘æ§å¼‚å¸¸å¯¹è±¡å›æ”¶
-XX:+PrintGCTimeStamps                       # æ‰“å°GCæ—¶é—´æˆ³
-XX:+LogVMOutput                             # è®°å½•VMè¾“å‡º
-XX:+FlightRecorder                          # å¯ç”¨JFR
-XX:StartFlightRecording=duration=300s,filename=exception_analysis.jfr

# æ€§èƒ½ç›‘æ§å’Œè°ƒè¯•
-XX:+PerfDataSaveToFile                      # ä¿å­˜æ€§èƒ½æ•°æ®åˆ°æ–‡ä»¶
-XX:+PrintCompilation                        # æ‰“å°ç¼–è¯‘ä¿¡æ¯
-XX:+PrintInlining                           # æ‰“å°å†…è”ä¿¡æ¯
-XX:+TraceClassLoading                       # è·Ÿè¸ªç±»åŠ è½½

# å†…å­˜ä¼˜åŒ–
-XX:+UseLargePages                           # ä½¿ç”¨å¤§é¡µå†…å­˜
-XX:LargePageSizeInBytes=2m                  # è®¾ç½®å¤§é¡µå¤§å°
-XX:+AlwaysPreTouch                          # é¢„åˆ†é…å †å†…å­˜

# ç¤ºä¾‹å®Œæ•´å¯åŠ¨å‘½ä»¤
java -Xms8g -Xmx8g \
     -XX:+UseG1GC -XX:G1HeapRegionSize=4m -XX:MaxGCPauseMillis=200 \
     -XX:+OptimizeStringConcat -XX:+EliminateAllocations -XX:+DoEscapeAnalysis \
     -XX:MaxJavaStackTraceDepth=1024 -XX:+UseFastUnorderedTimeStamps \
     -XX:+UseCompressedOops -XX:+UseCompressedClassPointers \
     -XX:CompileThreshold=10000 -XX:+TieredCompilation \
     -XX:+UnlockDiagnosticVMOptions -XX:+TraceExceptions \
     -XX:+PrintGCDetails -XX:+LogVMOutput \
     -XX:+FlightRecorder -XX:StartFlightRecording=duration=300s,filename=exception_analysis.jfr \
     -XX:+UseLargePages -XX:+AlwaysPreTouch \
     YourApplication
```

#### 5.1.2 å¼‚å¸¸å¤„ç†æœ€ä½³å®è·µ

```java
/**
 * å¼‚å¸¸å¤„ç†æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µç¤ºä¾‹
 */
public class ExceptionHandlingBestPractices {
    
    // === 1. å¼‚å¸¸å¯¹è±¡é‡ç”¨ç­–ç•¥ ===
    
    // é¢„å®šä¹‰å¸¸ç”¨å¼‚å¸¸ï¼Œé¿å…é‡å¤åˆ›å»º
    private static final IllegalArgumentException INVALID_ARGUMENT = 
        new IllegalArgumentException("Invalid argument");
    
    private static final NullPointerException NULL_POINTER = 
        new NullPointerException("Null pointer detected");
    
    // ä½¿ç”¨ThreadLocalç¼“å­˜å¼‚å¸¸å¯¹è±¡
    private static final ThreadLocal<StringBuilder> EXCEPTION_MESSAGE_BUILDER = 
        ThreadLocal.withInitial(() -> new StringBuilder(256));
    
    // === 2. é«˜æ€§èƒ½å¼‚å¸¸æ£€æŸ¥ ===
    
    /**
     * ä¼˜åŒ–çš„å‚æ•°éªŒè¯ - é¿å…å¼‚å¸¸åˆ›å»ºå¼€é”€
     */
    public static boolean validateParameters(Object obj, int value) {
        // å¿«é€Ÿè·¯å¾„ï¼šå…ˆè¿›è¡Œå»‰ä»·æ£€æŸ¥
        if (obj == null) return false;
        if (value < 0) return false;
        if (value > MAX_VALUE) return false;
        
        return true; // æ‰€æœ‰æ£€æŸ¥é€šè¿‡
    }
    
    /**
     * æ¡ä»¶å¼‚å¸¸æŠ›å‡º - åªåœ¨å¿…è¦æ—¶åˆ›å»ºå¼‚å¸¸
     */
    public static void processWithValidation(Object obj, int value) {
        if (!validateParameters(obj, value)) {
            // åªæœ‰åœ¨éªŒè¯å¤±è´¥æ—¶æ‰åˆ›å»ºå¼‚å¸¸
            if (obj == null) {
                throw NULL_POINTER; // é‡ç”¨é¢„å®šä¹‰å¼‚å¸¸
            }
            if (value < 0 || value > MAX_VALUE) {
                throw INVALID_ARGUMENT; // é‡ç”¨é¢„å®šä¹‰å¼‚å¸¸
            }
        }
        
        // æ­£å¸¸å¤„ç†é€»è¾‘
        processInternal(obj, value);
    }
    
    // === 3. æ ˆè·Ÿè¸ªä¼˜åŒ–ç­–ç•¥ ===
    
    /**
     * è½»é‡çº§å¼‚å¸¸ - ä¸å¡«å……æ ˆè·Ÿè¸ª
     */
    public static class LightweightException extends Exception {
        public LightweightException(String message) {
            super(message, null, false, false); // ä¸å¡«å……æ ˆè·Ÿè¸ª
        }
    }
    
    /**
     * å»¶è¿Ÿæ ˆè·Ÿè¸ªå¡«å……
     */
    public static class LazyStackTraceException extends Exception {
        private boolean stackTraceFilled = false;
        
        public LazyStackTraceException(String message) {
            super(message);
        }
        
        @Override
        public synchronized Throwable fillInStackTrace() {
            if (!stackTraceFilled) {
                stackTraceFilled = true;
                return super.fillInStackTrace();
            }
            return this;
        }
    }
    
    // === 4. å¼‚å¸¸å¤„ç†å™¨ä¼˜åŒ– ===
    
    /**
     * é«˜æ•ˆçš„å¤šå¼‚å¸¸å¤„ç†
     */
    public static void optimizedExceptionHandling() {
        try {
            riskyOperation();
        } catch (IllegalArgumentException | NullPointerException e) {
            // åˆå¹¶å¤„ç†ç›¸ä¼¼å¼‚å¸¸ï¼Œå‡å°‘å¤„ç†å™¨æ•°é‡
            handleValidationException(e);
        } catch (IOException e) {
            // ä¸“é—¨å¤„ç†IOå¼‚å¸¸
            handleIOException(e);
        } catch (Exception e) {
            // é€šç”¨å¼‚å¸¸å¤„ç†
            handleGenericException(e);
        }
    }
    
    /**
     * å¼‚å¸¸å¤„ç†å™¨ç¼“å­˜ç­–ç•¥
     */
    private static final Map<Class<? extends Exception>, ExceptionHandler> HANDLER_CACHE = 
        new ConcurrentHashMap<>();
    
    public static void cachedExceptionHandling(Exception e) {
        ExceptionHandler handler = HANDLER_CACHE.computeIfAbsent(
            e.getClass(), 
            ExceptionHandlerFactory::createHandler
        );
        handler.handle(e);
    }
    
    // === 5. æ€§èƒ½ç›‘æ§é›†æˆ ===
    
    private static final AtomicLong exceptionCount = new AtomicLong(0);
    private static final AtomicLong totalHandlingTime = new AtomicLong(0);
    
    /**
     * å¸¦æ€§èƒ½ç›‘æ§çš„å¼‚å¸¸å¤„ç†
     */
    public static void monitoredExceptionHandling(Runnable operation) {
        long startTime = System.nanoTime();
        try {
            operation.run();
        } catch (Exception e) {
            long handlingTime = System.nanoTime() - startTime;
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            exceptionCount.incrementAndGet();
            totalHandlingTime.addAndGet(handlingTime);
            
            // è®°å½•æ€§èƒ½æ•°æ®
            recordExceptionMetrics(e.getClass(), handlingTime);
            
            // é‡æ–°æŠ›å‡ºå¼‚å¸¸
            throw e;
        }
    }
    
    /**
     * å¼‚å¸¸æ€§èƒ½ç»Ÿè®¡æŠ¥å‘Š
     */
    public static void printExceptionStatistics() {
        long count = exceptionCount.get();
        long totalTime = totalHandlingTime.get();
        
        if (count > 0) {
            double avgTime = totalTime / (double) count;
            System.out.printf("å¼‚å¸¸å¤„ç†ç»Ÿè®¡: æ€»æ•°=%d, å¹³å‡å¤„ç†æ—¶é—´=%.2fçº³ç§’%n", 
                            count, avgTime);
        }
    }
    
    // === è¾…åŠ©æ–¹æ³• ===
    
    private static final int MAX_VALUE = 1000000;
    
    private static void processInternal(Object obj, int value) {
        // å®é™…å¤„ç†é€»è¾‘
    }
    
    private static void riskyOperation() throws Exception {
        // å¯èƒ½æŠ›å‡ºå¼‚å¸¸çš„æ“ä½œ
    }
    
    private static void handleValidationException(Exception e) {
        // å¤„ç†éªŒè¯å¼‚å¸¸
    }
    
    private static void handleIOException(IOException e) {
        // å¤„ç†IOå¼‚å¸¸
    }
    
    private static void handleGenericException(Exception e) {
        // å¤„ç†é€šç”¨å¼‚å¸¸
    }
    
    private static void recordExceptionMetrics(Class<? extends Exception> exceptionType, long handlingTime) {
        // è®°å½•å¼‚å¸¸å¤„ç†æ€§èƒ½æŒ‡æ ‡
    }
    
    // å¼‚å¸¸å¤„ç†å™¨æ¥å£å’Œå·¥å‚
    interface ExceptionHandler {
        void handle(Exception e);
    }
    
    static class ExceptionHandlerFactory {
        static ExceptionHandler createHandler(Class<? extends Exception> exceptionType) {
            // æ ¹æ®å¼‚å¸¸ç±»å‹åˆ›å»ºç›¸åº”çš„å¤„ç†å™¨
            return e -> System.err.println("å¤„ç†å¼‚å¸¸: " + e.getMessage());
        }
    }
}
```

---

## ğŸ¯ æ€»ç»“ï¼šå¼‚å¸¸å¤„ç†æœºåˆ¶æ·±åº¦æŒæ¡

### æ ¸å¿ƒæŠ€æœ¯è¦ç‚¹

1. **å¼‚å¸¸å¯¹è±¡ç”Ÿå‘½å‘¨æœŸ**: ä»åˆ›å»ºã€å¡«å……æ ˆè·Ÿè¸ªã€ä¼ æ’­åˆ°å›æ”¶çš„å®Œæ•´æµç¨‹
2. **æ ˆå±•å¼€ç®—æ³•**: å¼‚å¸¸åœ¨è°ƒç”¨æ ˆä¸­çš„ä¼ æ’­æœºåˆ¶å’Œæ€§èƒ½ä¼˜åŒ–
3. **å¼‚å¸¸è¡¨æŸ¥æ‰¾**: é«˜æ•ˆçš„å¼‚å¸¸å¤„ç†å™¨åŒ¹é…ç®—æ³•å’Œç¼“å­˜ç­–ç•¥
4. **è°ƒè¯•ä¿¡æ¯ç®¡ç†**: è¡Œå·è¡¨ã€å±€éƒ¨å˜é‡è¡¨çš„ç”Ÿæˆå’Œå‹ç¼©å­˜å‚¨
5. **æ€§èƒ½ç›‘æ§é›†æˆ**: JFRäº‹ä»¶è®°å½•å’Œæ€§èƒ½è®¡æ•°å™¨çš„ä¼ä¸šçº§åº”ç”¨

### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

1. **é¢„åˆ†é…å¼‚å¸¸æ± **: é¿å…é¢‘ç¹åˆ›å»ºå¸¸è§å¼‚å¸¸å¯¹è±¡
2. **å¼‚å¸¸å¤„ç†å™¨ç¼“å­˜**: æå‡å¼‚å¸¸å¤„ç†å™¨æŸ¥æ‰¾æ•ˆç‡
3. **æ ˆè·Ÿè¸ªä¼˜åŒ–**: å»¶è¿Ÿå¡«å……å’Œæ·±åº¦é™åˆ¶ç­–ç•¥
4. **ç¼–è¯‘å™¨ä¼˜åŒ–**: å¼‚å¸¸è·¯å¾„æ¶ˆé™¤å’Œæ£€æŸ¥ä¼˜åŒ–
5. **é›¶å¼€é”€åŸåˆ™**: æ­£å¸¸è·¯å¾„ä¸å—å¼‚å¸¸å¤„ç†æœºåˆ¶å½±å“

é€šè¿‡æœ¬ç« çš„æ·±åº¦å­¦ä¹ ï¼Œæ‚¨å·²ç»æŒæ¡äº†JVMå¼‚å¸¸å¤„ç†æœºåˆ¶çš„å®Œæ•´å®ç°ç»†èŠ‚ï¼Œèƒ½å¤Ÿè¿›è¡Œä¸“ä¸šçº§çš„å¼‚å¸¸å¤„ç†æ€§èƒ½è°ƒä¼˜å’Œé—®é¢˜è¯Šæ–­ã€‚