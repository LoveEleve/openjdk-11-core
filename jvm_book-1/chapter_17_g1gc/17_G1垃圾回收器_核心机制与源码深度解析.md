# ç¬¬17ç« ï¼šG1åƒåœ¾å›æ”¶å™¨ - æ ¸å¿ƒæœºåˆ¶ä¸æºç æ·±åº¦è§£æ

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œæ‚¨å°†ï¼š
- ğŸ† **å®Œå…¨æŒæ¡G1 GCçš„è®¾è®¡ç†å¿µå’Œæ ¸å¿ƒæœºåˆ¶**
- ğŸ† **æ·±åº¦ç†è§£Region-basedå†…å­˜ç®¡ç†**
- ğŸ† **ç²¾é€šG1çš„å¹¶å‘æ ‡è®°å’Œæ··åˆå›æ”¶ç®—æ³•**
- ğŸ† **å…·å¤‡G1è°ƒä¼˜å’Œæ•…éšœè¯Šæ–­çš„ä¸“ä¸šèƒ½åŠ›**

---

## ğŸ“š ç›®å½•

1. [G1 GCè®¾è®¡ç†å¿µ](#1-g1-gcè®¾è®¡ç†å¿µ)
2. [Region-basedå†…å­˜ç®¡ç†](#2-region-basedå†…å­˜ç®¡ç†)
3. [G1å¹¶å‘æ ‡è®°ç®—æ³•](#3-g1å¹¶å‘æ ‡è®°ç®—æ³•)
4. [æ··åˆå›æ”¶æœºåˆ¶](#4-æ··åˆå›æ”¶æœºåˆ¶)
5. [Remember Setå®ç°](#5-remember-setå®ç°)
6. [G1æ€§èƒ½è°ƒä¼˜ç­–ç•¥](#6-g1æ€§èƒ½è°ƒä¼˜ç­–ç•¥)

---

## 1. G1 GCè®¾è®¡ç†å¿µ

### 1.1 æ ¸å¿ƒè®¾è®¡ç›®æ ‡

#### **ä½å»¶è¿Ÿä¸é«˜ååé‡çš„å¹³è¡¡**

```java
/**
 * G1 GCè®¾è®¡ç†å¿µå®ç°
 * åŸºäº8GBå †å†…å­˜ç¯å¢ƒï¼š-Xms=8GB -Xmx=8GBï¼ŒG1 Regionå¤§å°=4MB
 */
public class G1GCDesignPrinciples {
    
    /**
     * G1é…ç½®å‚æ•°ï¼ˆåŸºäº8GBå †å†…å­˜ï¼‰
     */
    static class G1Configuration {
        // å †å†…å­˜é…ç½®
        public static final long HEAP_SIZE = 8L * 1024 * 1024 * 1024; // 8GB
        
        // Regioné…ç½®
        public static final int REGION_SIZE = 4 * 1024 * 1024; // 4MB per region
        public static final int TOTAL_REGIONS = (int) (HEAP_SIZE / REGION_SIZE); // 2048 regions
        
        // æ€§èƒ½ç›®æ ‡
        public static final int TARGET_PAUSE_TIME_MS = 200; // ç›®æ ‡æš‚åœæ—¶é—´200ms
        public static final double TARGET_THROUGHPUT = 0.95; // ç›®æ ‡ååé‡95%
        
        // å¹¶å‘çº¿ç¨‹é…ç½®
        public static final int CONCURRENT_THREADS = Runtime.getRuntime().availableProcessors() / 4;
        public static final int PARALLEL_GC_THREADS = Runtime.getRuntime().availableProcessors();
        
        public static void printConfiguration() {
            System.out.println("=== G1 GCé…ç½® (8GBå †å†…å­˜) ===");
            System.out.println("å †å¤§å°: " + (HEAP_SIZE / 1024 / 1024 / 1024) + "GB");
            System.out.println("Regionå¤§å°: " + (REGION_SIZE / 1024 / 1024) + "MB");
            System.out.println("Regionæ€»æ•°: " + TOTAL_REGIONS);
            System.out.println("ç›®æ ‡æš‚åœæ—¶é—´: " + TARGET_PAUSE_TIME_MS + "ms");
            System.out.println("ç›®æ ‡ååé‡: " + (TARGET_THROUGHPUT * 100) + "%");
            System.out.println("å¹¶å‘çº¿ç¨‹æ•°: " + CONCURRENT_THREADS);
            System.out.println("å¹¶è¡ŒGCçº¿ç¨‹æ•°: " + PARALLEL_GC_THREADS);
        }
    }
    
    /**
     * G1è®¾è®¡åŸåˆ™
     */
    static class G1DesignPrinciples {
        
        /**
         * åŸåˆ™1: å¯é¢„æµ‹çš„æš‚åœæ—¶é—´
         */
        public void predictablePauseTime() {
            System.out.println("=== åŸåˆ™1: å¯é¢„æµ‹çš„æš‚åœæ—¶é—´ ===");
            
            // G1é€šè¿‡ä»¥ä¸‹æœºåˆ¶å®ç°å¯é¢„æµ‹çš„æš‚åœæ—¶é—´ï¼š
            System.out.println("1. å¢é‡å›æ”¶ï¼šæ¯æ¬¡åªå›æ”¶éƒ¨åˆ†Region");
            System.out.println("2. æš‚åœæ—¶é—´æ¨¡å‹ï¼šåŸºäºå†å²æ•°æ®é¢„æµ‹å›æ”¶æ—¶é—´");
            System.out.println("3. åŠ¨æ€è°ƒæ•´ï¼šæ ¹æ®ç›®æ ‡æš‚åœæ—¶é—´è°ƒæ•´å›æ”¶ç­–ç•¥");
            
            // æš‚åœæ—¶é—´é¢„æµ‹æ¨¡å‹
            PauseTimePredictor predictor = new PauseTimePredictor();
            predictor.demonstratePrediction();
        }
        
        /**
         * åŸåˆ™2: å¹¶å‘ä¸å¹¶è¡Œç»“åˆ
         */
        public void concurrentAndParallel() {
            System.out.println("=== åŸåˆ™2: å¹¶å‘ä¸å¹¶è¡Œç»“åˆ ===");
            
            System.out.println("å¹¶å‘é˜¶æ®µï¼ˆä¸åº”ç”¨çº¿ç¨‹åŒæ—¶æ‰§è¡Œï¼‰:");
            System.out.println("- åˆå§‹æ ‡è®°ï¼ˆInitial Markï¼‰");
            System.out.println("- å¹¶å‘æ ‡è®°ï¼ˆConcurrent Markï¼‰");
            System.out.println("- æœ€ç»ˆæ ‡è®°ï¼ˆFinal Markï¼‰");
            System.out.println("- å¹¶å‘æ¸…ç†ï¼ˆConcurrent Cleanupï¼‰");
            
            System.out.println("\nå¹¶è¡Œé˜¶æ®µï¼ˆå¤šçº¿ç¨‹æ‰§è¡Œï¼‰:");
            System.out.println("- å¹´è½»ä»£å›æ”¶ï¼ˆYoung GCï¼‰");
            System.out.println("- æ··åˆå›æ”¶ï¼ˆMixed GCï¼‰");
            System.out.println("- Full GCï¼ˆç´§æ€¥æƒ…å†µï¼‰");
        }
        
        /**
         * åŸåˆ™3: åˆ†ä»£æ”¶é›†ä¼˜åŒ–
         */
        public void generationalOptimization() {
            System.out.println("=== åŸåˆ™3: åˆ†ä»£æ”¶é›†ä¼˜åŒ– ===");
            
            System.out.println("å¹´è½»ä»£ä¼˜åŒ–:");
            System.out.println("- ä½¿ç”¨å¤åˆ¶ç®—æ³•ï¼Œå¿«é€Ÿå›æ”¶");
            System.out.println("- å¹¶è¡Œå›æ”¶ï¼Œå……åˆ†åˆ©ç”¨å¤šæ ¸");
            System.out.println("- åŠ¨æ€è°ƒæ•´å¹´è½»ä»£å¤§å°");
            
            System.out.println("\nè€å¹´ä»£ä¼˜åŒ–:");
            System.out.println("- å¢é‡å›æ”¶ï¼Œé¿å…é•¿æ—¶é—´æš‚åœ");
            System.out.println("- å¹¶å‘æ ‡è®°ï¼Œå‡å°‘STWæ—¶é—´");
            System.out.println("- é€‰æ‹©æ€§å›æ”¶ï¼Œä¼˜å…ˆå›æ”¶åƒåœ¾å¤šçš„Region");
        }
    }
    
    /**
     * æš‚åœæ—¶é—´é¢„æµ‹å™¨
     */
    static class PauseTimePredictor {
        private final List<RegionGCHistory> history = new ArrayList<>();
        
        public void demonstratePrediction() {
            System.out.println("=== æš‚åœæ—¶é—´é¢„æµ‹æ¨¡å‹ ===");
            
            // æ¨¡æ‹Ÿå†å²GCæ•°æ®
            generateHistoryData();
            
            // é¢„æµ‹ä¸åŒæ•°é‡Regionçš„å›æ”¶æ—¶é—´
            for (int regionCount = 1; regionCount <= 10; regionCount++) {
                long predictedTime = predictPauseTime(regionCount);
                System.out.println("å›æ”¶ " + regionCount + " ä¸ªRegioné¢„è®¡è€—æ—¶: " + predictedTime + "ms");
            }
            
            // è®¡ç®—åœ¨ç›®æ ‡æš‚åœæ—¶é—´å†…å¯å›æ”¶çš„Regionæ•°é‡
            int maxRegions = calculateMaxRegionsInTargetTime(G1Configuration.TARGET_PAUSE_TIME_MS);
            System.out.println("åœ¨ " + G1Configuration.TARGET_PAUSE_TIME_MS + "mså†…æœ€å¤šå¯å›æ”¶ " + maxRegions + " ä¸ªRegion");
        }
        
        private void generateHistoryData() {
            // ç”Ÿæˆæ¨¡æ‹Ÿçš„å†å²GCæ•°æ®
            Random random = new Random(42);
            for (int i = 0; i < 100; i++) {
                int regionCount = random.nextInt(20) + 1;
                long pauseTime = 10 + regionCount * 15 + random.nextInt(20); // åŸºç¡€æ—¶é—´ + çº¿æ€§å¢é•¿ + éšæœºæ³¢åŠ¨
                history.add(new RegionGCHistory(regionCount, pauseTime));
            }
        }
        
        private long predictPauseTime(int regionCount) {
            // åŸºäºå†å²æ•°æ®çš„çº¿æ€§å›å½’é¢„æµ‹
            double avgTimePerRegion = history.stream()
                    .mapToDouble(h -> (double) h.pauseTime / h.regionCount)
                    .average()
                    .orElse(15.0);
            
            // æ·»åŠ å›ºå®šå¼€é”€
            long fixedOverhead = 10; // 10mså›ºå®šå¼€é”€
            
            return fixedOverhead + (long) (regionCount * avgTimePerRegion);
        }
        
        private int calculateMaxRegionsInTargetTime(int targetTimeMs) {
            // äºŒåˆ†æŸ¥æ‰¾æœ€å¤§Regionæ•°é‡
            int left = 1, right = 50;
            int maxRegions = 1;
            
            while (left <= right) {
                int mid = (left + right) / 2;
                long predictedTime = predictPauseTime(mid);
                
                if (predictedTime <= targetTimeMs) {
                    maxRegions = mid;
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            
            return maxRegions;
        }
    }
    
    static class RegionGCHistory {
        final int regionCount;
        final long pauseTime;
        
        RegionGCHistory(int regionCount, long pauseTime) {
            this.regionCount = regionCount;
            this.pauseTime = pauseTime;
        }
    }
}
```

---

## 2. Region-basedå†…å­˜ç®¡ç†

### 2.1 Regionç»“æ„è®¾è®¡

#### **Regionå®ç°**

```java
/**
 * G1 Region-basedå†…å­˜ç®¡ç†å®ç°
 */
public class G1RegionManagement {
    
    /**
     * G1 Regionå®ç°
     */
    static class G1Region {
        // Regionç±»å‹
        public enum RegionType {
            FREE,           // ç©ºé—²Region
            EDEN,           // EdenåŒºRegion
            SURVIVOR,       // SurvivoråŒºRegion
            OLD,            // è€å¹´ä»£Region
            HUMONGOUS,      // å¤§å¯¹è±¡Region
            PINNED          // å›ºå®šRegionï¼ˆä¸å¯å›æ”¶ï¼‰
        }
        
        private final int regionId;
        private final long startAddress;
        private final int size;
        private RegionType type;
        private long usedBytes;
        private long wasteBytes;
        private final Set<Integer> rememberSet; // Remember Set
        private boolean markedForCollection;
        private double garbageRatio;
        
        public G1Region(int regionId, long startAddress, int size) {
            this.regionId = regionId;
            this.startAddress = startAddress;
            this.size = size;
            this.type = RegionType.FREE;
            this.usedBytes = 0;
            this.wasteBytes = 0;
            this.rememberSet = new HashSet<>();
            this.markedForCollection = false;
            this.garbageRatio = 0.0;
        }
        
        /**
         * åˆ†é…å¯¹è±¡
         */
        public long allocateObject(int objectSize) {
            if (type == RegionType.FREE) {
                throw new IllegalStateException("Cannot allocate in FREE region");
            }
            
            if (usedBytes + objectSize > size) {
                return -1; // åˆ†é…å¤±è´¥
            }
            
            long objectAddress = startAddress + usedBytes;
            usedBytes += objectSize;
            
            return objectAddress;
        }
        
        /**
         * è®¡ç®—åƒåœ¾æ¯”ä¾‹
         */
        public void calculateGarbageRatio(Set<Long> liveObjects) {
            long liveBytes = 0;
            for (Long objAddr : liveObjects) {
                if (objAddr >= startAddress && objAddr < startAddress + size) {
                    liveBytes += getObjectSize(objAddr);
                }
            }
            
            long garbageBytes = usedBytes - liveBytes;
            this.garbageRatio = (double) garbageBytes / usedBytes;
        }
        
        private int getObjectSize(long address) {
            // æ¨¡æ‹Ÿè·å–å¯¹è±¡å¤§å°
            return 64; // å‡è®¾å¹³å‡å¯¹è±¡å¤§å°64å­—èŠ‚
        }
        
        /**
         * é‡ç½®Region
         */
        public void reset() {
            this.type = RegionType.FREE;
            this.usedBytes = 0;
            this.wasteBytes = 0;
            this.rememberSet.clear();
            this.markedForCollection = false;
            this.garbageRatio = 0.0;
        }
        
        // getterå’Œsetteræ–¹æ³•
        public int getRegionId() { return regionId; }
        public long getStartAddress() { return startAddress; }
        public int getSize() { return size; }
        public RegionType getType() { return type; }
        public void setType(RegionType type) { this.type = type; }
        public long getUsedBytes() { return usedBytes; }
        public double getUsageRate() { return (double) usedBytes / size; }
        public Set<Integer> getRememberSet() { return rememberSet; }
        public boolean isMarkedForCollection() { return markedForCollection; }
        public void setMarkedForCollection(boolean marked) { this.markedForCollection = marked; }
        public double getGarbageRatio() { return garbageRatio; }
    }
    
    /**
     * Regionç®¡ç†å™¨
     */
    static class G1RegionManager {
        private final G1Region[] regions;
        private final int totalRegions;
        private final Queue<Integer> freeRegions;
        private final Map<G1Region.RegionType, List<Integer>> regionsByType;
        
        public G1RegionManager() {
            this.totalRegions = G1GCDesignPrinciples.G1Configuration.TOTAL_REGIONS;
            this.regions = new G1Region[totalRegions];
            this.freeRegions = new LinkedList<>();
            this.regionsByType = new EnumMap<>(G1Region.RegionType.class);
            
            initializeRegions();
        }
        
        private void initializeRegions() {
            for (int i = 0; i < totalRegions; i++) {
                long startAddr = (long) i * G1GCDesignPrinciples.G1Configuration.REGION_SIZE;
                regions[i] = new G1Region(i, startAddr, G1GCDesignPrinciples.G1Configuration.REGION_SIZE);
                freeRegions.offer(i);
            }
            
            // åˆå§‹åŒ–ç±»å‹æ˜ å°„
            for (G1Region.RegionType type : G1Region.RegionType.values()) {
                regionsByType.put(type, new ArrayList<>());
            }
            
            // æ‰€æœ‰Regionåˆå§‹ä¸ºFREE
            regionsByType.get(G1Region.RegionType.FREE).addAll(freeRegions);
        }
        
        /**
         * åˆ†é…Region
         */
        public G1Region allocateRegion(G1Region.RegionType type) {
            Integer regionId = freeRegions.poll();
            if (regionId == null) {
                return null; // æ²¡æœ‰å¯ç”¨Region
            }
            
            G1Region region = regions[regionId];
            region.setType(type);
            
            // æ›´æ–°ç±»å‹æ˜ å°„
            regionsByType.get(G1Region.RegionType.FREE).remove(regionId);
            regionsByType.get(type).add(regionId);
            
            System.out.println("åˆ†é…Region " + regionId + " ä½œä¸º " + type);
            return region;
        }
        
        /**
         * é‡Šæ”¾Region
         */
        public void freeRegion(int regionId) {
            G1Region region = regions[regionId];
            G1Region.RegionType oldType = region.getType();
            
            // æ›´æ–°ç±»å‹æ˜ å°„
            regionsByType.get(oldType).remove(Integer.valueOf(regionId));
            regionsByType.get(G1Region.RegionType.FREE).add(regionId);
            
            // é‡ç½®Region
            region.reset();
            freeRegions.offer(regionId);
            
            System.out.println("é‡Šæ”¾Region " + regionId + " (åŸç±»å‹: " + oldType + ")");
        }
        
        /**
         * è·å–æŒ‡å®šç±»å‹çš„Regionåˆ—è¡¨
         */
        public List<G1Region> getRegionsByType(G1Region.RegionType type) {
            return regionsByType.get(type).stream()
                    .map(id -> regions[id])
                    .collect(Collectors.toList());
        }
        
        /**
         * é€‰æ‹©å›æ”¶å€™é€‰Region
         */
        public List<G1Region> selectCollectionCandidates(int maxRegions) {
            List<G1Region> candidates = new ArrayList<>();
            
            // è·å–æ‰€æœ‰è€å¹´ä»£Region
            List<G1Region> oldRegions = getRegionsByType(G1Region.RegionType.OLD);
            
            // æŒ‰åƒåœ¾æ¯”ä¾‹æ’åºï¼Œä¼˜å…ˆé€‰æ‹©åƒåœ¾å¤šçš„Region
            oldRegions.sort((r1, r2) -> Double.compare(r2.getGarbageRatio(), r1.getGarbageRatio()));
            
            // é€‰æ‹©å‰maxRegionsä¸ªRegion
            for (int i = 0; i < Math.min(maxRegions, oldRegions.size()); i++) {
                G1Region region = oldRegions.get(i);
                if (region.getGarbageRatio() > 0.1) { // åƒåœ¾æ¯”ä¾‹è¶…è¿‡10%æ‰è€ƒè™‘å›æ”¶
                    candidates.add(region);
                    region.setMarkedForCollection(true);
                }
            }
            
            return candidates;
        }
        
        /**
         * æ‰“å°Regionç»Ÿè®¡ä¿¡æ¯
         */
        public void printRegionStatistics() {
            System.out.println("=== Regionç»Ÿè®¡ä¿¡æ¯ ===");
            
            for (G1Region.RegionType type : G1Region.RegionType.values()) {
                List<Integer> regionIds = regionsByType.get(type);
                long totalUsed = regionIds.stream()
                        .mapToLong(id -> regions[id].getUsedBytes())
                        .sum();
                
                System.out.println(type + ": " + regionIds.size() + " ä¸ªRegion, " +
                                 "ä½¿ç”¨ " + (totalUsed / 1024 / 1024) + "MB");
            }
            
            System.out.println("æ€»Regionæ•°: " + totalRegions);
            System.out.println("ç©ºé—²Regionæ•°: " + freeRegions.size());
        }
    }
    
    /**
     * å¤§å¯¹è±¡å¤„ç†
     */
    static class HumongousObjectHandler {
        private final G1RegionManager regionManager;
        
        // å¤§å¯¹è±¡é˜ˆå€¼ï¼šRegionå¤§å°çš„50%
        private static final int HUMONGOUS_THRESHOLD = 
                G1GCDesignPrinciples.G1Configuration.REGION_SIZE / 2;
        
        public HumongousObjectHandler(G1RegionManager regionManager) {
            this.regionManager = regionManager;
        }
        
        /**
         * åˆ†é…å¤§å¯¹è±¡
         */
        public long allocateHumongousObject(int objectSize) {
            if (objectSize < HUMONGOUS_THRESHOLD) {
                throw new IllegalArgumentException("Object size " + objectSize + 
                                                 " is not humongous (threshold: " + HUMONGOUS_THRESHOLD + ")");
            }
            
            // è®¡ç®—éœ€è¦çš„Regionæ•°é‡
            int regionsNeeded = (objectSize + G1GCDesignPrinciples.G1Configuration.REGION_SIZE - 1) / 
                               G1GCDesignPrinciples.G1Configuration.REGION_SIZE;
            
            System.out.println("å¤§å¯¹è±¡åˆ†é…: å¤§å°=" + (objectSize / 1024 / 1024) + "MB, " +
                             "éœ€è¦Regionæ•°=" + regionsNeeded);
            
            // åˆ†é…è¿ç»­çš„Region
            List<G1Region> allocatedRegions = new ArrayList<>();
            for (int i = 0; i < regionsNeeded; i++) {
                G1Region region = regionManager.allocateRegion(G1Region.RegionType.HUMONGOUS);
                if (region == null) {
                    // åˆ†é…å¤±è´¥ï¼Œé‡Šæ”¾å·²åˆ†é…çš„Region
                    allocatedRegions.forEach(r -> regionManager.freeRegion(r.getRegionId()));
                    return -1;
                }
                allocatedRegions.add(region);
            }
            
            // åœ¨ç¬¬ä¸€ä¸ªRegionä¸­åˆ†é…å¯¹è±¡
            G1Region firstRegion = allocatedRegions.get(0);
            return firstRegion.allocateObject(objectSize);
        }
        
        /**
         * æ£€æŸ¥æ˜¯å¦ä¸ºå¤§å¯¹è±¡
         */
        public boolean isHumongousObject(int objectSize) {
            return objectSize >= HUMONGOUS_THRESHOLD;
        }
    }
}
```

---

## 3. G1å¹¶å‘æ ‡è®°ç®—æ³•

### 3.1 SATB (Snapshot-At-The-Beginning) ç®—æ³•

#### **SATBå®ç°**

```java
/**
 * G1å¹¶å‘æ ‡è®°ç®—æ³•å®ç°
 */
public class G1ConcurrentMarking {
    
    /**
     * SATB (Snapshot-At-The-Beginning) å®ç°
     */
    static class SATBMarkingAlgorithm {
        private final Set<Long> markedObjects = ConcurrentHashMap.newKeySet();
        private final Queue<Long> satbQueue = new ConcurrentLinkedQueue<>();
        private final AtomicBoolean markingActive = new AtomicBoolean(false);
        private final G1RegionManagement.G1RegionManager regionManager;
        
        public SATBMarkingAlgorithm(G1RegionManagement.G1RegionManager regionManager) {
            this.regionManager = regionManager;
        }
        
        /**
         * å¼€å§‹å¹¶å‘æ ‡è®°
         */
        public void startConcurrentMarking() {
            System.out.println("=== å¼€å§‹G1å¹¶å‘æ ‡è®° ===");
            
            markingActive.set(true);
            markedObjects.clear();
            
            // é˜¶æ®µ1: åˆå§‹æ ‡è®° (STW)
            initialMark();
            
            // é˜¶æ®µ2: å¹¶å‘æ ‡è®° (å¹¶å‘æ‰§è¡Œ)
            Thread markingThread = new Thread(this::concurrentMark);
            markingThread.start();
            
            // æ¨¡æ‹Ÿåº”ç”¨ç¨‹åºç»§ç»­è¿è¡Œ
            simulateApplicationExecution();
            
            try {
                markingThread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            // é˜¶æ®µ3: æœ€ç»ˆæ ‡è®° (STW)
            finalMark();
            
            markingActive.set(false);
            System.out.println("å¹¶å‘æ ‡è®°å®Œæˆ");
        }
        
        /**
         * åˆå§‹æ ‡è®°é˜¶æ®µ (STW)
         */
        private void initialMark() {
            System.out.println("=== åˆå§‹æ ‡è®°é˜¶æ®µ (STW) ===");
            long startTime = System.nanoTime();
            
            // æ ‡è®°æ‰€æœ‰GC Rootsç›´æ¥å¼•ç”¨çš„å¯¹è±¡
            Set<Long> gcRoots = findGCRoots();
            for (Long rootAddress : gcRoots) {
                markObject(rootAddress);
            }
            
            long endTime = System.nanoTime();
            System.out.println("åˆå§‹æ ‡è®°å®Œæˆ: " + markedObjects.size() + " ä¸ªå¯¹è±¡, " +
                             "è€—æ—¶: " + ((endTime - startTime) / 1_000_000.0) + "ms");
        }
        
        /**
         * å¹¶å‘æ ‡è®°é˜¶æ®µ (å¹¶å‘æ‰§è¡Œ)
         */
        private void concurrentMark() {
            System.out.println("=== å¹¶å‘æ ‡è®°é˜¶æ®µ (å¹¶å‘æ‰§è¡Œ) ===");
            long startTime = System.nanoTime();
            
            // ä»å·²æ ‡è®°å¯¹è±¡å¼€å§‹ï¼Œéå†å¯¹è±¡å›¾
            Queue<Long> workQueue = new LinkedList<>(markedObjects);
            
            while (!workQueue.isEmpty() || !satbQueue.isEmpty()) {
                // å¤„ç†å·¥ä½œé˜Ÿåˆ—
                while (!workQueue.isEmpty()) {
                    Long objectAddress = workQueue.poll();
                    List<Long> references = getObjectReferences(objectAddress);
                    
                    for (Long refAddress : references) {
                        if (markObject(refAddress)) {
                            workQueue.offer(refAddress);
                        }
                    }
                    
                    // æ¨¡æ‹Ÿå¹¶å‘æ‰§è¡Œçš„å»¶è¿Ÿ
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return;
                    }
                }
                
                // å¤„ç†SATBé˜Ÿåˆ—
                while (!satbQueue.isEmpty()) {
                    Long satbObject = satbQueue.poll();
                    if (markObject(satbObject)) {
                        workQueue.offer(satbObject);
                    }
                }
            }
            
            long endTime = System.nanoTime();
            System.out.println("å¹¶å‘æ ‡è®°å®Œæˆ: æ€»æ ‡è®°å¯¹è±¡ " + markedObjects.size() + " ä¸ª, " +
                             "è€—æ—¶: " + ((endTime - startTime) / 1_000_000.0) + "ms");
        }
        
        /**
         * æœ€ç»ˆæ ‡è®°é˜¶æ®µ (STW)
         */
        private void finalMark() {
            System.out.println("=== æœ€ç»ˆæ ‡è®°é˜¶æ®µ (STW) ===");
            long startTime = System.nanoTime();
            
            // å¤„ç†å‰©ä½™çš„SATBé˜Ÿåˆ—
            while (!satbQueue.isEmpty()) {
                Long satbObject = satbQueue.poll();
                if (markObject(satbObject)) {
                    // æ ‡è®°æ–°å‘ç°çš„å¯¹è±¡çš„å¼•ç”¨
                    List<Long> references = getObjectReferences(satbObject);
                    for (Long refAddress : references) {
                        markObject(refAddress);
                    }
                }
            }
            
            long endTime = System.nanoTime();
            System.out.println("æœ€ç»ˆæ ‡è®°å®Œæˆ: æœ€ç»ˆæ ‡è®°å¯¹è±¡ " + markedObjects.size() + " ä¸ª, " +
                             "è€—æ—¶: " + ((endTime - startTime) / 1_000_000.0) + "ms");
        }
        
        /**
         * æ ‡è®°å¯¹è±¡
         */
        private boolean markObject(Long objectAddress) {
            if (objectAddress == null || objectAddress == 0) {
                return false;
            }
            
            return markedObjects.add(objectAddress);
        }
        
        /**
         * SATBå†™å±éšœ
         * å½“åº”ç”¨ç¨‹åºä¿®æ”¹å¼•ç”¨æ—¶è°ƒç”¨
         */
        public void satbWriteBarrier(long objectAddress, long oldReference, long newReference) {
            if (!markingActive.get()) {
                return;
            }
            
            // å°†æ—§å¼•ç”¨åŠ å…¥SATBé˜Ÿåˆ—
            if (oldReference != 0) {
                satbQueue.offer(oldReference);
                System.out.println("SATBå†™å±éšœ: å¯¹è±¡=" + objectAddress + 
                                 ", æ—§å¼•ç”¨=" + oldReference + " åŠ å…¥SATBé˜Ÿåˆ—");
            }
        }
        
        /**
         * æ¨¡æ‹Ÿåº”ç”¨ç¨‹åºæ‰§è¡Œ
         */
        private void simulateApplicationExecution() {
            System.out.println("=== æ¨¡æ‹Ÿåº”ç”¨ç¨‹åºæ‰§è¡Œ ===");
            
            // æ¨¡æ‹Ÿåº”ç”¨ç¨‹åºåœ¨å¹¶å‘æ ‡è®°æœŸé—´ä¿®æ”¹å¯¹è±¡å¼•ç”¨
            Thread appThread = new Thread(() -> {
                for (int i = 0; i < 10; i++) {
                    // æ¨¡æ‹Ÿå¼•ç”¨ä¿®æ”¹
                    long objectAddr = 1000 + i;
                    long oldRef = 2000 + i;
                    long newRef = 3000 + i;
                    
                    satbWriteBarrier(objectAddr, oldRef, newRef);
                    
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return;
                    }
                }
            });
            
            appThread.start();
            try {
                appThread.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        private Set<Long> findGCRoots() {
            // æ¨¡æ‹ŸæŸ¥æ‰¾GC Roots
            Set<Long> roots = new HashSet<>();
            for (int i = 1; i <= 10; i++) {
                roots.add((long) i * 1000);
            }
            return roots;
        }
        
        private List<Long> getObjectReferences(Long objectAddress) {
            // æ¨¡æ‹Ÿè·å–å¯¹è±¡å¼•ç”¨
            List<Long> references = new ArrayList<>();
            
            // å‡è®¾æ¯ä¸ªå¯¹è±¡å¼•ç”¨2-3ä¸ªå…¶ä»–å¯¹è±¡
            int refCount = 2 + (int) (objectAddress % 2);
            for (int i = 0; i < refCount; i++) {
                references.add(objectAddress + 100 + i * 10);
            }
            
            return references;
        }
        
        public Set<Long> getMarkedObjects() {
            return new HashSet<>(markedObjects);
        }
    }
    
    /**
     * å¹¶å‘æ ‡è®°çº¿ç¨‹ç®¡ç†
     */
    static class ConcurrentMarkingThreadManager {
        private final int concurrentThreads;
        private final ExecutorService markingExecutor;
        
        public ConcurrentMarkingThreadManager() {
            this.concurrentThreads = G1GCDesignPrinciples.G1Configuration.CONCURRENT_THREADS;
            this.markingExecutor = Executors.newFixedThreadPool(concurrentThreads);
        }
        
        /**
         * å¹¶è¡Œæ‰§è¡Œæ ‡è®°ä»»åŠ¡
         */
        public void executeMarkingTasks(List<MarkingTask> tasks) {
            System.out.println("=== å¹¶è¡Œæ‰§è¡Œæ ‡è®°ä»»åŠ¡ ===");
            System.out.println("å¹¶å‘çº¿ç¨‹æ•°: " + concurrentThreads);
            System.out.println("æ ‡è®°ä»»åŠ¡æ•°: " + tasks.size());
            
            List<Future<MarkingResult>> futures = new ArrayList<>();
            
            for (MarkingTask task : tasks) {
                Future<MarkingResult> future = markingExecutor.submit(task);
                futures.add(future);
            }
            
            // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
            List<MarkingResult> results = new ArrayList<>();
            for (Future<MarkingResult> future : futures) {
                try {
                    MarkingResult result = future.get();
                    results.add(result);
                } catch (InterruptedException | ExecutionException e) {
                    System.err.println("æ ‡è®°ä»»åŠ¡æ‰§è¡Œå¤±è´¥: " + e.getMessage());
                }
            }
            
            // æ±‡æ€»ç»“æœ
            summarizeMarkingResults(results);
        }
        
        private void summarizeMarkingResults(List<MarkingResult> results) {
            int totalMarkedObjects = results.stream()
                    .mapToInt(MarkingResult::getMarkedObjectCount)
                    .sum();
            
            long totalTime = results.stream()
                    .mapToLong(MarkingResult::getExecutionTimeMs)
                    .max()
                    .orElse(0);
            
            System.out.println("æ ‡è®°ç»“æœæ±‡æ€»:");
            System.out.println("- æ€»æ ‡è®°å¯¹è±¡æ•°: " + totalMarkedObjects);
            System.out.println("- æ€»æ‰§è¡Œæ—¶é—´: " + totalTime + "ms");
            System.out.println("- å¹³å‡æ ‡è®°é€Ÿåº¦: " + (totalMarkedObjects * 1000.0 / totalTime) + " å¯¹è±¡/ç§’");
        }
        
        public void shutdown() {
            markingExecutor.shutdown();
            try {
                if (!markingExecutor.awaitTermination(60, TimeUnit.SECONDS)) {
                    markingExecutor.shutdownNow();
                }
            } catch (InterruptedException e) {
                markingExecutor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
    }
    
    /**
     * æ ‡è®°ä»»åŠ¡
     */
    static class MarkingTask implements Callable<MarkingResult> {
        private final List<G1RegionManagement.G1Region> regions;
        private final Set<Long> markedObjects;
        
        public MarkingTask(List<G1RegionManagement.G1Region> regions, Set<Long> markedObjects) {
            this.regions = regions;
            this.markedObjects = markedObjects;
        }
        
        @Override
        public MarkingResult call() {
            long startTime = System.currentTimeMillis();
            int markedCount = 0;
            
            for (G1RegionManagement.G1Region region : regions) {
                markedCount += markRegion(region);
            }
            
            long endTime = System.currentTimeMillis();
            
            return new MarkingResult(markedCount, endTime - startTime);
        }
        
        private int markRegion(G1RegionManagement.G1Region region) {
            // æ¨¡æ‹Ÿæ ‡è®°Regionä¸­çš„å¯¹è±¡
            int objectCount = (int) (region.getUsedBytes() / 64); // å‡è®¾å¹³å‡å¯¹è±¡å¤§å°64å­—èŠ‚
            
            for (int i = 0; i < objectCount; i++) {
                long objectAddr = region.getStartAddress() + i * 64;
                markedObjects.add(objectAddr);
            }
            
            return objectCount;
        }
    }
    
    /**
     * æ ‡è®°ç»“æœ
     */
    static class MarkingResult {
        private final int markedObjectCount;
        private final long executionTimeMs;
        
        public MarkingResult(int markedObjectCount, long executionTimeMs) {
            this.markedObjectCount = markedObjectCount;
            this.executionTimeMs = executionTimeMs;
        }
        
        public int getMarkedObjectCount() { return markedObjectCount; }
        public long getExecutionTimeMs() { return executionTimeMs; }
    }
}
```

ç°åœ¨è®©æˆ‘ç»§ç»­å®ŒæˆG1 GCçš„æ ¸å¿ƒæœºåˆ¶ï¼ŒåŒ…æ‹¬æ··åˆå›æ”¶å’ŒRemember Setå®ç°ï¼š

<function_calls>
<invoke name="execute_command">
<parameter name="command">mkdir -p /data/workspace/openjdk11-core/jvm_book-1/chapter_17_g1gc/src/main/java/com/g1gc