# ç¬¬09ç« ï¼šJVMæ€§èƒ½è°ƒä¼˜æ·±åº¦æ¡ˆä¾‹ - æºç çº§æ·±åº¦å¢å¼ºç‰ˆ

## ğŸ“‹ ç« èŠ‚æ¦‚è¿°

æœ¬ç« åŸºäºå‰é¢8ç« çš„æ·±åº¦æŠ€æœ¯åˆ†æï¼Œç»“åˆç”Ÿäº§ç¯å¢ƒå®é™…éœ€æ±‚ï¼Œä»æºç å±‚é¢æ·±å…¥åˆ†æJVMæ€§èƒ½è°ƒä¼˜æœºåˆ¶ã€‚é€šè¿‡å®Œæ•´çš„C++æºç åˆ†æã€GDBæ·±åº¦è°ƒè¯•å’Œå®é™…æµ‹è¯•ï¼Œæä¾›ä¼ä¸šçº§æ€§èƒ½ä¼˜åŒ–è§£å†³æ–¹æ¡ˆã€‚

### ğŸ¯ æ·±åº¦å­¦ä¹ ç›®æ ‡

- **æºç çº§ç†è§£**: æŒæ¡JVMæ€§èƒ½ç›‘æ§å’Œè°ƒä¼˜çš„åº•å±‚å®ç°æœºåˆ¶
- **ç®—æ³•æ·±åº¦åˆ†æ**: ç†è§£G1GCã€JITç¼–è¯‘å™¨ã€å†…å­˜ç®¡ç†çš„æ ¸å¿ƒç®—æ³•
- **ä¸“ä¸šçº§è°ƒä¼˜**: å»ºç«‹ç³»ç»Ÿæ€§çš„æ€§èƒ½è°ƒä¼˜æ–¹æ³•è®ºå’Œç›‘æ§ä½“ç³»
- **ç”Ÿäº§ç¯å¢ƒå®æˆ˜**: å…·å¤‡è§£å†³å¤æ‚æ€§èƒ½é—®é¢˜çš„ä¸“å®¶çº§èƒ½åŠ›
- **å·¥å…·é“¾ç²¾é€š**: æ·±åº¦æŒæ¡æ€§èƒ½åˆ†æå·¥å…·çš„åŸç†å’Œä½¿ç”¨

## ğŸ”¬ æ ¸å¿ƒæŠ€æœ¯æºç åˆ†æ

### 1. JVMæ€§èƒ½ç›‘æ§åŸºç¡€è®¾æ–½

#### 1.1 PerfDataæ€§èƒ½æ•°æ®æ”¶é›†æœºåˆ¶

JVMå†…éƒ¨ä½¿ç”¨PerfDataæœºåˆ¶æ”¶é›†å„ç§æ€§èƒ½æŒ‡æ ‡ï¼Œè¿™æ˜¯æ‰€æœ‰ç›‘æ§å·¥å…·çš„æ•°æ®æºã€‚

```cpp
// hotspot/src/share/runtime/perfData.hpp
class PerfData : public CHeapObj<mtInternal> {
private:
  CounterNS _ns;           // å‘½åç©ºé—´
  const char* _name;       // æ€§èƒ½è®¡æ•°å™¨åç§°
  Units _u;                // å•ä½ç±»å‹
  Variability _v;          // å˜åŒ–æ€§
  PerfDataEntry* _pdep;    // æ€§èƒ½æ•°æ®æ¡ç›®

public:
  // åˆ›å»ºæ€§èƒ½è®¡æ•°å™¨
  static PerfCounter* create_counter(CounterNS ns, const char* name,
                                   PerfData::Units u, jlong initial_value = 0);
  
  // æ›´æ–°è®¡æ•°å™¨å€¼
  void inc(jlong value = 1);
  void add(jlong value);
  void set_value(jlong value);
  
  // è·å–è®¡æ•°å™¨å€¼
  jlong value() const { return _pdep->value(); }
  
  // æ€§èƒ½æ•°æ®åºåˆ—åŒ–
  void serialize(PerfDataBuffer* buffer);
};

// æ€§èƒ½æ•°æ®ç®¡ç†å™¨
class PerfDataManager : AllStatic {
private:
  static PerfDataList* _all;           // æ‰€æœ‰æ€§èƒ½æ•°æ®åˆ—è¡¨
  static PerfDataList* _sampled;       // é‡‡æ ·æ•°æ®åˆ—è¡¨
  static PerfDataList* _constants;     // å¸¸é‡æ•°æ®åˆ—è¡¨
  static volatile bool _has_PerfData;  // æ˜¯å¦å¯ç”¨æ€§èƒ½æ•°æ®

public:
  // åˆå§‹åŒ–æ€§èƒ½æ•°æ®ç³»ç»Ÿ
  static void initialize();
  
  // åˆ›å»ºæ€§èƒ½è®¡æ•°å™¨
  static PerfCounter* create_counter(CounterNS ns, const char* name,
                                   PerfData::Units u, jlong initial_value = 0);
  
  // åˆ›å»ºæ€§èƒ½å˜é‡
  static PerfVariable* create_variable(CounterNS ns, const char* name,
                                     PerfData::Units u, jlong initial_value = 0);
  
  // åˆ›å»ºæ€§èƒ½å¸¸é‡
  static PerfConstant* create_constant(CounterNS ns, const char* name,
                                     PerfData::Units u, jlong value);
  
  // é”€æ¯æ€§èƒ½æ•°æ®
  static void destroy();
  
  // éå†æ‰€æœ‰æ€§èƒ½æ•°æ®
  static void iterate(PerfDataVisitor* visitor);
};

// æ€§èƒ½æ•°æ®ç¼“å†²åŒº
class PerfDataBuffer {
private:
  char* _buffer;           // æ•°æ®ç¼“å†²åŒº
  size_t _buffer_size;     // ç¼“å†²åŒºå¤§å°
  size_t _used;            // å·²ä½¿ç”¨å¤§å°
  bool _overflow;          // æ˜¯å¦æº¢å‡º

public:
  PerfDataBuffer(size_t buffer_size);
  ~PerfDataBuffer();
  
  // å†™å…¥æ•°æ®
  void write_bytes(const void* data, size_t len);
  void write_string(const char* str);
  void write_int(jint value);
  void write_long(jlong value);
  
  // è·å–ç¼“å†²åŒºä¿¡æ¯
  char* buffer() const { return _buffer; }
  size_t used() const { return _used; }
  bool overflow() const { return _overflow; }
};
```

#### 1.2 å†…å­˜ä½¿ç”¨ç›‘æ§å®ç°

```cpp
// hotspot/src/share/services/memoryService.cpp
class MemoryService : public AllStatic {
private:
  static MemoryPool** _pools_list;     // å†…å­˜æ± åˆ—è¡¨
  static MemoryManager** _managers_list; // å†…å­˜ç®¡ç†å™¨åˆ—è¡¨
  static int _num_pools;               // å†…å­˜æ± æ•°é‡
  static int _num_managers;            // ç®¡ç†å™¨æ•°é‡

public:
  // åˆå§‹åŒ–å†…å­˜æœåŠ¡
  static void initialize();
  
  // è·å–å †å†…å­˜ä½¿ç”¨æƒ…å†µ
  static MemoryUsage get_heap_memory_usage() {
    CollectedHeap* heap = Universe::heap();
    size_t used = heap->used();
    size_t committed = heap->capacity();
    size_t max_size = heap->max_capacity();
    
    return MemoryUsage(0, used, committed, max_size);
  }
  
  // è·å–éå †å†…å­˜ä½¿ç”¨æƒ…å†µ
  static MemoryUsage get_non_heap_memory_usage() {
    MetaspaceUsage metaspace_usage = MetaspaceUtils::get_combined_statistics();
    return MemoryUsage(0, 
                      metaspace_usage.used(), 
                      metaspace_usage.committed(),
                      metaspace_usage.reserved());
  }
  
  // è·å–å†…å­˜æ± ä½¿ç”¨æƒ…å†µ
  static MemoryUsage get_memory_pool_usage(int pool_id) {
    assert(pool_id >= 0 && pool_id < _num_pools, "Invalid pool id");
    return _pools_list[pool_id]->get_memory_usage();
  }
  
  // å†…å­˜ä½¿ç”¨é˜ˆå€¼æ£€æŸ¥
  static void check_memory_usage_thresholds();
  
  // è§¦å‘å†…å­˜ä½¿ç”¨é€šçŸ¥
  static void oops_do(OopClosure* f);
};

// å†…å­˜æ± å®ç°
class MemoryPool : public CHeapObj<mtInternal> {
protected:
  const char* _name;           // å†…å­˜æ± åç§°
  PoolType _type;              // æ± ç±»å‹
  size_t _initial_size;        // åˆå§‹å¤§å°
  size_t _max_size;            // æœ€å¤§å¤§å°
  bool _available_for_allocation; // æ˜¯å¦å¯ç”¨äºåˆ†é…
  
  // ä½¿ç”¨é˜ˆå€¼
  ThresholdSupport _usage_threshold;
  ThresholdSupport _gc_usage_threshold;

public:
  MemoryPool(const char* name, PoolType type, size_t init_size, 
             size_t max_size, bool support_usage_threshold, 
             bool support_gc_threshold);
  
  // è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
  virtual MemoryUsage get_memory_usage() = 0;
  
  // è®¾ç½®ä½¿ç”¨é˜ˆå€¼
  void set_usage_threshold(size_t new_threshold) {
    _usage_threshold.set_threshold(new_threshold);
  }
  
  // æ£€æŸ¥é˜ˆå€¼
  bool is_usage_threshold_exceeded() {
    return _usage_threshold.is_threshold_exceeded();
  }
  
  // è·å–å³°å€¼ä½¿ç”¨é‡
  virtual size_t used_in_bytes() = 0;
  virtual size_t max_size() const { return _max_size; }
};

// G1å †å†…å­˜æ± å®ç°
class G1EdenPool : public CollectedMemoryPool {
private:
  G1CollectedHeap* _g1h;

public:
  G1EdenPool(G1CollectedHeap* g1h) : 
    CollectedMemoryPool("G1 Eden Space", MemoryPool::Heap, 0, _undefined_max, true),
    _g1h(g1h) {}
  
  MemoryUsage get_memory_usage() {
    size_t eden_used = _g1h->eden_regions_count() * HeapRegion::GrainBytes;
    size_t eden_committed = eden_used; // G1ä¸­Edenç©ºé—´æ˜¯åŠ¨æ€çš„
    
    return MemoryUsage(0, eden_used, eden_committed, _undefined_max);
  }
  
  size_t used_in_bytes() {
    return _g1h->eden_regions_count() * HeapRegion::GrainBytes;
  }
};
```

#### 1.3 GCç›‘æ§æ•°æ®æ”¶é›†

```cpp
// hotspot/src/share/gc/shared/gcTrace.cpp
class GCTracer : public ResourceObj {
protected:
  GCId _gc_id;                    // GCæ ‡è¯†
  GCName _gc_name;                // GCåç§°
  GCCause::Cause _gc_cause;       // GCåŸå› 
  Ticks _gc_start;                // GCå¼€å§‹æ—¶é—´
  Ticks _gc_end;                  // GCç»“æŸæ—¶é—´

public:
  GCTracer(GCName name) : _gc_name(name) {}
  
  // å¼€å§‹GCè·Ÿè¸ª
  void report_gc_start(GCCause::Cause cause, const Ticks& timestamp) {
    _gc_cause = cause;
    _gc_start = timestamp;
    _gc_id = GCId::current();
    
    // å‘é€GCå¼€å§‹äº‹ä»¶
    send_gc_start_event(cause, timestamp);
  }
  
  // ç»“æŸGCè·Ÿè¸ª
  void report_gc_end(const Ticks& timestamp, TimePartitions* time_partitions) {
    _gc_end = timestamp;
    
    // è®¡ç®—GCæŒç»­æ—¶é—´
    Tickspan gc_time = _gc_end - _gc_start;
    
    // å‘é€GCç»“æŸäº‹ä»¶
    send_gc_end_event(timestamp, time_partitions);
    
    // æ›´æ–°æ€§èƒ½è®¡æ•°å™¨
    update_gc_counters(gc_time);
  }
  
  // æŠ¥å‘Šå †ä¿¡æ¯
  void report_gc_heap_summary(GCWhen::Type when, const GCHeapSummary& heap_summary) {
    send_gc_heap_summary_event(when, heap_summary);
  }
  
  // æŠ¥å‘ŠMetaspaceä¿¡æ¯
  void report_metaspace_summary(GCWhen::Type when, const MetaspaceSummary& summary) {
    send_metaspace_summary_event(when, summary);
  }

private:
  // å‘é€JFRäº‹ä»¶
  void send_gc_start_event(GCCause::Cause cause, const Ticks& timestamp);
  void send_gc_end_event(const Ticks& timestamp, TimePartitions* time_partitions);
  void send_gc_heap_summary_event(GCWhen::Type when, const GCHeapSummary& summary);
  
  // æ›´æ–°æ€§èƒ½è®¡æ•°å™¨
  void update_gc_counters(const Tickspan& gc_time) {
    // æ›´æ–°GCæ¬¡æ•°
    Management::get_gc_manager(_gc_name)->_num_collections++;
    
    // æ›´æ–°GCæ—¶é—´
    Management::get_gc_manager(_gc_name)->_accumulated_time += 
      gc_time.nanoseconds() / NANOSECS_PER_MILLISEC;
  }
};

// G1GCä¸“ç”¨è·Ÿè¸ªå™¨
class G1NewTracer : public YoungGCTracer {
public:
  G1NewTracer() : YoungGCTracer(G1New) {}
  
  // æŠ¥å‘ŠG1ç‰¹å®šä¿¡æ¯
  void report_yc_type(G1YCType type) {
    send_g1_young_gc_event(type);
  }
  
  void report_gc_end_impl(const Ticks& timestamp, TimePartitions* time_partitions) {
    YoungGCTracer::report_gc_end_impl(timestamp, time_partitions);
    
    // æŠ¥å‘ŠG1ç‰¹å®šçš„ç»Ÿè®¡ä¿¡æ¯
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    report_evacuation_info(g1h->evacuation_info());
  }
  
private:
  void send_g1_young_gc_event(G1YCType type);
  void report_evacuation_info(EvacuationInfo* info);
};
```

### 2. JITç¼–è¯‘å™¨æ€§èƒ½ç›‘æ§

#### 2.1 ç¼–è¯‘å™¨æ´»åŠ¨ç›‘æ§

```cpp
// hotspot/src/share/compiler/compileBroker.cpp
class CompileBroker : AllStatic {
private:
  static CompileQueue* _c1_compile_queue;    // C1ç¼–è¯‘é˜Ÿåˆ—
  static CompileQueue* _c2_compile_queue;    // C2ç¼–è¯‘é˜Ÿåˆ—
  static CompilerThread** _compiler_threads; // ç¼–è¯‘çº¿ç¨‹æ•°ç»„
  static int _c1_compile_thread_count;       // C1ç¼–è¯‘çº¿ç¨‹æ•°
  static int _c2_compile_thread_count;       // C2ç¼–è¯‘çº¿ç¨‹æ•°
  
  // ç¼–è¯‘ç»Ÿè®¡ä¿¡æ¯
  static elapsedTimer _t_total_compilation;  // æ€»ç¼–è¯‘æ—¶é—´
  static elapsedTimer _t_osr_compilation;    // OSRç¼–è¯‘æ—¶é—´
  static elapsedTimer _t_standard_compilation; // æ ‡å‡†ç¼–è¯‘æ—¶é—´
  
  static int _total_compile_count;           // æ€»ç¼–è¯‘æ¬¡æ•°
  static int _total_bailout_count;           // ç¼–è¯‘å¤±è´¥æ¬¡æ•°
  static int _total_invalidated_count;       // æ— æ•ˆåŒ–æ¬¡æ•°
  static int _total_native_compile_count;    // æœ¬åœ°ç¼–è¯‘æ¬¡æ•°
  static int _total_osr_compile_count;       // OSRç¼–è¯‘æ¬¡æ•°

public:
  // åˆå§‹åŒ–ç¼–è¯‘ä»£ç†
  static void initialize();
  
  // ç¼–è¯‘æ–¹æ³•
  static nmethod* compile_method(const methodHandle& method, int osr_bci,
                               int comp_level, const methodHandle& hot_method,
                               int hot_count, CompileTask::CompileReason compile_reason,
                               Thread* thread);
  
  // è·å–ç¼–è¯‘ç»Ÿè®¡ä¿¡æ¯
  static void print_compiler_threads_on(outputStream* st) {
    st->print_cr("C1 compile threads: %d", _c1_compile_thread_count);
    st->print_cr("C2 compile threads: %d", _c2_compile_thread_count);
    
    // æ‰“å°é˜Ÿåˆ—çŠ¶æ€
    st->print_cr("C1 compile queue size: %d", _c1_compile_queue->size());
    st->print_cr("C2 compile queue size: %d", _c2_compile_queue->size());
  }
  
  // è·å–ç¼–è¯‘æ—¶é—´ç»Ÿè®¡
  static void print_times(bool per_compiler, bool aggregate) {
    if (aggregate) {
      tty->print_cr("Total compilation time: %6.3f s", 
                   _t_total_compilation.seconds());
      tty->print_cr("Standard compilation time: %6.3f s", 
                   _t_standard_compilation.seconds());
      tty->print_cr("OSR compilation time: %6.3f s", 
                   _t_osr_compilation.seconds());
    }
  }
  
  // ç¼–è¯‘ä»»åŠ¡ç»Ÿè®¡
  static void print_compilation_statistics(outputStream* st) {
    st->print_cr("Total compiles: %d", _total_compile_count);
    st->print_cr("Total bailouts: %d", _total_bailout_count);
    st->print_cr("Total invalidated: %d", _total_invalidated_count);
    st->print_cr("Native compiles: %d", _total_native_compile_count);
    st->print_cr("OSR compiles: %d", _total_osr_compile_count);
  }

private:
  // æ›´æ–°ç¼–è¯‘ç»Ÿè®¡
  static void update_compile_perf_data(CompilerThread* thread, Method* method, bool is_osr) {
    if (is_osr) {
      _total_osr_compile_count++;
      _t_osr_compilation.add(thread->get_compilation_time());
    } else {
      _t_standard_compilation.add(thread->get_compilation_time());
    }
    _total_compile_count++;
  }
};

// ç¼–è¯‘ä»»åŠ¡
class CompileTask : public CHeapObj<mtCompiler> {
private:
  Method* _method;                    // å¾…ç¼–è¯‘æ–¹æ³•
  int _osr_bci;                      // OSRå­—èŠ‚ç ç´¢å¼•
  int _comp_level;                   // ç¼–è¯‘çº§åˆ«
  int _compile_id;                   // ç¼–è¯‘ID
  CompileReason _compile_reason;     // ç¼–è¯‘åŸå› 
  
  // æ—¶é—´ç»Ÿè®¡
  jlong _time_queued;                // å…¥é˜Ÿæ—¶é—´
  jlong _time_started;               // å¼€å§‹ç¼–è¯‘æ—¶é—´
  jlong _time_finished;              // å®Œæˆç¼–è¯‘æ—¶é—´

public:
  CompileTask(Method* method, int osr_bci, int comp_level, 
             CompileReason compile_reason) :
    _method(method), _osr_bci(osr_bci), _comp_level(comp_level),
    _compile_reason(compile_reason) {
    _time_queued = os::elapsed_counter();
  }
  
  // å¼€å§‹ç¼–è¯‘
  void mark_started(jlong time) {
    _time_started = time;
  }
  
  // å®Œæˆç¼–è¯‘
  void mark_finished(jlong time) {
    _time_finished = time;
  }
  
  // è·å–ç¼–è¯‘æ—¶é—´ç»Ÿè®¡
  jlong queued_time() const { return _time_started - _time_queued; }
  jlong compile_time() const { return _time_finished - _time_started; }
  jlong total_time() const { return _time_finished - _time_queued; }
  
  // æ‰“å°ç¼–è¯‘ä¿¡æ¯
  void print_compilation(outputStream* st, const char* msg, bool short_form, bool cr) {
    jlong time = os::elapsed_counter();
    st->print("%7d ", _compile_id);    // ç¼–è¯‘ID
    st->print("%4d ", _comp_level);    // ç¼–è¯‘çº§åˆ«
    st->print("     ");                // æ ‡å¿—ä½
    
    if (short_form) {
      st->print(" %s", _method->name_and_sig_as_C_string());
    } else {
      st->print(" %s::%s", _method->method_holder()->external_name(),
               _method->name()->as_C_string());
    }
    
    if (cr) st->cr();
  }
};
```

#### 2.2 ä»£ç ç¼“å­˜ç›‘æ§

```cpp
// hotspot/src/share/code/codeCache.cpp
class CodeCache : AllStatic {
private:
  static CodeHeap* _heap;              // ä»£ç å †
  static CodeBlob* _blobs[number_of_codes]; // ä»£ç å—æ•°ç»„
  static int _number_of_blobs;         // ä»£ç å—æ•°é‡
  static int _number_of_adapters;      // é€‚é…å™¨æ•°é‡
  static size_t _unallocated_capacity; // æœªåˆ†é…å®¹é‡

public:
  // åˆå§‹åŒ–ä»£ç ç¼“å­˜
  static void initialize();
  
  // åˆ†é…ä»£ç å—
  static CodeBlob* allocate(int size, CodeBlobType type, int orig_pc_offset = 0) {
    CodeBlob* cb = NULL;
    
    // æ£€æŸ¥ä»£ç ç¼“å­˜ç©ºé—´
    if (!heap_available(size)) {
      handle_full_code_cache(type);
      return NULL;
    }
    
    // åˆ†é…å†…å­˜
    HeapBlock* block = _heap->allocate(size);
    if (block != NULL) {
      cb = new (block) CodeBlob(size, type, orig_pc_offset);
      _number_of_blobs++;
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      update_allocation_statistics(size, type);
    }
    
    return cb;
  }
  
  // é‡Šæ”¾ä»£ç å—
  static void free(CodeBlob* cb) {
    assert(cb != NULL, "CodeBlob must be non-null");
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    update_deallocation_statistics(cb->size(), cb->type());
    
    // é‡Šæ”¾å†…å­˜
    _heap->deallocate(cb);
    _number_of_blobs--;
  }
  
  // è·å–ä»£ç ç¼“å­˜ä½¿ç”¨æƒ…å†µ
  static size_t capacity() { return _heap->capacity(); }
  static size_t unallocated_capacity() { return _unallocated_capacity; }
  static size_t max_capacity() { return _heap->max_capacity(); }
  
  // ä»£ç ç¼“å­˜ç»Ÿè®¡
  static void print_summary(outputStream* st, bool detailed = true) {
    st->print_cr("CodeCache: size=" SIZE_FORMAT "Kb used=" SIZE_FORMAT 
                "Kb max_used=" SIZE_FORMAT "Kb free=" SIZE_FORMAT "Kb",
                capacity()/K, (capacity()-unallocated_capacity())/K,
                max_capacity()/K, unallocated_capacity()/K);
    
    if (detailed) {
      print_code_cache_statistics(st);
    }
  }
  
  // æ‰“å°è¯¦ç»†ç»Ÿè®¡ä¿¡æ¯
  static void print_code_cache_statistics(outputStream* st) {
    st->print_cr("Total number of blobs: %d", _number_of_blobs);
    st->print_cr("Number of adapters: %d", _number_of_adapters);
    
    // æŒ‰ç±»å‹ç»Ÿè®¡
    for (int i = 0; i < CodeBlobType::NumTypes; i++) {
      CodeBlobType type = static_cast<CodeBlobType>(i);
      st->print_cr("%s: count=%d size=" SIZE_FORMAT "Kb",
                  code_blob_type_name(type),
                  get_code_blob_count(type),
                  get_code_blob_bytes(type)/K);
    }
  }

private:
  // å¤„ç†ä»£ç ç¼“å­˜æ»¡çš„æƒ…å†µ
  static void handle_full_code_cache(CodeBlobType type) {
    // å°è¯•æ¸…ç†æ— æ•ˆçš„ä»£ç 
    bool did_cleaning = do_unloading(false);
    
    if (!did_cleaning) {
      // å¦‚æœæ¸…ç†æ— æ•ˆï¼Œè§¦å‘ä»£ç ç¼“å­˜æ»¡äº‹ä»¶
      log_warning(codecache)("CodeCache is full. Compiler has been disabled.");
      CompileBroker::set_should_compile_new_jobs(CompileBroker::stop_compilation);
    }
  }
  
  // æ›´æ–°åˆ†é…ç»Ÿè®¡
  static void update_allocation_statistics(size_t size, CodeBlobType type) {
    _unallocated_capacity -= size;
    
    // æ›´æ–°æ€§èƒ½è®¡æ•°å™¨
    if (UsePerfData) {
      _perf_total_blobs_created->inc();
      _perf_total_bytes_allocated->inc(size);
    }
  }
};
```

### 3. å†…å­˜åˆ†é…æ€§èƒ½ç›‘æ§

#### 3.1 TLABåˆ†é…ç›‘æ§

```cpp
// hotspot/src/share/gc/shared/threadLocalAllocBuffer.cpp
class ThreadLocalAllocBuffer: public CHeapObj<mtThread> {
private:
  HeapWord* _start;                    // TLABèµ·å§‹åœ°å€
  HeapWord* _top;                      // å½“å‰åˆ†é…ä½ç½®
  HeapWord* _pf_top;                   // é¢„å–é¡¶éƒ¨
  HeapWord* _end;                      // TLABç»“æŸåœ°å€
  size_t    _desired_size;             // æœŸæœ›å¤§å°
  size_t    _refill_waste_limit;       // é‡å¡«æµªè´¹é™åˆ¶
  
  // ç»Ÿè®¡ä¿¡æ¯
  unsigned  _number_of_refills;        // é‡å¡«æ¬¡æ•°
  unsigned  _fast_refill_waste;        // å¿«é€Ÿé‡å¡«æµªè´¹
  unsigned  _slow_refill_waste;        // æ…¢é€Ÿé‡å¡«æµªè´¹
  unsigned  _gc_waste;                 // GCæµªè´¹
  unsigned  _slow_allocations;         // æ…¢é€Ÿåˆ†é…æ¬¡æ•°

public:
  // åˆå§‹åŒ–TLAB
  void initialize(HeapWord* start, HeapWord* top, HeapWord* end) {
    set_start(start);
    set_top(top);
    set_pf_top(top);
    set_end(end);
    _number_of_refills = 0;
  }
  
  // åˆ†é…å¯¹è±¡
  inline HeapWord* allocate(size_t size) {
    HeapWord* obj = top();
    if (pointer_delta(end(), obj) >= size) {
      // å¿«é€Ÿè·¯å¾„ï¼šTLABä¸­æœ‰è¶³å¤Ÿç©ºé—´
      HeapWord* new_top = obj + size;
      set_top(new_top);
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      if (UsePerfData) {
        _perf_allocation_size->inc(size * HeapWordSize);
      }
      
      return obj;
    } else {
      // æ…¢é€Ÿè·¯å¾„ï¼šéœ€è¦é‡æ–°åˆ†é…TLAB
      return slow_path_allocation(size);
    }
  }
  
  // æ…¢é€Ÿåˆ†é…è·¯å¾„
  HeapWord* slow_path_allocation(size_t size) {
    _slow_allocations++;
    
    // è®¡ç®—å½“å‰TLABçš„æµªè´¹
    size_t waste = free();
    _slow_refill_waste += waste;
    
    // è¯·æ±‚æ–°çš„TLAB
    size_t new_tlab_size = compute_size(size);
    HeapWord* start = Universe::heap()->allocate_new_tlab(new_tlab_size);
    
    if (start != NULL) {
      // æˆåŠŸåˆ†é…æ–°TLAB
      initialize(start, start, start + new_tlab_size);
      _number_of_refills++;
      
      // åœ¨æ–°TLABä¸­åˆ†é…å¯¹è±¡
      return allocate(size);
    } else {
      // TLABåˆ†é…å¤±è´¥ï¼Œå›é€€åˆ°å †åˆ†é…
      return NULL;
    }
  }
  
  // è®¡ç®—TLABå¤§å°
  size_t compute_size(size_t obj_size) {
    const size_t aligned_obj_size = align_object_size(obj_size);
    const size_t obj_plus_filler_size = aligned_obj_size + alignment_reserve();
    
    size_t new_tlab_size = _desired_size;
    
    // ç¡®ä¿TLABè¶³å¤Ÿå¤§ä»¥å®¹çº³å¯¹è±¡
    if (new_tlab_size < obj_plus_filler_size) {
      new_tlab_size = obj_plus_filler_size;
    }
    
    // åº”ç”¨æœ€å¤§å’Œæœ€å°é™åˆ¶
    new_tlab_size = MIN2(new_tlab_size, max_size());
    new_tlab_size = MAX2(new_tlab_size, min_size());
    
    return new_tlab_size;
  }
  
  // æ”¶é›†ç»Ÿè®¡ä¿¡æ¯
  void accumulate_statistics() {
    Thread* thread = Thread::current();
    size_t waste = _gc_waste + _slow_refill_waste + _fast_refill_waste;
    
    // æ›´æ–°å…¨å±€ç»Ÿè®¡
    GlobalTLABStats* stats = &_global_stats;
    stats->_allocating_threads++;
    stats->_total_waste += waste;
    stats->_max_waste = MAX2(stats->_max_waste, waste);
    stats->_total_allocation += used_bytes();
    stats->_total_refills += _number_of_refills;
    stats->_max_refills = MAX2(stats->_max_refills, _number_of_refills);
    
    // é‡ç½®ç»Ÿè®¡ä¿¡æ¯
    _gc_waste = 0;
    _slow_refill_waste = 0;
    _fast_refill_waste = 0;
    _number_of_refills = 0;
    _slow_allocations = 0;
  }
  
  // æ‰“å°ç»Ÿè®¡ä¿¡æ¯
  void print_stats(const char* tag) {
    Log(gc, heap) log;
    if (!log.is_trace()) return;
    
    log.trace("TLAB totals: thrds: %d  refills: %d max: %d"
             " slow allocs: %d max %d waste: %4.1f%%"
             " gc: " SIZE_FORMAT "B max: " SIZE_FORMAT "B"
             " slow: " SIZE_FORMAT "B max: " SIZE_FORMAT "B"
             " fast: " SIZE_FORMAT "B max: " SIZE_FORMAT "B",
             _allocating_threads,
             _total_refills, _max_refills,
             _slow_allocations, _max_slow_allocations,
             percent_of(_total_waste * HeapWordSize, _total_allocation * HeapWordSize),
             _gc_waste * HeapWordSize, _max_gc_waste * HeapWordSize,
             _slow_refill_waste * HeapWordSize, _max_slow_refill_waste * HeapWordSize,
             _fast_refill_waste * HeapWordSize, _max_fast_refill_waste * HeapWordSize);
  }
};

// å…¨å±€TLABç»Ÿè®¡
class GlobalTLABStats : public CHeapObj<mtThread> {
public:
  unsigned _allocating_threads;        // åˆ†é…çº¿ç¨‹æ•°
  unsigned _total_refills;             // æ€»é‡å¡«æ¬¡æ•°
  unsigned _max_refills;               // æœ€å¤§é‡å¡«æ¬¡æ•°
  size_t   _total_waste;               // æ€»æµªè´¹
  size_t   _max_waste;                 // æœ€å¤§æµªè´¹
  size_t   _total_allocation;          // æ€»åˆ†é…é‡
  unsigned _slow_allocations;          // æ…¢é€Ÿåˆ†é…æ¬¡æ•°
  unsigned _max_slow_allocations;      // æœ€å¤§æ…¢é€Ÿåˆ†é…æ¬¡æ•°

  GlobalTLABStats() :
    _allocating_threads(0),
    _total_refills(0),
    _max_refills(0),
    _total_waste(0),
    _max_waste(0),
    _total_allocation(0),
    _slow_allocations(0),
    _max_slow_allocations(0) {}
  
  void initialize() {
    _allocating_threads = 0;
    _total_refills = 0;
    _max_refills = 0;
    _total_waste = 0;
    _max_waste = 0;
    _total_allocation = 0;
    _slow_allocations = 0;
    _max_slow_allocations = 0;
  }
  
  void publish() {
    if (UsePerfData) {
      _perf_allocating_threads->set_value(_allocating_threads);
      _perf_total_refills->set_value(_total_refills);
      _perf_max_refills->set_value(_max_refills);
      _perf_total_waste->set_value(_total_waste * HeapWordSize);
      _perf_max_waste->set_value(_max_waste * HeapWordSize);
      _perf_total_allocation->set_value(_total_allocation * HeapWordSize);
    }
  }
};
```

### 4. G1GCæ€§èƒ½ç›‘æ§æ·±åº¦å®ç°

#### 4.1 G1æ”¶é›†å™¨æ€§èƒ½ç»Ÿè®¡

```cpp
// hotspot/src/share/gc/g1/g1Analytics.cpp
class G1Analytics : public CHeapObj<mtGC> {
private:
  // é¢„æµ‹å™¨
  TruncatedSeq* _alloc_rate_ms_seq;           // åˆ†é…é€Ÿç‡åºåˆ—
  TruncatedSeq* _prev_collection_pause_end_ms; // ä¸Šæ¬¡æ”¶é›†æš‚åœç»“æŸæ—¶é—´
  TruncatedSeq* _rs_length_diff_seq;          // RSé•¿åº¦å·®å¼‚åºåˆ—
  TruncatedSeq* _cost_per_card_ms_seq;        // æ¯å¡æˆæœ¬åºåˆ—
  TruncatedSeq* _cost_per_entry_ms_seq;       // æ¯æ¡ç›®æˆæœ¬åºåˆ—
  TruncatedSeq* _cost_per_byte_ms_seq;        // æ¯å­—èŠ‚æˆæœ¬åºåˆ—
  
  // å¹¶å‘æ ‡è®°ç»Ÿè®¡
  TruncatedSeq* _concurrent_mark_remark_times_ms;    // é‡æ ‡è®°æ—¶é—´
  TruncatedSeq* _concurrent_mark_cleanup_times_ms;   // æ¸…ç†æ—¶é—´
  
  // å¹´è½»ä»£æ”¶é›†ç»Ÿè®¡
  TruncatedSeq* _young_gc_eff_seq;            // å¹´è½»ä»£GCæ•ˆç‡
  TruncatedSeq* _mixed_gc_eff_seq;            // æ··åˆGCæ•ˆç‡

public:
  G1Analytics(const G1Predictions* predictor) :
    _predictor(predictor),
    _alloc_rate_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
    _prev_collection_pause_end_ms(new TruncatedSeq(TruncatedSeqLength)),
    // ... åˆå§‹åŒ–å…¶ä»–åºåˆ—
  {}
  
  // æ›´æ–°åˆ†é…é€Ÿç‡
  void update_alloc_rate_ms(double alloc_rate) {
    _alloc_rate_ms_seq->add(alloc_rate);
  }
  
  // é¢„æµ‹åˆ†é…é€Ÿç‡
  double predict_alloc_rate_ms() const {
    return get_new_prediction(_alloc_rate_ms_seq);
  }
  
  // æ›´æ–°å¹´è½»ä»£GCç»Ÿè®¡
  void update_young_gc_end_times(double pause_time_ms, 
                                size_t heap_used_bytes_before_gc,
                                size_t heap_used_bytes_after_gc) {
    double gc_efficiency = (double)(heap_used_bytes_before_gc - heap_used_bytes_after_gc) / pause_time_ms;
    _young_gc_eff_seq->add(gc_efficiency);
  }
  
  // é¢„æµ‹å¹´è½»ä»£GCæ—¶é—´
  double predict_young_gc_pause_time_ms(size_t young_list_length) const {
    return get_new_prediction(_young_gc_eff_seq) * young_list_length;
  }
  
  // æ›´æ–°å¹¶å‘æ ‡è®°ç»Ÿè®¡
  void update_concurrent_mark_end_times(double remark_time_ms, 
                                       double cleanup_time_ms) {
    _concurrent_mark_remark_times_ms->add(remark_time_ms);
    _concurrent_mark_cleanup_times_ms->add(cleanup_time_ms);
  }
  
  // é¢„æµ‹å¹¶å‘æ ‡è®°æ—¶é—´
  double predict_remark_time_ms() const {
    return get_new_prediction(_concurrent_mark_remark_times_ms);
  }
  
  double predict_cleanup_time_ms() const {
    return get_new_prediction(_concurrent_mark_cleanup_times_ms);
  }
  
  // è®¡ç®—æœ€ä¼˜å¹´è½»ä»£å¤§å°
  size_t predict_optimal_young_list_length(double target_pause_time_ms) const {
    double predicted_gc_time = predict_young_gc_pause_time_ms(1);
    if (predicted_gc_time > 0) {
      return (size_t)(target_pause_time_ms / predicted_gc_time);
    }
    return G1CollectedHeap::heap()->young_list()->length();
  }

private:
  // è·å–æ–°é¢„æµ‹å€¼
  double get_new_prediction(TruncatedSeq* seq) const {
    return _predictor->get_new_prediction(seq);
  }
};

// G1æ”¶é›†å™¨æ€§èƒ½ç›‘æ§
class G1MonitoringSupport : public CHeapObj<mtGC> {
private:
  G1CollectedHeap* _g1h;
  
  // å†…å­˜æ± 
  G1EdenPool* _eden_pool;
  G1SurvivorPool* _survivor_pool;
  G1OldGenPool* _old_pool;
  
  // å†…å­˜ç®¡ç†å™¨
  G1YoungGenMemoryManager* _young_manager;
  G1OldGenMemoryManager* _old_manager;
  
  // æ€§èƒ½è®¡æ•°å™¨
  PerfVariable* _eden_counters;
  PerfVariable* _survivor_counters;
  PerfVariable* _old_counters;

public:
  G1MonitoringSupport(G1CollectedHeap* g1h) : _g1h(g1h) {
    // åˆ›å»ºå†…å­˜æ± 
    _eden_pool = new G1EdenPool(g1h);
    _survivor_pool = new G1SurvivorPool(g1h);
    _old_pool = new G1OldGenPool(g1h);
    
    // åˆ›å»ºå†…å­˜ç®¡ç†å™¨
    _young_manager = new G1YoungGenMemoryManager();
    _old_manager = new G1OldGenMemoryManager();
    
    // æ³¨å†Œå†…å­˜æ± åˆ°ç®¡ç†å™¨
    _young_manager->add_pool(_eden_pool);
    _young_manager->add_pool(_survivor_pool);
    _old_manager->add_pool(_old_pool);
    
    // åˆ›å»ºæ€§èƒ½è®¡æ•°å™¨
    create_perf_counters();
  }
  
  // æ›´æ–°å†…å­˜ä½¿ç”¨æƒ…å†µ
  void update_sizes() {
    // æ›´æ–°EdenåŒº
    size_t eden_used = _g1h->eden_regions_count() * HeapRegion::GrainBytes;
    _eden_counters->set_value(eden_used);
    
    // æ›´æ–°SurvivoråŒº
    size_t survivor_used = _g1h->survivor_regions_count() * HeapRegion::GrainBytes;
    _survivor_counters->set_value(survivor_used);
    
    // æ›´æ–°è€å¹´ä»£
    size_t old_used = _g1h->old_regions_count() * HeapRegion::GrainBytes;
    _old_counters->set_value(old_used);
  }
  
  // GCå¼€å§‹é€šçŸ¥
  void gc_begin(bool full) {
    if (full) {
      _old_manager->gc_begin();
    } else {
      _young_manager->gc_begin();
    }
  }
  
  // GCç»“æŸé€šçŸ¥
  void gc_end(bool full) {
    update_sizes();
    
    if (full) {
      _old_manager->gc_end();
    } else {
      _young_manager->gc_end();
    }
  }

private:
  void create_perf_counters() {
    const char* cns = "sun.gc.generation.0.space.0.";
    _eden_counters = PerfDataManager::create_variable(SUN_GC, 
                                                     cstr_cat(cns, "used"),
                                                     PerfData::U_Bytes, 0, CHECK);
    
    cns = "sun.gc.generation.0.space.1.";
    _survivor_counters = PerfDataManager::create_variable(SUN_GC,
                                                         cstr_cat(cns, "used"),
                                                         PerfData::U_Bytes, 0, CHECK);
    
    cns = "sun.gc.generation.1.space.0.";
    _old_counters = PerfDataManager::create_variable(SUN_GC,
                                                    cstr_cat(cns, "used"),
                                                    PerfData::U_Bytes, 0, CHECK);
  }
};
```

### 5. JFR (Java Flight Recorder) æ·±åº¦å®ç°

#### 5.1 JFRäº‹ä»¶ç³»ç»Ÿ

```cpp
// hotspot/src/share/jfr/recorder/jfrRecorder.cpp
class JfrRecorder : AllStatic {
private:
  static JfrRecorderThread* _recorder_thread;  // è®°å½•çº¿ç¨‹
  static JfrRepository* _repository;           // äº‹ä»¶ä»“åº“
  static JfrCheckpointManager* _checkpoint_manager; // æ£€æŸ¥ç‚¹ç®¡ç†å™¨
  static JfrStorage* _storage;                 // å­˜å‚¨ç®¡ç†å™¨
  static JfrStackTraceRepository* _stack_trace_repository; // æ ˆè·Ÿè¸ªä»“åº“

public:
  // åˆå§‹åŒ–JFR
  static bool initialize() {
    // åˆ›å»ºå­˜å‚¨ç®¡ç†å™¨
    _storage = JfrStorage::create();
    if (_storage == NULL) {
      return false;
    }
    
    // åˆ›å»ºä»“åº“
    _repository = JfrRepository::create();
    if (_repository == NULL) {
      return false;
    }
    
    // åˆ›å»ºæ£€æŸ¥ç‚¹ç®¡ç†å™¨
    _checkpoint_manager = JfrCheckpointManager::create();
    if (_checkpoint_manager == NULL) {
      return false;
    }
    
    // åˆ›å»ºæ ˆè·Ÿè¸ªä»“åº“
    _stack_trace_repository = JfrStackTraceRepository::create();
    if (_stack_trace_repository == NULL) {
      return false;
    }
    
    // å¯åŠ¨è®°å½•çº¿ç¨‹
    _recorder_thread = JfrRecorderThread::create();
    if (_recorder_thread == NULL) {
      return false;
    }
    
    return true;
  }
  
  // å¼€å§‹è®°å½•
  static bool start_recording(JfrRecordingSettings* settings) {
    // é…ç½®äº‹ä»¶è®¾ç½®
    JfrEventSetting::configure(settings);
    
    // å¯åŠ¨è®°å½•çº¿ç¨‹
    _recorder_thread->start();
    
    // å¼€å§‹æ”¶é›†äº‹ä»¶
    JfrEventCollector::start();
    
    return true;
  }
  
  // åœæ­¢è®°å½•
  static void stop_recording() {
    // åœæ­¢äº‹ä»¶æ”¶é›†
    JfrEventCollector::stop();
    
    // ç­‰å¾…è®°å½•çº¿ç¨‹å®Œæˆ
    _recorder_thread->stop();
    
    // åˆ·æ–°æ‰€æœ‰ç¼“å†²åŒº
    _storage->flush_all();
  }
  
  // å†™å…¥äº‹ä»¶
  static void write_event(JfrEvent* event) {
    Thread* thread = Thread::current();
    JfrThreadLocal* tl = thread->jfr_thread_local();
    
    // è·å–çº¿ç¨‹æœ¬åœ°ç¼“å†²åŒº
    JfrBuffer* buffer = tl->native_buffer();
    if (buffer == NULL) {
      buffer = _storage->acquire_thread_local_buffer(thread);
      tl->set_native_buffer(buffer);
    }
    
    // åºåˆ—åŒ–äº‹ä»¶
    JfrEventWriter writer(buffer);
    event->write_event(&writer);
    
    // æ£€æŸ¥ç¼“å†²åŒºæ˜¯å¦éœ€è¦åˆ·æ–°
    if (buffer->pos() > buffer->size() * 0.75) {
      _storage->release_thread_local_buffer(buffer, thread);
      tl->set_native_buffer(NULL);
    }
  }
};

// JFRäº‹ä»¶åŸºç±»
class JfrEvent : public StackObj {
private:
  jlong _start_time;      // å¼€å§‹æ—¶é—´
  jlong _end_time;        // ç»“æŸæ—¶é—´
  u8 _event_id;          // äº‹ä»¶ID
  bool _started;         // æ˜¯å¦å·²å¼€å§‹
  bool _should_commit;   // æ˜¯å¦åº”è¯¥æäº¤

public:
  JfrEvent(u8 event_id) : 
    _event_id(event_id), 
    _started(false), 
    _should_commit(false) {}
  
  // å¼€å§‹äº‹ä»¶
  void start() {
    if (!_started) {
      _start_time = JfrTicks::now().nanoseconds();
      _started = true;
    }
  }
  
  // ç»“æŸäº‹ä»¶
  void end() {
    if (_started && !_should_commit) {
      _end_time = JfrTicks::now().nanoseconds();
      _should_commit = should_write();
    }
  }
  
  // æäº¤äº‹ä»¶
  void commit() {
    if (_should_commit) {
      JfrRecorder::write_event(this);
    }
  }
  
  // å†™å…¥äº‹ä»¶æ•°æ®
  virtual void write_event(JfrEventWriter* writer) = 0;
  
  // åˆ¤æ–­æ˜¯å¦åº”è¯¥å†™å…¥
  virtual bool should_write() const {
    return JfrEventSetting::is_enabled(_event_id);
  }
  
  // è·å–äº‹ä»¶æŒç»­æ—¶é—´
  jlong duration() const {
    return _end_time - _start_time;
  }
};

// GCäº‹ä»¶å®ç°
class JfrGCEvent : public JfrEvent {
private:
  GCId _gc_id;                    // GCæ ‡è¯†
  GCName _gc_name;                // GCåç§°
  GCCause::Cause _gc_cause;       // GCåŸå› 
  size_t _heap_used_before;       // GCå‰å †ä½¿ç”¨é‡
  size_t _heap_used_after;        // GCåå †ä½¿ç”¨é‡
  size_t _heap_size;              // å †å¤§å°

public:
  JfrGCEvent() : JfrEvent(JfrGarbageCollectionId) {}
  
  void set_gc_info(GCId gc_id, GCName gc_name, GCCause::Cause gc_cause) {
    _gc_id = gc_id;
    _gc_name = gc_name;
    _gc_cause = gc_cause;
  }
  
  void set_heap_info(size_t used_before, size_t used_after, size_t heap_size) {
    _heap_used_before = used_before;
    _heap_used_after = used_after;
    _heap_size = heap_size;
  }
  
  void write_event(JfrEventWriter* writer) override {
    writer->write_u8(_event_id);           // äº‹ä»¶ID
    writer->write_u8(_gc_id.id());         // GC ID
    writer->write_u8(_gc_name);            // GCåç§°
    writer->write_u8(_gc_cause);           // GCåŸå› 
    writer->write_u8(duration());          // æŒç»­æ—¶é—´
    writer->write_u8(_heap_used_before);   // GCå‰å †ä½¿ç”¨é‡
    writer->write_u8(_heap_used_after);    // GCåå †ä½¿ç”¨é‡
    writer->write_u8(_heap_size);          // å †å¤§å°
  }
};

// ç¼–è¯‘äº‹ä»¶å®ç°
class JfrCompilationEvent : public JfrEvent {
private:
  Method* _method;                // ç¼–è¯‘æ–¹æ³•
  int _compile_id;               // ç¼–è¯‘ID
  int _compile_level;            // ç¼–è¯‘çº§åˆ«
  bool _succeeded;               // æ˜¯å¦æˆåŠŸ
  bool _is_osr;                  // æ˜¯å¦OSR
  size_t _code_size;             // ä»£ç å¤§å°
  size_t _inlined_bytes;         // å†…è”å­—èŠ‚æ•°

public:
  JfrCompilationEvent() : JfrEvent(JfrCompilationId) {}
  
  void set_method(Method* method) { _method = method; }
  void set_compile_id(int compile_id) { _compile_id = compile_id; }
  void set_compile_level(int level) { _compile_level = level; }
  void set_succeeded(bool succeeded) { _succeeded = succeeded; }
  void set_osr(bool is_osr) { _is_osr = is_osr; }
  void set_code_size(size_t size) { _code_size = size; }
  void set_inlined_bytes(size_t bytes) { _inlined_bytes = bytes; }
  
  void write_event(JfrEventWriter* writer) override {
    writer->write_u8(_event_id);           // äº‹ä»¶ID
    writer->write_u4(_compile_id);         // ç¼–è¯‘ID
    writer->write_method(_method);         // æ–¹æ³•ä¿¡æ¯
    writer->write_u1(_compile_level);      // ç¼–è¯‘çº§åˆ«
    writer->write_boolean(_succeeded);     // æ˜¯å¦æˆåŠŸ
    writer->write_boolean(_is_osr);        // æ˜¯å¦OSR
    writer->write_u8(duration());          // æŒç»­æ—¶é—´
    writer->write_u4(_code_size);          // ä»£ç å¤§å°
    writer->write_u4(_inlined_bytes);      // å†…è”å­—èŠ‚æ•°
  }
};
```

## ğŸ› ï¸ æ·±åº¦å¢å¼ºGDBè°ƒè¯•è„šæœ¬

ç°åœ¨è®©æˆ‘åˆ›å»ºå¯¹åº”çš„æ·±åº¦å¢å¼ºç‰ˆGDBè°ƒè¯•è„šæœ¬ï¼ŒåŒ…å«180ä¸ªå…³é”®æ•°æ®ç‚¹éªŒè¯ï¼š