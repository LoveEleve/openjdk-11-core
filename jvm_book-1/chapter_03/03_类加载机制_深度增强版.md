# ç¬¬03ç« ï¼šç±»åŠ è½½æœºåˆ¶ - æ·±åº¦æºç åˆ†æä¸å®Œæ•´ç”Ÿå‘½å‘¨æœŸè¿½è¸ª

## ğŸ“– ç« èŠ‚æ¦‚è¿°

æœ¬ç« æ·±å…¥åˆ†æHotSpot VMçš„ç±»åŠ è½½æœºåˆ¶ï¼ŒåŸºäº**-Xms=Xmx=8GB, éå¤§é¡µ, éNUMA, G1GC**çš„æ ‡å‡†é…ç½®ï¼Œé€šè¿‡æºç çº§åˆ†æå’ŒGDBè°ƒè¯•éªŒè¯ç±»åŠ è½½çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸã€‚æˆ‘ä»¬å°†ä»åº•å±‚C++å®ç°å‰–æç±»åŠ è½½å™¨å±‚æ¬¡ç»“æ„ã€ç±»åŠ è½½è¿‡ç¨‹çš„ä¸ƒä¸ªé˜¶æ®µã€Metaspaceå†…å­˜ç®¡ç†æœºåˆ¶ï¼Œä»¥åŠç±»åŠ è½½æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ã€‚

### ğŸ¯ å­¦ä¹ ç›®æ ‡

- **æºç çº§ç†è§£**ï¼šæŒæ¡HotSpot VMç±»åŠ è½½å™¨çš„å®Œæ•´C++å®ç°
- **å®Œæ•´ç”Ÿå‘½å‘¨æœŸ**ï¼šæ·±å…¥åˆ†æç±»åŠ è½½ä¸ƒé˜¶æ®µçš„è¯¦ç»†å®ç°æœºåˆ¶
- **å†…å­˜ç®¡ç†**ï¼šç†è§£Metaspaceåˆ†é…ã€å‹ç¼©ã€å›æ”¶çš„å®Œæ•´ç®—æ³•
- **æ€§èƒ½ä¼˜åŒ–**ï¼šæŒæ¡ç±»åŠ è½½æ€§èƒ½è°ƒä¼˜å’Œé—®é¢˜è¯Šæ–­æŠ€æœ¯
- **å®æˆ˜éªŒè¯**ï¼šé€šè¿‡GDBéªŒè¯ç±»åŠ è½½è¿‡ç¨‹çš„å…³é”®èŠ‚ç‚¹å’Œæ€§èƒ½æ•°æ®

### ğŸ”§ å®éªŒç¯å¢ƒ

```bash
# æ ‡å‡†JVMé…ç½®
-Xms8g -Xmx8g                    # 8GBå †å†…å­˜
-XX:+UseG1GC                     # G1åƒåœ¾æ”¶é›†å™¨
-XX:+UnlockDiagnosticVMOptions   # è§£é”è¯Šæ–­é€‰é¡¹
-XX:+LogVMOutput                 # VMè¾“å‡ºæ—¥å¿—
-XX:+TraceClassLoading           # ç±»åŠ è½½è·Ÿè¸ª
-XX:+TraceClassUnloading         # ç±»å¸è½½è·Ÿè¸ª
-XX:MetaspaceSize=512m           # Metaspaceåˆå§‹å¤§å°
-XX:MaxMetaspaceSize=1g          # Metaspaceæœ€å¤§å¤§å°
```

---

## ğŸ—ï¸ 1. ç±»åŠ è½½å™¨å±‚æ¬¡ç»“æ„æºç åˆ†æ

### 1.1 SystemDictionary - ç±»åŠ è½½æ ¸å¿ƒç®¡ç†å™¨

SystemDictionaryæ˜¯HotSpot VMä¸­ç±»åŠ è½½çš„æ ¸å¿ƒç®¡ç†å™¨ï¼Œè´Ÿè´£ç»´æŠ¤æ‰€æœ‰å·²åŠ è½½ç±»çš„å­—å…¸ï¼š

```cpp
// src/hotspot/share/classfile/systemDictionary.hpp
class SystemDictionary : AllStatic {
private:
  // ç±»åŠ è½½å™¨å±‚æ¬¡ç»“æ„
  static oop _java_system_loader;        // ç³»ç»Ÿç±»åŠ è½½å™¨(AppClassLoader)
  static oop _java_platform_loader;      // å¹³å°ç±»åŠ è½½å™¨(PlatformClassLoader)
  
  // ç±»å­—å…¸å’Œçº¦æŸè¡¨
  static Dictionary*           _dictionary;           // ä¸»ç±»å­—å…¸
  static PlaceholderTable*     _placeholders;        // å ä½ç¬¦è¡¨
  static LoaderConstraintTable* _loader_constraints; // åŠ è½½å™¨çº¦æŸè¡¨
  static ResolutionErrorTable* _resolution_errors;   // è§£æé”™è¯¯è¡¨
  
  // ä¿æŠ¤åŸŸç¼“å­˜
  static ProtectionDomainCacheTable* _pd_cache_table;
  
  // å…±äº«ç±»æ”¯æŒ
  static Dictionary*           _shared_dictionary;
  
public:
  // æ ¸å¿ƒç±»åŠ è½½æ–¹æ³•
  static Klass* resolve_or_fail(Symbol* class_name,
                                Handle class_loader,
                                Handle protection_domain,
                                bool throw_error, TRAPS);
                                
  static Klass* resolve_or_null(Symbol* class_name,
                                Handle class_loader,
                                Handle protection_domain, TRAPS);
                                
  // ç±»åŠ è½½å™¨ç®¡ç†
  static oop java_system_loader()   { return _java_system_loader; }
  static oop java_platform_loader() { return _java_platform_loader; }
  
  // ç±»å­—å…¸æ“ä½œ
  static void add_to_hierarchy(Klass* k, TRAPS);
  static void remove_classes_in_error_state();
};
```

### 1.2 ClassLoader - ç±»åŠ è½½å™¨åŸºç¡€è®¾æ–½

ClassLoaderç±»æä¾›äº†ç±»åŠ è½½çš„åŸºç¡€è®¾æ–½å’Œæœç´¢è·¯å¾„ç®¡ç†ï¼š

```cpp
// src/hotspot/share/classfile/classLoader.hpp
class ClassLoader: AllStatic {
private:
  // ç±»è·¯å¾„æ¡ç›®
  static ClassPathEntry* _first_entry;         // ç¬¬ä¸€ä¸ªç±»è·¯å¾„æ¡ç›®
  static ClassPathEntry* _last_entry;          // æœ€åä¸€ä¸ªç±»è·¯å¾„æ¡ç›®
  static int             _num_entries;         // æ¡ç›®æ•°é‡
  
  // å¯åŠ¨ç±»è·¯å¾„
  static ClassPathEntry* _first_append_entry;  // ç¬¬ä¸€ä¸ªè¿½åŠ æ¡ç›®
  
  // å…±äº«ç±»æ”¯æŒ
  static SharedPathsMiscInfo* _shared_paths_misc_info;
  
  // æ€§èƒ½ç»Ÿè®¡
  static PerfCounter* _perf_accumulated_time;
  static PerfCounter* _perf_classes_inited;
  static PerfCounter* _perf_class_init_time;
  static PerfCounter* _perf_class_verify_time;
  static PerfCounter* _perf_classes_linked;
  
public:
  // åˆå§‹åŒ–æ–¹æ³•
  static void initialize();
  static void setup_bootstrap_search_path();
  static void setup_search_paths(const char *class_path);
  
  // ç±»åŠ è½½æ ¸å¿ƒæ–¹æ³•
  static ClassFileStream* open_stream(const char* name, TRAPS);
  static instanceKlassHandle load_class(Symbol* class_name, TRAPS);
  
  // ç±»è·¯å¾„ç®¡ç†
  static void add_to_list(ClassPathEntry *new_entry);
  static void prepend_to_list(ClassPathEntry *new_entry);
  
  // æ€§èƒ½ç›‘æ§
  static void perf_accumulated_time(jlong time) { 
    _perf_accumulated_time->inc(time); 
  }
};
```

### 1.3 Bootstrap ClassLoaderå®ç°

Bootstrap ClassLoaderæ˜¯ç”¨C++å®ç°çš„ï¼Œè´Ÿè´£åŠ è½½JDKæ ¸å¿ƒç±»åº“ï¼š

```cpp
// src/hotspot/share/classfile/classLoader.cpp
void ClassLoader::setup_bootstrap_search_path() {
  const char* sys_class_path = Arguments::get_sysclasspath();
  
  if (PrintVMOptions) {
    tty->print_cr("bootstrap class path=%s", sys_class_path);
  }
  
  // è®¾ç½®å¯åŠ¨ç±»è·¯å¾„
  if (DumpSharedSpaces || DynamicDumpSharedSpaces) {
    // CDS(Class Data Sharing)æ¨¡å¼ä¸‹çš„ç‰¹æ®Šå¤„ç†
    _shared_paths_misc_info = SharedPathsMiscInfo::allocate();
  }
  
  // è§£æå¹¶è®¾ç½®ç±»è·¯å¾„
  setup_search_paths(sys_class_path);
  
  // è®¾ç½®æ¨¡å—è·¯å¾„(Java 9+)
  if (Arguments::get_javamodulepath() != NULL) {
    setup_module_search_path(Arguments::get_javamodulepath(), THREAD);
  }
}

// è®¾ç½®æœç´¢è·¯å¾„
void ClassLoader::setup_search_paths(const char *class_path) {
  int len = (int)strlen(class_path);
  int end = 0;
  
  // è§£æç±»è·¯å¾„å­—ç¬¦ä¸²
  for (int start = 0; start < len; start = end) {
    while (class_path[start] == os::path_separator()[0] && start < len) {
      start++;
    }
    if (start == len) break;
    
    // æŸ¥æ‰¾è·¯å¾„åˆ†éš”ç¬¦
    end = start;
    while (end < len && class_path[end] != os::path_separator()[0]) {
      end++;
    }
    
    // åˆ›å»ºç±»è·¯å¾„æ¡ç›®
    EXCEPTION_MARK;
    char* path = NEW_C_HEAP_ARRAY(char, end - start + 1, mtClass);
    strncpy(path, &class_path[start], end - start);
    path[end - start] = '\0';
    
    update_class_path_entry_list(path, false, false);
    FREE_C_HEAP_ARRAY(char, path);
  }
}
```

### 1.4 Platform ClassLoaderå®ç°

Java 9å¼•å…¥çš„å¹³å°ç±»åŠ è½½å™¨ï¼Œç”¨äºåŠ è½½å¹³å°æ¨¡å—ï¼š

```java
// jdk/internal/loader/PlatformClassLoader.java
public class PlatformClassLoader extends BuiltinClassLoader {
    static {
        if (!ClassLoader.registerAsParallelCapable())
            throw new InternalError("Unable to register as parallel capable");
    }
    
    PlatformClassLoader(BootClassLoader parent) {
        super("platform", parent, false);
    }
    
    @Override
    protected Class<?> loadClassOrNull(String cn, boolean resolve) {
        synchronized (getClassLoadingLock(cn)) {
            Class<?> c = findLoadedClass(cn);
            if (c == null) {
                // æ£€æŸ¥æ˜¯å¦ä¸ºå¹³å°æ¨¡å—ä¸­çš„ç±»
                if (System.getProperty("jdk.system.module.finder.disabledFastPath") == null) {
                    c = findClassInModuleOrNull(loadedModule, cn);
                }
                if (c == null) {
                    c = super.loadClassOrNull(cn, resolve);
                }
            }
            if (resolve && c != null) {
                resolveClass(c);
            }
            return c;
        }
    }
}
```

### 1.5 Application ClassLoaderå®ç°

åº”ç”¨ç±»åŠ è½½å™¨ï¼Œè´Ÿè´£åŠ è½½åº”ç”¨ç¨‹åºç±»ï¼š

```java
// jdk/internal/loader/AppClassLoader.java
public class AppClassLoader extends BuiltinClassLoader {
    final URLClassPath ucp;
    
    AppClassLoader(PlatformClassLoader parent, URLClassPath ucp) {
        super("app", parent, ucp);
        this.ucp = ucp;
    }
    
    @Override
    protected Class<?> loadClassOrNull(String cn, boolean resolve) {
        synchronized (getClassLoadingLock(cn)) {
            Class<?> c = findLoadedClass(cn);
            if (c == null) {
                // é¦–å…ˆå°è¯•ä»çˆ¶åŠ è½½å™¨åŠ è½½
                c = parent.loadClassOrNull(cn, false);
                if (c == null) {
                    // ä»åº”ç”¨ç±»è·¯å¾„åŠ è½½
                    c = findClassOrNull(cn);
                }
            }
            if (resolve && c != null) {
                resolveClass(c);
            }
            return c;
        }
    }
    
    @Override
    protected Class<?> findClass(String cn) throws ClassNotFoundException {
        // ä»URLClassPathä¸­æŸ¥æ‰¾ç±»
        String path = cn.replace('.', '/').concat(".class");
        Resource res = ucp.getResource(path, false);
        if (res != null) {
            try {
                return defineClass(cn, res);
            } catch (IOException ioe) {
                throw new ClassNotFoundException(cn, ioe);
            }
        } else {
            throw new ClassNotFoundException(cn);
        }
    }
}
```

---

## ğŸ”„ 2. ç±»åŠ è½½ä¸ƒé˜¶æ®µå®Œæ•´å®ç°

### 2.1 é˜¶æ®µ1ï¼šåŠ è½½(Loading) - å­—èŠ‚ç è¯»å–ä¸Klassåˆ›å»º

åŠ è½½é˜¶æ®µè´Ÿè´£ä»å­—èŠ‚ç æ–‡ä»¶åˆ›å»ºKlasså¯¹è±¡ï¼š

```cpp
// src/hotspot/share/classfile/systemDictionary.cpp
Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,
                                         Handle class_loader,
                                         Handle protection_domain,
                                         bool throw_error, TRAPS) {
  // 1. æ£€æŸ¥æ˜¯å¦å·²åŠ è½½
  Klass* klass = find_class(class_name, class_loader);
  if (klass != NULL) {
    return klass;
  }
  
  // 2. æ£€æŸ¥å ä½ç¬¦è¡¨
  PlaceholderEntry* placeholder = placeholders()->get_entry(class_name, class_loader);
  if (placeholder != NULL && placeholder->super_load_in_progress()) {
    // æ­£åœ¨åŠ è½½ä¸­ï¼Œç­‰å¾…å®Œæˆ
    return find_or_define_instance_class(class_name, class_loader, 
                                        instanceKlassHandle(), THREAD);
  }
  
  // 3. å¼€å§‹åŠ è½½è¿‡ç¨‹
  return load_instance_class(class_name, class_loader, THREAD);
}

// å®ä¾‹ç±»åŠ è½½
Klass* SystemDictionary::load_instance_class(Symbol* class_name,
                                            Handle class_loader, TRAPS) {
  // 1. åˆ›å»ºå ä½ç¬¦
  PlaceholderEntry* placeholder = placeholders()->find_and_add(class_name, 
                                                              class_loader, 
                                                              PlaceholderTable::LOAD_INSTANCE);
  
  // 2. è°ƒç”¨ç±»åŠ è½½å™¨çš„loadClassæ–¹æ³•
  Handle string_name = java_lang_String::create_from_symbol(class_name, CHECK_NULL);
  
  JavaValue result(T_OBJECT);
  JavaCalls::call_virtual(&result,
                         class_loader,
                         KlassHandle(THREAD, SystemDictionary::ClassLoader_klass()),
                         vmSymbols::loadClass_name(),
                         vmSymbols::string_class_signature(),
                         string_name,
                         CHECK_NULL);
  
  // 3. è·å–åŠ è½½ç»“æœ
  Handle h_obj(THREAD, (oop)result.get_jobject());
  if (h_obj.not_null()) {
    Klass* k = java_lang_Class::as_Klass(h_obj());
    
    // 4. æ·»åŠ åˆ°ç³»ç»Ÿå­—å…¸
    if (k != NULL) {
      define_instance_class(k, CHECK_NULL);
    }
    return k;
  }
  
  return NULL;
}
```

### 2.2 é˜¶æ®µ2ï¼šéªŒè¯(Verification) - å­—èŠ‚ç å®‰å…¨æ£€æŸ¥

éªŒè¯é˜¶æ®µç¡®ä¿å­—èŠ‚ç çš„å®‰å…¨æ€§å’Œæ­£ç¡®æ€§ï¼š

```cpp
// src/hotspot/share/classfile/verifier.cpp
bool Verifier::verify(InstanceKlass* klass, Verifier::Mode mode, TRAPS) {
  HandleMark hm;
  ResourceMark rm(THREAD);
  
  // 1. è·å–ç±»æ–‡ä»¶ç‰ˆæœ¬
  u2 major_version = klass->major_version();
  
  // 2. é€‰æ‹©éªŒè¯ç­–ç•¥
  if (major_version < STACKMAP_ATTRIBUTE_MAJOR_VERSION) {
    // æ—§ç‰ˆæœ¬ä½¿ç”¨ç±»å‹æ¨æ–­éªŒè¯
    return verify_byte_codes(klass, CHECK_false);
  } else {
    // æ–°ç‰ˆæœ¬ä½¿ç”¨æ ˆæ˜ å°„è¡¨éªŒè¯
    return verify_class_with_stack_maps(klass, CHECK_false);
  }
}

// æ ˆæ˜ å°„è¡¨éªŒè¯
bool Verifier::verify_class_with_stack_maps(InstanceKlass* klass, TRAPS) {
  Array<Method*>* methods = klass->methods();
  int num_methods = methods->length();
  
  for (int index = 0; index < num_methods; index++) {
    Method* m = methods->at(index);
    
    // è·³è¿‡æŠ½è±¡å’Œæœ¬åœ°æ–¹æ³•
    if (m->is_abstract() || m->is_native()) continue;
    
    // éªŒè¯æ–¹æ³•å­—èŠ‚ç 
    ClassVerifier split_verifier(klass, THREAD);
    split_verifier.verify_method(m, CHECK_false);
  }
  
  return true;
}

// å­—èŠ‚ç éªŒè¯æ ¸å¿ƒé€»è¾‘
void ClassVerifier::verify_method(Method* m, TRAPS) {
  HandleMark hm;
  _method = m;
  
  // 1. åˆå§‹åŒ–éªŒè¯çŠ¶æ€
  if (VerboseVerification) {
    tty->print_cr("Verifying method %s", m->name_and_sig_as_C_string());
  }
  
  // 2. æ„å»ºæ§åˆ¶æµå›¾
  _code_data = NEW_RESOURCE_ARRAY(VerificationType, m->code_size());
  
  // 3. æ•°æ®æµåˆ†æ
  verify_code_flow(CHECK_VTOS);
  
  // 4. å¼‚å¸¸å¤„ç†è¡¨éªŒè¯
  verify_exception_handler_table(CHECK_VTOS);
  
  // 5. æ ˆæ˜ å°„è¡¨éªŒè¯
  verify_stackmap_table(CHECK_VTOS);
}
```

### 2.3 é˜¶æ®µ3ï¼šå‡†å¤‡(Preparation) - é™æ€å˜é‡å†…å­˜åˆ†é…

å‡†å¤‡é˜¶æ®µä¸ºç±»çš„é™æ€å˜é‡åˆ†é…å†…å­˜å¹¶è®¾ç½®é»˜è®¤å€¼ï¼š

```cpp
// src/hotspot/share/oops/instanceKlass.cpp
void InstanceKlass::initialize_static_field(fieldDescriptor* fd, TRAPS) {
  Handle mirror(THREAD, java_mirror());
  assert(mirror.not_null(), "java mirror should not be null");
  
  // 1. è·å–å­—æ®µä¿¡æ¯
  BasicType field_type = fd->field_type();
  int offset = fd->offset();
  
  // 2. æ ¹æ®ç±»å‹è®¾ç½®é»˜è®¤å€¼
  switch (field_type) {
    case T_BYTE:
      mirror()->byte_field_put(offset, 0);
      break;
    case T_BOOLEAN:
      mirror()->bool_field_put(offset, false);
      break;
    case T_CHAR:
      mirror()->char_field_put(offset, 0);
      break;
    case T_SHORT:
      mirror()->short_field_put(offset, 0);
      break;
    case T_INT:
      mirror()->int_field_put(offset, 0);
      break;
    case T_LONG:
      mirror()->long_field_put(offset, 0L);
      break;
    case T_FLOAT:
      mirror()->float_field_put(offset, 0.0f);
      break;
    case T_DOUBLE:
      mirror()->double_field_put(offset, 0.0);
      break;
    case T_OBJECT:
    case T_ARRAY:
      mirror()->obj_field_put(offset, NULL);
      break;
    default:
      fatal("Illegal FieldType");
  }
}

// ç±»å‡†å¤‡è¿‡ç¨‹
void InstanceKlass::prepare_impl(InstanceKlass* this_k, TRAPS) {
  // 1. è®¾ç½®ç±»çŠ¶æ€
  this_k->set_init_state(being_initialized);
  
  // 2. åˆå§‹åŒ–é™æ€å­—æ®µ
  for (JavaFieldStream fs(this_k); !fs.done(); fs.next()) {
    if (fs.access_flags().is_static()) {
      fieldDescriptor fd;
      fs.field_descriptor(fd);
      this_k->initialize_static_field(&fd, CHECK);
    }
  }
  
  // 3. åˆ†é…é™æ€OOPæ˜ å°„
  this_k->allocate_static_oop_map(CHECK);
  
  // 4. æ›´æ–°ç±»çŠ¶æ€
  this_k->set_init_state(prepared);
}
```

### 2.4 é˜¶æ®µ4ï¼šè§£æ(Resolution) - ç¬¦å·å¼•ç”¨è½¬æ¢

è§£æé˜¶æ®µå°†ç¬¦å·å¼•ç”¨è½¬æ¢ä¸ºç›´æ¥å¼•ç”¨ï¼š

```cpp
// src/hotspot/share/interpreter/linkResolver.cpp
void LinkResolver::resolve_method(methodHandle& resolved_method,
                                 KlassHandle& resolved_klass,
                                 Symbol* method_name,
                                 Symbol* method_signature,
                                 KlassHandle current_klass,
                                 bool check_access, TRAPS) {
  
  // 1. è§£ææ–¹æ³•æ‰€å±çš„ç±»
  resolve_klass(resolved_klass, method_name, current_klass, CHECK);
  
  // 2. åœ¨ç±»ä¸­æŸ¥æ‰¾æ–¹æ³•
  Method* resolved_method_result = lookup_method_in_klasses(resolved_klass(),
                                                           method_name,
                                                           method_signature,
                                                           false);
  
  if (resolved_method_result == NULL) {
    // 3. åœ¨æ¥å£ä¸­æŸ¥æ‰¾
    resolved_method_result = lookup_method_in_interfaces(resolved_klass(),
                                                        method_name,
                                                        method_signature);
  }
  
  if (resolved_method_result == NULL) {
    // 4. æŠ›å‡ºNoSuchMethodError
    ResourceMark rm(THREAD);
    THROW_MSG(vmSymbols::java_lang_NoSuchMethodError(),
              Method::name_and_sig_as_C_string(resolved_klass(),
                                              method_name,
                                              method_signature));
  }
  
  // 5. è®¿é—®æƒé™æ£€æŸ¥
  if (check_access) {
    check_method_accessability(current_klass(),
                              resolved_klass(),
                              KlassHandle(THREAD, resolved_method_result->method_holder()),
                              resolved_method_result,
                              CHECK);
  }
  
  resolved_method = methodHandle(THREAD, resolved_method_result);
}

// å¸¸é‡æ± è§£æ
void ConstantPool::resolve_constant_at_impl(const constantPoolHandle& this_cp,
                                           int index, int cache_index, TRAPS) {
  constantTag tag = this_cp->tag_at(index);
  
  switch (tag.value()) {
    case JVM_CONSTANT_Class: {
      // è§£æç±»å¼•ç”¨
      Klass* k = klass_at_impl(this_cp, index, CHECK);
      this_cp->klass_at_put(index, k);
      break;
    }
    case JVM_CONSTANT_Fieldref: {
      // è§£æå­—æ®µå¼•ç”¨
      resolve_field_at_impl(this_cp, index, cache_index, CHECK);
      break;
    }
    case JVM_CONSTANT_Methodref: {
      // è§£ææ–¹æ³•å¼•ç”¨
      resolve_method_at_impl(this_cp, index, cache_index, CHECK);
      break;
    }
    case JVM_CONSTANT_InterfaceMethodref: {
      // è§£ææ¥å£æ–¹æ³•å¼•ç”¨
      resolve_interface_method_at_impl(this_cp, index, cache_index, CHECK);
      break;
    }
    default:
      fatal("unexpected constant tag at CP index %d", index);
  }
}
```

### 2.5 é˜¶æ®µ5ï¼šåˆå§‹åŒ–(Initialization) - é™æ€ä»£ç å—æ‰§è¡Œ

åˆå§‹åŒ–é˜¶æ®µæ‰§è¡Œç±»çš„é™æ€åˆå§‹åŒ–ä»£ç ï¼š

```cpp
// src/hotspot/share/oops/instanceKlass.cpp
void InstanceKlass::initialize_impl(InstanceKlass* this_k, TRAPS) {
  // 1. æ£€æŸ¥åˆå§‹åŒ–çŠ¶æ€
  if (this_k->is_initialized()) return;
  
  // 2. è®¾ç½®åˆå§‹åŒ–é”
  Handle h_init_lock(THREAD, this_k->init_lock());
  ObjectLocker ol(h_init_lock, THREAD);
  
  // 3. å†æ¬¡æ£€æŸ¥çŠ¶æ€(åŒé‡æ£€æŸ¥)
  if (this_k->is_initialized()) return;
  
  // 4. æ£€æŸ¥æ˜¯å¦æ­£åœ¨åˆå§‹åŒ–
  if (this_k->is_being_initialized() && 
      this_k->is_reentrant_initialization(THREAD)) {
    return; // é‡å…¥åˆå§‹åŒ–ï¼Œç›´æ¥è¿”å›
  }
  
  // 5. åˆå§‹åŒ–çˆ¶ç±»
  Klass* super_klass = this_k->super();
  if (super_klass != NULL && !this_k->is_interface() && 
      super_klass->should_be_initialized()) {
    super_klass->initialize(THREAD);
    if (HAS_PENDING_EXCEPTION) {
      this_k->set_initialization_state_and_notify(initialization_error, THREAD);
      return;
    }
  }
  
  // 6. åˆå§‹åŒ–æ¥å£
  if (this_k->has_default_methods()) {
    initialize_super_interfaces(this_k, THREAD);
    if (HAS_PENDING_EXCEPTION) {
      this_k->set_initialization_state_and_notify(initialization_error, THREAD);
      return;
    }
  }
  
  // 7. è®¾ç½®åˆå§‹åŒ–çŠ¶æ€
  this_k->set_init_state(being_initialized);
  this_k->set_init_thread(THREAD);
  
  // 8. æ‰§è¡Œç±»åˆå§‹åŒ–æ–¹æ³•(<clinit>)
  Method* clinit = this_k->class_initializer();
  if (clinit != NULL) {
    // è°ƒç”¨<clinit>æ–¹æ³•
    JavaCallArguments args;
    JavaValue result(T_VOID);
    JavaCalls::call_static(&result, this_k, 
                          vmSymbols::class_initializer_name(),
                          vmSymbols::void_method_signature(), 
                          &args, CHECK);
  }
  
  // 9. è®¾ç½®åˆå§‹åŒ–å®ŒæˆçŠ¶æ€
  this_k->set_initialization_state_and_notify(fully_initialized, THREAD);
}

// é™æ€åˆå§‹åŒ–æ–¹æ³•æ‰§è¡Œ
void InstanceKlass::call_class_initializer_impl(InstanceKlass* this_k, TRAPS) {
  if (ReplayCompiles &&
      (ReplayIgnoreInitErrors || this_k->is_shared())) {
    // é‡æ”¾ç¼–è¯‘æ¨¡å¼ä¸‹çš„ç‰¹æ®Šå¤„ç†
    return;
  }
  
  methodHandle h_method(THREAD, this_k->class_initializer());
  assert(!this_k->is_initialized(), "we cannot initialize twice");
  
  if (log_is_enabled(Info, class, init)) {
    ResourceMark rm;
    log_info(class, init)("Initializing '%s'", this_k->external_name());
  }
  
  // æ‰§è¡Œé™æ€åˆå§‹åŒ–ä»£ç 
  JavaCallArguments args;
  JavaValue result(T_VOID);
  JavaCalls::call_static(&result, this_k, h_method, &args, CHECK);
}
```

### 2.6 é˜¶æ®µ6ï¼šä½¿ç”¨(Using) - è¿è¡Œæ—¶è®¿é—®

ä½¿ç”¨é˜¶æ®µæ¶‰åŠè¿è¡Œæ—¶çš„ç±»è®¿é—®å’Œæ–¹æ³•è°ƒç”¨ï¼š

```cpp
// src/hotspot/share/interpreter/interpreterRuntime.cpp
IRT_ENTRY(void, InterpreterRuntime::resolve_get_put(JavaThread* thread, Bytecodes::Code bytecode))
  // 1. è·å–å½“å‰æ–¹æ³•å’Œå­—èŠ‚ç ç´¢å¼•
  LastFrameAccessor last_frame(thread);
  frame fr = last_frame.frame();
  Method* method = last_frame.method();
  int bci = last_frame.bci();
  
  // 2. è·å–å¸¸é‡æ± å’Œå­—æ®µç´¢å¼•
  ConstantPool* pool = method->constants();
  int cp_index = get_index_u2_cpcache(thread, bytecode, method, bci);
  
  // 3. è§£æå­—æ®µå¼•ç”¨
  fieldDescriptor info;
  constantPoolHandle cp(thread, pool);
  bool is_static = (bytecode == Bytecodes::_getstatic || bytecode == Bytecodes::_putstatic);
  
  resolve_field_access(info, cp, cp_index, bytecode, CHECK);
  
  // 4. æ£€æŸ¥å­—æ®µè®¿é—®æƒé™
  KlassHandle current_klass(thread, method->method_holder());
  check_field_access(current_klass, info.field_holder(), info.access_flags(), CHECK);
  
  // 5. æ›´æ–°å¸¸é‡æ± ç¼“å­˜
  ConstantPoolCacheEntry* cache_entry = cp->cache()->entry_at(cp_index);
  cache_entry->set_field(bytecode, info.field_holder(), info.index(), 
                        info.field_type(), info.access_flags().is_final(),
                        info.access_flags().is_volatile());
IRT_END

// æ–¹æ³•è°ƒç”¨è§£æ
IRT_ENTRY(void, InterpreterRuntime::resolve_invoke(JavaThread* thread, Bytecodes::Code bytecode))
  LastFrameAccessor last_frame(thread);
  Method* method = last_frame.method();
  
  // 1. è·å–æ–¹æ³•å¼•ç”¨ä¿¡æ¯
  ConstantPool* pool = method->constants();
  int cp_index = get_index_u2_cpcache(thread, bytecode, method, last_frame.bci());
  
  // 2. è§£ææ–¹æ³•å¼•ç”¨
  methodHandle resolved_method;
  KlassHandle resolved_klass;
  
  constantPoolHandle cp(thread, pool);
  resolve_method(resolved_method, resolved_klass, cp, cp_index, bytecode, CHECK);
  
  // 3. è™šæ–¹æ³•è¡¨æ›´æ–°
  if (bytecode == Bytecodes::_invokevirtual) {
    update_vtable_for_method(resolved_klass(), resolved_method());
  }
  
  // 4. æ›´æ–°å¸¸é‡æ± ç¼“å­˜
  ConstantPoolCacheEntry* cache_entry = cp->cache()->entry_at(cp_index);
  cache_entry->set_method(bytecode, resolved_method, resolved_klass);
IRT_END
```

### 2.7 é˜¶æ®µ7ï¼šå¸è½½(Unloading) - ç±»ç”Ÿå‘½å‘¨æœŸç»“æŸ

ç±»å¸è½½å‘ç”Ÿåœ¨GCè¿‡ç¨‹ä¸­ï¼Œå½“ç±»ä¸å†è¢«å¼•ç”¨æ—¶ï¼š

```cpp
// src/hotspot/share/gc/shared/classUnloading.cpp
void ClassUnloadingTask::work(uint worker_id) {
  // 1. æ ‡è®°ä¸å¯è¾¾çš„ç±»
  {
    SuspendibleThreadSetJoiner sts_join;
    bool unloading_occurred = false;
    
    // éå†æ‰€æœ‰ç±»åŠ è½½å™¨
    ClassLoaderDataGraph::classes_unloading_do(&_is_alive_closure, 
                                               &_clean_klass_tree_closure,
                                               &unloading_occurred);
    
    if (unloading_occurred) {
      // 2. æ¸…ç†Metaspace
      MetaspaceShared::link_and_cleanup_shared_classes(&_is_alive_closure);
      
      // 3. æ¸…ç†å¸¸é‡æ± ç¼“å­˜
      _constant_pool_cache_closure.do_void();
      
      // 4. æ¸…ç†ç¼–è¯‘ä»£ç 
      CodeCache::unlink_scavenge_root_nmethods();
    }
  }
  
  // 5. æ¸…ç†ç±»åŠ è½½å™¨æ•°æ®
  ClassLoaderDataGraph::purge();
}

// ç±»å¸è½½æ£€æŸ¥
bool ClassLoaderData::is_alive(BoolObjectClosure* is_alive_closure) const {
  bool alive = keep_alive() // å¯åŠ¨ç±»åŠ è½½å™¨æ°¸è¿œå­˜æ´»
              || is_alive_closure->do_object_b(class_loader()); // æ£€æŸ¥ç±»åŠ è½½å™¨æ˜¯å¦å­˜æ´»
              
  if (!alive) {
    // æ ‡è®°ä¸ºä¸å¯è¾¾
    if (log_is_enabled(Trace, class, unload)) {
      ResourceMark rm;
      log_trace(class, unload)("Unloading class loader data %p", this);
    }
  }
  
  return alive;
}

// Metaspaceå›æ”¶
void MetaspaceGC::compute_new_size() {
  size_t used_after_gc = MetaspaceAux::used_bytes();
  size_t capacity_until_GC = MetaspaceGC::capacity_until_GC();
  
  // 1. è®¡ç®—æ–°çš„Metaspaceå¤§å°
  const double minimum_free_percentage = MinMetaspaceFreeRatio / 100.0;
  const double maximum_used_percentage = 1.0 - minimum_free_percentage;
  
  const double min_tmp = used_after_gc / maximum_used_percentage;
  size_t minimum_desired_capacity = (size_t)min_tmp;
  
  // 2. è®¾ç½®æ–°çš„å®¹é‡
  size_t new_capacity_until_GC = MAX2(minimum_desired_capacity, 
                                     MetaspaceSize);
  new_capacity_until_GC = MAX2(new_capacity_until_GC, 
                              capacity_until_GC);
  new_capacity_until_GC = align_size_down(new_capacity_until_GC,
                                         Metaspace::commit_alignment());
  
  if (new_capacity_until_GC != capacity_until_GC) {
    MetaspaceGC::set_capacity_until_GC(new_capacity_until_GC);
    
    if (log_is_enabled(Trace, gc, metaspace)) {
      log_trace(gc, metaspace)("New capacity until GC: " SIZE_FORMAT,
                              new_capacity_until_GC);
    }
  }
}
```

---

## ğŸ’¾ 3. Metaspaceå†…å­˜ç®¡ç†æ·±åº¦åˆ†æ

### 3.1 Metaspaceæ¶æ„è®¾è®¡

Metaspaceæ˜¯Java 8å¼•å…¥çš„æ–¹æ³•åŒºå®ç°ï¼Œæ›¿ä»£äº†æ°¸ä¹…ä»£ï¼š

```cpp
// src/hotspot/share/memory/metaspace.hpp
class Metaspace : public CHeapObj<mtClass> {
private:
  // Metaspaceåˆ†é…å™¨
  MetaspaceArena* _class_space_arena;    // ç±»ç©ºé—´åˆ†é…å™¨
  MetaspaceArena* _non_class_space_arena; // éç±»ç©ºé—´åˆ†é…å™¨
  
  // ç©ºé—´ç®¡ç†
  static VirtualSpaceList* _space_list;        // è™šæ‹Ÿç©ºé—´åˆ—è¡¨
  static VirtualSpaceList* _class_space_list;  // ç±»ç©ºé—´åˆ—è¡¨
  
  // å†…å­˜ç»Ÿè®¡
  static size_t _compressed_class_space_size;  // å‹ç¼©ç±»ç©ºé—´å¤§å°
  static ReservedSpace _class_space_rs;        // ç±»ç©ºé—´ä¿ç•™åŒºåŸŸ
  
public:
  // å†…å­˜åˆ†é…
  MetaWord* allocate(size_t word_size, MetaspaceObj::Type type);
  void deallocate(MetaWord* ptr, size_t word_size, bool is_class);
  
  // ç©ºé—´ç®¡ç†
  static void initialize();
  static void global_initialize();
  
  // ç»Ÿè®¡ä¿¡æ¯
  static size_t used_bytes_slow(MetadataType mdtype);
  static size_t free_bytes_slow(MetadataType mdtype);
  static size_t capacity_bytes_slow(MetadataType mdtype);
};
```

### 3.2 MetaspaceArena - å†…å­˜åˆ†é…å™¨

MetaspaceArenaè´Ÿè´£å…·ä½“çš„å†…å­˜åˆ†é…å’Œç®¡ç†ï¼š

```cpp
// src/hotspot/share/memory/metaspaceArena.hpp
class MetaspaceArena : public CHeapObj<mtClass> {
private:
  // å½“å‰åˆ†é…å—
  MetaBlock* _current_chunk;
  
  // åˆ†é…ç»Ÿè®¡
  size_t _total_allocated;
  size_t _total_deallocated;
  
  // ç©ºé—²å—ç®¡ç†
  FreeBlocks _fbl;
  
public:
  // åˆ†é…æ–¹æ³•
  MetaWord* allocate(size_t word_size) {
    // 1. å°è¯•ä»å½“å‰å—åˆ†é…
    if (_current_chunk != NULL) {
      MetaWord* result = _current_chunk->allocate(word_size);
      if (result != NULL) {
        _total_allocated += word_size;
        return result;
      }
    }
    
    // 2. åˆ†é…æ–°å—
    return allocate_new_chunk(word_size);
  }
  
  // é‡Šæ”¾æ–¹æ³•
  void deallocate(MetaWord* p, size_t word_size) {
    // 1. æ›´æ–°ç»Ÿè®¡
    _total_deallocated += word_size;
    
    // 2. æ·»åŠ åˆ°ç©ºé—²åˆ—è¡¨
    _fbl.return_block(p, word_size);
    
    // 3. æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆå¹¶
    attempt_merge_with_neighbors(p, word_size);
  }
  
private:
  MetaWord* allocate_new_chunk(size_t word_size) {
    // è®¡ç®—æ‰€éœ€å—å¤§å°
    size_t chunk_word_size = MAX2(word_size, Settings::commit_granule_words());
    
    // ä»VirtualSpaceListè·å–æ–°å—
    MetaBlock* new_chunk = _space_list->get_new_chunk(chunk_word_size);
    if (new_chunk == NULL) {
      return NULL; // å†…å­˜ä¸è¶³
    }
    
    // è®¾ç½®ä¸ºå½“å‰å—
    _current_chunk = new_chunk;
    
    // ä»æ–°å—åˆ†é…
    return new_chunk->allocate(word_size);
  }
};
```

### 3.3 å‹ç¼©ç±»æŒ‡é’ˆä¼˜åŒ–

å‹ç¼©ç±»æŒ‡é’ˆæ˜¯Metaspaceçš„é‡è¦ä¼˜åŒ–ç‰¹æ€§ï¼š

```cpp
// src/hotspot/share/oops/compressedOops.hpp
class CompressedClassPointers : AllStatic {
private:
  static address _base;                    // åŸºåœ°å€
  static int     _shift;                   // ä½ç§»é‡
  static size_t  _class_space_size;        // ç±»ç©ºé—´å¤§å°
  static address _class_space_start;       // ç±»ç©ºé—´èµ·å§‹åœ°å€
  static address _class_space_end;         // ç±»ç©ºé—´ç»“æŸåœ°å€
  
public:
  // ç¼–ç ï¼šå°†64ä½æŒ‡é’ˆå‹ç¼©ä¸º32ä½
  static narrowKlass encode(Klass* v) {
    assert(is_in_class_space(v), "Class pointer not in class space");
    uint64_t pd = (uint64_t)(pointer_delta((void*)v, (void*)_base, 1));
    assert(pd < (uint64_t)(UINT_MAX << _shift), "Pointer overflow");
    return (narrowKlass)(pd >> _shift);
  }
  
  // è§£ç ï¼šå°†32ä½å‹ç¼©æŒ‡é’ˆè¿˜åŸä¸º64ä½
  static Klass* decode(narrowKlass v) {
    return (Klass*)((uintptr_t)_base + ((uintptr_t)v << _shift));
  }
  
  // æ£€æŸ¥æ˜¯å¦åœ¨ç±»ç©ºé—´èŒƒå›´å†…
  static bool is_in_class_space(void* p) {
    return (address)p >= _class_space_start && (address)p < _class_space_end;
  }
  
  // åˆå§‹åŒ–å‹ç¼©ç±»æŒ‡é’ˆ
  static void initialize(ReservedSpace rs, size_t used_size) {
    _class_space_start = (address)rs.base();
    _class_space_end = _class_space_start + rs.size();
    _class_space_size = rs.size();
    
    // è®¡ç®—æœ€ä¼˜çš„åŸºåœ°å€å’Œä½ç§»
    _base = _class_space_start;
    _shift = LogKlassAlignmentInBytes;
    
    // éªŒè¯å‹ç¼©èŒƒå›´
    assert((_class_space_size >> _shift) <= UINT_MAX, 
           "Class space too large for compressed class pointers");
  }
};
```

### 3.4 ç±»å…ƒæ•°æ®å¸ƒå±€ä¼˜åŒ–

ç±»å…ƒæ•°æ®åœ¨Metaspaceä¸­çš„å¸ƒå±€ç»è¿‡ç²¾å¿ƒä¼˜åŒ–ï¼š

```cpp
// src/hotspot/share/oops/instanceKlass.hpp
class InstanceKlass: public Klass {
private:
  // æ ¸å¿ƒå…ƒæ•°æ®(çƒ­æ•°æ®ï¼Œé¢‘ç¹è®¿é—®)
  Array<Method*>*     _methods;           // æ–¹æ³•æ•°ç»„
  Array<Method*>*     _default_methods;   // é»˜è®¤æ–¹æ³•æ•°ç»„
  ConstantPool*       _constants;         // å¸¸é‡æ± 
  Array<jushort>*     _inner_classes;     // å†…éƒ¨ç±»ä¿¡æ¯
  
  // å­—æ®µä¿¡æ¯
  Array<u2>*          _fields;            // å­—æ®µæ•°ç»„
  u2                  _java_fields_count; // Javaå­—æ®µæ•°é‡
  
  // ç»§æ‰¿å…³ç³»
  Klass*              _super;             // çˆ¶ç±»
  Array<Klass*>*      _local_interfaces; // æœ¬åœ°æ¥å£
  Array<Klass*>*      _transitive_interfaces; // ä¼ é€’æ¥å£
  
  // æ–¹æ³•è¡¨å’Œæ¥å£è¡¨
  Array<Method*>*     _vtable;            // è™šæ–¹æ³•è¡¨
  Array<Method*>*     _itable;            // æ¥å£æ–¹æ³•è¡¨
  
  // é™æ€å­—æ®µå¸ƒå±€ä¼˜åŒ–
  int                 _static_field_size; // é™æ€å­—æ®µå¤§å°
  int                 _static_oop_field_count; // é™æ€OOPå­—æ®µæ•°é‡
  
public:
  // å†…å­˜å¸ƒå±€è®¡ç®—
  static int size(int vtable_length, int itable_length,
                 int nonstatic_oop_map_size,
                 bool is_interface, bool is_anonymous) {
    return align_metadata_size(header_size() +
                              vtable_length +
                              itable_length +
                              nonstatic_oop_map_size +
                              (is_interface ? 0 : static_field_size()) +
                              (is_anonymous ? 0 : 0));
  }
  
  // å­—æ®µåç§»è®¡ç®—
  void compute_field_offsets(int super_static_field_size) {
    FieldLayoutInfo info;
    layout_fields(class_loader_data(), &info, CHECK);
    
    // ä¼˜åŒ–å­—æ®µå¸ƒå±€ä»¥å‡å°‘å†…å­˜ç¢ç‰‡
    set_instance_size(align_object_size(info.instance_size));
    set_static_field_size(info.static_field_size);
  }
};
```

---

## ğŸ” 4. ç±»åŠ è½½æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 4.1 ç±»åŠ è½½ç¼“å­˜æœºåˆ¶

SystemDictionaryæä¾›äº†å¤šçº§ç¼“å­˜æ¥ä¼˜åŒ–ç±»åŠ è½½æ€§èƒ½ï¼š

```cpp
// src/hotspot/share/classfile/dictionary.hpp
class Dictionary : public Hashtable<Klass*, mtClass> {
private:
  // ç±»å­—å…¸æ¡ç›®
  class DictionaryEntry : public HashtableEntry<Klass*, mtClass> {
    ClassLoaderData* _loader_data;
    ProtectionDomain _pd_set;
    
  public:
    // å¿«é€ŸæŸ¥æ‰¾ä¼˜åŒ–
    bool equals(Symbol* class_name, ClassLoaderData* loader_data) const {
      return (literal()->name() == class_name &&
              _loader_data == loader_data);
    }
  };
  
public:
  // é«˜æ•ˆæŸ¥æ‰¾ç®—æ³•
  Klass* find_class(int index, unsigned int hash,
                   Symbol* name, ClassLoaderData* loader_data) {
    assert_locked_or_safepoint(SystemDictionary_lock);
    
    for (DictionaryEntry* entry = bucket(index); entry != NULL; entry = entry->next()) {
      if (entry->hash() == hash && entry->equals(name, loader_data)) {
        return entry->klass();
      }
    }
    return NULL;
  }
  
  // æ‰¹é‡é¢„åŠ è½½ä¼˜åŒ–
  void preload_classes(GrowableArray<Symbol*>* class_names, TRAPS) {
    for (int i = 0; i < class_names->length(); i++) {
      Symbol* name = class_names->at(i);
      
      // å¼‚æ­¥é¢„åŠ è½½
      if (!find_class_from_basic_type_mirror(name)) {
        SystemDictionary::resolve_or_null(name, 
                                         Handle(THREAD, SystemDictionary::java_system_loader()),
                                         Handle(), THREAD);
      }
    }
  }
};
```

### 4.2 å¹¶è¡Œç±»åŠ è½½ä¼˜åŒ–

HotSpotæ”¯æŒå¹¶è¡Œç±»åŠ è½½æ¥æé«˜å¤šçº¿ç¨‹åº”ç”¨çš„å¯åŠ¨æ€§èƒ½ï¼š

```cpp
// src/hotspot/share/classfile/systemDictionary.cpp
Klass* SystemDictionary::resolve_or_fail_parallel(Symbol* class_name,
                                                  Handle class_loader,
                                                  Handle protection_domain,
                                                  bool throw_error, TRAPS) {
  
  // 1. æ£€æŸ¥æ˜¯å¦æ”¯æŒå¹¶è¡ŒåŠ è½½
  if (!is_parallelCapable(class_loader)) {
    return resolve_or_fail(class_name, class_loader, protection_domain, throw_error, THREAD);
  }
  
  // 2. è·å–ç±»åŠ è½½é”
  Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
  check_loader_lock_contention(lockObject, THREAD);
  
  ObjectLocker ol(lockObject, THREAD);
  
  // 3. åŒé‡æ£€æŸ¥æ¨¡å¼
  Klass* check = find_class(class_name, class_loader);
  if (check != NULL) {
    return check;
  }
  
  // 4. æ£€æŸ¥å ä½ç¬¦
  PlaceholderEntry* placeholder = placeholders()->get_entry(class_name, class_loader);
  if (placeholder && placeholder->super_load_in_progress()) {
    // ç­‰å¾…å…¶ä»–çº¿ç¨‹å®ŒæˆåŠ è½½
    return find_or_define_instance_class(class_name, class_loader, 
                                        instanceKlassHandle(), THREAD);
  }
  
  // 5. å¼€å§‹å¹¶è¡ŒåŠ è½½
  return load_instance_class_parallel(class_name, class_loader, THREAD);
}

// å¹¶è¡ŒåŠ è½½å®ç°
Klass* SystemDictionary::load_instance_class_parallel(Symbol* class_name,
                                                     Handle class_loader, TRAPS) {
  // åˆ›å»ºåŠ è½½ä»»åŠ¡
  ClassLoadingTask* task = new ClassLoadingTask(class_name, class_loader);
  
  // æäº¤åˆ°çº¿ç¨‹æ± 
  if (ParallelGCThreads > 1) {
    ClassLoadingThreadPool::submit_task(task);
    
    // ç­‰å¾…åŠ è½½å®Œæˆ
    task->wait_for_completion();
    
    Klass* result = task->loaded_class();
    delete task;
    return result;
  } else {
    // å•çº¿ç¨‹æ¨¡å¼
    return load_instance_class(class_name, class_loader, THREAD);
  }
}
```

### 4.3 ç±»æ•°æ®å…±äº«(CDS)ä¼˜åŒ–

CDSé€šè¿‡é¢„å¤„ç†å’Œå…±äº«ç±»æ•°æ®æ¥åŠ é€Ÿå¯åŠ¨ï¼š

```cpp
// src/hotspot/share/memory/metaspaceShared.hpp
class MetaspaceShared : AllStatic {
private:
  static ReservedSpace _shared_rs;           // å…±äº«åŒºåŸŸ
  static VirtualSpace  _shared_vs;           // è™šæ‹Ÿç©ºé—´
  static int           _max_alignment;       // æœ€å¤§å¯¹é½
  static MetaspaceClosure* _closure;         // å…ƒç©ºé—´é—­åŒ…
  
public:
  // åˆå§‹åŒ–å…±äº«ç©ºé—´
  static void initialize_shared_spaces() {
    FileMapInfo* mapinfo = FileMapInfo::current_info();
    
    // 1. æ˜ å°„å…±äº«å½’æ¡£
    char* addr = mapinfo->region_addr(0);
    size_t size = mapinfo->region_size(0);
    
    if (!_shared_vs.initialize(_shared_rs, size)) {
      vm_exit_during_initialization("Unable to allocate shared space");
    }
    
    // 2. é‡å®šä½å…±äº«å¯¹è±¡
    relocate_shared_objects(addr, size);
    
    // 3. åˆå§‹åŒ–å…±äº«å­—å…¸
    SystemDictionary::initialize_shared_dictionary();
  }
  
  // å…±äº«ç±»åŠ è½½
  static Klass* find_shared_class(Symbol* class_name) {
    if (!UseSharedSpaces) return NULL;
    
    // åœ¨å…±äº«å­—å…¸ä¸­æŸ¥æ‰¾
    return _shared_dictionary->find_shared_class(class_name);
  }
  
  // é¢„åŠ è½½æ ¸å¿ƒç±»
  static void preload_and_dump_classes(TRAPS) {
    GrowableArray<Symbol*> core_classes(1000);
    
    // æ·»åŠ æ ¸å¿ƒç±»åˆ—è¡¨
    core_classes.append(vmSymbols::java_lang_Object());
    core_classes.append(vmSymbols::java_lang_String());
    core_classes.append(vmSymbols::java_lang_Class());
    // ... æ›´å¤šæ ¸å¿ƒç±»
    
    // æ‰¹é‡åŠ è½½
    for (int i = 0; i < core_classes.length(); i++) {
      SystemDictionary::resolve_or_null(core_classes.at(i),
                                       Handle(THREAD, SystemDictionary::java_system_loader()),
                                       Handle(), THREAD);
    }
  }
};
```

### 4.4 AppCDSåº”ç”¨ç±»æ•°æ®å…±äº«

AppCDSæ‰©å±•äº†CDSï¼Œæ”¯æŒåº”ç”¨ç±»çš„å…±äº«ï¼š

```cpp
// src/hotspot/share/classfile/classListParser.cpp
class ClassListParser : public StackObj {
private:
  static const char* _classlist_file;
  static FILE* _file;
  
public:
  // è§£æç±»åˆ—è¡¨æ–‡ä»¶
  static void parse_classlist(const char* filename, TRAPS) {
    _file = fopen(filename, "r");
    if (_file == NULL) {
      vm_exit_during_initialization("Cannot open classlist file", filename);
    }
    
    char class_name[256];
    while (fgets(class_name, sizeof(class_name), _file) != NULL) {
      // ç§»é™¤æ¢è¡Œç¬¦
      size_t len = strlen(class_name);
      if (len > 0 && class_name[len-1] == '\n') {
        class_name[len-1] = '\0';
      }
      
      // åŠ è½½å¹¶å½’æ¡£ç±»
      load_and_archive_class(class_name, THREAD);
    }
    
    fclose(_file);
  }
  
private:
  static void load_and_archive_class(const char* class_name, TRAPS) {
    TempNewSymbol name = SymbolTable::new_symbol(class_name, CHECK);
    
    // åŠ è½½ç±»
    Klass* klass = SystemDictionary::resolve_or_null(name,
                                                    Handle(THREAD, SystemDictionary::java_system_loader()),
                                                    Handle(), THREAD);
    
    if (klass != NULL && klass->is_instance_klass()) {
      InstanceKlass* ik = InstanceKlass::cast(klass);
      
      // æ·»åŠ åˆ°å…±äº«å½’æ¡£
      if (ik->is_shared_app_class()) {
        MetaspaceShared::add_to_dump_time_shared_table(ik);
      }
    }
  }
};
```

---

## ğŸ§ª 5. æ·±åº¦GDBè°ƒè¯•éªŒè¯

ç°åœ¨è®©æˆ‘åˆ›å»ºæ·±åº¦å¢å¼ºç‰ˆçš„GDBè°ƒè¯•è„šæœ¬ï¼Œç”¨äºéªŒè¯ç±»åŠ è½½æœºåˆ¶çš„å„ä¸ªæ–¹é¢ï¼š

### 5.1 å®Œæ•´çš„ç±»åŠ è½½çŠ¶æ€åˆ†æ

```gdb
# ç±»åŠ è½½å™¨å±‚æ¬¡ç»“æ„åˆ†æ
define analyze_classloader_hierarchy
    printf "=== ç±»åŠ è½½å™¨å±‚æ¬¡ç»“æ„åˆ†æ ===\n"
    
    # 1. Bootstrap ClassLoader (C++å®ç°)
    printf "1. Bootstrap ClassLoader:\n"
    printf "   - å®ç°è¯­è¨€: C++\n"
    printf "   - åŠ è½½è·¯å¾„: %s\n", Arguments::get_sysclasspath()
    
    # 2. Platform ClassLoader
    set $platform_loader = SystemDictionary::_java_platform_loader
    if $platform_loader != 0
        printf "2. Platform ClassLoader: 0x%lx\n", $platform_loader
        printf "   - ç±»å‹: %s\n", $platform_loader->_metadata->_name->_body
    else
        printf "2. Platform ClassLoader: æœªåˆå§‹åŒ–\n"
    end
    
    # 3. Application ClassLoader  
    set $app_loader = SystemDictionary::_java_system_loader
    if $app_loader != 0
        printf "3. Application ClassLoader: 0x%lx\n", $app_loader
        printf "   - ç±»å‹: %s\n", $app_loader->_metadata->_name->_body
    else
        printf "3. Application ClassLoader: æœªåˆå§‹åŒ–\n"
    end
    
    printf "\n"
end

# ç±»å­—å…¸çŠ¶æ€åˆ†æ
define analyze_class_dictionary
    printf "=== ç±»å­—å…¸çŠ¶æ€åˆ†æ ===\n"
    
    set $dict = SystemDictionary::_dictionary
    if $dict != 0
        printf "ä¸»ç±»å­—å…¸: 0x%lx\n", $dict
        printf "- è¡¨å¤§å°: %d\n", $dict->_table_size
        printf "- å·²ç”¨æ§½ä½: %d\n", $dict->_number_of_entries
        printf "- è´Ÿè½½å› å­: %.2f\n", (double)$dict->_number_of_entries / $dict->_table_size
        
        # ç»Ÿè®¡æ¯ä¸ªåŠ è½½å™¨çš„ç±»æ•°é‡
        set $i = 0
        set $bootstrap_count = 0
        set $platform_count = 0
        set $app_count = 0
        
        while $i < $dict->_table_size
            set $entry = $dict->_buckets[$i]
            while $entry != 0
                set $loader_data = ((Dictionary::DictionaryEntry*)$entry)->_loader_data
                if $loader_data->_class_loader == 0
                    set $bootstrap_count = $bootstrap_count + 1
                else
                    set $loader_oop = $loader_data->_class_loader
                    # ç®€åŒ–çš„åŠ è½½å™¨ç±»å‹åˆ¤æ–­
                    if $loader_oop == SystemDictionary::_java_platform_loader
                        set $platform_count = $platform_count + 1
                    else
                        set $app_count = $app_count + 1
                    end
                end
                set $entry = $entry->_next
            end
            set $i = $i + 1
        end
        
        printf "- BootstrapåŠ è½½çš„ç±»: %d\n", $bootstrap_count
        printf "- PlatformåŠ è½½çš„ç±»: %d\n", $platform_count  
        printf "- ApplicationåŠ è½½çš„ç±»: %d\n", $app_count
    else
        printf "ç±»å­—å…¸æœªåˆå§‹åŒ–\n"
    end
    
    printf "\n"
end

# Metaspaceä½¿ç”¨æƒ…å†µåˆ†æ
define analyze_metaspace_usage
    printf "=== Metaspaceä½¿ç”¨æƒ…å†µåˆ†æ ===\n"
    
    # è·å–Metaspaceç»Ÿè®¡ä¿¡æ¯
    set $used_bytes = MetaspaceAux::used_bytes()
    set $capacity_bytes = MetaspaceAux::capacity_bytes()
    set $reserved_bytes = MetaspaceAux::reserved_bytes()
    
    printf "Metaspaceæ€»ä½“ä½¿ç”¨æƒ…å†µ:\n"
    printf "- å·²ä½¿ç”¨: %lu bytes (%.2f MB)\n", $used_bytes, (double)$used_bytes / 1048576
    printf "- å·²åˆ†é…: %lu bytes (%.2f MB)\n", $capacity_bytes, (double)$capacity_bytes / 1048576
    printf "- å·²ä¿ç•™: %lu bytes (%.2f MB)\n", $reserved_bytes, (double)$reserved_bytes / 1048576
    printf "- ä½¿ç”¨ç‡: %.2f%%\n", (double)$used_bytes * 100 / $capacity_bytes
    
    # ç±»ç©ºé—´ä½¿ç”¨æƒ…å†µ
    if UseCompressedClassPointers
        set $class_used = MetaspaceAux::used_bytes_slow(Metaspace::ClassType)
        set $class_capacity = MetaspaceAux::capacity_bytes_slow(Metaspace::ClassType)
        
        printf "\nå‹ç¼©ç±»ç©ºé—´ä½¿ç”¨æƒ…å†µ:\n"
        printf "- å·²ä½¿ç”¨: %lu bytes (%.2f MB)\n", $class_used, (double)$class_used / 1048576
        printf "- å·²åˆ†é…: %lu bytes (%.2f MB)\n", $class_capacity, (double)$class_capacity / 1048576
        printf "- ä½¿ç”¨ç‡: %.2f%%\n", (double)$class_used * 100 / $class_capacity
        
        # å‹ç¼©æŒ‡é’ˆé…ç½®
        printf "\nå‹ç¼©ç±»æŒ‡é’ˆé…ç½®:\n"
        printf "- åŸºåœ°å€: 0x%lx\n", CompressedClassPointers::_base
        printf "- ä½ç§»é‡: %d\n", CompressedClassPointers::_shift
        printf "- ç©ºé—´å¤§å°: %lu bytes (%.2f MB)\n", CompressedClassPointers::_class_space_size, (double)CompressedClassPointers::_class_space_size / 1048576
    end
    
    printf "\n"
end

# ç±»åŠ è½½æ€§èƒ½ç»Ÿè®¡
define analyze_classloading_performance
    printf "=== ç±»åŠ è½½æ€§èƒ½ç»Ÿè®¡ ===\n"
    
    # è·å–æ€§èƒ½è®¡æ•°å™¨
    set $perf_time = ClassLoader::_perf_accumulated_time
    set $perf_classes_inited = ClassLoader::_perf_classes_inited
    set $perf_init_time = ClassLoader::_perf_class_init_time
    set $perf_verify_time = ClassLoader::_perf_class_verify_time
    set $perf_classes_linked = ClassLoader::_perf_classes_linked
    
    if $perf_time != 0
        printf "ç´¯è®¡åŠ è½½æ—¶é—´: %lu ns (%.2f ms)\n", $perf_time->_value, (double)$perf_time->_value / 1000000
    end
    
    if $perf_classes_inited != 0
        printf "å·²åˆå§‹åŒ–ç±»æ•°é‡: %lu\n", $perf_classes_inited->_value
    end
    
    if $perf_init_time != 0
        printf "ç´¯è®¡åˆå§‹åŒ–æ—¶é—´: %lu ns (%.2f ms)\n", $perf_init_time->_value, (double)$perf_init_time->_value / 1000000
    end
    
    if $perf_verify_time != 0
        printf "ç´¯è®¡éªŒè¯æ—¶é—´: %lu ns (%.2f ms)\n", $perf_verify_time->_value, (double)$perf_verify_time->_value / 1000000
    end
    
    if $perf_classes_linked != 0
        printf "å·²é“¾æ¥ç±»æ•°é‡: %lu\n", $perf_classes_linked->_value
    end
    
    # è®¡ç®—å¹³å‡æ€§èƒ½
    if $perf_classes_inited != 0 && $perf_classes_inited->_value > 0
        set $avg_load_time = $perf_time->_value / $perf_classes_inited->_value
        printf "å¹³å‡åŠ è½½æ—¶é—´: %lu ns (%.2f Î¼s)\n", $avg_load_time, (double)$avg_load_time / 1000
        
        if $perf_init_time != 0
            set $avg_init_time = $perf_init_time->_value / $perf_classes_inited->_value
            printf "å¹³å‡åˆå§‹åŒ–æ—¶é—´: %lu ns (%.2f Î¼s)\n", $avg_init_time, (double)$avg_init_time / 1000
        end
    end
    
    printf "\n"
end

# å ä½ç¬¦è¡¨åˆ†æ
define analyze_placeholder_table
    printf "=== å ä½ç¬¦è¡¨åˆ†æ ===\n"
    
    set $placeholders = SystemDictionary::_placeholders
    if $placeholders != 0
        printf "å ä½ç¬¦è¡¨: 0x%lx\n", $placeholders
        printf "- è¡¨å¤§å°: %d\n", $placeholders->_table_size
        printf "- æ¡ç›®æ•°é‡: %d\n", $placeholders->_number_of_entries
        
        # ç»Ÿè®¡ä¸åŒçŠ¶æ€çš„å ä½ç¬¦
        set $i = 0
        set $load_count = 0
        set $super_count = 0
        set $define_count = 0
        
        while $i < $placeholders->_table_size
            set $entry = $placeholders->_buckets[$i]
            while $entry != 0
                set $flags = ((PlaceholderEntry*)$entry)->_loadInstanceThreadQ._flags
                if $flags & PlaceholderTable::LOAD_INSTANCE
                    set $load_count = $load_count + 1
                end
                if $flags & PlaceholderTable::LOAD_SUPER
                    set $super_count = $super_count + 1
                end
                if $flags & PlaceholderTable::DEFINE_CLASS
                    set $define_count = $define_count + 1
                end
                set $entry = $entry->_next
            end
            set $i = $i + 1
        end
        
        printf "- æ­£åœ¨åŠ è½½: %d\n", $load_count
        printf "- æ­£åœ¨åŠ è½½çˆ¶ç±»: %d\n", $super_count
        printf "- æ­£åœ¨å®šä¹‰: %d\n", $define_count
    else
        printf "å ä½ç¬¦è¡¨æœªåˆå§‹åŒ–\n"
    end
    
    printf "\n"
end

# ç‰¹å®šç±»çš„è¯¦ç»†åˆ†æ
define analyze_specific_class
    if $argc != 1
        printf "ç”¨æ³•: analyze_specific_class <ç±»å>\n"
        printf "ç¤ºä¾‹: analyze_specific_class \"java/lang/String\"\n"
    else
        printf "=== ç±»è¯¦ç»†åˆ†æ: %s ===\n", $arg0
        
        # æŸ¥æ‰¾ç±»
        set $class_name = SymbolTable::lookup($arg0, strlen($arg0))
        if $class_name != 0
            set $klass = SystemDictionary::find_class($class_name, 0)
            if $klass != 0
                printf "ç±»å¯¹è±¡: 0x%lx\n", $klass
                printf "ç±»å: %s\n", $klass->_name->_body
                
                if $klass->_vtable_len > 0
                    printf "è™šæ–¹æ³•è¡¨é•¿åº¦: %d\n", $klass->_vtable_len
                end
                
                # å¦‚æœæ˜¯å®ä¾‹ç±»
                set $ik = (InstanceKlass*)$klass
                printf "ç±»çŠ¶æ€: "
                set $state = $ik->_init_state
                if $state == 0
                    printf "æœªåˆ†é…\n"
                elif $state == 1
                    printf "å·²åˆ†é…\n"
                elif $state == 2
                    printf "å·²åŠ è½½\n"
                elif $state == 3
                    printf "å·²é“¾æ¥\n"
                elif $state == 4
                    printf "æ­£åœ¨åˆå§‹åŒ–\n"
                elif $state == 5
                    printf "å·²åˆå§‹åŒ–\n"
                elif $state == 6
                    printf "åˆå§‹åŒ–é”™è¯¯\n"
                else
                    printf "æœªçŸ¥çŠ¶æ€(%d)\n", $state
                end
                
                printf "æ–¹æ³•æ•°é‡: %d\n", $ik->_methods->_length
                printf "å­—æ®µæ•°é‡: %d\n", $ik->_java_fields_count
                printf "å¸¸é‡æ± å¤§å°: %d\n", $ik->_constants->_length
                
                # å†…å­˜ä½¿ç”¨æƒ…å†µ
                set $size = $ik->size() * 8  # è½¬æ¢ä¸ºå­—èŠ‚
                printf "å…ƒæ•°æ®å¤§å°: %d bytes\n", $size
                
            else
                printf "ç±»æœªæ‰¾åˆ°æˆ–æœªåŠ è½½\n"
            end
        else
            printf "æ— æ•ˆçš„ç±»å\n"
        end
    end
    
    printf "\n"
end

# ç±»åŠ è½½å™¨çº¦æŸè¡¨åˆ†æ
define analyze_loader_constraints
    printf "=== ç±»åŠ è½½å™¨çº¦æŸè¡¨åˆ†æ ===\n"
    
    set $constraints = SystemDictionary::_loader_constraints
    if $constraints != 0
        printf "çº¦æŸè¡¨: 0x%lx\n", $constraints
        printf "- è¡¨å¤§å°: %d\n", $constraints->_table_size
        printf "- çº¦æŸæ•°é‡: %d\n", $constraints->_number_of_entries
        
        # éå†çº¦æŸè¡¨ç»Ÿè®¡ä¿¡æ¯
        set $i = 0
        set $constraint_count = 0
        
        while $i < $constraints->_table_size
            set $entry = $constraints->_buckets[$i]
            while $entry != 0
                set $constraint_count = $constraint_count + 1
                set $entry = $entry->_next
            end
            set $i = $i + 1
        end
        
        printf "- æœ‰æ•ˆçº¦æŸ: %d\n", $constraint_count
    else
        printf "çº¦æŸè¡¨æœªåˆå§‹åŒ–\n"
    end
    
    printf "\n"
end

# å…±äº«ç±»åˆ†æ(CDS)
define analyze_shared_classes
    printf "=== å…±äº«ç±»åˆ†æ(CDS) ===\n"
    
    if UseSharedSpaces
        printf "CDSçŠ¶æ€: å¯ç”¨\n"
        
        set $shared_dict = SystemDictionary::_shared_dictionary
        if $shared_dict != 0
            printf "å…±äº«å­—å…¸: 0x%lx\n", $shared_dict
            printf "- å…±äº«ç±»æ•°é‡: %d\n", $shared_dict->_number_of_entries
            
            # å…±äº«ç©ºé—´ä¿¡æ¯
            set $shared_rs = MetaspaceShared::_shared_rs
            printf "- å…±äº«åŒºåŸŸå¤§å°: %lu bytes (%.2f MB)\n", $shared_rs._size, (double)$shared_rs._size / 1048576
            printf "- å…±äº«åŒºåŸŸåŸºå€: 0x%lx\n", $shared_rs._base
        else
            printf "å…±äº«å­—å…¸æœªåˆå§‹åŒ–\n"
        end
    else
        printf "CDSçŠ¶æ€: ç¦ç”¨\n"
    end
    
    printf "\n"
end

# å®Œæ•´çš„ç±»åŠ è½½ç³»ç»Ÿå¥åº·æ£€æŸ¥
define classloading_health_check
    printf "========================================\n"
    printf "      ç±»åŠ è½½ç³»ç»Ÿå¥åº·æ£€æŸ¥æŠ¥å‘Š\n"
    printf "========================================\n\n"
    
    analyze_classloader_hierarchy
    analyze_class_dictionary
    analyze_metaspace_usage
    analyze_classloading_performance
    analyze_placeholder_table
    analyze_loader_constraints
    analyze_shared_classes
    
    printf "========================================\n"
    printf "           å¥åº·æ£€æŸ¥å®Œæˆ\n"
    printf "========================================\n"
end

# è®¾ç½®ç±»åŠ è½½ç›¸å…³æ–­ç‚¹
define set_classloading_breakpoints
    printf "è®¾ç½®ç±»åŠ è½½ç›¸å…³æ–­ç‚¹...\n"
    
    # æ ¸å¿ƒç±»åŠ è½½æ–­ç‚¹
    break SystemDictionary::resolve_or_fail
    break SystemDictionary::load_instance_class
    break InstanceKlass::initialize_impl
    break ClassLoader::load_class
    
    # éªŒè¯ç›¸å…³æ–­ç‚¹
    break Verifier::verify
    break ClassVerifier::verify_method
    
    # Metaspaceåˆ†é…æ–­ç‚¹
    break MetaspaceArena::allocate
    break Metaspace::allocate
    
    # ç±»å¸è½½æ–­ç‚¹
    break ClassLoaderData::is_alive
    break ClassUnloadingTask::work
    
    printf "ç±»åŠ è½½æ–­ç‚¹è®¾ç½®å®Œæˆ\n"
end

# ç§»é™¤ç±»åŠ è½½æ–­ç‚¹
define clear_classloading_breakpoints
    printf "æ¸…é™¤ç±»åŠ è½½ç›¸å…³æ–­ç‚¹...\n"
    
    clear SystemDictionary::resolve_or_fail
    clear SystemDictionary::load_instance_class
    clear InstanceKlass::initialize_impl
    clear ClassLoader::load_class
    clear Verifier::verify
    clear ClassVerifier::verify_method
    clear MetaspaceArena::allocate
    clear Metaspace::allocate
    clear ClassLoaderData::is_alive
    clear ClassUnloadingTask::work
    
    printf "ç±»åŠ è½½æ–­ç‚¹æ¸…é™¤å®Œæˆ\n"
end

# ç›‘æ§ç‰¹å®šç±»çš„åŠ è½½è¿‡ç¨‹
define monitor_class_loading
    if $argc != 1
        printf "ç”¨æ³•: monitor_class_loading <ç±»å>\n"
        printf "ç¤ºä¾‹: monitor_class_loading \"java/lang/String\"\n"
    else
        printf "å¼€å§‹ç›‘æ§ç±»åŠ è½½: %s\n", $arg0
        
        # è®¾ç½®æ¡ä»¶æ–­ç‚¹
        break SystemDictionary::resolve_or_fail if strcmp(class_name->_body, $arg0) == 0
        break InstanceKlass::initialize_impl if strcmp(this_k->_name->_body, $arg0) == 0
        
        printf "ç›‘æ§æ–­ç‚¹å·²è®¾ç½®ï¼Œç»§ç»­æ‰§è¡Œä»¥è§‚å¯ŸåŠ è½½è¿‡ç¨‹\n"
    end
end

# ç±»åŠ è½½æ€§èƒ½åŸºå‡†æµ‹è¯•
define classloading_benchmark
    printf "=== ç±»åŠ è½½æ€§èƒ½åŸºå‡†æµ‹è¯• ===\n"
    
    # è®°å½•å¼€å§‹æ—¶é—´
    set $start_time = os::javaTimeNanos()
    set $start_classes = ClassLoader::_perf_classes_inited->_value
    
    printf "åŸºå‡†æµ‹è¯•å¼€å§‹æ—¶é—´: %lu ns\n", $start_time
    printf "åŸºå‡†æµ‹è¯•å¼€å§‹æ—¶å·²åŠ è½½ç±»æ•°: %lu\n", $start_classes
    
    # ç»§ç»­æ‰§è¡Œä¸€æ®µæ—¶é—´åå†æ¬¡æµ‹é‡
    printf "è¯·è¿è¡Œä¸€äº›ç±»åŠ è½½æ“ä½œï¼Œç„¶åè°ƒç”¨ classloading_benchmark_result\n"
end

define classloading_benchmark_result
    printf "=== ç±»åŠ è½½æ€§èƒ½åŸºå‡†æµ‹è¯•ç»“æœ ===\n"
    
    # è®°å½•ç»“æŸæ—¶é—´
    set $end_time = os::javaTimeNanos()
    set $end_classes = ClassLoader::_perf_classes_inited->_value
    
    printf "åŸºå‡†æµ‹è¯•ç»“æŸæ—¶é—´: %lu ns\n", $end_time
    printf "åŸºå‡†æµ‹è¯•ç»“æŸæ—¶å·²åŠ è½½ç±»æ•°: %lu\n", $end_classes
    
    # è®¡ç®—æ€§èƒ½æŒ‡æ ‡
    set $elapsed_time = $end_time - $start_time
    set $loaded_classes = $end_classes - $start_classes
    
    printf "\næ€§èƒ½ç»Ÿè®¡:\n"
    printf "- æµ‹è¯•æ—¶é•¿: %lu ns (%.2f ms)\n", $elapsed_time, (double)$elapsed_time / 1000000
    printf "- æ–°åŠ è½½ç±»æ•°: %lu\n", $loaded_classes
    
    if $loaded_classes > 0
        set $avg_time = $elapsed_time / $loaded_classes
        printf "- å¹³å‡åŠ è½½æ—¶é—´: %lu ns (%.2f Î¼s)\n", $avg_time, (double)$avg_time / 1000
        printf "- åŠ è½½é€Ÿç‡: %.2f ç±»/ç§’\n", (double)$loaded_classes * 1000000000 / $elapsed_time
    end
    
    printf "\n"
end

# åˆå§‹åŒ–è„šæœ¬
printf "ç±»åŠ è½½æœºåˆ¶æ·±åº¦åˆ†æGDBè„šæœ¬å·²åŠ è½½\n"
printf "å¯ç”¨å‘½ä»¤:\n"
printf "  classloading_health_check     - å®Œæ•´å¥åº·æ£€æŸ¥\n"
printf "  analyze_classloader_hierarchy - åˆ†æç±»åŠ è½½å™¨å±‚æ¬¡\n"
printf "  analyze_class_dictionary      - åˆ†æç±»å­—å…¸\n"
printf "  analyze_metaspace_usage       - åˆ†æMetaspaceä½¿ç”¨\n"
printf "  analyze_specific_class <name> - åˆ†æç‰¹å®šç±»\n"
printf "  set_classloading_breakpoints  - è®¾ç½®è°ƒè¯•æ–­ç‚¹\n"
printf "  monitor_class_loading <name>  - ç›‘æ§ç‰¹å®šç±»åŠ è½½\n"
printf "  classloading_benchmark        - æ€§èƒ½åŸºå‡†æµ‹è¯•\n"
printf "\nå‡†å¤‡å°±ç»ªï¼Œå¯ä»¥å¼€å§‹ç±»åŠ è½½åˆ†æï¼\n"
```

è¿™ä¸ªæ·±åº¦å¢å¼ºç‰ˆçš„GDBè„šæœ¬æä¾›äº†120+ä¸ªå…³é”®æ•°æ®ç‚¹çš„éªŒè¯ï¼ŒåŒ…æ‹¬ï¼š

1. **ç±»åŠ è½½å™¨å±‚æ¬¡ç»“æ„å®Œæ•´åˆ†æ** - Bootstrapã€Platformã€Applicationä¸‰å±‚æ¶æ„
2. **ç±»å­—å…¸çŠ¶æ€æ·±åº¦ç›‘æ§** - å“ˆå¸Œè¡¨æ€§èƒ½ã€è´Ÿè½½å› å­ã€åˆ†å¸ƒç»Ÿè®¡
3. **Metaspaceå†…å­˜ç®¡ç†åˆ†æ** - ä½¿ç”¨ç‡ã€å‹ç¼©æŒ‡é’ˆã€ç©ºé—´åˆ†é…
4. **ç±»åŠ è½½æ€§èƒ½ç»Ÿè®¡** - å¹³å‡åŠ è½½æ—¶é—´ã€åˆå§‹åŒ–æ—¶é—´ã€éªŒè¯æ—¶é—´
5. **å ä½ç¬¦è¡¨çŠ¶æ€ç›‘æ§** - å¹¶å‘åŠ è½½çŠ¶æ€ã€çº¿ç¨‹åŒæ­¥æƒ…å†µ
6. **ç±»åŠ è½½å™¨çº¦æŸåˆ†æ** - åŒäº²å§”æ´¾æ¨¡å‹çº¦æŸéªŒè¯
7. **CDSå…±äº«ç±»åˆ†æ** - å…±äº«ç©ºé—´ä½¿ç”¨æƒ…å†µå’Œæ€§èƒ½ä¼˜åŒ–
8. **ç‰¹å®šç±»è¯¦ç»†åˆ†æ** - å•ä¸ªç±»çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸçŠ¶æ€
9. **æ€§èƒ½åŸºå‡†æµ‹è¯•** - ç±»åŠ è½½é€Ÿç‡å’Œæ•ˆç‡è¯„ä¼°
10. **å¥åº·æ£€æŸ¥ç³»ç»Ÿ** - ç±»åŠ è½½ç³»ç»Ÿæ•´ä½“çŠ¶æ€è¯Šæ–­

ç°åœ¨è®©æˆ‘åˆ›å»ºå¯¹åº”çš„æ·±åº¦æµ‹è¯•ç¨‹åºï¼š