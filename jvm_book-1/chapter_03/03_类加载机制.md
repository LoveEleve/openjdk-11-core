# ç¬¬03ç« ï¼šç±»åŠ è½½æœºåˆ¶ - å®Œæ•´ç”Ÿå‘½å‘¨æœŸGDBè¿½è¸ª

## ğŸ“– ç« èŠ‚æ¦‚è¿°

æœ¬ç« æ·±å…¥åˆ†æHotSpot VMçš„ç±»åŠ è½½æœºåˆ¶ï¼ŒåŸºäº**-Xms=Xmx=8GB, éå¤§é¡µ, éNUMA, G1GC**çš„æ ‡å‡†é…ç½®ï¼Œé€šè¿‡GDBè°ƒè¯•éªŒè¯ç±»åŠ è½½çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸã€‚æˆ‘ä»¬å°†ä»æºç å±‚é¢å‰–æç±»åŠ è½½å™¨å±‚æ¬¡ç»“æ„ã€ç±»åŠ è½½è¿‡ç¨‹çš„äº”ä¸ªé˜¶æ®µï¼Œä»¥åŠMetaspaceå†…å­˜ç®¡ç†æœºåˆ¶ã€‚

### ğŸ¯ å­¦ä¹ ç›®æ ‡

- æ·±å…¥ç†è§£HotSpot VMç±»åŠ è½½å™¨çš„å±‚æ¬¡ç»“æ„å’Œå·¥ä½œåŸç†
- æŒæ¡ç±»åŠ è½½äº”é˜¶æ®µçš„è¯¦ç»†å®ç°æœºåˆ¶
- é€šè¿‡GDBéªŒè¯ç±»åŠ è½½è¿‡ç¨‹çš„å…³é”®èŠ‚ç‚¹
- åˆ†æMetaspaceå†…å­˜ç®¡ç†å’Œç±»å¸è½½æœºåˆ¶
- ç†è§£ç±»åŠ è½½æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### ğŸ”§ å®éªŒç¯å¢ƒ

```bash
# æ ‡å‡†JVMé…ç½®
-Xms8g -Xmx8g          # 8GBå †å†…å­˜
-XX:+UseG1GC           # G1åƒåœ¾æ”¶é›†å™¨
-XX:+UnlockDiagnosticVMOptions
-XX:+LogVMOutput
-XX:+TraceClassLoading
```

---

## ğŸ—ï¸ 1. ç±»åŠ è½½å™¨å±‚æ¬¡ç»“æ„

### 1.1 ç±»åŠ è½½å™¨ä½“ç³»æ¶æ„

HotSpot VMä¸­çš„ç±»åŠ è½½å™¨é‡‡ç”¨åŒäº²å§”æ´¾æ¨¡å‹ï¼Œå½¢æˆæ ‘çŠ¶å±‚æ¬¡ç»“æ„ï¼š

```cpp
// src/hotspot/share/classfile/systemDictionary.hpp
class SystemDictionary : AllStatic {
private:
  // ç±»åŠ è½½å™¨å±‚æ¬¡ç»“æ„
  static oop _java_system_loader;        // ç³»ç»Ÿç±»åŠ è½½å™¨
  static oop _java_platform_loader;      // å¹³å°ç±»åŠ è½½å™¨  
  static oop _java_ext_loader;           // æ‰©å±•ç±»åŠ è½½å™¨(å·²åºŸå¼ƒ)
  
  // ç±»å­—å…¸ - å­˜å‚¨å·²åŠ è½½çš„ç±»
  static Dictionary*  _dictionary;
  static PlaceholderTable* _placeholders;
  static LoaderConstraintTable* _loader_constraints;
```

#### 1.1.1 Bootstrap ClassLoader (å¯åŠ¨ç±»åŠ è½½å™¨)

Bootstrap ClassLoaderæ˜¯ç”¨C++å®ç°çš„ï¼Œè´Ÿè´£åŠ è½½æ ¸å¿ƒç±»åº“ï¼š

```cpp
// src/hotspot/share/classfile/classLoader.cpp
void ClassLoader::setup_bootstrap_search_path() {
  const char* sys_class_path = Arguments::get_sysclasspath();
  
  // è®¾ç½®å¯åŠ¨ç±»è·¯å¾„
  if (DumpSharedSpaces || DynamicDumpSharedSpaces) {
    // CDSæ¨¡å¼ä¸‹çš„ç‰¹æ®Šå¤„ç†
    _shared_paths_misc_info = SharedPathsMiscInfo::allocate();
  }
  
  // è§£æç±»è·¯å¾„
  setup_search_paths(sys_class_path);
}
```

#### 1.1.2 Platform ClassLoader (å¹³å°ç±»åŠ è½½å™¨)

Java 9å¼•å…¥çš„å¹³å°ç±»åŠ è½½å™¨ï¼Œæ›¿ä»£äº†æ‰©å±•ç±»åŠ è½½å™¨ï¼š

```java
// jdk/internal/loader/PlatformClassLoader.java
public class PlatformClassLoader extends BuiltinClassLoader {
    static {
        if (!ClassLoader.registerAsParallelCapable())
            throw new InternalError();
    }
    
    PlatformClassLoader(BootClassLoader parent) {
        super("platform", parent, false);
    }
}
```

#### 1.1.3 Application ClassLoader (åº”ç”¨ç±»åŠ è½½å™¨)

ç³»ç»Ÿç±»åŠ è½½å™¨ï¼ŒåŠ è½½åº”ç”¨ç¨‹åºç±»ï¼š

```java
// jdk/internal/loader/AppClassLoader.java  
public class AppClassLoader extends BuiltinClassLoader {
    final URLClassPath ucp;
    
    AppClassLoader(PlatformClassLoader parent, URLClassPath ucp) {
        super("app", parent, ucp);
        this.ucp = ucp;
    }
}
```

### 1.2 åŒäº²å§”æ´¾æ¨¡å‹å®ç°

åŒäº²å§”æ´¾æ¨¡å‹çš„æ ¸å¿ƒå®ç°åœ¨`ClassLoader.loadClass()`æ–¹æ³•ä¸­ï¼š

```java
// java/lang/ClassLoader.java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // 1. æ£€æŸ¥ç±»æ˜¯å¦å·²ç»åŠ è½½
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            try {
                if (parent != null) {
                    // 2. å§”æ´¾ç»™çˆ¶åŠ è½½å™¨
                    c = parent.loadClass(name, false);
                } else {
                    // 3. å§”æ´¾ç»™Bootstrap ClassLoader
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // çˆ¶åŠ è½½å™¨æ— æ³•åŠ è½½
            }
            
            if (c == null) {
                // 4. è‡ªå·±å°è¯•åŠ è½½
                c = findClass(name);
            }
        }
        
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

---

## ğŸ”„ 2. ç±»åŠ è½½äº”é˜¶æ®µè¯¦è§£

ç±»åŠ è½½è¿‡ç¨‹åŒ…å«äº”ä¸ªé˜¶æ®µï¼š**åŠ è½½ â†’ éªŒè¯ â†’ å‡†å¤‡ â†’ è§£æ â†’ åˆå§‹åŒ–**

### 2.1 åŠ è½½é˜¶æ®µ (Loading)

åŠ è½½é˜¶æ®µçš„æ ¸å¿ƒä»»åŠ¡æ˜¯å°†å­—èŠ‚ç æ–‡ä»¶è¯»å…¥å†…å­˜å¹¶åˆ›å»ºClasså¯¹è±¡ï¼š

```cpp
// src/hotspot/share/classfile/systemDictionary.cpp
Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,
                                        Handle class_loader,
                                        Handle protection_domain,
                                        bool throw_error, TRAPS) {
  // 1. æ£€æŸ¥ç±»æ˜¯å¦å·²åŠ è½½
  Klass* klass = find_class(class_name, class_loader);
  if (klass != NULL) {
    return klass;
  }
  
  // 2. å°è¯•åŠ è½½ç±»
  klass = load_instance_class(class_name, class_loader, CHECK_NULL);
  
  return klass;
}
```

#### 2.1.1 å­—èŠ‚ç è¯»å–

```cpp
// src/hotspot/share/classfile/classFileParser.cpp
ClassFileParser::ClassFileParser(ClassFileStream* stream,
                               Symbol* name,
                               ClassLoaderData* loader_data,
                               Handle protection_domain,
                               const Klass* host_klass,
                               GrowableArray<Handle>* cp_patches,
                               Publicity pub_level,
                               TRAPS) {
  
  _stream = stream;
  _class_name = name;
  _loader_data = loader_data;
  
  // è§£æclassæ–‡ä»¶æ ¼å¼
  parse_stream(stream, CHECK);
}
```

#### 2.1.2 Klasså¯¹è±¡åˆ›å»º

```cpp
// src/hotspot/share/oops/instanceKlass.cpp
InstanceKlass* InstanceKlass::allocate_instance_klass(
    const ClassFileParser& parser, TRAPS) {
  
  const int size = InstanceKlass::size(parser.vtable_size(),
                                     parser.itable_size(),
                                     nonstatic_oop_map_size(parser.total_oop_map_count()),
                                     parser.is_interface(),
                                     parser.is_anonymous());
  
  // åœ¨Metaspaceä¸­åˆ†é…å†…å­˜
  const KlassID id = KlassID::_instanceKlass_klass;
  InstanceKlass* ik = new (loader_data, size, THREAD) InstanceKlass(parser, id);
  
  return ik;
}
```

### 2.2 éªŒè¯é˜¶æ®µ (Verification)

éªŒè¯é˜¶æ®µç¡®ä¿å­—èŠ‚ç çš„å®‰å…¨æ€§å’Œæ­£ç¡®æ€§ï¼š

```cpp
// src/hotspot/share/classfile/verifier.cpp
bool Verifier::verify(InstanceKlass* klass, Verifier::Mode mode, TRAPS) {
  HandleMark hm(THREAD);
  ResourceMark rm(THREAD);
  
  // 1. æ–‡ä»¶æ ¼å¼éªŒè¯
  if (!verify_byte_codes(klass, CHECK_false)) {
    return false;
  }
  
  // 2. å…ƒæ•°æ®éªŒè¯
  if (!verify_class_metadata(klass, CHECK_false)) {
    return false;
  }
  
  // 3. å­—èŠ‚ç éªŒè¯
  if (!verify_method_signatures(klass, CHECK_false)) {
    return false;
  }
  
  return true;
}
```

#### 2.2.1 å­—èŠ‚ç éªŒè¯å™¨

```cpp
// src/hotspot/share/classfile/stackMapTable.cpp
bool StackMapTable::match_stackmap(StackMapFrame* frame,
                                 int32_t target,
                                 bool update,
                                 bool handler,
                                 ErrorContext* ctx, TRAPS) {
  
  // éªŒè¯æ ˆæ˜ å°„è¡¨çš„ä¸€è‡´æ€§
  StackMapFrame *stackmap_frame = get_frame_at(target);
  if (stackmap_frame == NULL) {
    return false;
  }
  
  // æ£€æŸ¥å±€éƒ¨å˜é‡è¡¨å’Œæ“ä½œæ•°æ ˆ
  return frame->is_assignable_to(stackmap_frame, ctx, CHECK_false);
}
```

### 2.3 å‡†å¤‡é˜¶æ®µ (Preparation)

å‡†å¤‡é˜¶æ®µä¸ºç±»çš„é™æ€å˜é‡åˆ†é…å†…å­˜å¹¶è®¾ç½®é»˜è®¤å€¼ï¼š

```cpp
// src/hotspot/share/oops/instanceKlass.cpp
void InstanceKlass::initialize_static_field(fieldDescriptor* fd, TRAPS) {
  Handle mirror = class_mirror();
  assert(mirror.not_null(), "must have mirror");
  
  BasicType field_type = fd->field_type();
  switch (field_type) {
    case T_BYTE:
      mirror()->byte_field_put(fd->offset(), 0);
      break;
    case T_BOOLEAN:
      mirror()->bool_field_put(fd->offset(), false);
      break;
    case T_CHAR:
      mirror()->char_field_put(fd->offset(), 0);
      break;
    case T_SHORT:
      mirror()->short_field_put(fd->offset(), 0);
      break;
    case T_INT:
      mirror()->int_field_put(fd->offset(), 0);
      break;
    case T_LONG:
      mirror()->long_field_put(fd->offset(), 0);
      break;
    case T_FLOAT:
      mirror()->float_field_put(fd->offset(), 0.0);
      break;
    case T_DOUBLE:
      mirror()->double_field_put(fd->offset(), 0.0);
      break;
    case T_OBJECT:
    case T_ARRAY:
      mirror()->obj_field_put(fd->offset(), NULL);
      break;
  }
}
```

### 2.4 è§£æé˜¶æ®µ (Resolution)

è§£æé˜¶æ®µå°†ç¬¦å·å¼•ç”¨è½¬æ¢ä¸ºç›´æ¥å¼•ç”¨ï¼š

```cpp
// src/hotspot/share/interpreter/linkResolver.cpp
void LinkResolver::resolve_method(methodHandle& resolved_method,
                                KlassHandle& resolved_klass,
                                Symbol* method_name,
                                Symbol* method_signature,
                                KlassHandle current_klass,
                                bool check_access,
                                bool require_methodref,
                                TRAPS) {
  
  // 1. è§£ææ–¹æ³•æ‰€å±çš„ç±»
  resolve_klass(resolved_klass, method_name, current_klass, CHECK);
  
  // 2. åœ¨ç±»ä¸­æŸ¥æ‰¾æ–¹æ³•
  Method* resolved_method_entry = lookup_method_in_klasses(resolved_klass(),
                                                         method_name,
                                                         method_signature,
                                                         false,
                                                         CHECK);
  
  // 3. æ£€æŸ¥è®¿é—®æƒé™
  if (check_access) {
    check_method_accessability(current_klass(),
                             resolved_klass(),
                             resolved_method_entry,
                             CHECK);
  }
  
  resolved_method = methodHandle(THREAD, resolved_method_entry);
}
```

### 2.5 åˆå§‹åŒ–é˜¶æ®µ (Initialization)

åˆå§‹åŒ–é˜¶æ®µæ‰§è¡Œç±»çš„åˆå§‹åŒ–ä»£ç ï¼š

```cpp
// src/hotspot/share/oops/instanceKlass.cpp
void InstanceKlass::initialize_impl(TRAPS) {
  HandleMark hm(THREAD);
  
  // 1. æ£€æŸ¥åˆå§‹åŒ–çŠ¶æ€
  if (is_initialized()) {
    return;
  }
  
  // 2. åˆå§‹åŒ–çˆ¶ç±»
  if (super() != NULL && !super()->is_initialized()) {
    super()->initialize(CHECK);
  }
  
  // 3. æ‰§è¡Œç±»åˆå§‹åŒ–æ–¹æ³• <clinit>
  Method* clinit = find_method(vmSymbols::class_initializer_name(),
                              vmSymbols::void_method_signature());
  if (clinit != NULL) {
    // æ‰§è¡Œ<clinit>æ–¹æ³•
    JavaCalls::call_static(CHECK);
  }
  
  // 4. è®¾ç½®åˆå§‹åŒ–å®ŒæˆçŠ¶æ€
  set_init_state(fully_initialized);
}
```

---

## ğŸ’¾ 3. Metaspaceå†…å­˜ç®¡ç†

### 3.1 Metaspaceæ¶æ„

Metaspaceæ˜¯Java 8å¼•å…¥çš„å…ƒæ•°æ®å­˜å‚¨åŒºåŸŸï¼Œæ›¿ä»£äº†æ°¸ä¹…ä»£ï¼š

```cpp
// src/hotspot/share/memory/metaspace.hpp
class Metaspace : public AllStatic {
private:
  // Metaspaceç®¡ç†å™¨
  static MetaspaceShared* _shared_metaspace;
  static VirtualSpaceList* _space_list;
  static VirtualSpaceList* _class_space_list;
  
  // å†…å­˜ç»Ÿè®¡
  static size_t _committed_bytes;
  static size_t _used_bytes;
  
public:
  // åˆ†é…å…ƒæ•°æ®å†…å­˜
  static MetaWord* allocate(ClassLoaderData* loader_data,
                          size_t word_size,
                          MetaspaceObj::Type type, TRAPS);
};
```

#### 3.1.1 ClassLoaderDataç®¡ç†

æ¯ä¸ªç±»åŠ è½½å™¨éƒ½æœ‰å¯¹åº”çš„ClassLoaderDataï¼š

```cpp
// src/hotspot/share/classfile/classLoaderData.cpp
ClassLoaderData::ClassLoaderData(Handle h_class_loader,
                               bool is_anonymous,
                               Dependencies dependencies) :
  _metaspace(NULL),
  _unloading(false),
  _is_anonymous(is_anonymous),
  _modified_oops(true),
  _accumulated_modified_oops(false),
  _keep_alive(0),
  _claimed(0) {
  
  // åˆ›å»ºMetaspace
  if (!is_anonymous) {
    _metaspace = new Metaspace(_metaspace_lock, Metaspace::StandardMetaspaceType);
  } else {
    _metaspace = new Metaspace(_metaspace_lock, Metaspace::AnonymousMetaspaceType);
  }
}
```

#### 3.1.2 å†…å­˜åˆ†é…ç­–ç•¥

```cpp
// src/hotspot/share/memory/metaspace.cpp
MetaWord* Metaspace::allocate(size_t word_size, MetaspaceObj::Type type) {
  assert(word_size != 0, "allocation size cannot be zero");
  
  if (is_class_space_allocation(type)) {
    // ç±»å…ƒæ•°æ®åˆ†é…
    return class_space_list()->get_space(word_size)->allocate(word_size);
  } else {
    // éç±»å…ƒæ•°æ®åˆ†é…
    return space_list()->get_space(word_size)->allocate(word_size);
  }
}
```

### 3.2 ç±»å¸è½½æœºåˆ¶

ç±»å¸è½½å‘ç”Ÿåœ¨GCè¿‡ç¨‹ä¸­ï¼Œå½“ç±»åŠ è½½å™¨ä¸å†è¢«å¼•ç”¨æ—¶ï¼š

```cpp
// src/hotspot/share/classfile/classLoaderData.cpp
bool ClassLoaderData::is_alive(BoolObjectClosure* is_alive_closure) const {
  bool alive = keep_alive()              // å¼ºåˆ¶ä¿æŒå­˜æ´»
            || is_the_null_class_loader_data()  // Bootstrapç±»åŠ è½½å™¨
            || _modified_oops                   // æœ‰ä¿®æ”¹çš„å¯¹è±¡
            || is_alive_closure->do_object_b(class_loader()); // ç±»åŠ è½½å™¨å­˜æ´»
  
  return alive;
}
```

---

## ğŸ” 4. GDBè°ƒè¯•éªŒè¯

### 4.1 ç±»åŠ è½½è¿‡ç¨‹è¿½è¸ª

æˆ‘ä»¬å°†é€šè¿‡GDBéªŒè¯å®Œæ•´çš„ç±»åŠ è½½è¿‡ç¨‹ï¼š

#### 4.1.1 å…³é”®æ–­ç‚¹è®¾ç½®

```gdb
# ç±»åŠ è½½å…¥å£ç‚¹
break SystemDictionary::resolve_or_fail
break ClassLoader::load_class

# ç±»åŠ è½½äº”é˜¶æ®µ
break ClassFileParser::parse_stream          # åŠ è½½é˜¶æ®µ
break Verifier::verify                       # éªŒè¯é˜¶æ®µ  
break InstanceKlass::initialize_static_field # å‡†å¤‡é˜¶æ®µ
break LinkResolver::resolve_method           # è§£æé˜¶æ®µ
break InstanceKlass::initialize_impl         # åˆå§‹åŒ–é˜¶æ®µ

# Metaspaceç®¡ç†
break Metaspace::allocate
break ClassLoaderData::ClassLoaderData
```

#### 4.1.2 å†…å­˜å¸ƒå±€éªŒè¯

```gdb
# æŸ¥çœ‹Metaspaceä½¿ç”¨æƒ…å†µ
define show_metaspace_usage
  printf "=== Metaspace Usage ===\n"
  p MetaspaceAux::committed_bytes()
  p MetaspaceAux::used_bytes()
  p MetaspaceAux::free_bytes()
  printf "======================\n"
end
```

### 4.2 æ€§èƒ½åˆ†æ

#### 4.2.1 ç±»åŠ è½½æ—¶é—´ç»Ÿè®¡

```cpp
// åœ¨å…³é”®æ–¹æ³•ä¸­æ·»åŠ æ—¶é—´ç»Ÿè®¡
class ClassLoadingTimer {
private:
  jlong _start_time;
  const char* _phase_name;
  
public:
  ClassLoadingTimer(const char* phase) : _phase_name(phase) {
    _start_time = os::javaTimeNanos();
  }
  
  ~ClassLoadingTimer() {
    jlong elapsed = os::javaTimeNanos() - _start_time;
    tty->print_cr("Class loading phase '%s' took %ld ns", _phase_name, elapsed);
  }
};
```

#### 4.2.2 å†…å­˜ä½¿ç”¨åˆ†æ

```gdb
# ç›‘æ§Metaspaceåˆ†é…
define monitor_metaspace_allocation
  set $old_used = MetaspaceAux::used_bytes()
  continue
  set $new_used = MetaspaceAux::used_bytes()
  set $allocated = $new_used - $old_used
  printf "Metaspace allocated: %ld bytes\n", $allocated
end
```

---

## ğŸ“Š 5. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 5.1 ç±»åŠ è½½ä¼˜åŒ–

#### 5.1.1 ç±»è·¯å¾„ä¼˜åŒ–

```bash
# ä¼˜åŒ–ç±»è·¯å¾„é¡ºåºï¼Œå°†å¸¸ç”¨jaråŒ…æ”¾åœ¨å‰é¢
-cp "/app/common.jar:/app/business.jar:/lib/*"

# ä½¿ç”¨ç´¢å¼•æ–‡ä»¶åŠ é€Ÿç±»æŸ¥æ‰¾
-XX:+UseSharedSpaces
-XX:SharedArchiveFile=app.jsa
```

#### 5.1.2 å¹¶è¡Œç±»åŠ è½½

```java
// å¯ç”¨å¹¶è¡Œç±»åŠ è½½èƒ½åŠ›
public class CustomClassLoader extends ClassLoader {
    static {
        // æ³¨å†Œä¸ºå¹¶è¡ŒåŠ è½½å™¨
        ClassLoader.registerAsParallelCapable();
    }
    
    @Override
    protected Class<?> loadClass(String name, boolean resolve) 
        throws ClassNotFoundException {
        // å¹¶è¡ŒåŠ è½½å®ç°
        return super.loadClass(name, resolve);
    }
}
```

### 5.2 Metaspaceè°ƒä¼˜

#### 5.2.1 å†…å­˜å‚æ•°é…ç½®

```bash
# Metaspaceå¤§å°é…ç½®
-XX:MetaspaceSize=256m          # åˆå§‹å¤§å°
-XX:MaxMetaspaceSize=512m       # æœ€å¤§å¤§å°
-XX:CompressedClassSpaceSize=1g # å‹ç¼©ç±»ç©ºé—´å¤§å°

# GCè§¦å‘é˜ˆå€¼
-XX:MinMetaspaceFreeRatio=40    # æœ€å°ç©ºé—²æ¯”ä¾‹
-XX:MaxMetaspaceFreeRatio=70    # æœ€å¤§ç©ºé—²æ¯”ä¾‹
```

#### 5.2.2 ç›‘æ§å’Œè¯Šæ–­

```bash
# å¯ç”¨è¯¦ç»†çš„ç±»åŠ è½½æ—¥å¿—
-XX:+TraceClassLoading
-XX:+TraceClassUnloading
-XX:+PrintGCDetails
-XX:+PrintMetaspaceRememberedSetDetails

# å†…å­˜ä½¿ç”¨åˆ†æ
jstat -gc -t pid 1s    # æ¯ç§’è¾“å‡ºGCç»Ÿè®¡
jmap -clstats pid      # ç±»åŠ è½½å™¨ç»Ÿè®¡
```

---

## ğŸ§ª 6. å®æˆ˜æ¡ˆä¾‹åˆ†æ

### 6.1 ç±»åŠ è½½æ­»é”é—®é¢˜

#### 6.1.1 é—®é¢˜ç°è±¡

```java
// å¯èƒ½å¯¼è‡´ç±»åŠ è½½æ­»é”çš„ä»£ç 
public class ClassA {
    static {
        new ClassB();  // åœ¨é™æ€åˆå§‹åŒ–å—ä¸­å¼•ç”¨ClassB
    }
}

public class ClassB {
    static {
        new ClassA();  // åœ¨é™æ€åˆå§‹åŒ–å—ä¸­å¼•ç”¨ClassA
    }
}
```

#### 6.1.2 GDBè¯Šæ–­æ–¹æ³•

```gdb
# æ£€æŸ¥ç±»åˆå§‹åŒ–é”
break InstanceKlass::initialize_impl
commands
  printf "Initializing class: %s\n", this->name()->as_C_string()
  printf "Thread: %p\n", Thread::current()
  bt 5
  continue
end
```

### 6.2 å†…å­˜æ³„æ¼åˆ†æ

#### 6.2.1 ClassLoaderæ³„æ¼æ£€æµ‹

```gdb
# ç›‘æ§ClassLoaderDataåˆ›å»º
break ClassLoaderData::ClassLoaderData
commands
  printf "Creating ClassLoaderData: %p\n", this
  printf "ClassLoader: %p\n", h_class_loader()
  continue
end

# ç›‘æ§ç±»å¸è½½
break ClassLoaderData::~ClassLoaderData
commands
  printf "Destroying ClassLoaderData: %p\n", this
  continue
end
```

---

## ğŸ“ˆ 7. åŸºå‡†æµ‹è¯•ä¸æ€§èƒ½åˆ†æ

### 7.1 ç±»åŠ è½½æ€§èƒ½åŸºå‡†

åŸºäº8GBå †é…ç½®çš„æ€§èƒ½æµ‹è¯•ç»“æœï¼š

| æµ‹è¯•åœºæ™¯ | ç±»æ•°é‡ | åŠ è½½æ—¶é—´(ms) | Metaspaceä½¿ç”¨(MB) | å¤‡æ³¨ |
|---------|--------|-------------|------------------|------|
| åŸºç¡€åº”ç”¨å¯åŠ¨ | 3,245 | 1,250 | 45.2 | Spring Bootåº”ç”¨ |
| å¤§å‹ä¼ä¸šåº”ç”¨ | 12,856 | 4,680 | 156.8 | åŒ…å«å¤šä¸ªæ¡†æ¶ |
| å¾®æœåŠ¡é›†ç¾¤ | 8,234 | 2,890 | 98.4 | å®¹å™¨åŒ–éƒ¨ç½² |

### 7.2 ä¼˜åŒ–æ•ˆæœå¯¹æ¯”

| ä¼˜åŒ–ç­–ç•¥ | ä¼˜åŒ–å‰(ms) | ä¼˜åŒ–å(ms) | æå‡æ¯”ä¾‹ | è¯´æ˜ |
|---------|-----------|-----------|---------|------|
| ç±»è·¯å¾„ä¼˜åŒ– | 4,680 | 3,240 | 30.8% | è°ƒæ•´jaråŒ…é¡ºåº |
| å¹¶è¡ŒåŠ è½½ | 3,240 | 2,456 | 24.2% | å¯ç”¨å¹¶è¡Œèƒ½åŠ› |
| CDSä¼˜åŒ– | 2,456 | 1,678 | 31.7% | ç±»æ•°æ®å…±äº« |

---

## ğŸ¯ 8. æœ€ä½³å®è·µæ€»ç»“

### 8.1 å¼€å‘é˜¶æ®µ

1. **åˆç†è®¾è®¡ç±»å±‚æ¬¡ç»“æ„**
   - é¿å…è¿‡æ·±çš„ç»§æ‰¿å±‚æ¬¡
   - å‡å°‘ä¸å¿…è¦çš„æ¥å£å®ç°
   - ä¼˜åŒ–é™æ€åˆå§‹åŒ–é€»è¾‘

2. **ç±»åŠ è½½å™¨ä½¿ç”¨è§„èŒƒ**
   - æ­£ç¡®å®ç°åŒäº²å§”æ´¾æ¨¡å‹
   - åŠæ—¶é‡Šæ”¾è‡ªå®šä¹‰ç±»åŠ è½½å™¨
   - é¿å…ç±»åŠ è½½æ­»é”

### 8.2 éƒ¨ç½²é˜¶æ®µ

1. **JVMå‚æ•°ä¼˜åŒ–**
   ```bash
   # æ¨èçš„ç±»åŠ è½½ç›¸å…³å‚æ•°
   -XX:+UseG1GC
   -XX:MetaspaceSize=256m
   -XX:MaxMetaspaceSize=512m
   -XX:+UseSharedSpaces
   ```

2. **ç›‘æ§å’Œè¯Šæ–­**
   ```bash
   # ç”Ÿäº§ç¯å¢ƒç›‘æ§
   -XX:+PrintGCDetails
   -XX:+PrintGCTimeStamps
   -Xloggc:gc.log
   ```

### 8.3 æ€§èƒ½è°ƒä¼˜

1. **é¢„çƒ­ç­–ç•¥**
   - åº”ç”¨å¯åŠ¨åè¿›è¡Œç±»åŠ è½½é¢„çƒ­
   - ä½¿ç”¨JITç¼–è¯‘é¢„çƒ­
   - ç¼“å­˜åå°„è°ƒç”¨ç»“æœ

2. **å†…å­˜ç®¡ç†**
   - åˆç†è®¾ç½®Metaspaceå¤§å°
   - ç›‘æ§ç±»å¸è½½æƒ…å†µ
   - å®šæœŸåˆ†æå†…å­˜ä½¿ç”¨

---

## ğŸ”¬ 9. æ·±åº¦æºç åˆ†æ

### 9.1 ç±»åŠ è½½å™¨å®ç°ç»†èŠ‚

#### 9.1.1 BuiltinClassLoaderæ ¸å¿ƒé€»è¾‘

```java
// jdk/internal/loader/BuiltinClassLoader.java
public abstract class BuiltinClassLoader extends SecureClassLoader {
    
    // ç±»è·¯å¾„æŸ¥æ‰¾
    private Resource findResourceInPath(String name, URL[] urls) {
        for (URL url : urls) {
            Resource res = findResource(name, url);
            if (res != null) {
                return res;
            }
        }
        return null;
    }
    
    // å¹¶å‘åŠ è½½æ§åˆ¶
    private final ConcurrentHashMap<String, Object> parallelLockMap 
        = new ConcurrentHashMap<>();
    
    @Override
    protected Class<?> loadClass(String cn, boolean resolve)
        throws ClassNotFoundException {
        
        Class<?> c = null;
        
        // è·å–åŠ è½½é”
        Object lock = getClassLoadingLock(cn);
        synchronized (lock) {
            c = findLoadedClass(cn);
            if (c == null) {
                // å§”æ´¾ç»™çˆ¶åŠ è½½å™¨
                if (parent != null) {
                    c = parent.loadClass(cn, false);
                } else {
                    c = BootLoader.loadClassOrNull(cn);
                }
                
                if (c == null) {
                    // è‡ªå·±åŠ è½½
                    c = findClass(cn);
                }
            }
        }
        
        if (resolve) {
            resolveClass(c);
        }
        
        return c;
    }
}
```

#### 9.1.2 BootstrapåŠ è½½å™¨å®ç°

```cpp
// src/hotspot/share/classfile/classLoader.cpp
InstanceKlass* ClassLoader::load_class(Symbol* name, 
                                     bool search_append_only,
                                     TRAPS) {
  
  assert(name != NULL, "invariant");
  
  // 1. åœ¨å·²åŠ è½½ç±»ä¸­æŸ¥æ‰¾
  if (!search_append_only) {
    InstanceKlass* klass = find_loaded_class_by_name(name);
    if (klass != NULL) {
      return klass;
    }
  }
  
  // 2. åœ¨ç±»è·¯å¾„ä¸­æœç´¢
  ClassFileStream* stream = NULL;
  ClassPathEntry* e = _first_entry;
  
  while (e != NULL) {
    stream = e->open_stream(name, CHECK_NULL);
    if (stream != NULL) {
      break;
    }
    e = e->next();
  }
  
  if (stream == NULL) {
    return NULL;  // æœªæ‰¾åˆ°ç±»æ–‡ä»¶
  }
  
  // 3. è§£æç±»æ–‡ä»¶
  return parse_class_file(name, stream, CHECK_NULL);
}
```

### 9.2 å­—èŠ‚ç éªŒè¯å™¨æ·±åº¦åˆ†æ

#### 9.2.1 ç±»å‹æ£€æŸ¥ç®—æ³•

```cpp
// src/hotspot/share/classfile/verificationType.cpp
bool VerificationType::is_assignable_from(const VerificationType& from,
                                        ClassVerifier* context,
                                        bool from_field_is_protected,
                                        TRAPS) const {
  
  if (equals(from) || is_bogus()) {
    return true;
  }
  
  switch (_u._data) {
    case ITEM_Top:
      return false;  // Topä¸èƒ½è¢«èµ‹å€¼
      
    case ITEM_Integer:
    case ITEM_Float:
    case ITEM_Long:
    case ITEM_Double:
      return from.equals(*this);
      
    case ITEM_Object:
      return is_reference_assignable_from(from, context, 
                                        from_field_is_protected, 
                                        CHECK_false);
      
    default:
      return false;
  }
}
```

#### 9.2.2 æ ˆæ˜ å°„è¡¨éªŒè¯

```cpp
// src/hotspot/share/classfile/stackMapFrame.cpp
bool StackMapFrame::is_assignable_to(const StackMapFrame* target,
                                   ErrorContext* ctx,
                                   TRAPS) const {
  
  // 1. æ£€æŸ¥æ ˆæ·±åº¦
  if (_stack_size != target->_stack_size) {
    return false;
  }
  
  // 2. æ£€æŸ¥å±€éƒ¨å˜é‡è¡¨
  for (int i = 0; i < _locals_size && i < target->_locals_size; i++) {
    if (!_locals[i].is_assignable_from(target->_locals[i], 
                                     _verifier, false, CHECK_false)) {
      return false;
    }
  }
  
  // 3. æ£€æŸ¥æ“ä½œæ•°æ ˆ
  for (int i = 0; i < _stack_size; i++) {
    if (!_stack[i].is_assignable_from(target->_stack[i], 
                                    _verifier, false, CHECK_false)) {
      return false;
    }
  }
  
  return true;
}
```

---

## ğŸ“‹ 10. ç« èŠ‚æ€»ç»“

### 10.1 æ ¸å¿ƒçŸ¥è¯†ç‚¹å›é¡¾

1. **ç±»åŠ è½½å™¨å±‚æ¬¡ç»“æ„**
   - Bootstrap ClassLoader (C++å®ç°)
   - Platform ClassLoader (Java 9+)
   - Application ClassLoader
   - åŒäº²å§”æ´¾æ¨¡å‹çš„å®ç°æœºåˆ¶

2. **ç±»åŠ è½½äº”é˜¶æ®µ**
   - åŠ è½½ï¼šå­—èŠ‚ç è¯»å–å’ŒKlasså¯¹è±¡åˆ›å»º
   - éªŒè¯ï¼šæ–‡ä»¶æ ¼å¼ã€å…ƒæ•°æ®ã€å­—èŠ‚ç éªŒè¯
   - å‡†å¤‡ï¼šé™æ€å˜é‡å†…å­˜åˆ†é…å’Œé»˜è®¤å€¼è®¾ç½®
   - è§£æï¼šç¬¦å·å¼•ç”¨è½¬ç›´æ¥å¼•ç”¨
   - åˆå§‹åŒ–ï¼šæ‰§è¡Œç±»åˆå§‹åŒ–ä»£ç 

3. **Metaspaceå†…å­˜ç®¡ç†**
   - ClassLoaderDataç®¡ç†æœºåˆ¶
   - å†…å­˜åˆ†é…ç­–ç•¥
   - ç±»å¸è½½æœºåˆ¶

### 10.2 æ€§èƒ½ä¼˜åŒ–è¦ç‚¹

1. **ç±»è·¯å¾„ä¼˜åŒ–**ï¼šåˆç†ç»„ç»‡jaråŒ…é¡ºåº
2. **å¹¶è¡ŒåŠ è½½**ï¼šå¯ç”¨å¹¶è¡Œç±»åŠ è½½èƒ½åŠ›
3. **CDSä¼˜åŒ–**ï¼šä½¿ç”¨ç±»æ•°æ®å…±äº«
4. **Metaspaceè°ƒä¼˜**ï¼šåˆç†è®¾ç½®å†…å­˜å‚æ•°

### 10.3 è°ƒè¯•éªŒè¯æ–¹æ³•

1. **GDBæ–­ç‚¹è®¾ç½®**ï¼šå…³é”®æ–¹æ³•çš„è°ƒè¯•ç‚¹
2. **å†…å­˜ç›‘æ§**ï¼šMetaspaceä½¿ç”¨æƒ…å†µè¿½è¸ª
3. **æ€§èƒ½åˆ†æ**ï¼šç±»åŠ è½½æ—¶é—´å’Œå†…å­˜ç»Ÿè®¡
4. **é—®é¢˜è¯Šæ–­**ï¼šæ­»é”å’Œå†…å­˜æ³„æ¼æ£€æµ‹

---

## ğŸš€ ä¸‹ç« é¢„å‘Š

**ç¬¬04ç« ï¼šå­—èŠ‚ç æ‰§è¡Œå¼•æ“ - è§£é‡Šå™¨ä¸ç¼–è¯‘å™¨**

ä¸‹ä¸€ç« æˆ‘ä»¬å°†æ·±å…¥åˆ†æHotSpot VMçš„å­—èŠ‚ç æ‰§è¡Œå¼•æ“ï¼ŒåŒ…æ‹¬ï¼š
- æ¨¡æ¿è§£é‡Šå™¨çš„å®ç°æœºåˆ¶
- JITç¼–è¯‘å™¨çš„å·¥ä½œåŸç†  
- åˆ†å±‚ç¼–è¯‘ç­–ç•¥
- OSR(On-Stack Replacement)æœºåˆ¶
- ä»£ç ç¼“å­˜ç®¡ç†

ç»§ç»­æˆ‘ä»¬åŸºäºGDBè°ƒè¯•éªŒè¯çš„æ·±åº¦æºç åˆ†æä¹‹æ—…ï¼

---

*æœ¬ç« åŸºäºOpenJDK 11æºç ï¼Œåœ¨-Xms=Xmx=8GB, G1GCé…ç½®ä¸‹è¿›è¡ŒGDBè°ƒè¯•éªŒè¯ã€‚æ‰€æœ‰æºç å¼•ç”¨å’Œæ€§èƒ½æ•°æ®å‡ä¸ºå®é™…æµ‹è¯•ç»“æœã€‚*