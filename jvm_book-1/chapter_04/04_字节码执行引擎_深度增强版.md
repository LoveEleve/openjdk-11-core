# ç¬¬04ç« ï¼šå­—èŠ‚ç æ‰§è¡Œå¼•æ“ - æ·±åº¦æºç åˆ†æä¸æ€§èƒ½ä¼˜åŒ–

## ğŸ“– ç« èŠ‚æ¦‚è¿°

æœ¬ç« æ·±å…¥åˆ†æHotSpot VMçš„å­—èŠ‚ç æ‰§è¡Œå¼•æ“ï¼ŒåŸºäº**-Xms=Xmx=8GB, éå¤§é¡µ, éNUMA, G1GC**çš„æ ‡å‡†é…ç½®ï¼Œé€šè¿‡æºç çº§åˆ†æå’ŒGDBè°ƒè¯•éªŒè¯è§£é‡Šå™¨å’ŒJITç¼–è¯‘å™¨çš„å·¥ä½œåŸç†ã€‚æˆ‘ä»¬å°†ä»åº•å±‚C++å®ç°å‰–ææ¨¡æ¿è§£é‡Šå™¨ã€å­—èŠ‚ç åˆ†å‘æœºåˆ¶ã€æ ˆå¸§ç®¡ç†ã€åˆ†å±‚ç¼–è¯‘ç­–ç•¥ã€OSRæœºåˆ¶ï¼Œä»¥åŠCodeCacheç®¡ç†çš„å®Œæ•´ç®—æ³•ã€‚

### ğŸ¯ å­¦ä¹ ç›®æ ‡

- **æºç çº§ç†è§£**ï¼šæŒæ¡HotSpot VMå­—èŠ‚ç æ‰§è¡Œå¼•æ“çš„å®Œæ•´C++å®ç°
- **è§£é‡Šå™¨æœºåˆ¶**ï¼šæ·±å…¥åˆ†ææ¨¡æ¿è§£é‡Šå™¨çš„å­—èŠ‚ç åˆ†å‘å’Œæ‰§è¡Œç®—æ³•
- **æ ˆå¸§ç®¡ç†**ï¼šç†è§£Javaæ ˆå¸§çš„åˆ›å»ºã€ç®¡ç†å’Œé”€æ¯æœºåˆ¶
- **ç¼–è¯‘å™¨é›†æˆ**ï¼šæŒæ¡è§£é‡Šå™¨ä¸JITç¼–è¯‘å™¨çš„åä½œæœºåˆ¶
- **æ€§èƒ½ä¼˜åŒ–**ï¼šç†è§£OSRã€å†…è”ã€åˆ†æ”¯é¢„æµ‹ç­‰å…³é”®ä¼˜åŒ–æŠ€æœ¯
- **å®æˆ˜éªŒè¯**ï¼šé€šè¿‡GDBéªŒè¯æ‰§è¡Œå¼•æ“çš„å…³é”®èŠ‚ç‚¹å’Œæ€§èƒ½æ•°æ®

### ğŸ”§ å®éªŒç¯å¢ƒ

```bash
# æ ‡å‡†JVMé…ç½®
-Xms8g -Xmx8g                    # 8GBå †å†…å­˜
-XX:+UseG1GC                     # G1åƒåœ¾æ”¶é›†å™¨
-XX:+UnlockDiagnosticVMOptions   # è§£é”è¯Šæ–­é€‰é¡¹
-XX:+TraceClassLoading           # ç±»åŠ è½½è·Ÿè¸ª
-XX:+PrintCompilation            # ç¼–è¯‘è·Ÿè¸ª
-XX:+PrintInlining               # å†…è”è·Ÿè¸ª
-XX:+LogVMOutput                 # VMè¾“å‡ºæ—¥å¿—
-XX:CompileThreshold=10000       # ç¼–è¯‘é˜ˆå€¼
-XX:+TieredCompilation           # åˆ†å±‚ç¼–è¯‘
```

---

## ğŸ—ï¸ 1. å­—èŠ‚ç æ‰§è¡Œå¼•æ“æ¶æ„æºç åˆ†æ

### 1.1 JavaThreadæ‰§è¡Œå¼•æ“æ ¸å¿ƒ

JavaThreadæ˜¯å­—èŠ‚ç æ‰§è¡Œçš„æ ¸å¿ƒè½½ä½“ï¼ŒåŒ…å«å®Œæ•´çš„æ‰§è¡ŒçŠ¶æ€ç®¡ç†ï¼š

```cpp
// src/hotspot/share/runtime/thread.hpp
class JavaThread : public Thread {
private:
  // æ‰§è¡Œå¼•æ“æ ¸å¿ƒçŠ¶æ€
  JavaFrameAnchor _anchor;              // Javaæ ˆå¸§é”šç‚¹
  frame           _last_Java_frame;     // æœ€åä¸€ä¸ªJavaæ ˆå¸§
  
  // è§£é‡Šå™¨æ‰§è¡ŒçŠ¶æ€
  intptr_t*       _interpreter_state;   // è§£é‡Šå™¨çŠ¶æ€æŒ‡é’ˆ
  address         _interpreter_frame_last_sp; // è§£é‡Šå™¨æ ˆé¡¶
  
  // ç¼–è¯‘ä»£ç æ‰§è¡ŒçŠ¶æ€
  nmethod*        _osr_nmethod_cache;   // OSRç¼–è¯‘ç¼“å­˜
  address         _exception_pc;        // å¼‚å¸¸PC
  oop             _exception_oop;       // å¼‚å¸¸å¯¹è±¡
  
  // æ ˆæº¢å‡ºæ£€æµ‹
  address         _stack_base;          // æ ˆåŸºå€
  size_t          _stack_size;          // æ ˆå¤§å°
  address         _stack_overflow_limit; // æ ˆæº¢å‡ºé™åˆ¶
  
  // æ‰§è¡Œç»Ÿè®¡
  int             _java_call_counter;   // Javaè°ƒç”¨è®¡æ•°
  
public:
  // å­—èŠ‚ç æ‰§è¡Œå…¥å£
  void call_run() {
    // è®¾ç½®çº¿ç¨‹çŠ¶æ€
    set_thread_state(_thread_in_Java);
    
    // è°ƒç”¨Javaä¸»æ–¹æ³•
    {
      HandleMark hm(this);
      JavaCallWrapper link(this, &result);
      JavaCalls::call(&result, method, &java_args, CHECK);
    }
  }
  
  // è§£é‡Šå™¨æ ˆå¸§éå†
  void interpreter_frame_do(void f(frame*)) {
    for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {
      if (fst.current()->is_interpreted_frame()) {
        f(fst.current());
      }
    }
  }
  
  // ç¼–è¯‘ä»£ç æ ˆå¸§éå†
  void compiled_frame_do(void f(frame*)) {
    for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {
      if (fst.current()->is_compiled_frame()) {
        f(fst.current());
      }
    }
  }
  
  // æ ˆæº¢å‡ºæ£€æŸ¥
  bool stack_overflow_check(address sp) {
    return sp < _stack_overflow_limit;
  }
};
```

### 1.2 AbstractInterpreter - è§£é‡Šå™¨æŠ½è±¡åŸºç±»

AbstractInterpreterå®šä¹‰äº†è§£é‡Šå™¨çš„æ ¸å¿ƒæ¥å£å’Œæ‰§è¡Œæ¡†æ¶ï¼š

```cpp
// src/hotspot/share/interpreter/abstractInterpreter.hpp
class AbstractInterpreter: AllStatic {
public:
  enum MethodKind {
    zerolocals,                   // æ— å±€éƒ¨å˜é‡æ–¹æ³•
    zerolocals_synchronized,      // æ— å±€éƒ¨å˜é‡åŒæ­¥æ–¹æ³•
    native,                       // æœ¬åœ°æ–¹æ³•
    native_synchronized,          // æœ¬åœ°åŒæ­¥æ–¹æ³•
    empty,                        // ç©ºæ–¹æ³•
    accessor,                     // è®¿é—®å™¨æ–¹æ³•
    abstract,                     // æŠ½è±¡æ–¹æ³•
    method_handle_invoke_FIRST,   // æ–¹æ³•å¥æŸ„è°ƒç”¨
    method_handle_invoke_LAST = method_handle_invoke_FIRST + 255,
    java_lang_math_sin,          // Math.sinä¼˜åŒ–
    java_lang_math_cos,          // Math.cosä¼˜åŒ–
    java_lang_math_tan,          // Math.tanä¼˜åŒ–
    java_lang_math_abs,          // Math.absä¼˜åŒ–
    java_lang_math_sqrt,         // Math.sqrtä¼˜åŒ–
    java_lang_math_log,          // Math.logä¼˜åŒ–
    java_lang_math_log10,        // Math.log10ä¼˜åŒ–
    java_lang_math_pow,          // Math.powä¼˜åŒ–
    java_lang_math_exp,          // Math.expä¼˜åŒ–
    java_lang_math_fmaF,         // Math.fma(float)ä¼˜åŒ–
    java_lang_math_fmaD,         // Math.fma(double)ä¼˜åŒ–
    number_of_method_entries
  };
  
private:
  // è§£é‡Šå™¨ä»£ç ç”Ÿæˆå™¨
  static InterpreterCodelet* _code;
  
  // æ–¹æ³•å…¥å£ç‚¹æ•°ç»„
  static address _entry_table[number_of_method_entries];
  
  // å­—èŠ‚ç è¡¨
  static address _bytecode_table[Bytecodes::number_of_codes];
  
public:
  // åˆå§‹åŒ–è§£é‡Šå™¨
  static void initialize();
  
  // è·å–æ–¹æ³•å…¥å£ç‚¹
  static address entry_for_method(methodHandle method) {
    MethodKind kind = method_kind(method);
    return _entry_table[kind];
  }
  
  // è·å–å­—èŠ‚ç å…¥å£ç‚¹
  static address entry_for_bytecode(Bytecodes::Code code) {
    assert(Bytecodes::is_defined(code), "bytecode must be defined");
    return _bytecode_table[code];
  }
  
  // æ–¹æ³•ç±»å‹åˆ¤æ–­
  static MethodKind method_kind(methodHandle m) {
    // æ£€æŸ¥æ–¹æ³•ç‰¹å¾
    if (m->is_empty_method()) return empty;
    if (m->is_accessor()) return accessor;
    if (m->is_abstract()) return abstract;
    if (m->is_native()) {
      return m->is_synchronized() ? native_synchronized : native;
    }
    
    // æ£€æŸ¥å±€éƒ¨å˜é‡
    if (m->max_locals() == 0) {
      return m->is_synchronized() ? zerolocals_synchronized : zerolocals;
    }
    
    // æ£€æŸ¥å†…ç½®æ–¹æ³•ä¼˜åŒ–
    if (m->intrinsic_id() != vmIntrinsics::_none) {
      switch (m->intrinsic_id()) {
        case vmIntrinsics::_dsin: return java_lang_math_sin;
        case vmIntrinsics::_dcos: return java_lang_math_cos;
        case vmIntrinsics::_dtan: return java_lang_math_tan;
        case vmIntrinsics::_dabs: return java_lang_math_abs;
        case vmIntrinsics::_dsqrt: return java_lang_math_sqrt;
        case vmIntrinsics::_dlog: return java_lang_math_log;
        case vmIntrinsics::_dlog10: return java_lang_math_log10;
        case vmIntrinsics::_dpow: return java_lang_math_pow;
        case vmIntrinsics::_dexp: return java_lang_math_exp;
        case vmIntrinsics::_fmaF: return java_lang_math_fmaF;
        case vmIntrinsics::_fmaD: return java_lang_math_fmaD;
      }
    }
    
    return zerolocals; // é»˜è®¤ç±»å‹
  }
};
```

### 1.3 TemplateInterpreter - æ¨¡æ¿è§£é‡Šå™¨å®ç°

TemplateInterpreteræ˜¯HotSpotçš„ä¸»è¦è§£é‡Šå™¨å®ç°ï¼Œä½¿ç”¨æ¨¡æ¿æŠ€æœ¯ç”Ÿæˆé«˜æ•ˆçš„å­—èŠ‚ç å¤„ç†ä»£ç ï¼š

```cpp
// src/hotspot/share/interpreter/templateInterpreter.hpp
class TemplateInterpreter: public AbstractInterpreter {
private:
  // æ¨¡æ¿è¡¨
  static Template _template_table[Bytecodes::number_of_codes];
  
  // è§£é‡Šå™¨ç”Ÿæˆå™¨
  static InterpreterGenerator* _generator;
  
public:
  // åˆå§‹åŒ–æ¨¡æ¿è§£é‡Šå™¨
  static void initialize() {
    if (_code != NULL) return;
    
    // åˆ›å»ºä»£ç ç¼“å†²åŒº
    _code = new StubQueue(new InterpreterCodeletInterface, 
                         code_size, NULL, "Interpreter");
    
    // ç”Ÿæˆè§£é‡Šå™¨ä»£ç 
    _generator = new InterpreterGenerator(_code);
    
    // ç”Ÿæˆå­—èŠ‚ç æ¨¡æ¿
    TemplateTable::initialize();
    
    // ç”Ÿæˆæ–¹æ³•å…¥å£ç‚¹
    generate_all();
  }
  
private:
  // ç”Ÿæˆæ‰€æœ‰å…¥å£ç‚¹
  static void generate_all() {
    // ç”Ÿæˆæ–¹æ³•å…¥å£ç‚¹
    for (int i = 0; i < number_of_method_entries; i++) {
      MethodKind kind = (MethodKind)i;
      _entry_table[kind] = generate_method_entry(kind);
    }
    
    // ç”Ÿæˆå­—èŠ‚ç å…¥å£ç‚¹
    for (int i = 0; i < Bytecodes::number_of_codes; i++) {
      Bytecodes::Code code = (Bytecodes::Code)i;
      if (Bytecodes::is_defined(code)) {
        _bytecode_table[code] = generate_bytecode_entry(code);
      }
    }
  }
  
  // ç”Ÿæˆæ–¹æ³•å…¥å£ç‚¹
  static address generate_method_entry(MethodKind kind) {
    InterpreterGenerator* ig = _generator;
    address entry_point = ig->generate_method_entry(kind);
    
    // åˆ›å»ºä»£ç ç‰‡æ®µ
    InterpreterCodelet* codelet = 
      new InterpreterCodelet(kind, entry_point, ig->code()->code_end());
    
    return entry_point;
  }
  
  // ç”Ÿæˆå­—èŠ‚ç å…¥å£ç‚¹
  static address generate_bytecode_entry(Bytecodes::Code code) {
    InterpreterGenerator* ig = _generator;
    Template* t = template_for(code);
    
    address entry_point = ig->generate_and_dispatch(t);
    return entry_point;
  }
};
```

---

## ğŸ”„ 2. å­—èŠ‚ç æŒ‡ä»¤é›†å®Œæ•´å®ç°

### 2.1 Bytecodes - å­—èŠ‚ç æŒ‡ä»¤å®šä¹‰

HotSpot VMæ”¯æŒå®Œæ•´çš„Javaå­—èŠ‚ç æŒ‡ä»¤é›†ï¼ŒåŒ…å«200+æ¡æŒ‡ä»¤ï¼š

```cpp
// src/hotspot/share/interpreter/bytecodes.hpp
class Bytecodes: AllStatic {
public:
  enum Code {
    _illegal    = -1,
    
    // å¸¸é‡æ“ä½œæŒ‡ä»¤ (0x00-0x14)
    _nop        = 0x00,   // æ— æ“ä½œ
    _aconst_null = 0x01,  // å°†nullæ¨é€è‡³æ ˆé¡¶
    _iconst_m1  = 0x02,   // å°†intå‹-1æ¨é€è‡³æ ˆé¡¶
    _iconst_0   = 0x03,   // å°†intå‹0æ¨é€è‡³æ ˆé¡¶
    _iconst_1   = 0x04,   // å°†intå‹1æ¨é€è‡³æ ˆé¡¶
    _iconst_2   = 0x05,   // å°†intå‹2æ¨é€è‡³æ ˆé¡¶
    _iconst_3   = 0x06,   // å°†intå‹3æ¨é€è‡³æ ˆé¡¶
    _iconst_4   = 0x07,   // å°†intå‹4æ¨é€è‡³æ ˆé¡¶
    _iconst_5   = 0x08,   // å°†intå‹5æ¨é€è‡³æ ˆé¡¶
    _lconst_0   = 0x09,   // å°†longå‹0æ¨é€è‡³æ ˆé¡¶
    _lconst_1   = 0x0a,   // å°†longå‹1æ¨é€è‡³æ ˆé¡¶
    _fconst_0   = 0x0b,   // å°†floatå‹0æ¨é€è‡³æ ˆé¡¶
    _fconst_1   = 0x0c,   // å°†floatå‹1æ¨é€è‡³æ ˆé¡¶
    _fconst_2   = 0x0d,   // å°†floatå‹2æ¨é€è‡³æ ˆé¡¶
    _dconst_0   = 0x0e,   // å°†doubleå‹0æ¨é€è‡³æ ˆé¡¶
    _dconst_1   = 0x0f,   // å°†doubleå‹1æ¨é€è‡³æ ˆé¡¶
    _bipush     = 0x10,   // å°†å•å­—èŠ‚çš„å¸¸é‡å€¼æ¨é€è‡³æ ˆé¡¶
    _sipush     = 0x11,   // å°†çŸ­æ•´å‹å¸¸é‡å€¼æ¨é€è‡³æ ˆé¡¶
    _ldc        = 0x12,   // å°†intã€floatæˆ–Stringå‹å¸¸é‡å€¼ä»å¸¸é‡æ± ä¸­æ¨é€è‡³æ ˆé¡¶
    _ldc_w      = 0x13,   // å°†intã€floatæˆ–Stringå‹å¸¸é‡å€¼ä»å¸¸é‡æ± ä¸­æ¨é€è‡³æ ˆé¡¶(å®½ç´¢å¼•)
    _ldc2_w     = 0x14,   // å°†longæˆ–doubleå‹å¸¸é‡å€¼ä»å¸¸é‡æ± ä¸­æ¨é€è‡³æ ˆé¡¶(å®½ç´¢å¼•)
    
    // å±€éƒ¨å˜é‡æ“ä½œæŒ‡ä»¤ (0x15-0x35)
    _iload      = 0x15,   // å°†æŒ‡å®šçš„intå‹å±€éƒ¨å˜é‡æ¨é€è‡³æ ˆé¡¶
    _lload      = 0x16,   // å°†æŒ‡å®šçš„longå‹å±€éƒ¨å˜é‡æ¨é€è‡³æ ˆé¡¶
    _fload      = 0x17,   // å°†æŒ‡å®šçš„floatå‹å±€éƒ¨å˜é‡æ¨é€è‡³æ ˆé¡¶
    _dload      = 0x18,   // å°†æŒ‡å®šçš„doubleå‹å±€éƒ¨å˜é‡æ¨é€è‡³æ ˆé¡¶
    _aload      = 0x19,   // å°†æŒ‡å®šçš„å¼•ç”¨ç±»å‹å±€éƒ¨å˜é‡æ¨é€è‡³æ ˆé¡¶
    _iload_0    = 0x1a,   // å°†ç¬¬ä¸€ä¸ªintå‹å±€éƒ¨å˜é‡æ¨é€è‡³æ ˆé¡¶
    _iload_1    = 0x1b,   // å°†ç¬¬äºŒä¸ªintå‹å±€éƒ¨å˜é‡æ¨é€è‡³æ ˆé¡¶
    _iload_2    = 0x1c,   // å°†ç¬¬ä¸‰ä¸ªintå‹å±€éƒ¨å˜é‡æ¨é€è‡³æ ˆé¡¶
    _iload_3    = 0x1d,   // å°†ç¬¬å››ä¸ªintå‹å±€éƒ¨å˜é‡æ¨é€è‡³æ ˆé¡¶
    // ... æ›´å¤šloadæŒ‡ä»¤
    
    _istore     = 0x36,   // å°†æ ˆé¡¶intå‹æ•°å€¼å­˜å…¥æŒ‡å®šå±€éƒ¨å˜é‡
    _lstore     = 0x37,   // å°†æ ˆé¡¶longå‹æ•°å€¼å­˜å…¥æŒ‡å®šå±€éƒ¨å˜é‡
    _fstore     = 0x38,   // å°†æ ˆé¡¶floatå‹æ•°å€¼å­˜å…¥æŒ‡å®šå±€éƒ¨å˜é‡
    _dstore     = 0x39,   // å°†æ ˆé¡¶doubleå‹æ•°å€¼å­˜å…¥æŒ‡å®šå±€éƒ¨å˜é‡
    _astore     = 0x3a,   // å°†æ ˆé¡¶å¼•ç”¨å‹æ•°å€¼å­˜å…¥æŒ‡å®šå±€éƒ¨å˜é‡
    // ... æ›´å¤šstoreæŒ‡ä»¤
    
    // æ•°ç»„æ“ä½œæŒ‡ä»¤ (0x46-0x53)
    _iaload     = 0x2e,   // å°†intå‹æ•°ç»„æŒ‡å®šç´¢å¼•çš„å€¼æ¨é€è‡³æ ˆé¡¶
    _laload     = 0x2f,   // å°†longå‹æ•°ç»„æŒ‡å®šç´¢å¼•çš„å€¼æ¨é€è‡³æ ˆé¡¶
    _faload     = 0x30,   // å°†floatå‹æ•°ç»„æŒ‡å®šç´¢å¼•çš„å€¼æ¨é€è‡³æ ˆé¡¶
    _daload     = 0x31,   // å°†doubleå‹æ•°ç»„æŒ‡å®šç´¢å¼•çš„å€¼æ¨é€è‡³æ ˆé¡¶
    _aaload     = 0x32,   // å°†å¼•ç”¨å‹æ•°ç»„æŒ‡å®šç´¢å¼•çš„å€¼æ¨é€è‡³æ ˆé¡¶
    _baload     = 0x33,   // å°†booleanæˆ–byteå‹æ•°ç»„æŒ‡å®šç´¢å¼•çš„å€¼æ¨é€è‡³æ ˆé¡¶
    _caload     = 0x34,   // å°†charå‹æ•°ç»„æŒ‡å®šç´¢å¼•çš„å€¼æ¨é€è‡³æ ˆé¡¶
    _saload     = 0x35,   // å°†shortå‹æ•°ç»„æŒ‡å®šç´¢å¼•çš„å€¼æ¨é€è‡³æ ˆé¡¶
    
    _iastore    = 0x4f,   // å°†æ ˆé¡¶intå‹æ•°å€¼å­˜å…¥æŒ‡å®šæ•°ç»„çš„æŒ‡å®šç´¢å¼•ä½ç½®
    _lastore    = 0x50,   // å°†æ ˆé¡¶longå‹æ•°å€¼å­˜å…¥æŒ‡å®šæ•°ç»„çš„æŒ‡å®šç´¢å¼•ä½ç½®
    _fastore    = 0x51,   // å°†æ ˆé¡¶floatå‹æ•°å€¼å­˜å…¥æŒ‡å®šæ•°ç»„çš„æŒ‡å®šç´¢å¼•ä½ç½®
    _dastore    = 0x52,   // å°†æ ˆé¡¶doubleå‹æ•°å€¼å­˜å…¥æŒ‡å®šæ•°ç»„çš„æŒ‡å®šç´¢å¼•ä½ç½®
    _aastore    = 0x53,   // å°†æ ˆé¡¶å¼•ç”¨å‹æ•°å€¼å­˜å…¥æŒ‡å®šæ•°ç»„çš„æŒ‡å®šç´¢å¼•ä½ç½®
    _bastore    = 0x54,   // å°†æ ˆé¡¶booleanæˆ–byteå‹æ•°å€¼å­˜å…¥æŒ‡å®šæ•°ç»„çš„æŒ‡å®šç´¢å¼•ä½ç½®
    _castore    = 0x55,   // å°†æ ˆé¡¶charå‹æ•°å€¼å­˜å…¥æŒ‡å®šæ•°ç»„çš„æŒ‡å®šç´¢å¼•ä½ç½®
    _sastore    = 0x56,   // å°†æ ˆé¡¶shortå‹æ•°å€¼å­˜å…¥æŒ‡å®šæ•°ç»„çš„æŒ‡å®šç´¢å¼•ä½ç½®
    
    // æ ˆæ“ä½œæŒ‡ä»¤ (0x57-0x5f)
    _pop        = 0x57,   // å°†æ ˆé¡¶æ•°å€¼å¼¹å‡º(æ•°å€¼ä¸èƒ½æ˜¯longæˆ–doubleç±»å‹çš„)
    _pop2       = 0x58,   // å°†æ ˆé¡¶çš„ä¸€ä¸ª(longæˆ–doubleç±»å‹çš„)æˆ–ä¸¤ä¸ªæ•°å€¼å¼¹å‡º
    _dup        = 0x59,   // å¤åˆ¶æ ˆé¡¶æ•°å€¼å¹¶å°†å¤åˆ¶å€¼å‹å…¥æ ˆé¡¶
    _dup_x1     = 0x5a,   // å¤åˆ¶æ ˆé¡¶æ•°å€¼å¹¶å°†ä¸¤ä¸ªå¤åˆ¶å€¼å‹å…¥æ ˆé¡¶
    _dup_x2     = 0x5b,   // å¤åˆ¶æ ˆé¡¶æ•°å€¼å¹¶å°†ä¸‰ä¸ªå¤åˆ¶å€¼å‹å…¥æ ˆé¡¶
    _dup2       = 0x5c,   // å¤åˆ¶æ ˆé¡¶ä¸€ä¸ªæˆ–ä¸¤ä¸ªæ•°å€¼å¹¶å°†å¤åˆ¶å€¼å‹å…¥æ ˆé¡¶
    _dup2_x1    = 0x5d,   // å¤åˆ¶æ ˆé¡¶æ•°å€¼å¹¶å°†å¤åˆ¶å€¼å‹å…¥æ ˆé¡¶
    _dup2_x2    = 0x5e,   // å¤åˆ¶æ ˆé¡¶æ•°å€¼å¹¶å°†å¤åˆ¶å€¼å‹å…¥æ ˆé¡¶
    _swap       = 0x5f,   // å°†æ ˆæœ€é¡¶ç«¯çš„ä¸¤ä¸ªæ•°å€¼äº’æ¢
    
    // æ•°å­¦è¿ç®—æŒ‡ä»¤ (0x60-0x83)
    _iadd       = 0x60,   // å°†æ ˆé¡¶ä¸¤intå‹æ•°å€¼ç›¸åŠ å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _ladd       = 0x61,   // å°†æ ˆé¡¶ä¸¤longå‹æ•°å€¼ç›¸åŠ å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _fadd       = 0x62,   // å°†æ ˆé¡¶ä¸¤floatå‹æ•°å€¼ç›¸åŠ å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _dadd       = 0x63,   // å°†æ ˆé¡¶ä¸¤doubleå‹æ•°å€¼ç›¸åŠ å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _isub       = 0x64,   // å°†æ ˆé¡¶ä¸¤intå‹æ•°å€¼ç›¸å‡å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _lsub       = 0x65,   // å°†æ ˆé¡¶ä¸¤longå‹æ•°å€¼ç›¸å‡å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _fsub       = 0x66,   // å°†æ ˆé¡¶ä¸¤floatå‹æ•°å€¼ç›¸å‡å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _dsub       = 0x67,   // å°†æ ˆé¡¶ä¸¤doubleå‹æ•°å€¼ç›¸å‡å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _imul       = 0x68,   // å°†æ ˆé¡¶ä¸¤intå‹æ•°å€¼ç›¸ä¹˜å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _lmul       = 0x69,   // å°†æ ˆé¡¶ä¸¤longå‹æ•°å€¼ç›¸ä¹˜å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _fmul       = 0x6a,   // å°†æ ˆé¡¶ä¸¤floatå‹æ•°å€¼ç›¸ä¹˜å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _dmul       = 0x6b,   // å°†æ ˆé¡¶ä¸¤doubleå‹æ•°å€¼ç›¸ä¹˜å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _idiv       = 0x6c,   // å°†æ ˆé¡¶ä¸¤intå‹æ•°å€¼ç›¸é™¤å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _ldiv       = 0x6d,   // å°†æ ˆé¡¶ä¸¤longå‹æ•°å€¼ç›¸é™¤å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _fdiv       = 0x6e,   // å°†æ ˆé¡¶ä¸¤floatå‹æ•°å€¼ç›¸é™¤å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _ddiv       = 0x6f,   // å°†æ ˆé¡¶ä¸¤doubleå‹æ•°å€¼ç›¸é™¤å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    
    // ä½è¿ç®—æŒ‡ä»¤ (0x78-0x83)
    _ishl       = 0x78,   // å°†intå‹æ•°å€¼å·¦ç§»ä½æŒ‡å®šä½æ•°å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _lshl       = 0x79,   // å°†longå‹æ•°å€¼å·¦ç§»ä½æŒ‡å®šä½æ•°å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _ishr       = 0x7a,   // å°†intå‹æ•°å€¼å³(ç¬¦å·)ç§»ä½æŒ‡å®šä½æ•°å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _lshr       = 0x7b,   // å°†longå‹æ•°å€¼å³(ç¬¦å·)ç§»ä½æŒ‡å®šä½æ•°å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _iushr      = 0x7c,   // å°†intå‹æ•°å€¼å³(æ— ç¬¦å·)ç§»ä½æŒ‡å®šä½æ•°å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _lushr      = 0x7d,   // å°†longå‹æ•°å€¼å³(æ— ç¬¦å·)ç§»ä½æŒ‡å®šä½æ•°å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _iand       = 0x7e,   // å°†æ ˆé¡¶ä¸¤intå‹æ•°å€¼ä½œ"æŒ‰ä½ä¸"å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _land       = 0x7f,   // å°†æ ˆé¡¶ä¸¤longå‹æ•°å€¼ä½œ"æŒ‰ä½ä¸"å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _ior        = 0x80,   // å°†æ ˆé¡¶ä¸¤intå‹æ•°å€¼ä½œ"æŒ‰ä½æˆ–"å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _lor        = 0x81,   // å°†æ ˆé¡¶ä¸¤longå‹æ•°å€¼ä½œ"æŒ‰ä½æˆ–"å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _ixor       = 0x82,   // å°†æ ˆé¡¶ä¸¤intå‹æ•°å€¼ä½œ"æŒ‰ä½å¼‚æˆ–"å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _lxor       = 0x83,   // å°†æ ˆé¡¶ä¸¤longå‹æ•°å€¼ä½œ"æŒ‰ä½å¼‚æˆ–"å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    
    // ç±»å‹è½¬æ¢æŒ‡ä»¤ (0x85-0x93)
    _i2l        = 0x85,   // å°†æ ˆé¡¶intå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆlongå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _i2f        = 0x86,   // å°†æ ˆé¡¶intå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆfloatå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _i2d        = 0x87,   // å°†æ ˆé¡¶intå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆdoubleå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _l2i        = 0x88,   // å°†æ ˆé¡¶longå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆintå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _l2f        = 0x89,   // å°†æ ˆé¡¶longå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆfloatå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _l2d        = 0x8a,   // å°†æ ˆé¡¶longå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆdoubleå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _f2i        = 0x8b,   // å°†æ ˆé¡¶floatå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆintå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _f2l        = 0x8c,   // å°†æ ˆé¡¶floatå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆlongå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _f2d        = 0x8d,   // å°†æ ˆé¡¶floatå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆdoubleå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _d2i        = 0x8e,   // å°†æ ˆé¡¶doubleå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆintå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _d2l        = 0x8f,   // å°†æ ˆé¡¶doubleå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆlongå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _d2f        = 0x90,   // å°†æ ˆé¡¶doubleå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆfloatå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _i2b        = 0x91,   // å°†æ ˆé¡¶intå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆbyteå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _i2c        = 0x92,   // å°†æ ˆé¡¶intå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆcharå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _i2s        = 0x93,   // å°†æ ˆé¡¶intå‹æ•°å€¼å¼ºåˆ¶è½¬æ¢æˆshortå‹æ•°å€¼å¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    
    // æ¯”è¾ƒæŒ‡ä»¤ (0x94-0xa6)
    _lcmp       = 0x94,   // æ¯”è¾ƒæ ˆé¡¶ä¸¤longå‹æ•°å€¼å¤§å°ï¼Œå¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _fcmpl      = 0x95,   // æ¯”è¾ƒæ ˆé¡¶ä¸¤floatå‹æ•°å€¼å¤§å°ï¼Œå¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _fcmpg      = 0x96,   // æ¯”è¾ƒæ ˆé¡¶ä¸¤floatå‹æ•°å€¼å¤§å°ï¼Œå¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _dcmpl      = 0x97,   // æ¯”è¾ƒæ ˆé¡¶ä¸¤doubleå‹æ•°å€¼å¤§å°ï¼Œå¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _dcmpg      = 0x98,   // æ¯”è¾ƒæ ˆé¡¶ä¸¤doubleå‹æ•°å€¼å¤§å°ï¼Œå¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶
    _ifeq       = 0x99,   // å½“æ ˆé¡¶intå‹æ•°å€¼ç­‰äº0æ—¶è·³è½¬
    _ifne       = 0x9a,   // å½“æ ˆé¡¶intå‹æ•°å€¼ä¸ç­‰äº0æ—¶è·³è½¬
    _iflt       = 0x9b,   // å½“æ ˆé¡¶intå‹æ•°å€¼å°äº0æ—¶è·³è½¬
    _ifge       = 0x9c,   // å½“æ ˆé¡¶intå‹æ•°å€¼å¤§äºç­‰äº0æ—¶è·³è½¬
    _ifgt       = 0x9d,   // å½“æ ˆé¡¶intå‹æ•°å€¼å¤§äº0æ—¶è·³è½¬
    _ifle       = 0x9e,   // å½“æ ˆé¡¶intå‹æ•°å€¼å°äºç­‰äº0æ—¶è·³è½¬
    _if_icmpeq  = 0x9f,   // æ¯”è¾ƒæ ˆé¡¶ä¸¤intå‹æ•°å€¼å¤§å°ï¼Œå½“ç»“æœç­‰äº0æ—¶è·³è½¬
    _if_icmpne  = 0xa0,   // æ¯”è¾ƒæ ˆé¡¶ä¸¤intå‹æ•°å€¼å¤§å°ï¼Œå½“ç»“æœä¸ç­‰äº0æ—¶è·³è½¬
    _if_icmplt  = 0xa1,   // æ¯”è¾ƒæ ˆé¡¶ä¸¤intå‹æ•°å€¼å¤§å°ï¼Œå½“ç»“æœå°äº0æ—¶è·³è½¬
    _if_icmpge  = 0xa2,   // æ¯”è¾ƒæ ˆé¡¶ä¸¤intå‹æ•°å€¼å¤§å°ï¼Œå½“ç»“æœå¤§äºç­‰äº0æ—¶è·³è½¬
    _if_icmpgt  = 0xa3,   // æ¯”è¾ƒæ ˆé¡¶ä¸¤intå‹æ•°å€¼å¤§å°ï¼Œå½“ç»“æœå¤§äº0æ—¶è·³è½¬
    _if_icmple  = 0xa4,   // æ¯”è¾ƒæ ˆé¡¶ä¸¤intå‹æ•°å€¼å¤§å°ï¼Œå½“ç»“æœå°äºç­‰äº0æ—¶è·³è½¬
    _if_acmpeq  = 0xa5,   // æ¯”è¾ƒæ ˆé¡¶ä¸¤å¼•ç”¨å‹æ•°å€¼ï¼Œå½“ç»“æœç›¸ç­‰æ—¶è·³è½¬
    _if_acmpne  = 0xa6,   // æ¯”è¾ƒæ ˆé¡¶ä¸¤å¼•ç”¨å‹æ•°å€¼ï¼Œå½“ç»“æœä¸ç›¸ç­‰æ—¶è·³è½¬
    
    // æ§åˆ¶è½¬ç§»æŒ‡ä»¤ (0xa7-0xb1)
    _goto       = 0xa7,   // æ— æ¡ä»¶è·³è½¬
    _jsr        = 0xa8,   // è·³è½¬è‡³æŒ‡å®š16ä½offsetä½ç½®ï¼Œå¹¶å°†jsrä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€å‹å…¥æ ˆé¡¶
    _ret        = 0xa9,   // è¿”å›è‡³å±€éƒ¨å˜é‡æŒ‡å®šçš„indexçš„æŒ‡ä»¤ä½ç½®
    _tableswitch = 0xaa,  // ç”¨äºswitchæ¡ä»¶è·³è½¬ï¼Œcaseå€¼è¿ç»­
    _lookupswitch = 0xab, // ç”¨äºswitchæ¡ä»¶è·³è½¬ï¼Œcaseå€¼ä¸è¿ç»­
    _ireturn    = 0xac,   // ä»å½“å‰æ–¹æ³•è¿”å›int
    _lreturn    = 0xad,   // ä»å½“å‰æ–¹æ³•è¿”å›long
    _freturn    = 0xae,   // ä»å½“å‰æ–¹æ³•è¿”å›float
    _dreturn    = 0xaf,   // ä»å½“å‰æ–¹æ³•è¿”å›double
    _areturn    = 0xb0,   // ä»å½“å‰æ–¹æ³•è¿”å›å¯¹è±¡å¼•ç”¨
    _return     = 0xb1,   // ä»å½“å‰æ–¹æ³•è¿”å›void
    
    // å¼•ç”¨ç±»æŒ‡ä»¤ (0xb2-0xc3)
    _getstatic  = 0xb2,   // è·å–æŒ‡å®šç±»çš„é™æ€åŸŸï¼Œå¹¶å°†å…¶å€¼å‹å…¥æ ˆé¡¶
    _putstatic  = 0xb3,   // ä¸ºæŒ‡å®šçš„ç±»çš„é™æ€åŸŸèµ‹å€¼
    _getfield   = 0xb4,   // è·å–æŒ‡å®šç±»çš„å®ä¾‹åŸŸï¼Œå¹¶å°†å…¶å€¼å‹å…¥æ ˆé¡¶
    _putfield   = 0xb5,   // ä¸ºæŒ‡å®šçš„ç±»çš„å®ä¾‹åŸŸèµ‹å€¼
    _invokevirtual = 0xb6, // è°ƒç”¨å®ä¾‹æ–¹æ³•
    _invokespecial = 0xb7, // è°ƒç”¨è¶…ç±»æ„é€ æ–¹æ³•ï¼Œå®ä¾‹åˆå§‹åŒ–æ–¹æ³•ï¼Œç§æœ‰æ–¹æ³•
    _invokestatic = 0xb8,  // è°ƒç”¨é™æ€æ–¹æ³•
    _invokeinterface = 0xb9, // è°ƒç”¨æ¥å£æ–¹æ³•
    _invokedynamic = 0xba, // è°ƒç”¨åŠ¨æ€æ–¹æ³•
    _new        = 0xbb,   // åˆ›å»ºä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶å°†å…¶å¼•ç”¨å€¼å‹å…¥æ ˆé¡¶
    _newarray   = 0xbc,   // åˆ›å»ºä¸€ä¸ªæŒ‡å®šåŸå§‹ç±»å‹çš„æ•°ç»„ï¼Œå¹¶å°†å…¶å¼•ç”¨å€¼å‹å…¥æ ˆé¡¶
    _anewarray  = 0xbd,   // åˆ›å»ºä¸€ä¸ªå¼•ç”¨å‹çš„æ•°ç»„ï¼Œå¹¶å°†å…¶å¼•ç”¨å€¼å‹å…¥æ ˆé¡¶
    _arraylength = 0xbe,  // è·å¾—æ•°ç»„çš„é•¿åº¦å€¼å¹¶å‹å…¥æ ˆé¡¶
    _athrow     = 0xbf,   // å°†æ ˆé¡¶çš„å¼‚å¸¸æŠ›å‡º
    _checkcast  = 0xc0,   // æ£€éªŒç±»å‹è½¬æ¢ï¼Œæ£€éªŒæœªé€šè¿‡å°†æŠ›å‡ºClassCastException
    _instanceof = 0xc1,   // æ£€éªŒå¯¹è±¡æ˜¯å¦æ˜¯æŒ‡å®šçš„ç±»çš„å®ä¾‹ï¼Œå¦‚æœæ˜¯å°†1å‹å…¥æ ˆé¡¶ï¼Œå¦åˆ™å°†0å‹å…¥æ ˆé¡¶
    _monitorenter = 0xc2, // è·å¾—å¯¹è±¡çš„monitorï¼Œç”¨äºåŒæ­¥
    _monitorexit = 0xc3,  // é‡Šæ”¾å¯¹è±¡çš„monitorï¼Œç”¨äºåŒæ­¥
    
    // æ‰©å±•æŒ‡ä»¤ (0xc4-0xc9)
    _wide       = 0xc4,   // æ‰©å±•è®¿é—®å±€éƒ¨å˜é‡è¡¨çš„ç´¢å¼•å®½åº¦
    _multianewarray = 0xc5, // åˆ›å»ºæŒ‡å®šç±»å‹å’ŒæŒ‡å®šç»´åº¦çš„å¤šç»´æ•°ç»„
    _ifnull     = 0xc6,   // ä¸ºnullæ—¶è·³è½¬
    _ifnonnull  = 0xc7,   // ä¸ä¸ºnullæ—¶è·³è½¬
    _goto_w     = 0xc8,   // æ— æ¡ä»¶è·³è½¬(å®½ç´¢å¼•)
    _jsr_w      = 0xc9,   // è·³è½¬è‡³æŒ‡å®š32ä½offsetä½ç½®ï¼Œå¹¶å°†jsr_wä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€å‹å…¥æ ˆé¡¶
    
    // è°ƒè¯•æŒ‡ä»¤
    _breakpoint = 0xca,   // è°ƒè¯•æ–­ç‚¹
    
    number_of_codes,
    
    // å¿«é€ŸæŒ‡ä»¤(JVMå†…éƒ¨ä½¿ç”¨)
    _fast_agetfield = number_of_codes,
    _fast_bgetfield,
    _fast_cgetfield,
    _fast_dgetfield,
    _fast_fgetfield,
    _fast_igetfield,
    _fast_lgetfield,
    _fast_sgetfield,
    
    _fast_aputfield,
    _fast_bputfield,
    _fast_cputfield,
    _fast_dputfield,
    _fast_fputfield,
    _fast_iputfield,
    _fast_lputfield,
    _fast_sputfield,
    
    _fast_aload_0,
    _fast_iaccess_0,
    _fast_aaccess_0,
    _fast_faccess_0,
    
    _fast_iload,
    _fast_iload2,
    _fast_icaload,
    
    _fast_invokevfinal,
    _fast_linearswitch,
    _fast_binaryswitch,
    
    _fast_aldc,
    _fast_aldc_w,
    
    _return_register_finalizer,
    
    _invokehandle,
    
    _nofast_getfield,
    _nofast_putfield,
    
    number_of_java_codes,
    
    // å¹³å°ç›¸å…³çš„å¿«é€ŸæŒ‡ä»¤
    platform_dependent_codes
  };
  
  // æŒ‡ä»¤å±æ€§
  enum Flags {
    _bc_can_trap      = 1 << 0,     // å¯èƒ½æŠ›å‡ºå¼‚å¸¸
    _bc_can_rewrite   = 1 << 1,     // å¯ä»¥è¢«é‡å†™ä¸ºå¿«é€ŸæŒ‡ä»¤
    _bc_has_wide_variant = 1 << 2   // æœ‰å®½ç´¢å¼•å˜ä½“
  };
  
private:
  // æŒ‡ä»¤ä¿¡æ¯è¡¨
  static jchar _flags          [number_of_codes];
  static jchar _lengths        [number_of_codes];
  static jchar _java_code      [number_of_codes];
  static const char* _name     [number_of_codes];
  static const char* _format   [number_of_codes];
  static const char* _wide_format[number_of_codes];
  
public:
  // æŒ‡ä»¤æŸ¥è¯¢æ–¹æ³•
  static bool is_defined(Code code) { 
    return 0 <= code && code < number_of_codes && _lengths[code] != 0; 
  }
  
  static int length_for(Code code) { 
    return _lengths[code]; 
  }
  
  static bool can_trap(Code code) { 
    return (_flags[code] & _bc_can_trap) != 0; 
  }
  
  static bool can_rewrite(Code code) { 
    return (_flags[code] & _bc_can_rewrite) != 0; 
  }
  
  static const char* name(Code code) { 
    return _name[code]; 
  }
  
  static const char* format(Code code) { 
    return _format[code]; 
  }
};
```

### 2.2 TemplateTable - å­—èŠ‚ç æ¨¡æ¿è¡¨

TemplateTableä¸ºæ¯ä¸ªå­—èŠ‚ç æŒ‡ä»¤å®šä¹‰äº†æ‰§è¡Œæ¨¡æ¿ï¼š

```cpp
// src/hotspot/share/interpreter/templateTable.hpp
class TemplateTable: AllStatic {
public:
  enum Operation { add, sub, mul, div, rem, _and, _or, _xor, shl, shr, ushr };
  enum Condition { equal, not_equal, less, less_equal, greater, greater_equal };
  
private:
  // æ¨¡æ¿å®šä¹‰ç»“æ„
  struct Template {
    enum Flags {
      uses_bcp_bit,                // ä½¿ç”¨å­—èŠ‚ç æŒ‡é’ˆ
      does_dispatch_bit,           // æ‰§è¡Œåˆ†å‘
      calls_vm_bit,                // è°ƒç”¨VM
      wide_bit                     // å®½æŒ‡ä»¤
    };
    
    typedef void (*generator)(int arg);
    
    int       _flags;              // æ ‡å¿—ä½
    TosState  _tos_in;            // è¾“å…¥æ ˆé¡¶çŠ¶æ€
    TosState  _tos_out;           // è¾“å‡ºæ ˆé¡¶çŠ¶æ€
    generator _gen;               // ä»£ç ç”Ÿæˆå™¨
    int       _arg;               // å‚æ•°
  };
  
  // æ¨¡æ¿è¡¨
  static Template _template_table     [Bytecodes::number_of_codes];
  static Template _template_table_wide[Bytecodes::number_of_codes];
  
public:
  // åˆå§‹åŒ–æ¨¡æ¿è¡¨
  static void initialize() {
    if (_is_initialized) return;
    
    // å®šä¹‰æ‰€æœ‰å­—èŠ‚ç æ¨¡æ¿
    def(Bytecodes::_nop                 , ____|____|____|____, vtos, vtos, nop                 ,  _           );
    def(Bytecodes::_aconst_null         , ____|____|____|____, vtos, atos, aconst_null         ,  _           );
    def(Bytecodes::_iconst_m1           , ____|____|____|____, vtos, itos, iconst              , -1           );
    def(Bytecodes::_iconst_0            , ____|____|____|____, vtos, itos, iconst              ,  0           );
    def(Bytecodes::_iconst_1            , ____|____|____|____, vtos, itos, iconst              ,  1           );
    def(Bytecodes::_iconst_2            , ____|____|____|____, vtos, itos, iconst              ,  2           );
    def(Bytecodes::_iconst_3            , ____|____|____|____, vtos, itos, iconst              ,  3           );
    def(Bytecodes::_iconst_4            , ____|____|____|____, vtos, itos, iconst              ,  4           );
    def(Bytecodes::_iconst_5            , ____|____|____|____, vtos, itos, iconst              ,  5           );
    def(Bytecodes::_lconst_0            , ____|____|____|____, vtos, ltos, lconst              ,  0           );
    def(Bytecodes::_lconst_1            , ____|____|____|____, vtos, ltos, lconst              ,  1           );
    def(Bytecodes::_fconst_0            , ____|____|____|____, vtos, ftos, fconst              ,  0           );
    def(Bytecodes::_fconst_1            , ____|____|____|____, vtos, ftos, fconst              ,  1           );
    def(Bytecodes::_fconst_2            , ____|____|____|____, vtos, ftos, fconst              ,  2           );
    def(Bytecodes::_dconst_0            , ____|____|____|____, vtos, dtos, dconst              ,  0           );
    def(Bytecodes::_dconst_1            , ____|____|____|____, vtos, dtos, dconst              ,  1           );
    
    // åŠ è½½æŒ‡ä»¤
    def(Bytecodes::_bipush              , ubcp|____|____|____, vtos, itos, bipush              ,  _           );
    def(Bytecodes::_sipush              , ubcp|____|____|____, vtos, itos, sipush              ,  _           );
    def(Bytecodes::_ldc                 , ubcp|____|clvm|____, vtos, vtos, ldc                 , false       );
    def(Bytecodes::_ldc_w               , ubcp|____|clvm|____, vtos, vtos, ldc                 , true        );
    def(Bytecodes::_ldc2_w              , ubcp|____|____|____, vtos, vtos, ldc2_w              ,  _           );
    
    // å±€éƒ¨å˜é‡æ“ä½œ
    def(Bytecodes::_iload               , ubcp|____|____|____, vtos, itos, iload               ,  _           );
    def(Bytecodes::_lload               , ubcp|____|____|____, vtos, ltos, lload               ,  _           );
    def(Bytecodes::_fload               , ubcp|____|____|____, vtos, ftos, fload               ,  _           );
    def(Bytecodes::_dload               , ubcp|____|____|____, vtos, dtos, dload               ,  _           );
    def(Bytecodes::_aload               , ubcp|____|____|____, vtos, atos, aload               ,  _           );
    
    // æ•°ç»„æ“ä½œ
    def(Bytecodes::_iaload              , ____|____|____|____, itos, itos, iaload              ,  _           );
    def(Bytecodes::_laload              , ____|____|____|____, itos, ltos, laload              ,  _           );
    def(Bytecodes::_faload              , ____|____|____|____, itos, ftos, faload              ,  _           );
    def(Bytecodes::_daload              , ____|____|____|____, itos, dtos, daload              ,  _           );
    def(Bytecodes::_aaload              , ____|____|____|____, itos, atos, aaload              ,  _           );
    def(Bytecodes::_baload              , ____|____|____|____, itos, itos, baload              ,  _           );
    def(Bytecodes::_caload              , ____|____|____|____, itos, itos, caload              ,  _           );
    def(Bytecodes::_saload              , ____|____|____|____, itos, itos, saload              ,  _           );
    
    // ç®—æœ¯è¿ç®—
    def(Bytecodes::_iadd                , ____|____|____|____, itos, itos, iop2                , add         );
    def(Bytecodes::_ladd                , ____|____|____|____, ltos, ltos, lop2                , add         );
    def(Bytecodes::_fadd                , ____|____|____|____, ftos, ftos, fop2                , add         );
    def(Bytecodes::_dadd                , ____|____|____|____, dtos, dtos, dop2                , add         );
    def(Bytecodes::_isub                , ____|____|____|____, itos, itos, iop2                , sub         );
    def(Bytecodes::_lsub                , ____|____|____|____, ltos, ltos, lop2                , sub         );
    def(Bytecodes::_fsub                , ____|____|____|____, ftos, ftos, fop2                , sub         );
    def(Bytecodes::_dsub                , ____|____|____|____, dtos, dtos, dop2                , sub         );
    def(Bytecodes::_imul                , ____|____|____|____, itos, itos, iop2                , mul         );
    def(Bytecodes::_lmul                , ____|____|____|____, ltos, ltos, lop2                , mul         );
    def(Bytecodes::_fmul                , ____|____|____|____, ftos, ftos, fop2                , mul         );
    def(Bytecodes::_dmul                , ____|____|____|____, dtos, dtos, dop2                , mul         );
    def(Bytecodes::_idiv                , ____|____|____|____, itos, itos, idiv                ,  _           );
    def(Bytecodes::_ldiv                , ____|____|____|____, ltos, ltos, ldiv                ,  _           );
    def(Bytecodes::_fdiv                , ____|____|____|____, ftos, ftos, fop2                , div         );
    def(Bytecodes::_ddiv                , ____|____|____|____, dtos, dtos, dop2                , div         );
    
    // æ–¹æ³•è°ƒç”¨
    def(Bytecodes::_invokevirtual       , ubcp|disp|clvm|____, vtos, vtos, invokevirtual       , f2_byte     );
    def(Bytecodes::_invokespecial       , ubcp|disp|clvm|____, vtos, vtos, invokespecial       , f1_byte     );
    def(Bytecodes::_invokestatic        , ubcp|disp|clvm|____, vtos, vtos, invokestatic        , f1_byte     );
    def(Bytecodes::_invokeinterface     , ubcp|disp|clvm|____, vtos, vtos, invokeinterface     , f1_byte     );
    def(Bytecodes::_invokedynamic       , ubcp|disp|clvm|____, vtos, vtos, invokedynamic       , f1_byte     );
    
    // æ§åˆ¶æµ
    def(Bytecodes::_ifeq                , ubcp|____|clvm|____, itos, vtos, if_0cmp             , equal       );
    def(Bytecodes::_ifne                , ubcp|____|clvm|____, itos, vtos, if_0cmp             , not_equal   );
    def(Bytecodes::_iflt                , ubcp|____|clvm|____, itos, vtos, if_0cmp             , less        );
    def(Bytecodes::_ifge                , ubcp|____|clvm|____, itos, vtos, if_0cmp             , greater_equal);
    def(Bytecodes::_ifgt                , ubcp|____|clvm|____, itos, vtos, if_0cmp             , greater     );
    def(Bytecodes::_ifle                , ubcp|____|clvm|____, itos, vtos, if_0cmp             , less_equal  );
    
    _is_initialized = true;
  }
  
  // è·å–æ¨¡æ¿
  static Template* template_for(Bytecodes::Code code) {
    Bytecodes::check(code);
    return &_template_table[code];
  }
  
  static Template* template_for_wide(Bytecodes::Code code) {
    Bytecodes::check(code);
    return &_template_table_wide[code];
  }
  
private:
  // æ¨¡æ¿å®šä¹‰å®
  static void def(Bytecodes::Code code, int flags, TosState in, TosState out, 
                  void (*gen)(int arg), int arg) {
    _template_table[code]._flags   = flags;
    _template_table[code]._tos_in  = in;
    _template_table[code]._tos_out = out;
    _template_table[code]._gen     = gen;
    _template_table[code]._arg     = arg;
  }
  
  // å­—èŠ‚ç ç”Ÿæˆå™¨å‡½æ•°
  static void nop(int arg);
  static void aconst_null(int arg);
  static void iconst(int value);
  static void lconst(int value);
  static void fconst(int value);
  static void dconst(int value);
  static void bipush(int arg);
  static void sipush(int arg);
  static void ldc(bool wide);
  static void ldc2_w(int arg);
  static void iload(int arg);
  static void lload(int arg);
  static void fload(int arg);
  static void dload(int arg);
  static void aload(int arg);
  // ... æ›´å¤šç”Ÿæˆå™¨å‡½æ•°
};
```

---

## ğŸ—‚ï¸ 3. æ ˆå¸§ç®¡ç†ä¸æ–¹æ³•è°ƒç”¨æœºåˆ¶

### 3.1 Frame - æ ˆå¸§ç»“æ„

Frameæ˜¯æ–¹æ³•æ‰§è¡Œçš„åŸºæœ¬å•ä½ï¼ŒåŒ…å«äº†æ–¹æ³•æ‰§è¡Œæ‰€éœ€çš„æ‰€æœ‰ä¿¡æ¯ï¼š

```cpp
// src/hotspot/share/runtime/frame.hpp
class frame VALUE_OBJ_CLASS_SPEC {
private:
  // æ ˆå¸§åŸºæœ¬ä¿¡æ¯
  intptr_t* _sp;                // æ ˆæŒ‡é’ˆ
  address   _pc;                // ç¨‹åºè®¡æ•°å™¨
  CodeBlob* _cb;                // ä»£ç å—
  
  // æ ˆå¸§ç±»å‹æ ‡è¯†
  enum {
    pc_return_offset                                 =  0,
    link_offset                                      =  1,
    interpreter_frame_sender_sp_offset               = -1,
    interpreter_frame_last_sp_offset                 = -2,
    interpreter_frame_method_offset                  = -3,
    interpreter_frame_mdp_offset                     = -4,
    interpreter_frame_cache_offset                   = -5,
    interpreter_frame_locals_offset                  = -6,
    interpreter_frame_bcp_offset                     = -7,
    interpreter_frame_initial_sp_offset              = -8,
    interpreter_frame_monitor_block_top_offset       = -9,
    interpreter_frame_monitor_block_bottom_offset    = -10
  };
  
public:
  // æ ˆå¸§ç±»å‹åˆ¤æ–­
  bool is_interpreted_frame() const {
    return Interpreter::contains(pc());
  }
  
  bool is_compiled_frame() const {
    return _cb != NULL && _cb->is_compiled();
  }
  
  bool is_entry_frame() const {
    return _cb != NULL && _cb->is_frame_complete_at(pc());
  }
  
  bool is_native_frame() const {
    return _cb != NULL && _cb->is_native_method();
  }
  
  // è§£é‡Šå™¨æ ˆå¸§è®¿é—®
  Method* interpreter_frame_method() const {
    assert(is_interpreted_frame(), "interpreted frame expected");
    Method* m = *interpreter_frame_method_addr();
    assert(m->is_method(), "not a Method*");
    return m;
  }
  
  ConstantPoolCache* interpreter_frame_cache() const {
    assert(is_interpreted_frame(), "interpreted frame expected");
    return *interpreter_frame_cache_addr();
  }
  
  intptr_t* interpreter_frame_locals() const {
    assert(is_interpreted_frame(), "interpreted frame expected");
    return (intptr_t*)at(interpreter_frame_locals_offset);
  }
  
  intptr_t* interpreter_frame_bcp_addr() const {
    assert(is_interpreted_frame(), "interpreted frame expected");
    return (intptr_t*)addr_at(interpreter_frame_bcp_offset);
  }
  
  // æ ˆå¸§éå†
  frame sender(RegisterMap* map) const {
    // è·å–è°ƒç”¨è€…æ ˆå¸§
    if (is_entry_frame()) return sender_for_entry_frame(map);
    if (is_interpreted_frame()) return sender_for_interpreter_frame(map);
    if (is_compiled_frame()) return sender_for_compiled_frame(map);
    return frame();
  }
  
  // æ ˆå¸§éªŒè¯
  bool is_valid_stack_pointer(intptr_t* valid_sp) const {
    return valid_sp != NULL && 
           valid_sp <= sp() && 
           sp() <= valid_sp + 1000; // åˆç†çš„æ ˆæ·±åº¦
  }
  
private:
  // è§£é‡Šå™¨æ ˆå¸§åœ°å€è®¡ç®—
  Method**              interpreter_frame_method_addr() const {
    return (Method**)addr_at(interpreter_frame_method_offset);
  }
  
  ConstantPoolCache**   interpreter_frame_cache_addr() const {
    return (ConstantPoolCache**)addr_at(interpreter_frame_cache_offset);
  }
  
  // å‘é€è€…æ ˆå¸§è·å–
  frame sender_for_entry_frame(RegisterMap* map) const;
  frame sender_for_interpreter_frame(RegisterMap* map) const;
  frame sender_for_compiled_frame(RegisterMap* map) const;
};
```

### 3.2 JavaCalls - æ–¹æ³•è°ƒç”¨æœºåˆ¶

JavaCallsæä¾›äº†ç»Ÿä¸€çš„æ–¹æ³•è°ƒç”¨æ¥å£ï¼š

```cpp
// src/hotspot/share/runtime/javaCalls.hpp
class JavaCalls: AllStatic {
public:
  // è°ƒç”¨é™æ€æ–¹æ³•
  static void call_static(JavaValue* result,
                         KlassHandle klass,
                         Symbol* name,
                         Symbol* signature,
                         JavaCallArguments* args,
                         TRAPS) {
    
    // æŸ¥æ‰¾æ–¹æ³•
    methodHandle method = resolve_method(klass, name, signature, CHECK);
    
    // éªŒè¯æ–¹æ³•
    if (!method->is_static()) {
      THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
                "Expected static method");
    }
    
    // æ‰§è¡Œè°ƒç”¨
    call(result, method, args, CHECK);
  }
  
  // è°ƒç”¨è™šæ–¹æ³•
  static void call_virtual(JavaValue* result,
                          Handle receiver,
                          KlassHandle spec_klass,
                          Symbol* name,
                          Symbol* signature,
                          JavaCallArguments* args,
                          TRAPS) {
    
    // è·å–æ¥æ”¶è€…ç±»å‹
    KlassHandle receiver_klass(THREAD, receiver->klass());
    
    // æŸ¥æ‰¾æ–¹æ³•
    methodHandle method = resolve_virtual_method(receiver_klass, spec_klass, 
                                               name, signature, CHECK);
    
    // è®¾ç½®æ¥æ”¶è€…
    args->set_receiver(receiver);
    
    // æ‰§è¡Œè°ƒç”¨
    call(result, method, args, CHECK);
  }
  
  // è°ƒç”¨æ¥å£æ–¹æ³•
  static void call_interface(JavaValue* result,
                            Handle receiver,
                            KlassHandle spec_klass,
                            Symbol* name,
                            Symbol* signature,
                            JavaCallArguments* args,
                            TRAPS) {
    
    // è·å–æ¥æ”¶è€…ç±»å‹
    KlassHandle receiver_klass(THREAD, receiver->klass());
    
    // æŸ¥æ‰¾æ¥å£æ–¹æ³•
    methodHandle method = resolve_interface_method(receiver_klass, spec_klass,
                                                 name, signature, CHECK);
    
    // è®¾ç½®æ¥æ”¶è€…
    args->set_receiver(receiver);
    
    // æ‰§è¡Œè°ƒç”¨
    call(result, method, args, CHECK);
  }
  
private:
  // æ ¸å¿ƒè°ƒç”¨æ–¹æ³•
  static void call(JavaValue* result,
                   methodHandle method,
                   JavaCallArguments* args,
                   TRAPS) {
    
    // æ£€æŸ¥çº¿ç¨‹çŠ¶æ€
    assert(THREAD->is_Java_thread(), "must be java thread");
    JavaThread* thread = (JavaThread*)THREAD;
    
    // ä¿å­˜å½“å‰çŠ¶æ€
    ThreadStateTransition::transition_from_vm(thread, _thread_in_Java);
    
    // è®¾ç½®è°ƒç”¨åŒ…è£…å™¨
    JavaCallWrapper link(thread, result);
    
    // æ‰§è¡Œæ–¹æ³•è°ƒç”¨
    if (method->is_static()) {
      call_static_method(result, method, args, CHECK);
    } else {
      call_instance_method(result, method, args, CHECK);
    }
  }
  
  // é™æ€æ–¹æ³•è°ƒç”¨
  static void call_static_method(JavaValue* result,
                                methodHandle method,
                                JavaCallArguments* args,
                                TRAPS) {
    
    // è·å–æ–¹æ³•å…¥å£ç‚¹
    address entry_point = method->from_interpreted_entry();
    
    // å‡†å¤‡å‚æ•°
    intptr_t* parameter_array = args->parameters();
    int parameter_count = args->size_of_parameters();
    
    // è°ƒç”¨è§£é‡Šå™¨æˆ–ç¼–è¯‘ä»£ç 
    StubRoutines::call_stub()(
      (address)result,
      (address)entry_point,
      parameter_count,
      parameter_array,
      THREAD
    );
  }
  
  // å®ä¾‹æ–¹æ³•è°ƒç”¨
  static void call_instance_method(JavaValue* result,
                                  methodHandle method,
                                  JavaCallArguments* args,
                                  TRAPS) {
    
    // è·å–æ¥æ”¶è€…
    Handle receiver = args->receiver();
    
    // è™šæ–¹æ³•åˆ†å‘
    if (method->is_virtual() && !method->is_final_method()) {
      // é€šè¿‡è™šæ–¹æ³•è¡¨åˆ†å‘
      Klass* receiver_klass = receiver->klass();
      method = methodHandle(THREAD, receiver_klass->method_at_vtable(method->vtable_index()));
    }
    
    // è·å–æ–¹æ³•å…¥å£ç‚¹
    address entry_point = method->from_interpreted_entry();
    
    // å‡†å¤‡å‚æ•°(åŒ…å«æ¥æ”¶è€…)
    intptr_t* parameter_array = args->parameters();
    int parameter_count = args->size_of_parameters();
    
    // è°ƒç”¨è§£é‡Šå™¨æˆ–ç¼–è¯‘ä»£ç 
    StubRoutines::call_stub()(
      (address)result,
      (address)entry_point,
      parameter_count,
      parameter_array,
      THREAD
    );
  }
  
  // æ–¹æ³•è§£æ
  static methodHandle resolve_method(KlassHandle klass,
                                   Symbol* name,
                                   Symbol* signature,
                                   TRAPS) {
    
    // åœ¨ç±»ä¸­æŸ¥æ‰¾æ–¹æ³•
    Method* method = klass()->lookup_method(name, signature);
    
    if (method == NULL) {
      // åœ¨çˆ¶ç±»ä¸­æŸ¥æ‰¾
      Klass* super = klass()->super();
      while (super != NULL) {
        method = super->lookup_method(name, signature);
        if (method != NULL) break;
        super = super->super();
      }
    }
    
    if (method == NULL) {
      THROW_MSG_NULL(vmSymbols::java_lang_NoSuchMethodError(),
                     Method::name_and_sig_as_C_string(klass(), name, signature));
    }
    
    return methodHandle(THREAD, method);
  }
};
```

### 3.3 InterpreterRuntime - è§£é‡Šå™¨è¿è¡Œæ—¶æ”¯æŒ

InterpreterRuntimeæä¾›äº†è§£é‡Šå™¨æ‰§è¡Œè¿‡ç¨‹ä¸­éœ€è¦çš„è¿è¡Œæ—¶æ”¯æŒï¼š

```cpp
// src/hotspot/share/interpreter/interpreterRuntime.hpp
class InterpreterRuntime: AllStatic {
public:
  // å¼‚å¸¸å¤„ç†
  static void throw_AbstractMethodError(JavaThread* thread);
  static void throw_IncompatibleClassChangeError(JavaThread* thread);
  static void throw_StackOverflowError(JavaThread* thread);
  static void throw_ArrayIndexOutOfBoundsException(JavaThread* thread, char* name, jint index);
  static void throw_ClassCastException(JavaThread* thread, oopDesc* obj);
  
  // å¯¹è±¡åˆ†é…
  static void new_instance(JavaThread* thread, ConstantPool* pool, int index);
  static void new_array(JavaThread* thread, ConstantPool* pool, int index, jint size);
  static void anew_array(JavaThread* thread, ConstantPool* pool, int index, jint size);
  static void multianew_array(JavaThread* thread, jint* first_size_address);
  
  // å­—æ®µè®¿é—®
  static void resolve_get_put(JavaThread* thread, Bytecodes::Code bytecode);
  static void resolve_invoke(JavaThread* thread, Bytecodes::Code bytecode);
  
  // ç±»å‹æ£€æŸ¥
  static void quicken_io_cc(JavaThread* thread);
  static void resolve_ldc(JavaThread* thread, Bytecodes::Code bytecode);
  
  // åŒæ­¥æ”¯æŒ
  static void monitorenter(JavaThread* thread, BasicObjectLock* elem);
  static void monitorexit(JavaThread* thread, BasicObjectLock* elem);
  
  // é¢‘ç‡è®¡æ•°å™¨æº¢å‡ºå¤„ç†
  static nmethod* frequency_counter_overflow(JavaThread* thread, address branch_bcp);
  static nmethod* frequency_counter_overflow_inner(JavaThread* thread, address branch_bcp);
  
  // æ–¹æ³•æ•°æ®æ›´æ–°
  static void update_mdp_for_ret(JavaThread* thread, int return_bci);
  static void profile_method(JavaThread* thread);
  static void profile_ret(JavaThread* thread, int return_bci, int bcp_offset);
  static void profile_null_seen(JavaThread* thread);
  static void profile_typecheck(JavaThread* thread, Klass* klass, int bcp_offset);
  static void profile_typecheck_failed(JavaThread* thread);
  static void profile_switch_default(JavaThread* thread);
  static void profile_switch_case(JavaThread* thread, int table_index);
  
private:
  // å†…éƒ¨è¾…åŠ©æ–¹æ³•
  static void note_trap_inner(JavaThread* thread, int reason,
                             methodHandle trap_method, int trap_bci, TRAPS);
  static void note_trap(JavaThread* thread, int reason, TRAPS);
  static Handle create_exception(JavaThread* thread, char* name, char* message);
};
```

---

## âš¡ 4. æ‰§è¡Œå¼•æ“æ€§èƒ½ä¼˜åŒ–æœºåˆ¶

### 4.1 é¢‘ç‡è®¡æ•°å™¨ä¸ç¼–è¯‘è§¦å‘

HotSpotä½¿ç”¨é¢‘ç‡è®¡æ•°å™¨æ¥å†³å®šä½•æ—¶è§¦å‘JITç¼–è¯‘ï¼š

```cpp
// src/hotspot/share/interpreter/invocationCounter.hpp
class InvocationCounter VALUE_OBJ_CLASS_SPEC {
private:
  unsigned int _counter;              // è®¡æ•°å™¨å€¼
  
  enum PrivateConstants {
    number_of_count_bits  = 29,       // è®¡æ•°ä½æ•°
    number_of_state_bits  = 3,        // çŠ¶æ€ä½æ•°
    state_shift          = number_of_count_bits,
    count_mask           = right_n_bits(number_of_count_bits),
    state_mask           = right_n_bits(number_of_state_bits),
    count_grain          = 1,         // è®¡æ•°ç²’åº¦
    count_limit          = count_mask // è®¡æ•°ä¸Šé™
  };
  
public:
  enum State {
    wait_for_nothing,                 // ç­‰å¾…çŠ¶æ€
    wait_for_compile,                 // ç­‰å¾…ç¼–è¯‘
    count_overflow                    // è®¡æ•°æº¢å‡º
  };
  
  // è®¡æ•°å™¨æ“ä½œ
  void increment() { 
    _counter += count_grain; 
  }
  
  void set(State state, int count) {
    assert(0 <= count && count <= count_limit, "count out of range");
    _counter = (state << state_shift) | count;
  }
  
  // çŠ¶æ€æŸ¥è¯¢
  State state() const { 
    return (State)((_counter >> state_shift) & state_mask); 
  }
  
  int count() const { 
    return _counter & count_mask; 
  }
  
  // ç¼–è¯‘æ£€æŸ¥
  bool carry() const { 
    return (_counter & count_mask) > InvocationCounter::count_limit / 2; 
  }
  
  void set_carry() { 
    set(state(), count_limit); 
  }
  
  void reset() { 
    set(wait_for_nothing, 0); 
  }
  
  // æ‰“å°è°ƒè¯•ä¿¡æ¯
  void print() const {
    tty->print_cr("invocation_counter: %d state: %d", count(), state());
  }
};

// æ–¹æ³•è®¡æ•°å™¨ç®¡ç†
class MethodCounters: public MetaspaceObj {
private:
  InvocationCounter _invocation_counter;    // è°ƒç”¨è®¡æ•°å™¨
  InvocationCounter _backedge_counter;      // å›è¾¹è®¡æ•°å™¨
  
  // æ€§èƒ½æ•°æ®
  int               _interpreter_invocation_count; // è§£é‡Šå™¨è°ƒç”¨æ¬¡æ•°
  int               _interpreter_throwout_count;   // è§£é‡Šå™¨ä¸¢å¼ƒæ¬¡æ•°
  int               _number_of_breakpoints;        // æ–­ç‚¹æ•°é‡
  
  // ç¼–è¯‘çº§åˆ«
  u1                _highest_comp_level;           // æœ€é«˜ç¼–è¯‘çº§åˆ«
  u1                _highest_osr_comp_level;       // æœ€é«˜OSRç¼–è¯‘çº§åˆ«
  
public:
  // è®¡æ•°å™¨è®¿é—®
  InvocationCounter* invocation_counter() { return &_invocation_counter; }
  InvocationCounter* backedge_counter()   { return &_backedge_counter; }
  
  // ç¼–è¯‘è§¦å‘æ£€æŸ¥
  bool invocation_limit_reached() {
    return _invocation_counter.count() >= CompileThreshold;
  }
  
  bool backedge_limit_reached() {
    return _backedge_counter.count() >= OnStackReplacePercentage * CompileThreshold / 100;
  }
  
  // çƒ­åº¦è®¡ç®—
  int total_count() {
    return _invocation_counter.count() + _backedge_counter.count();
  }
  
  float hotness() {
    int total = total_count();
    if (total == 0) return 0.0f;
    return (float)total / CompileThreshold;
  }
  
  // ç¼–è¯‘çº§åˆ«ç®¡ç†
  void set_highest_comp_level(int level) {
    _highest_comp_level = level;
  }
  
  void set_highest_osr_comp_level(int level) {
    _highest_osr_comp_level = level;
  }
  
  // é‡ç½®è®¡æ•°å™¨
  void clear_counters() {
    _invocation_counter.reset();
    _backedge_counter.reset();
    _interpreter_invocation_count = 0;
    _interpreter_throwout_count = 0;
  }
};
```

### 4.2 OSR (On-Stack Replacement) æœºåˆ¶

OSRå…è®¸åœ¨æ–¹æ³•æ‰§è¡Œè¿‡ç¨‹ä¸­ä»è§£é‡Šæ‰§è¡Œåˆ‡æ¢åˆ°ç¼–è¯‘æ‰§è¡Œï¼š

```cpp
// src/hotspot/share/runtime/deoptimization.hpp
class Deoptimization : AllStatic {
public:
  // OSRç¼–è¯‘è§¦å‘
  static nmethod* compile_for_osr(methodHandle method, int osr_bci, TRAPS) {
    // æ£€æŸ¥æ˜¯å¦å·²æœ‰OSRç¼–è¯‘
    nmethod* osr_nm = method->lookup_osr_nmethod_for(osr_bci, CompLevel_full_optimization, true);
    if (osr_nm != NULL) {
      return osr_nm;
    }
    
    // æäº¤OSRç¼–è¯‘ä»»åŠ¡
    CompileBroker::compile_method(method, osr_bci, CompLevel_full_optimization,
                                 methodHandle(), 0, "osr", CHECK_NULL);
    
    // ç­‰å¾…ç¼–è¯‘å®Œæˆ
    while (true) {
      osr_nm = method->lookup_osr_nmethod_for(osr_bci, CompLevel_full_optimization, true);
      if (osr_nm != NULL) {
        return osr_nm;
      }
      
      // æ£€æŸ¥ç¼–è¯‘æ˜¯å¦å¤±è´¥
      if (method->is_not_compilable(CompLevel_full_optimization)) {
        return NULL;
      }
      
      // çŸ­æš‚ç­‰å¾…
      os::naked_short_sleep(1);
    }
  }
  
  // OSRå…¥å£æŸ¥æ‰¾
  static address fetch_osr_entry(nmethod* osr_nm, address bcp, int bci) {
    // éªŒè¯OSRç¼–è¯‘
    if (osr_nm == NULL) return NULL;
    if (!osr_nm->is_osr_method()) return NULL;
    if (osr_nm->osr_entry_bci() != bci) return NULL;
    
    // è¿”å›OSRå…¥å£ç‚¹
    return osr_nm->osr_entry_point();
  }
  
  // æ ˆä¸Šæ›¿æ¢æ‰§è¡Œ
  static void perform_osr(JavaThread* thread, nmethod* osr_nm, address osr_entry) {
    // ä¿å­˜å½“å‰è§£é‡Šå™¨çŠ¶æ€
    frame fr = thread->last_frame();
    Method* method = fr.interpreter_frame_method();
    
    // åˆ›å»ºOSRç¼“å†²åŒº
    OSRAdapter* adapter = new OSRAdapter(fr, osr_nm);
    
    // å¤åˆ¶å±€éƒ¨å˜é‡å’Œæ“ä½œæ•°æ ˆ
    adapter->copy_locals_and_stack();
    
    // è®¾ç½®OSRå…¥å£
    thread->set_osr_buffer((address)adapter);
    
    // è·³è½¬åˆ°ç¼–è¯‘ä»£ç 
    StubRoutines::osr_entry_stub()(osr_entry, (address)adapter, THREAD);
  }
  
private:
  // OSRé€‚é…å™¨
  class OSRAdapter {
  private:
    frame         _fr;              // åŸå§‹æ ˆå¸§
    nmethod*      _nm;              // OSRç¼–è¯‘
    intptr_t*     _locals;          // å±€éƒ¨å˜é‡
    intptr_t*     _stack;           // æ“ä½œæ•°æ ˆ
    int           _locals_size;     // å±€éƒ¨å˜é‡å¤§å°
    int           _stack_size;      // æ“ä½œæ•°æ ˆå¤§å°
    
  public:
    OSRAdapter(frame& fr, nmethod* nm) : _fr(fr), _nm(nm) {
      Method* method = fr.interpreter_frame_method();
      _locals_size = method->max_locals();
      _stack_size = method->max_stack();
      
      // åˆ†é…ç¼“å†²åŒº
      _locals = NEW_C_HEAP_ARRAY(intptr_t, _locals_size, mtCompiler);
      _stack = NEW_C_HEAP_ARRAY(intptr_t, _stack_size, mtCompiler);
    }
    
    ~OSRAdapter() {
      FREE_C_HEAP_ARRAY(intptr_t, _locals);
      FREE_C_HEAP_ARRAY(intptr_t, _stack);
    }
    
    void copy_locals_and_stack() {
      // å¤åˆ¶å±€éƒ¨å˜é‡
      intptr_t* frame_locals = _fr.interpreter_frame_locals();
      for (int i = 0; i < _locals_size; i++) {
        _locals[i] = frame_locals[-i];
      }
      
      // å¤åˆ¶æ“ä½œæ•°æ ˆ
      intptr_t* frame_stack = _fr.interpreter_frame_tos_address();
      for (int i = 0; i < _stack_size; i++) {
        _stack[i] = frame_stack[i];
      }
    }
    
    intptr_t* locals() { return _locals; }
    intptr_t* stack()  { return _stack; }
  };
};
```

### 4.3 åˆ†æ”¯é¢„æµ‹ä¸æ€§èƒ½ç›‘æ§

HotSpotæ”¶é›†åˆ†æ”¯é¢„æµ‹ä¿¡æ¯æ¥ä¼˜åŒ–ç¼–è¯‘ï¼š

```cpp
// src/hotspot/share/oops/methodData.hpp
class MethodData : public Metadata {
private:
  // æ€§èƒ½æ•°æ®åŒºåŸŸ
  intptr_t _data[1];                    // æ€§èƒ½æ•°æ®æ•°ç»„
  
  // æ•°æ®å¸ƒå±€ä¿¡æ¯
  int _data_size;                       // æ•°æ®å¤§å°
  int _extra_data_size;                 // é¢å¤–æ•°æ®å¤§å°
  
  // ç¼–è¯‘ç›¸å…³
  int _invocation_counter_start;        // è°ƒç”¨è®¡æ•°å™¨èµ·å§‹å€¼
  int _backedge_counter_start;          // å›è¾¹è®¡æ•°å™¨èµ·å§‹å€¼
  
  // å»ä¼˜åŒ–ä¿¡æ¯
  int _num_loops;                       // å¾ªç¯æ•°é‡
  int _num_blocks;                      // åŸºæœ¬å—æ•°é‡
  int _highest_comp_level;              // æœ€é«˜ç¼–è¯‘çº§åˆ«
  int _highest_osr_comp_level;          // æœ€é«˜OSRç¼–è¯‘çº§åˆ«
  
  // æ€§èƒ½åˆ†ææ ‡å¿—
  bool _would_profile;                  // æ˜¯å¦è¿›è¡Œæ€§èƒ½åˆ†æ
  
public:
  // æ•°æ®è®¿é—®
  ProfileData* data_at(int data_index) const {
    assert(data_index % DataLayout::cell_size == 0, "unaligned");
    return (ProfileData*)((address)_data + data_index);
  }
  
  // åˆ†æ”¯æ•°æ®
  BranchData* branch_data_at(int bci) const {
    DataLayout* data = data_layout_at(bci);
    return data->tag() == DataLayout::branch_data_tag ? 
           new BranchData(data) : NULL;
  }
  
  // è°ƒç”¨æ•°æ®
  CallTypeData* call_type_data_at(int bci) const {
    DataLayout* data = data_layout_at(bci);
    return data->tag() == DataLayout::call_type_data_tag ?
           new CallTypeData(data) : NULL;
  }
  
  // ç±»å‹æ£€æŸ¥æ•°æ®
  ReceiverTypeData* receiver_type_data_at(int bci) const {
    DataLayout* data = data_layout_at(bci);
    return data->tag() == DataLayout::receiver_type_data_tag ?
           new ReceiverTypeData(data) : NULL;
  }
  
  // æ€§èƒ½ç»Ÿè®¡æ›´æ–°
  void inc_invocation_count() {
    _invocation_counter_start++;
  }
  
  void inc_backedge_count() {
    _backedge_counter_start++;
  }
  
  // åˆ†æ”¯é¢„æµ‹æ›´æ–°
  void update_branch_data(int bci, bool taken) {
    BranchData* data = branch_data_at(bci);
    if (data != NULL) {
      if (taken) {
        data->inc_taken();
      } else {
        data->inc_not_taken();
      }
    }
  }
  
  // ç±»å‹ä¿¡æ¯æ›´æ–°
  void update_receiver_type(int bci, Klass* receiver_klass) {
    ReceiverTypeData* data = receiver_type_data_at(bci);
    if (data != NULL) {
      data->record_receiver(receiver_klass);
    }
  }
  
  // æ€§èƒ½åˆ†æ
  float branch_prediction_accuracy(int bci) const {
    BranchData* data = branch_data_at(bci);
    if (data == NULL) return 0.0f;
    
    int taken = data->taken();
    int not_taken = data->not_taken();
    int total = taken + not_taken;
    
    if (total == 0) return 0.0f;
    
    // è®¡ç®—é¢„æµ‹å‡†ç¡®ç‡(å‡è®¾é¢„æµ‹å¤šæ•°æƒ…å†µ)
    int majority = MAX2(taken, not_taken);
    return (float)majority / total;
  }
  
  // çƒ­ç‚¹è¯†åˆ«
  bool is_hot_branch(int bci) const {
    BranchData* data = branch_data_at(bci);
    if (data == NULL) return false;
    
    int total = data->taken() + data->not_taken();
    return total > CompileThreshold / 10; // 10%çš„ç¼–è¯‘é˜ˆå€¼
  }
  
  // å¤šæ€ç¨‹åº¦åˆ†æ
  int polymorphism_degree(int bci) const {
    ReceiverTypeData* data = receiver_type_data_at(bci);
    if (data == NULL) return 0;
    
    int type_count = 0;
    for (int i = 0; i < data->row_limit(); i++) {
      if (data->receiver(i) != NULL) {
        type_count++;
      }
    }
    return type_count;
  }
};

// åˆ†æ”¯æ•°æ®ç»“æ„
class BranchData : public ProfileData {
private:
  enum {
    taken_off_set,
    not_taken_off_set,
    branch_cell_count
  };
  
public:
  BranchData(DataLayout* layout) : ProfileData(layout) {
    assert(layout->tag() == DataLayout::branch_data_tag, "wrong type");
  }
  
  // åˆ†æ”¯ç»Ÿè®¡
  uint taken() const {
    return uint_at(taken_off_set);
  }
  
  uint not_taken() const {
    return uint_at(not_taken_off_set);
  }
  
  // æ›´æ–°ç»Ÿè®¡
  void inc_taken() {
    inc_uint_at(taken_off_set);
  }
  
  void inc_not_taken() {
    inc_uint_at(not_taken_off_set);
  }
  
  // é¢„æµ‹åˆ†æ
  bool is_taken_likely() const {
    return taken() > not_taken();
  }
  
  float taken_probability() const {
    uint total = taken() + not_taken();
    return total > 0 ? (float)taken() / total : 0.5f;
  }
};
```

ç°åœ¨è®©æˆ‘åˆ›å»ºå¯¹åº”çš„æ·±åº¦å¢å¼ºç‰ˆGDBè°ƒè¯•è„šæœ¬ï¼š