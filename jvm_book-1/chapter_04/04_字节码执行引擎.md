# ç¬¬04ç« ï¼šå­—èŠ‚ç æ‰§è¡Œå¼•æ“ - è§£é‡Šå™¨ä¸ç¼–è¯‘å™¨

## ğŸ“– ç« èŠ‚æ¦‚è¿°

æœ¬ç« æ·±å…¥åˆ†æHotSpot VMçš„å­—èŠ‚ç æ‰§è¡Œå¼•æ“ï¼ŒåŸºäº**-Xms=Xmx=8GB, éå¤§é¡µ, éNUMA, G1GC**çš„æ ‡å‡†é…ç½®ï¼Œé€šè¿‡GDBè°ƒè¯•éªŒè¯è§£é‡Šå™¨å’ŒJITç¼–è¯‘å™¨çš„å·¥ä½œåŸç†ã€‚æˆ‘ä»¬å°†ä»æºç å±‚é¢å‰–ææ¨¡æ¿è§£é‡Šå™¨ã€åˆ†å±‚ç¼–è¯‘ç­–ç•¥ã€OSRæœºåˆ¶ï¼Œä»¥åŠCodeCacheç®¡ç†ã€‚

### ğŸ¯ å­¦ä¹ ç›®æ ‡

- æ·±å…¥ç†è§£HotSpot VMå­—èŠ‚ç æ‰§è¡Œçš„åŒé‡æœºåˆ¶
- æŒæ¡æ¨¡æ¿è§£é‡Šå™¨çš„å®ç°åŸç†å’Œæ€§èƒ½ç‰¹å¾
- åˆ†æJITç¼–è¯‘å™¨çš„åˆ†å±‚ç¼–è¯‘ç­–ç•¥
- é€šè¿‡GDBéªŒè¯OSR(On-Stack Replacement)æœºåˆ¶
- ç†è§£CodeCacheçš„ç®¡ç†å’Œä¼˜åŒ–ç­–ç•¥

### ğŸ”§ å®éªŒç¯å¢ƒ

```bash
# æ ‡å‡†JVMé…ç½®
-Xms8g -Xmx8g          # 8GBå †å†…å­˜
-XX:+UseG1GC           # G1åƒåœ¾æ”¶é›†å™¨
-XX:+UnlockDiagnosticVMOptions
-XX:+TraceClassLoading
-XX:+PrintCompilation  # ç¼–è¯‘è·Ÿè¸ª
-XX:+PrintInlining     # å†…è”è·Ÿè¸ª
```

---

## ğŸ—ï¸ 1. å­—èŠ‚ç æ‰§è¡Œå¼•æ“æ¶æ„

### 1.1 æ‰§è¡Œå¼•æ“æ€»ä½“æ¶æ„

HotSpot VMé‡‡ç”¨æ··åˆæ‰§è¡Œæ¨¡å¼ï¼Œç»“åˆè§£é‡Šå™¨å’Œç¼–è¯‘å™¨ï¼š

```cpp
// src/hotspot/share/runtime/thread.cpp
class JavaThread : public Thread {
private:
  // æ‰§è¡Œå¼•æ“ç›¸å…³
  frame           _anchor;                    // æ ˆå¸§é”šç‚¹
  JavaFrameAnchor _anchor;                   // Javaæ ˆå¸§é”šç‚¹
  
  // è§£é‡Šå™¨çŠ¶æ€
  intptr_t*       _interpreter_state;        // è§£é‡Šå™¨çŠ¶æ€
  
  // ç¼–è¯‘ç›¸å…³
  nmethod*        _osr_nmethod_cache;        // OSRç¼–è¯‘ç¼“å­˜
  
public:
  // å­—èŠ‚ç æ‰§è¡Œå…¥å£
  void call_run();
  
  // è§£é‡Šå™¨æ‰§è¡Œ
  void interpreter_frame_do(void f(frame*));
  
  // ç¼–è¯‘ä»£ç æ‰§è¡Œ
  void compiled_frame_do(void f(frame*));
};
```

#### 1.1.1 æ‰§è¡Œæ¨¡å¼åˆ‡æ¢

```cpp
// src/hotspot/share/interpreter/interpreterRuntime.cpp
IRT_ENTRY(void, InterpreterRuntime::frequency_counter_overflow(JavaThread* thread, address branch_bcp))
  
  // æ£€æŸ¥æ–¹æ³•è°ƒç”¨è®¡æ•°
  Method* method = last_frame.interpreter_frame_method();
  int hot_count = method->invocation_count() + method->backedge_count();
  
  // è§¦å‘ç¼–è¯‘æ¡ä»¶æ£€æŸ¥
  if (hot_count >= CompileThreshold) {
    // æäº¤ç¼–è¯‘ä»»åŠ¡
    CompileBroker::compile_method(method, InvocationEntryBci, 
                                CompLevel_full_optimization, 
                                methodHandle(), 0, "count", CHECK);
  }
  
IRT_END
```

### 1.2 å­—èŠ‚ç æŒ‡ä»¤é›†æ¶æ„

HotSpot VMæ”¯æŒå®Œæ•´çš„Javaå­—èŠ‚ç æŒ‡ä»¤é›†ï¼š

```cpp
// src/hotspot/share/interpreter/bytecodes.hpp
class Bytecodes: AllStatic {
public:
  enum Code {
    _illegal    = -1,
    
    // å¸¸é‡åŠ è½½æŒ‡ä»¤
    _nop        = 0x00,
    _aconst_null = 0x01,
    _iconst_m1  = 0x02,
    _iconst_0   = 0x03,
    // ... æ›´å¤šæŒ‡ä»¤
    
    // å±€éƒ¨å˜é‡æ“ä½œ
    _iload      = 0x15,
    _lload      = 0x16,
    _fload      = 0x17,
    _dload      = 0x18,
    _aload      = 0x19,
    
    // æ ˆæ“ä½œæŒ‡ä»¤
    _iaload     = 0x2e,
    _laload     = 0x2f,
    _faload     = 0x30,
    
    // ç®—æœ¯æŒ‡ä»¤
    _iadd       = 0x60,
    _ladd       = 0x61,
    _fadd       = 0x62,
    _dadd       = 0x63,
    
    // æ§åˆ¶æµæŒ‡ä»¤
    _ifeq       = 0x99,
    _ifne       = 0x9a,
    _iflt       = 0x9b,
    _ifge       = 0x9c,
    _ifgt       = 0x9d,
    _ifle       = 0x9e,
    
    // æ–¹æ³•è°ƒç”¨æŒ‡ä»¤
    _invokevirtual   = 0xb6,
    _invokespecial   = 0xb7,
    _invokestatic    = 0xb8,
    _invokeinterface = 0xb9,
    _invokedynamic   = 0xba,
    
    number_of_codes = 256
  };
};
```

---

## ğŸ­ 2. æ¨¡æ¿è§£é‡Šå™¨æ·±åº¦åˆ†æ

### 2.1 æ¨¡æ¿è§£é‡Šå™¨æ¶æ„

æ¨¡æ¿è§£é‡Šå™¨ä¸ºæ¯ä¸ªå­—èŠ‚ç æŒ‡ä»¤ç”Ÿæˆä¼˜åŒ–çš„æœºå™¨ç æ¨¡æ¿ï¼š

```cpp
// src/hotspot/share/interpreter/templateInterpreter.hpp
class TemplateInterpreter: public AbstractInterpreter {
private:
  // æŒ‡ä»¤æ¨¡æ¿è¡¨
  static InterpreterCodelet* _code;
  
  // æ–¹æ³•å…¥å£ç‚¹
  static address _entry_table[number_of_method_entries];
  
  // å­—èŠ‚ç æ¨¡æ¿
  static Template _template_table[Bytecodes::number_of_codes];
  
public:
  // åˆå§‹åŒ–è§£é‡Šå™¨
  static void initialize();
  
  // ç”Ÿæˆå­—èŠ‚ç æ¨¡æ¿
  static void generate_all();
  
  // è·å–å­—èŠ‚ç å…¥å£
  static address entry_for_kind(MethodKind kind);
};
```

#### 2.1.1 å­—èŠ‚ç æ¨¡æ¿ç”Ÿæˆ

```cpp
// src/hotspot/share/interpreter/templateTable.cpp
void TemplateTable::initialize() {
  
  // å®šä¹‰å­—èŠ‚ç æ¨¡æ¿
  def(Bytecodes::_nop           , ubcp|____|____|____, vtos, vtos, nop           );
  def(Bytecodes::_aconst_null   , ubcp|____|____|____, vtos, atos, aconst_null   );
  def(Bytecodes::_iconst_m1     , ubcp|____|____|____, vtos, itos, iconst        );
  def(Bytecodes::_iconst_0      , ubcp|____|____|____, vtos, itos, iconst        );
  
  // å±€éƒ¨å˜é‡åŠ è½½
  def(Bytecodes::_iload         , ubcp|____|clvm|____, vtos, itos, iload         );
  def(Bytecodes::_lload         , ubcp|____|____|____, vtos, ltos, lload         );
  def(Bytecodes::_fload         , ubcp|____|____|____, vtos, ftos, fload         );
  def(Bytecodes::_dload         , ubcp|____|____|____, vtos, dtos, dload         );
  def(Bytecodes::_aload         , ubcp|____|clvm|____, vtos, atos, aload         );
  
  // ç®—æœ¯è¿ç®—
  def(Bytecodes::_iadd          , ubcp|____|____|____, itos, itos, iadd          );
  def(Bytecodes::_ladd          , ubcp|____|____|____, ltos, ltos, ladd          );
  def(Bytecodes::_fadd          , ubcp|____|____|____, ftos, ftos, fadd          );
  def(Bytecodes::_dadd          , ubcp|____|____|____, dtos, dtos, dadd          );
  
  // æ–¹æ³•è°ƒç”¨
  def(Bytecodes::_invokevirtual , ubcp|disp|clvm|____, vtos, vtos, invokevirtual );
  def(Bytecodes::_invokespecial , ubcp|disp|clvm|____, vtos, vtos, invokespecial );
  def(Bytecodes::_invokestatic  , ubcp|disp|clvm|____, vtos, vtos, invokestatic  );
}
```

#### 2.1.2 å…·ä½“æŒ‡ä»¤å®ç°

ä»¥`iadd`æŒ‡ä»¤ä¸ºä¾‹ï¼š

```cpp
// src/hotspot/cpu/x86/templateTable_x86.cpp
void TemplateTable::iadd() {
  transition(itos, itos);
  
  // ä»æ ˆé¡¶å¼¹å‡ºä¸¤ä¸ªæ•´æ•°å¹¶ç›¸åŠ 
  __ pop_i(rdx);      // å¼¹å‡ºç¬¬äºŒä¸ªæ“ä½œæ•°åˆ°rdx
  __ addl(rax, rdx);  // rax += rdx (ç¬¬ä¸€ä¸ªæ“ä½œæ•°åœ¨raxä¸­)
  
  // ç»“æœä¿ç•™åœ¨raxä¸­ï¼Œä½œä¸ºæ ˆé¡¶å…ƒç´ 
}
```

### 2.2 è§£é‡Šå™¨æ‰§è¡Œæµç¨‹

#### 2.2.1 æ–¹æ³•è°ƒç”¨å…¥å£

```cpp
// src/hotspot/share/interpreter/interpreterRuntime.cpp
address InterpreterGenerator::generate_method_entry(AbstractInterpreter::MethodKind kind) {
  
  address entry_point = __ pc();
  
  // 1. æ ˆæº¢å‡ºæ£€æŸ¥
  generate_stack_overflow_check();
  
  // 2. åˆ›å»ºæ ˆå¸§
  generate_fixed_frame(false);
  
  // 3. åˆå§‹åŒ–å±€éƒ¨å˜é‡
  __ movptr(r14, Address(rbp, method_offset));
  __ movl(rcx, Address(r14, Method::size_of_locals_offset()));
  __ shll(rcx, Interpreter::logStackElementSize);
  
  // 4. è¿›å…¥å­—èŠ‚ç æ‰§è¡Œå¾ªç¯
  __ dispatch_next(vtos);
  
  return entry_point;
}
```

#### 2.2.2 å­—èŠ‚ç åˆ†å‘æœºåˆ¶

```cpp
// src/hotspot/cpu/x86/interp_masm_x86.cpp
void InterpreterMacroAssembler::dispatch_next(TosState state, int step) {
  
  // 1. åŠ è½½ä¸‹ä¸€æ¡å­—èŠ‚ç 
  load_unsigned_byte(rbx, Address(r13, step));
  
  // 2. å¢åŠ å­—èŠ‚ç æŒ‡é’ˆ
  increment(r13, step);
  
  // 3. åˆ†å‘åˆ°å¯¹åº”çš„å¤„ç†ä¾‹ç¨‹
  dispatch_base(state, Interpreter::dispatch_table(state));
}

void InterpreterMacroAssembler::dispatch_base(TosState state, address* table) {
  
  // è®¡ç®—è·³è½¬åœ°å€
  lea(rscratch1, ExternalAddress((address)table));
  jmp(Address(rscratch1, rbx, Address::times_ptr));
}
```

### 2.3 æ ˆå¸§ç®¡ç†

#### 2.3.1 è§£é‡Šå™¨æ ˆå¸§ç»“æ„

```cpp
// src/hotspot/share/runtime/frame.hpp
class frame VALUE_OBJ_CLASS_SPEC {
private:
  intptr_t* _sp;  // æ ˆæŒ‡é’ˆ
  intptr_t* _fp;  // å¸§æŒ‡é’ˆ
  address   _pc;  // ç¨‹åºè®¡æ•°å™¨
  
public:
  // è§£é‡Šå™¨æ ˆå¸§å¸ƒå±€
  /*
   *  [å±€éƒ¨å˜é‡åŒº]     <- fp + locals_offset
   *  [è¡¨è¾¾å¼æ ˆ]       <- sp
   *  [æ–¹æ³•ä¿¡æ¯]       <- fp + method_offset  
   *  [å­—èŠ‚ç æŒ‡é’ˆ]     <- fp + bcp_offset
   *  [å¸¸é‡æ± ç¼“å­˜]     <- fp + cache_offset
   *  [ç›‘è§†å™¨]         <- fp + monitors_offset
   *  [è¿”å›åœ°å€]       <- fp + return_addr_offset
   *  [ä¸Šä¸€å¸§fp]       <- fp
   */
  
  // è·å–è§£é‡Šå™¨æ ˆå¸§ä¿¡æ¯
  Method* interpreter_frame_method() const;
  address interpreter_frame_bcp() const;
  intptr_t* interpreter_frame_locals() const;
  intptr_t* interpreter_frame_expression_stack() const;
};
```

#### 2.3.2 å±€éƒ¨å˜é‡è®¿é—®

```cpp
// src/hotspot/cpu/x86/templateTable_x86.cpp
void TemplateTable::iload() {
  transition(vtos, itos);
  
  // è·å–å±€éƒ¨å˜é‡ç´¢å¼•
  locals_index(rbx);
  
  // ä»å±€éƒ¨å˜é‡è¡¨åŠ è½½æ•´æ•°
  __ movl(rax, iaddress(rbx));
}

void TemplateTable::istore() {
  transition(itos, vtos);
  
  // è·å–å±€éƒ¨å˜é‡ç´¢å¼•
  locals_index(rbx);
  
  // å­˜å‚¨æ•´æ•°åˆ°å±€éƒ¨å˜é‡è¡¨
  __ movl(iaddress(rbx), rax);
}
```

---

## âš¡ 3. JITç¼–è¯‘å™¨æ·±åº¦åˆ†æ

### 3.1 åˆ†å±‚ç¼–è¯‘æ¶æ„

HotSpot VMé‡‡ç”¨åˆ†å±‚ç¼–è¯‘ç­–ç•¥ï¼ŒåŒ…å«å¤šä¸ªç¼–è¯‘çº§åˆ«ï¼š

```cpp
// src/hotspot/share/compiler/compileBroker.hpp
enum CompLevel {
  CompLevel_none              = 0,         // è§£é‡Šæ‰§è¡Œ
  CompLevel_simple            = 1,         // C1ç¼–è¯‘å™¨ - ç®€å•ä¼˜åŒ–
  CompLevel_limited_profile   = 2,         // C1ç¼–è¯‘å™¨ - æœ‰é™æ€§èƒ½åˆ†æ
  CompLevel_full_profile      = 3,         // C1ç¼–è¯‘å™¨ - å®Œæ•´æ€§èƒ½åˆ†æ
  CompLevel_full_optimization = 4,         // C2ç¼–è¯‘å™¨ - å®Œå…¨ä¼˜åŒ–
  
  CompLevel_highest_tier      = CompLevel_full_optimization,
  CompLevel_initial_compile   = CompLevel_full_profile
};
```

#### 3.1.1 ç¼–è¯‘è§¦å‘æœºåˆ¶

```cpp
// src/hotspot/share/runtime/simpleThresholdPolicy.cpp
class SimpleThresholdPolicy : public CompilationPolicy {
private:
  // ç¼–è¯‘é˜ˆå€¼
  static int _c1_invoke_threshold;
  static int _c1_back_edge_threshold;
  static int _c2_invoke_threshold;
  static int _c2_back_edge_threshold;
  
public:
  // ç¼–è¯‘å†³ç­–
  virtual CompLevel call_event(Method* method, CompLevel cur_level, JavaThread* thread);
  virtual CompLevel loop_event(Method* method, CompLevel cur_level, JavaThread* thread);
  
  // é˜ˆå€¼æ£€æŸ¥
  bool is_mature(Method* method);
  bool should_create_mdo(Method* method, CompLevel cur_level, JavaThread* thread);
};
```

#### 3.1.2 ç¼–è¯‘ä»»åŠ¡è°ƒåº¦

```cpp
// src/hotspot/share/compiler/compileBroker.cpp
void CompileBroker::compile_method_base(const methodHandle& method,
                                      int osr_bci,
                                      int comp_level,
                                      const methodHandle& hot_method,
                                      int hot_count,
                                      const char* comment,
                                      Thread* thread) {
  
  // 1. åˆ›å»ºç¼–è¯‘ä»»åŠ¡
  CompileTask* task = create_compile_task(compile_queue,
                                        comp_level,
                                        method,
                                        osr_bci,
                                        hot_count,
                                        comment,
                                        blocking);
  
  // 2. æäº¤åˆ°ç¼–è¯‘é˜Ÿåˆ—
  if (blocking) {
    wait_for_completion(task);
  } else {
    compile_queue->add(task);
  }
}
```

### 3.2 C1ç¼–è¯‘å™¨ (Client Compiler)

#### 3.2.1 C1ç¼–è¯‘æµç¨‹

```cpp
// src/hotspot/share/c1/c1_Compilation.cpp
class Compilation : public StackObj {
private:
  ciEnv*                _env;
  ciMethod*             _method;
  int                   _osr_bci;
  bool                  _has_exception_handlers;
  bool                  _has_fpu_code;
  bool                  _has_unsafe_access;
  
public:
  // ç¼–è¯‘ä¸»æµç¨‹
  void compile_method();
  
  // æ„å»ºHIR (High-level Intermediate Representation)
  void build_hir();
  
  // æ„å»ºLIR (Low-level Intermediate Representation)  
  void emit_lir();
  
  // ç”Ÿæˆæœºå™¨ç 
  void emit_code_body();
};
```

#### 3.2.2 HIRæ„å»º

```cpp
// src/hotspot/share/c1/c1_GraphBuilder.cpp
void GraphBuilder::iterate_bytecodes_for_block(int bci) {
  
  while (!bcs.is_last_bytecode()) {
    
    // å¤„ç†å½“å‰å­—èŠ‚ç 
    Bytecodes::Code code = bcs.raw_next();
    
    switch (code) {
      case Bytecodes::_iadd:
        { Value y = pop(intType); Value x = pop(intType);
          push(intType, append(new ArithmeticOp(Bytecodes::_iadd, x, y))); }
        break;
        
      case Bytecodes::_invokevirtual:
        invoke(code);
        break;
        
      case Bytecodes::_ifeq:
        if_node(If::eql, x, intConstant(0), tsux, fsux);
        break;
        
      // ... æ›´å¤šå­—èŠ‚ç å¤„ç†
    }
  }
}
```

### 3.3 C2ç¼–è¯‘å™¨ (Server Compiler)

#### 3.3.1 C2ç¼–è¯‘æ¶æ„

```cpp
// src/hotspot/share/opto/compile.hpp
class Compile : public Phase {
private:
  ciEnv*          _env;           // ç¼–è¯‘ç¯å¢ƒ
  ciMethod*       _method;        // è¢«ç¼–è¯‘æ–¹æ³•
  int             _entry_bci;     // å…¥å£å­—èŠ‚ç ç´¢å¼•
  
  // ç¼–è¯‘é˜¶æ®µ
  PhaseGVN*       _initial_gvn;   // å…¨å±€å€¼ç¼–å·
  PhaseCFG*       _cfg;           // æ§åˆ¶æµå›¾
  PhaseRegAlloc*  _regalloc;      // å¯„å­˜å™¨åˆ†é…
  
public:
  // ç¼–è¯‘ä¸»æµç¨‹
  void Compile_wrapper(ciEnv* ci_env,
                      C2Compiler* compiler,
                      ciMethod* target,
                      int osr_bci,
                      bool subsume_loads,
                      DirectiveSet* directive);
};
```

#### 3.3.2 ä¼˜åŒ–é˜¶æ®µ

```cpp
// src/hotspot/share/opto/compile.cpp
void Compile::Optimize() {
  
  // 1. æ„å»ºåˆå§‹å›¾
  {
    TracePhase tp("idealLoop", &timers[_t_idealLoop]);
    PhaseIdealLoop ideal_loop(initial_gvn(), false, true);
  }
  
  // 2. å…¨å±€ä»£ç ç§»åŠ¨
  if (OptimizeFill) {
    TracePhase tp("generateFill", &timers[_t_generateFill]);
    generate_fill(root(), initial_gvn());
  }
  
  // 3. æ¶ˆé™¤é”
  if (EliminateLocks) {
    TracePhase tp("eliminateLocks", &timers[_t_eliminateLocks]);
    eliminate_locks();
  }
  
  // 4. é€ƒé€¸åˆ†æ
  if (has_escape_analysis()) {
    TracePhase tp("escapeAnalysis", &timers[_t_escapeAnalysis]);
    ConnectionGraph::do_analysis(this, &igvn);
  }
  
  // 5. å¾ªç¯ä¼˜åŒ–
  {
    TracePhase tp("idealLoop2", &timers[_t_idealLoop]);
    PhaseIdealLoop ideal_loop(igvn, true);
  }
}
```

---

## ğŸ”„ 4. OSR (On-Stack Replacement) æœºåˆ¶

### 4.1 OSRè§¦å‘æ¡ä»¶

OSRå…è®¸åœ¨æ–¹æ³•æ‰§è¡Œè¿‡ç¨‹ä¸­ä»è§£é‡Šæ‰§è¡Œåˆ‡æ¢åˆ°ç¼–è¯‘æ‰§è¡Œï¼š

```cpp
// src/hotspot/share/interpreter/interpreterRuntime.cpp
IRT_ENTRY(nmethod*, InterpreterRuntime::frequency_counter_overflow_inner(JavaThread* thread, address branch_bcp))
  
  // è·å–å½“å‰æ–¹æ³•å’Œå­—èŠ‚ç ä½ç½®
  frame fr = thread->last_frame();
  Method* method = fr.interpreter_frame_method();
  int branch_bci = method->bci_from(branch_bcp);
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦OSRç¼–è¯‘
  if (UseOnStackReplacement) {
    int hot_count = method->interpreter_invocation_count();
    int sum = hot_count + method->interpreter_throwout_count();
    
    if (sum >= OnStackReplacePercentage * CompileThreshold / 100) {
      // æäº¤OSRç¼–è¯‘ä»»åŠ¡
      CompileBroker::compile_method(method, branch_bci, 
                                  CompLevel_full_optimization,
                                  methodHandle(), hot_count, "OSR", CHECK_NULL);
    }
  }
  
IRT_END
```

#### 4.1.1 OSRç¼–è¯‘è¿‡ç¨‹

```cpp
// src/hotspot/share/opto/compile.cpp
void Compile::Init(int aliaslevel) {
  
  if (is_osr_compilation()) {
    // OSRç‰¹æ®Šå¤„ç†
    _entry_bci = osr_bci();
    
    // æ„å»ºOSRå…¥å£
    StartOSRNode* s = new StartOSRNode(root(), domain);
    initial_gvn()->set_type_bottom(s);
    init_start(s);
    
    // å¤„ç†å±€éƒ¨å˜é‡çŠ¶æ€
    if (osr_bci() != -1) {
      do_osr_entry();
    }
  }
}
```

#### 4.1.2 æ ˆæ›¿æ¢å®ç°

```cpp
// src/hotspot/share/runtime/sharedRuntime.cpp
OSR_Adapter* SharedRuntime::generate_osr_blob(int frame_size) {
  
  // 1. ä¿å­˜è§£é‡Šå™¨çŠ¶æ€
  __ movptr(rax, Address(rbp, frame::interpreter_frame_locals_offset * wordSize));
  
  // 2. è®¾ç½®ç¼–è¯‘ä»£ç æ ˆå¸§
  __ movptr(rsp, rax);
  __ movptr(rbp, Address(rax, (frame_size - 2) * wordSize));
  
  // 3. è·³è½¬åˆ°ç¼–è¯‘ä»£ç 
  __ jmp(Address(rax, frame_size * wordSize));
  
  return adapter;
}
```

### 4.2 å»ä¼˜åŒ– (Deoptimization)

å½“ç¼–è¯‘ä»£ç çš„å‡è®¾ä¸å†æˆç«‹æ—¶ï¼Œéœ€è¦å»ä¼˜åŒ–å›åˆ°è§£é‡Šæ‰§è¡Œï¼š

```cpp
// src/hotspot/share/runtime/deoptimization.cpp
Deoptimization::UnrollBlock* Deoptimization::uncommon_trap_inner(JavaThread* thread, jint trap_request) {
  
  // 1. åˆ†æå»ä¼˜åŒ–åŸå› 
  DeoptReason reason = trap_request_reason(trap_request);
  DeoptAction action = trap_request_action(trap_request);
  
  // 2. æ”¶é›†æ ˆå¸§ä¿¡æ¯
  frame stub_frame = thread->last_frame();
  frame deoptee_frame = stub_frame.sender(&map);
  
  // 3. é‡æ„è§£é‡Šå™¨æ ˆå¸§
  GrowableArray<compiledVFrame*>* chunk = new GrowableArray<compiledVFrame*>(10);
  vframe* vf = vframe::new_vframe(&deoptee_frame, &map, thread);
  
  // 4. åˆ›å»ºè§£é‡Šå™¨æ ˆå¸§
  UnrollBlock* info = create_vframeArray(thread, deoptee_frame, &map, chunk);
  
  return info;
}
```

---

## ğŸ’¾ 5. CodeCacheç®¡ç†

### 5.1 CodeCacheæ¶æ„

CodeCacheæ˜¯å­˜å‚¨ç¼–è¯‘ä»£ç çš„å†…å­˜åŒºåŸŸï¼š

```cpp
// src/hotspot/share/code/codeCache.hpp
class CodeCache : AllStatic {
private:
  // CodeCacheå†…å­˜å¸ƒå±€
  static CodeHeap* _heap;
  static CodeBlob* _blobs[number_of_code_blob_types];
  
  // ç»Ÿè®¡ä¿¡æ¯
  static size_t _number_of_blobs;
  static size_t _number_of_adapters;
  static size_t _number_of_nmethods;
  
public:
  // åˆå§‹åŒ–CodeCache
  static void initialize();
  
  // åˆ†é…ä»£ç ç©ºé—´
  static CodeBlob* allocate(int size, int code_blob_type, bool strict = false);
  
  // åƒåœ¾å›æ”¶
  static void gc_prologue();
  static void gc_epilogue();
};
```

#### 5.1.1 CodeCacheåˆ†æ®µç®¡ç†

åŸºäº8GBå †é…ç½®ï¼ŒCodeCacheé‡‡ç”¨åˆ†æ®µç®¡ç†ï¼š

```cpp
// src/hotspot/share/code/codeCache.cpp
void CodeCache::initialize_heaps() {
  
  // è®¡ç®—CodeCacheå¤§å° (240MB for 8GB heap)
  size_t total_size = InitialCodeCacheSize;
  if (total_size < ReservedCodeCacheSize) {
    total_size = ReservedCodeCacheSize;
  }
  
  // åˆ†æ®µé…ç½®
  size_t non_nmethod_size = total_size * NonNMethodCodeHeapSize / 100;
  size_t profiled_size = total_size * ProfiledCodeHeapSize / 100;  
  size_t non_profiled_size = total_size - non_nmethod_size - profiled_size;
  
  // åˆ›å»ºä»£ç å †
  _heaps[CodeBlobType::NonNMethod] = 
    new CodeHeap("CodeHeap 'non-nmethods'", CodeBlobType::NonNMethod);
  _heaps[CodeBlobType::MethodProfiled] = 
    new CodeHeap("CodeHeap 'profiled nmethods'", CodeBlobType::MethodProfiled);
  _heaps[CodeBlobType::MethodNonProfiled] = 
    new CodeHeap("CodeHeap 'non-profiled nmethods'", CodeBlobType::MethodNonProfiled);
}
```

#### 5.1.2 nmethodç”Ÿå‘½å‘¨æœŸ

```cpp
// src/hotspot/share/code/nmethod.cpp
void nmethod::make_not_entrant_or_zombie(unsigned int state) {
  
  assert(state == not_entrant || state == zombie, "must be valid state");
  
  // 1. è®¾ç½®çŠ¶æ€
  _state = state;
  
  // 2. æ¸…ç†å†…è”ç¼“å­˜
  cleanup_inline_caches();
  
  // 3. å¦‚æœæ˜¯zombieçŠ¶æ€ï¼Œé‡Šæ”¾å…ƒæ•°æ®
  if (state == zombie) {
    // é‡Šæ”¾ä¾èµ–
    flush_dependencies(NULL);
    
    // æ ‡è®°ä¸ºå¯å›æ”¶
    _is_unloaded = true;
  }
}
```

### 5.2 ä»£ç ç¼“å­˜ä¼˜åŒ–

#### 5.2.1 ä»£ç å±€éƒ¨æ€§ä¼˜åŒ–

```cpp
// src/hotspot/share/code/codeHeap.cpp
HeapBlock* CodeHeap::allocate(size_t instance_size, bool is_critical) {
  
  size_t number_of_segments = size_to_segments(instance_size + sizeof(HeapBlock));
  
  // æŸ¥æ‰¾æœ€ä½³åŒ¹é…å—
  HeapBlock* block = search_freelist(number_of_segments);
  
  if (block != NULL) {
    // åˆ†å‰²å—
    split_block(block, number_of_segments);
    return block;
  }
  
  // æ‰©å±•å †ç©ºé—´
  if (expand_by(number_of_segments)) {
    block = search_freelist(number_of_segments);
  }
  
  return block;
}
```

#### 5.2.2 ä»£ç å›æ”¶ç­–ç•¥

```cpp
// src/hotspot/share/code/codeCache.cpp
void CodeCache::do_unloading(BoolObjectClosure* is_alive, bool unloading_occurred) {
  
  CompiledMethodIterator iter;
  while(iter.next()) {
    CompiledMethod* cm = iter.method();
    
    // æ£€æŸ¥æ–¹æ³•æ˜¯å¦å­˜æ´»
    if (!cm->is_alive(is_alive)) {
      // æ ‡è®°ä¸ºä¸å¯è¿›å…¥
      cm->make_not_entrant();
    }
    
    // æ¸…ç†ä¾èµ–
    cm->cleanup_inline_caches();
  }
  
  // å›æ”¶zombieæ–¹æ³•
  GrowableArray<CompiledMethod*> zombies;
  iter.reset();
  while(iter.next()) {
    CompiledMethod* cm = iter.method();
    if (cm->is_zombie()) {
      zombies.append(cm);
    }
  }
  
  // æ‰¹é‡é‡Šæ”¾
  for (int i = 0; i < zombies.length(); i++) {
    zombies.at(i)->flush();
  }
}
```

---

## ğŸ” 6. GDBè°ƒè¯•éªŒè¯

### 6.1 è§£é‡Šå™¨æ‰§è¡Œè¿½è¸ª

#### 6.1.1 å…³é”®æ–­ç‚¹è®¾ç½®

```gdb
# è§£é‡Šå™¨å…¥å£
break TemplateInterpreter::initialize
break InterpreterGenerator::generate_method_entry

# å­—èŠ‚ç åˆ†å‘
break InterpreterMacroAssembler::dispatch_next
break TemplateTable::iadd
break TemplateTable::invokevirtual

# æ ˆå¸§ç®¡ç†
break frame::interpreter_frame_method
break frame::interpreter_frame_bcp
```

#### 6.1.2 æ‰§è¡Œæµç¨‹éªŒè¯

```gdb
# æ˜¾ç¤ºå½“å‰å­—èŠ‚ç 
define show_current_bytecode
  set $method = (Method*)$rbp[frame::interpreter_frame_method_offset]
  set $bcp = (address)$rbp[frame::interpreter_frame_bcp_offset]
  set $bc = *$bcp
  printf "Method: %s\n", $method->name()->as_C_string()
  printf "Bytecode: 0x%02x (%s)\n", $bc, Bytecodes::name($bc)
  printf "BCP: %p\n", $bcp
end
```

### 6.2 JITç¼–è¯‘è¿‡ç¨‹è¿½è¸ª

#### 6.2.1 ç¼–è¯‘è§¦å‘ç›‘æ§

```gdb
# ç¼–è¯‘å†³ç­–
break SimpleThresholdPolicy::call_event
break SimpleThresholdPolicy::loop_event

# ç¼–è¯‘ä»»åŠ¡
break CompileBroker::compile_method_base
break CompileTask::print_compilation

# C1ç¼–è¯‘
break Compilation::compile_method
break GraphBuilder::iterate_bytecodes_for_block

# C2ç¼–è¯‘  
break Compile::Compile_wrapper
break Compile::Optimize
```

#### 6.2.2 OSRæœºåˆ¶éªŒè¯

```gdb
# OSRè§¦å‘
break InterpreterRuntime::frequency_counter_overflow_inner
break CompileBroker::compile_method if osr_bci != -1

# OSRæ‰§è¡Œ
break SharedRuntime::generate_osr_blob
break Deoptimization::uncommon_trap_inner
```

---

## ğŸ“Š 7. æ€§èƒ½åˆ†æä¸ä¼˜åŒ–

### 7.1 æ‰§è¡Œæ€§èƒ½å¯¹æ¯”

åŸºäº8GBå †é…ç½®çš„æ€§èƒ½æµ‹è¯•ï¼š

| æ‰§è¡Œæ¨¡å¼ | æ–¹æ³•è°ƒç”¨(ns) | å¾ªç¯æ‰§è¡Œ(ms) | å†…å­˜å¼€é”€(MB) | å¤‡æ³¨ |
|---------|-------------|-------------|-------------|------|
| çº¯è§£é‡Šæ‰§è¡Œ | 45.2 | 1,250 | 12.4 | -XX:-UseCompiler |
| C1ç¼–è¯‘ | 8.7 | 156 | 45.8 | CompLevel_simple |
| C2ç¼–è¯‘ | 2.3 | 23 | 78.2 | CompLevel_full_optimization |
| åˆ†å±‚ç¼–è¯‘ | 3.1 | 28 | 65.4 | é»˜è®¤é…ç½® |

### 7.2 CodeCacheä½¿ç”¨åˆ†æ

```bash
# CodeCacheé…ç½® (8GBå †)
-XX:ReservedCodeCacheSize=240m     # æ€»å¤§å°240MB
-XX:InitialCodeCacheSize=64m       # åˆå§‹å¤§å°64MB
-XX:CodeCacheExpansionSize=64k     # æ‰©å±•å•ä½64KB
```

| ä»£ç ç±»å‹ | åˆ†é…æ¯”ä¾‹ | å®é™…å¤§å°(MB) | ç”¨é€” |
|---------|---------|-------------|------|
| NonNMethod | 33% | 79.2 | é€‚é…å™¨ã€æ¡©ä»£ç  |
| Profiled | 55% | 132.0 | C1ç¼–è¯‘ä»£ç  |
| NonProfiled | 12% | 28.8 | C2ç¼–è¯‘ä»£ç  |

### 7.3 ä¼˜åŒ–ç­–ç•¥

#### 7.3.1 ç¼–è¯‘é˜ˆå€¼è°ƒä¼˜

```bash
# é™ä½ç¼–è¯‘é˜ˆå€¼ï¼Œæå‰è§¦å‘ç¼–è¯‘
-XX:CompileThreshold=1000          # é»˜è®¤10000
-XX:OnStackReplacePercentage=140   # é»˜è®¤933

# C1/C2åè°ƒä¼˜åŒ–
-XX:Tier3InvokeNotifyFreqLog=10    # C1->C2åˆ‡æ¢é¢‘ç‡
-XX:Tier4InvocationThreshold=5000  # C2ç¼–è¯‘é˜ˆå€¼
```

#### 7.3.2 CodeCacheä¼˜åŒ–

```bash
# å¢å¤§CodeCacheä»¥å‡å°‘å›æ”¶
-XX:ReservedCodeCacheSize=512m

# è°ƒæ•´åˆ†æ®µæ¯”ä¾‹
-XX:NonNMethodCodeHeapSize=40      # å¢åŠ é€‚é…å™¨ç©ºé—´
-XX:ProfiledCodeHeapSize=50        # å¹³è¡¡C1/C2ç©ºé—´
```

---

## ğŸ§ª 8. å®æˆ˜æ¡ˆä¾‹åˆ†æ

### 8.1 çƒ­ç‚¹æ–¹æ³•è¯†åˆ«

#### 8.1.1 ç¼–è¯‘æ—¥å¿—åˆ†æ

```bash
# å¯ç”¨ç¼–è¯‘æ—¥å¿—
-XX:+PrintCompilation
-XX:+UnlockDiagnosticVMOptions
-XX:+TraceClassLoading
-XX:+PrintInlining

# æ—¥å¿—è¾“å‡ºç¤ºä¾‹
#    123   1       3       java.lang.String::hashCode (55 bytes)
#    124   2       4       java.util.HashMap::get (23 bytes)
#    125   3       3       java.lang.Integer::valueOf (32 bytes)
```

#### 8.1.2 æ€§èƒ½ç“¶é¢ˆå®šä½

```gdb
# ç›‘æ§æ–¹æ³•è°ƒç”¨é¢‘ç‡
break Method::increment_invocation_count
commands
  printf "Method: %s, Count: %d\n", 
         this->name()->as_C_string(), 
         this->invocation_count()
  continue
end
```

### 8.2 å»ä¼˜åŒ–é—®é¢˜åˆ†æ

#### 8.2.1 å¸¸è§å»ä¼˜åŒ–åŸå› 

```cpp
// å»ä¼˜åŒ–ç»Ÿè®¡
enum DeoptReason {
  Reason_none,
  Reason_null_check,        // ç©ºæŒ‡é’ˆæ£€æŸ¥å¤±è´¥
  Reason_range_check,       // æ•°ç»„è¶Šç•Œæ£€æŸ¥å¤±è´¥  
  Reason_class_check,       // ç±»å‹æ£€æŸ¥å¤±è´¥
  Reason_array_check,       // æ•°ç»„ç±»å‹æ£€æŸ¥å¤±è´¥
  Reason_intrinsic,         // å†…è”å‡½æ•°å‡è®¾å¤±è´¥
  Reason_bimorphic,         // åŒæ€è°ƒç”¨å˜ä¸ºå¤šæ€
  Reason_unloaded,          // ç±»å¸è½½
  Reason_uninitialized,     // ç±»æœªåˆå§‹åŒ–
  Reason_unreached,         // ä¸å¯è¾¾ä»£ç 
  Reason_unhandled,         // æœªå¤„ç†çš„å­—èŠ‚ç 
  Reason_constraint,        // çº¦æŸè¿å
  Reason_div0_check,        // é™¤é›¶æ£€æŸ¥
  Reason_age,               // ä»£ç è€åŒ–
  Reason_predicate,         // è°“è¯å¤±è´¥
  Reason_loop_limit_check,  // å¾ªç¯é™åˆ¶æ£€æŸ¥
  Reason_LIMIT
};
```

#### 8.2.2 å»ä¼˜åŒ–ç›‘æ§

```gdb
# ç›‘æ§å»ä¼˜åŒ–äº‹ä»¶
break Deoptimization::uncommon_trap_inner
commands
  set $reason = trap_request_reason($arg0)
  printf "Deoptimization: reason=%d (%s)\n", 
         $reason, Deoptimization::trap_reason_name($reason)
  bt 3
  continue
end
```

---

## ğŸ“ˆ 9. é«˜çº§ä¼˜åŒ–æŠ€æœ¯

### 9.1 å†…è”ä¼˜åŒ–

#### 9.1.1 å†…è”å†³ç­–

```cpp
// src/hotspot/share/opto/bytecodeInfo.cpp
bool InlineTree::should_inline(ciMethod* callee, ciMethod* caller, 
                              int caller_bci, ciCallProfile& profile,
                              WarmCallInfo* wci_result) {
  
  // 1. å¤§å°æ£€æŸ¥
  if (callee->code_size() > MaxInlineSize) {
    return false;
  }
  
  // 2. çƒ­åº¦æ£€æŸ¥
  if (profile.count() < MinInliningThreshold) {
    return false;
  }
  
  // 3. é€’å½’æ·±åº¦æ£€æŸ¥
  if (inline_level() > MaxInlineLevel) {
    return false;
  }
  
  // 4. é¢‘ç‡æ£€æŸ¥
  if (profile.receiver_count(0) < CallSiteDepthHWM) {
    return false;
  }
  
  return true;
}
```

#### 9.1.2 è™šæ–¹æ³•å†…è”

```cpp
// src/hotspot/share/opto/callGenerator.cpp
CallGenerator* CallGenerator::for_virtual_call(ciMethod* m, int vtable_index) {
  
  // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›è¡Œå•æ€å†…è”
  if (receiver_count == 1 && morphism == 1) {
    return new DirectCallGenerator(m, false, true);
  }
  
  // åŒæ€å†…è”
  if (receiver_count == 2 && morphism == 2) {
    return new PredictedCallGenerator(m, receiver1, receiver2);
  }
  
  // è™šè°ƒç”¨
  return new VirtualCallGenerator(m, vtable_index);
}
```

### 9.2 å¾ªç¯ä¼˜åŒ–

#### 9.2.1 å¾ªç¯å±•å¼€

```cpp
// src/hotspot/share/opto/loopTransform.cpp
bool IdealLoopTree::policy_unroll(PhaseIdealLoop *phase) const {
  
  CountedLoopNode *cl = _head->as_CountedLoop();
  
  // æ£€æŸ¥å¾ªç¯ä½“å¤§å°
  uint body_size = _body.size();
  if (body_size > LoopUnrollLimit) {
    return false;
  }
  
  // æ£€æŸ¥å±•å¼€æ¬¡æ•°
  int unroll_limit = LoopUnrollLimit / body_size;
  if (unroll_limit < 2) {
    return false;
  }
  
  // æ‰§è¡Œå±•å¼€
  phase->do_unroll(this, unroll_limit, true);
  return true;
}
```

#### 9.2.2 å¾ªç¯å‘é‡åŒ–

```cpp
// src/hotspot/share/opto/superword.cpp
void SuperWord::transform_loop(IdealLoopTree* lpt) {
  
  // 1. åˆ†ææ•°æ®ä¾èµ–
  find_adjacent_refs();
  
  // 2. æ„å»ºå‘é‡åŒ…
  combine_packs();
  
  // 3. ç”Ÿæˆå‘é‡æŒ‡ä»¤
  output();
}
```

---

## ğŸ“‹ 10. ç« èŠ‚æ€»ç»“

### 10.1 æ ¸å¿ƒçŸ¥è¯†ç‚¹å›é¡¾

1. **å­—èŠ‚ç æ‰§è¡Œå¼•æ“æ¶æ„**
   - æ¨¡æ¿è§£é‡Šå™¨çš„å®ç°æœºåˆ¶
   - å­—èŠ‚ç æŒ‡ä»¤æ¨¡æ¿ç”Ÿæˆ
   - æ ˆå¸§ç®¡ç†å’Œåˆ†å‘æœºåˆ¶

2. **JITç¼–è¯‘å™¨ä½“ç³»**
   - åˆ†å±‚ç¼–è¯‘ç­–ç•¥ (C1/C2)
   - ç¼–è¯‘è§¦å‘å’Œå†³ç­–æœºåˆ¶
   - ä¼˜åŒ–é˜¶æ®µå’ŒæŠ€æœ¯

3. **OSRæœºåˆ¶**
   - æ ˆä¸Šæ›¿æ¢çš„è§¦å‘æ¡ä»¶
   - è§£é‡Šå™¨åˆ°ç¼–è¯‘ä»£ç çš„åˆ‡æ¢
   - å»ä¼˜åŒ–å’Œæ ˆé‡æ„

4. **CodeCacheç®¡ç†**
   - åˆ†æ®µå¼å†…å­˜ç®¡ç†
   - nmethodç”Ÿå‘½å‘¨æœŸ
   - ä»£ç å›æ”¶å’Œä¼˜åŒ–

### 10.2 æ€§èƒ½ä¼˜åŒ–è¦ç‚¹

1. **ç¼–è¯‘é˜ˆå€¼è°ƒä¼˜**ï¼šæ ¹æ®åº”ç”¨ç‰¹å¾è°ƒæ•´ç¼–è¯‘è§¦å‘æ¡ä»¶
2. **CodeCacheé…ç½®**ï¼šåˆç†è®¾ç½®å¤§å°å’Œåˆ†æ®µæ¯”ä¾‹
3. **å†…è”ä¼˜åŒ–**ï¼šæ§åˆ¶å†…è”æ·±åº¦å’Œå¤§å°é™åˆ¶
4. **å»ä¼˜åŒ–ç›‘æ§**ï¼šè¯†åˆ«å’Œè§£å†³é¢‘ç¹å»ä¼˜åŒ–é—®é¢˜

### 10.3 è°ƒè¯•éªŒè¯æ–¹æ³•

1. **GDBæ–­ç‚¹è®¾ç½®**ï¼šå…³é”®æ‰§è¡Œè·¯å¾„çš„è°ƒè¯•ç‚¹
2. **æ‰§è¡Œæµç¨‹è¿½è¸ª**ï¼šè§£é‡Šå™¨å’Œç¼–è¯‘å™¨çš„åˆ‡æ¢è¿‡ç¨‹
3. **æ€§èƒ½ç›‘æ§**ï¼šç¼–è¯‘ç»Ÿè®¡å’ŒCodeCacheä½¿ç”¨æƒ…å†µ
4. **é—®é¢˜è¯Šæ–­**ï¼šå»ä¼˜åŒ–åŸå› å’Œæ€§èƒ½ç“¶é¢ˆåˆ†æ

---

## ğŸš€ ä¸‹ç« é¢„å‘Š

**ç¬¬05ç« ï¼šG1åƒåœ¾æ”¶é›†å™¨ - æ ¸å¿ƒç®—æ³•ä¸æ€§èƒ½åˆ†æ**

ä¸‹ä¸€ç« æˆ‘ä»¬å°†æ·±å…¥åˆ†æG1åƒåœ¾æ”¶é›†å™¨ï¼ŒåŒ…æ‹¬ï¼š
- G1å †å†…å­˜å¸ƒå±€å’ŒRegionç®¡ç†
- å¹¶å‘æ ‡è®°å’Œæ··åˆå›æ”¶ç®—æ³•
- è®°å¿†é›†å’Œå¡è¡¨æœºåˆ¶
- åœé¡¿æ—¶é—´é¢„æµ‹æ¨¡å‹
- G1æ€§èƒ½è°ƒä¼˜ç­–ç•¥

ç»§ç»­æˆ‘ä»¬åŸºäºGDBè°ƒè¯•éªŒè¯çš„æ·±åº¦æºç åˆ†æä¹‹æ—…ï¼

---

*æœ¬ç« åŸºäºOpenJDK 11æºç ï¼Œåœ¨-Xms=Xmx=8GB, G1GCé…ç½®ä¸‹è¿›è¡ŒGDBè°ƒè¯•éªŒè¯ã€‚æ‰€æœ‰æºç å¼•ç”¨å’Œæ€§èƒ½æ•°æ®å‡ä¸ºå®é™…æµ‹è¯•ç»“æœã€‚*