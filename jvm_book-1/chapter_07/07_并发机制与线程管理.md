# 第07章：并发机制与线程管理 - 多线程JVM深度分析

## 章节概述

本章深入分析OpenJDK 11中的并发机制和线程管理，重点研究Java线程模型、同步原语、锁优化、内存模型以及并发垃圾收集等核心技术。通过GDB调试验证，我们将深入了解多线程环境下JVM的工作原理和性能优化策略。

**标准测试环境**：
- **JVM配置**：-Xms=8GB -Xmx=8GB（初始堆=最大堆）
- **GC配置**：G1垃圾收集器，Region大小4MB
- **系统配置**：非大页，非NUMA
- **调试版本**：OpenJDK 11 slowdebug build

---

## 7.1 Java线程模型架构

### 7.1.1 线程实现模型

OpenJDK 11采用1:1线程模型，每个Java线程对应一个操作系统线程：

```cpp
// src/hotspot/share/runtime/thread.hpp
class JavaThread : public Thread {
private:
  ThreadState      _thread_state;           // 线程状态
  OSThread*        _osthread;               // 操作系统线程
  JNIEnv           _jni_environment;        // JNI环境
  
  // 线程栈相关
  address          _stack_base;             // 栈基地址
  size_t           _stack_size;             // 栈大小
  
  // 异常处理
  oop              _pending_exception;      // 待处理异常
  
  // 同步相关
  ObjectMonitor*   _current_pending_monitor; // 当前等待的监视器
  ObjectMonitor*   _current_waiting_monitor; // 当前等待中的监视器
  
public:
  enum ThreadState {
    _thread_uninitialized     =  0,         // 未初始化
    _thread_new               =  2,         // 新建
    _thread_new_trans         =  3,         // 新建转换中
    _thread_in_native         =  4,         // 本地代码中
    _thread_in_native_trans   =  5,         // 本地代码转换中
    _thread_in_vm             =  6,         // 虚拟机中
    _thread_in_vm_trans       =  7,         // 虚拟机转换中
    _thread_in_Java           =  8,         // Java代码中
    _thread_in_Java_trans     =  9,         // Java代码转换中
    _thread_blocked           = 10,         // 阻塞
    _thread_blocked_trans     = 11,         // 阻塞转换中
  };
};
```

### 7.1.2 线程创建与初始化

**线程创建过程**：
```cpp
// src/hotspot/share/runtime/thread.cpp
JavaThread::JavaThread(bool is_attaching_via_jni) : Thread() {
  initialize();
  
  // 设置线程状态
  set_thread_state(_thread_new);
  
  // 创建操作系统线程
  _osthread = new OSThread(NULL, NULL);
  
  // 初始化JNI环境
  _jni_environment.functions = &jni_NativeInterface;
  _jni_environment.reserved0 = (void*)this;
  
  // 初始化栈信息
  _stack_base = NULL;
  _stack_size = 0;
  
  // 初始化同步相关
  _current_pending_monitor = NULL;
  _current_waiting_monitor = NULL;
}
```

**线程启动流程**：
```cpp
// src/hotspot/share/runtime/thread.cpp
void JavaThread::run() {
  // 1. 线程状态转换
  ThreadStateTransition::transition_and_fence(this, _thread_new, _thread_in_vm);
  
  // 2. 执行线程主体
  thread_main_inner();
  
  // 3. 线程清理
  this->exit(false);
  delete this;
}

void JavaThread::thread_main_inner() {
  // 调用Java线程的run方法
  JavaCalls::call_virtual(&result, thread_oop, klass,
                         vmSymbols::run_method_name(),
                         vmSymbols::void_method_signature(),
                         CHECK);
}
```

### 7.1.3 线程状态管理

**状态转换机制**：
```cpp
// src/hotspot/share/runtime/threadStateTransition.hpp
class ThreadStateTransition : public StackObj {
public:
  static inline void transition(JavaThread *thread, JavaThreadState from, JavaThreadState to) {
    assert(from != _thread_in_Java || to != _thread_in_native, "use transition_from_java");
    assert(from != _thread_in_native || to != _thread_in_Java, "use transition_from_native");
    
    // 原子性状态更新
    thread->set_thread_state(to);
  }
  
  static inline void transition_and_fence(JavaThread *thread, JavaThreadState from, JavaThreadState to) {
    transition(thread, from, to);
    if (SafepointSynchronize::do_call_back()) {
      SafepointSynchronize::block(thread);
    }
  }
};
```

---

## 7.2 同步原语与锁机制

### 7.2.1 对象监视器（ObjectMonitor）

**监视器结构**：
```cpp
// src/hotspot/share/runtime/objectMonitor.hpp
class ObjectMonitor {
private:
  void*     _owner;          // 拥有者线程
  volatile intptr_t _recursions; // 重入次数
  ObjectWaiter* _EntryList;  // 入口等待队列
  ObjectWaiter* _WaitSet;    // 等待集合
  volatile int _count;       // 计数器
  volatile int _WaitSetLock; // 等待集合锁
  
public:
  void* owner() const { return _owner; }
  void set_owner(void* owner) { _owner = owner; }
  
  bool try_enter(Thread* self);
  void enter(TRAPS);
  void exit(bool not_suspended, TRAPS);
  void wait(jlong millis, bool interruptible, TRAPS);
  void notify(TRAPS);
  void notifyAll(TRAPS);
};
```

**监视器获取流程**：
```cpp
// src/hotspot/share/runtime/objectMonitor.cpp
void ObjectMonitor::enter(TRAPS) {
  Thread * const Self = THREAD;
  void * cur = Atomic::cmpxchg(Self, &_owner, (void*)NULL);
  
  if (cur == NULL) {
    // 快速路径：成功获取锁
    return;
  }
  
  if (cur == Self) {
    // 重入锁
    _recursions++;
    return;
  }
  
  // 慢速路径：需要等待
  EnterI(THREAD);
}

void ObjectMonitor::EnterI(TRAPS) {
  Thread * const Self = THREAD;
  
  // 自旋尝试获取锁
  if (TrySpin(Self) > 0) {
    return;
  }
  
  // 进入等待队列
  ObjectWaiter node(Self);
  Self->_ParkEvent->reset();
  
  // 添加到入口列表
  AddWaiter(&node);
  
  // 阻塞等待
  for (;;) {
    if (TryLock(Self) > 0) break;
    if (Self->is_suspended()) {
      Self->java_suspend_self();
    }
    Self->_ParkEvent->park();
  }
  
  // 从等待列表移除
  UnlinkAfterAcquire(Self, &node);
}
```

### 7.2.2 轻量级锁（Biased Locking & Thin Locking）

**偏向锁机制**：
```cpp
// src/hotspot/share/runtime/biasedLocking.cpp
class BiasedLocking : AllStatic {
public:
  static BiasedLockingResult revoke_and_rebias(Handle obj, bool attempt_rebias, TRAPS);
  
  enum BiasedLockingResult {
    BIAS_REVOKED,                    // 偏向撤销
    BIAS_REVOKED_AND_REBIASED,      // 撤销并重新偏向
    NOT_BIASED                       // 非偏向状态
  };
};

// 偏向锁检查
bool ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, bool attempt_rebias, TRAPS) {
  if (UseBiasedLocking) {
    if (!SafepointSynchronize::is_at_safepoint()) {
      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);
      if (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) {
        return true;
      }
    }
  }
  
  // 轻量级锁尝试
  return slow_enter(obj, lock, THREAD);
}
```

**轻量级锁实现**：
```cpp
// src/hotspot/share/runtime/synchronizer.cpp
bool ObjectSynchronizer::quick_enter(oop obj, Thread* Self, BasicLock* lock) {
  markOop mark = obj->mark();
  
  if (mark->is_neutral()) {
    // 无锁状态，尝试CAS获取
    markOop locked_mark = mark->set_unlocked();
    if (mark == obj->cas_set_mark(locked_mark, mark)) {
      return true;
    }
  } else if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {
    // 重入锁
    lock->set_displaced_header(NULL);
    return true;
  }
  
  // 膨胀为重量级锁
  return false;
}
```

### 7.2.3 重量级锁与监视器膨胀

**锁膨胀过程**：
```cpp
// src/hotspot/share/runtime/synchronizer.cpp
ObjectMonitor* ObjectSynchronizer::inflate(Thread * Self, oop object, const InflateCause cause) {
  // 快速检查是否已经膨胀
  markOop mark = object->mark();
  if (mark->has_monitor()) {
    ObjectMonitor* inf = mark->monitor();
    return inf;
  }
  
  // 分配新的监视器
  ObjectMonitor* m = omAlloc(Self);
  
  // 设置监视器属性
  m->set_header(mark);
  m->set_owner(NULL);
  m->set_object(object);
  
  // 原子性替换对象头
  markOop cmp = object->cas_set_mark(markOopDesc::encode(m), mark);
  if (cmp != mark) {
    omRelease(Self, m, true);
    continue;  // 重试
  }
  
  return m;
}
```

---

## 7.3 Java内存模型（JMM）

### 7.3.1 内存屏障实现

**内存屏障类型**：
```cpp
// src/hotspot/share/runtime/orderAccess.hpp
class OrderAccess : AllStatic {
public:
  static void     loadload();      // LoadLoad屏障
  static void     storestore();    // StoreStore屏障
  static void     loadstore();     // LoadStore屏障
  static void     storeload();     // StoreLoad屏障
  
  static void     acquire();       // 获取屏障
  static void     release();       // 释放屏障
  static void     fence();         // 全屏障
};
```

**x86平台实现**：
```cpp
// src/hotspot/os_cpu/linux_x86/orderAccess_linux_x86.hpp
inline void OrderAccess::loadload()   { acquire(); }
inline void OrderAccess::storestore()  { release(); }
inline void OrderAccess::loadstore()   { acquire(); }
inline void OrderAccess::storeload()   { fence(); }

inline void OrderAccess::acquire() {
  volatile intptr_t local_dummy;
  __asm__ volatile ("movq 0(%%rsp), %0" : "=r" (local_dummy) : : "memory");
}

inline void OrderAccess::release() {
  // x86的store-store是自动保证的
  volatile jint local_dummy = 0;
}

inline void OrderAccess::fence() {
  __asm__ volatile ("lock; addl $0,0(%%rsp)" : : : "cc", "memory");
}
```

### 7.3.2 volatile字段访问

**volatile读写实现**：
```cpp
// src/hotspot/share/oops/oop.inline.hpp
template <class T> T oopDesc::load_heap_oop_volatile(T* p) {
  T result = RawAccess<MO_VOLATILE>::oop_load(p);
  return result;
}

template <class T> void oopDesc::store_heap_oop_volatile(T* p, T v) {
  RawAccess<MO_VOLATILE>::oop_store(p, v);
}
```

**内存序语义**：
```cpp
// src/hotspot/share/runtime/atomic.hpp
template<typename T>
inline T Atomic::load_acquire(const volatile T* dest) {
  return LoadImpl<T, PlatformOrderedLoad<sizeof(T), X_ACQUIRE> >()(dest);
}

template<typename T>
inline void Atomic::store_release(volatile T* dest, T value) {
  StoreImpl<T, PlatformOrderedStore<sizeof(T), RELEASE_X> >()(dest, value);
}
```

### 7.3.3 CAS操作实现

**比较并交换**：
```cpp
// src/hotspot/share/runtime/atomic.hpp
template<typename T>
inline T Atomic::cmpxchg(T exchange_value, volatile T* dest, T compare_value, 
                        cmpxchg_memory_order order) {
  return CmpxchgImpl<T, T>()(exchange_value, dest, compare_value, order);
}

// x86平台实现
template<>
struct Atomic::CmpxchgImpl<jint, jint> {
  jint operator()(jint exchange_value, jint volatile* dest, jint compare_value,
                 cmpxchg_memory_order order) const {
    __asm__ volatile ("lock cmpxchgl %1,(%3)"
                    : "=a" (exchange_value)
                    : "r" (exchange_value), "a" (compare_value), "r" (dest)
                    : "cc", "memory");
    return exchange_value;
  }
};
```

---

## 7.4 线程本地存储（TLS）

### 7.4.1 ThreadLocal实现机制

**ThreadLocalMap结构**：
```java
// java.lang.ThreadLocal.ThreadLocalMap
static class ThreadLocalMap {
    static class Entry extends WeakReference<ThreadLocal<?>> {
        Object value;
        Entry(ThreadLocal<?> k, Object v) {
            super(k);
            value = v;
        }
    }
    
    private Entry[] table;
    private int size = 0;
    private int threshold;
    
    private void set(ThreadLocal<?> key, Object value) {
        Entry[] tab = table;
        int len = tab.length;
        int i = key.threadLocalHashCode & (len-1);
        
        // 线性探测解决冲突
        for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {
            ThreadLocal<?> k = e.get();
            if (k == key) {
                e.value = value;
                return;
            }
            if (k == null) {
                replaceStaleEntry(key, value, i);
                return;
            }
        }
        
        tab[i] = new Entry(key, value);
        int sz = ++size;
        if (!cleanSomeSlots(i, sz) && sz >= threshold)
            rehash();
    }
}
```

**JVM层面支持**：
```cpp
// src/hotspot/share/runtime/thread.hpp
class Thread : public ThreadShadow {
private:
  // 线程本地存储
  ThreadLocalStorage _tls;
  
public:
  ThreadLocalStorage* tls() { return &_tls; }
  
  // 快速访问当前线程
  static inline Thread* current() {
    return ThreadLocalStorage::thread();
  }
};
```

### 7.4.2 TLAB（Thread Local Allocation Buffer）

**TLAB结构**：
```cpp
// src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp
class ThreadLocalAllocBuffer: public CHeapObj<mtThread> {
private:
  HeapWord* _start;                    // TLAB起始地址
  HeapWord* _top;                      // 当前分配位置
  HeapWord* _pf_top;                   // 预取顶部
  HeapWord* _end;                      // TLAB结束地址
  
  size_t    _desired_size;             // 期望大小
  size_t    _refill_waste_limit;       // 重填浪费限制
  
public:
  HeapWord* allocate(size_t size) {
    invariants();
    HeapWord* obj = top();
    if (pointer_delta(end(), obj) >= size) {
      // 快速分配路径
      set_top(obj + size);
      invariants();
      return obj;
    }
    return slow_path_allocation(size);
  }
  
  void initialize(HeapWord* start, HeapWord* top, HeapWord* end) {
    set_start(start);
    set_top(top);
    set_pf_top(top);
    set_end(end);
  }
};
```

**TLAB分配流程**：
```cpp
// src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp
HeapWord* ThreadLocalAllocBuffer::slow_path_allocation(size_t size) {
  // 1. 记录浪费的空间
  size_t refill_waste = 0;
  if (top() != NULL) {
    refill_waste = pointer_delta(end(), top());
  }
  
  // 2. 退休当前TLAB
  retire_before_allocation(size);
  
  // 3. 分配新的TLAB
  size_t new_tlab_size = compute_size(size);
  if (new_tlab_size == 0) {
    return NULL;
  }
  
  // 4. 从堆中分配新TLAB
  HeapWord* new_tlab = Universe::heap()->allocate_new_tlab(new_tlab_size);
  if (new_tlab == NULL) {
    return NULL;
  }
  
  // 5. 初始化新TLAB
  initialize(new_tlab, new_tlab, new_tlab + new_tlab_size);
  
  // 6. 在新TLAB中分配对象
  return allocate(size);
}
```

---

## 7.5 安全点机制（Safepoint）

### 7.5.1 安全点同步

**安全点状态管理**：
```cpp
// src/hotspot/share/runtime/safepoint.hpp
class SafepointSynchronize : AllStatic {
private:
  enum SynchronizeState {
    _not_synchronized = 0,           // 非同步状态
    _synchronizing    = 1,           // 同步中
    _synchronized     = 2            // 已同步
  };
  
  static volatile SynchronizeState _state;
  static volatile int _waiting_to_block;   // 等待阻塞的线程数
  static int _current_jni_active_count;    // 活跃JNI线程数
  
public:
  static void begin();                     // 开始安全点
  static void end();                       // 结束安全点
  static bool is_at_safepoint() { return _state == _synchronized; }
  
  static void block(JavaThread *thread);   // 阻塞线程
  static void signal_thread_at_safepoint(); // 通知线程到达安全点
};
```

**安全点执行流程**：
```cpp
// src/hotspot/share/runtime/safepoint.cpp
void SafepointSynchronize::begin() {
  // 1. 设置同步状态
  _state = _synchronizing;
  OrderAccess::fence();
  
  // 2. 等待所有线程到达安全点
  int iterations = 0;
  while (_waiting_to_block > 0) {
    // 处理VM线程
    if (VMThread::should_terminate()) break;
    
    // 处理编译器线程
    if (iterations == 0) {
      CompileBroker::set_should_block();
    }
    
    // 等待一段时间
    os::naked_short_sleep(1);
    iterations++;
  }
  
  // 3. 进入同步状态
  _state = _synchronized;
  OrderAccess::fence();
}

void SafepointSynchronize::block(JavaThread *thread) {
  // 线程状态必须允许阻塞
  assert(thread->thread_state() != _thread_in_vm_trans, "must not be in vm transition");
  
  // 增加等待计数
  Atomic::inc(&_waiting_to_block);
  
  // 等待安全点结束
  while (is_at_safepoint()) {
    thread->safepoint_state()->handle_polling_page_exception();
  }
  
  // 减少等待计数
  Atomic::dec(&_waiting_to_block);
}
```

### 7.5.2 安全点轮询

**轮询页机制**：
```cpp
// src/hotspot/share/runtime/safepointMechanism.hpp
class SafepointMechanism : public AllStatic {
private:
  static address _polling_page;            // 轮询页地址
  
public:
  static void initialize();
  static void block_if_requested(JavaThread* thread);
  
  static bool local_poll_armed(JavaThread* thread) {
    const intptr_t poll_word = reinterpret_cast<intptr_t>(thread->get_polling_page());
    return (poll_word & poll_bit()) != 0;
  }
  
  static bool global_poll() {
    return SafepointSynchronize::do_call_back();
  }
};
```

**编译器插入轮询**：
```cpp
// src/hotspot/share/opto/parse1.cpp
void Parse::add_safepoint() {
  // 在循环回边和方法调用处插入安全点检查
  Node* chk = _gvn.transform(new SafePointNode(control(), i_o()));
  
  // 检查是否需要进入安全点
  Node* poll = make_runtime_call(RC_LEAF, OptoRuntime::safepoint_Type(),
                                CAST_FROM_FN_PTR(address, SafepointSynchronize::block),
                                "safepoint_poll", TypeRawPtr::BOTTOM);
}
```

---

## 7.6 并发垃圾收集

### 7.6.1 G1并发标记

**并发标记线程**：
```cpp
// src/hotspot/share/gc/g1/g1ConcurrentMark.hpp
class G1ConcurrentMark: public CHeapObj<mtGC> {
private:
  G1CollectedHeap* _g1h;               // G1堆引用
  G1CMTask**       _tasks;             // 标记任务数组
  uint             _max_worker_id;     // 最大工作线程ID
  
  // 并发标记位图
  G1CMBitMap       _markBitMap1;
  G1CMBitMap       _markBitMap2;
  G1CMBitMap*      _prevMarkBitMap;    // 上次标记位图
  G1CMBitMap*      _nextMarkBitMap;    // 下次标记位图
  
public:
  void concurrent_cycle_start();        // 开始并发周期
  void concurrent_cycle_end();          // 结束并发周期
  
  void mark_from_roots();              // 从根开始标记
  void concurrent_mark();              // 并发标记
  void remark();                       // 重新标记
  void cleanup();                      // 清理
};
```

**SATB队列处理**：
```cpp
// src/hotspot/share/gc/g1/g1SATBCardTableModRefBS.cpp
void G1SATBCardTableModRefBS::write_ref_field_pre_static(oop* field, oop new_val) {
  G1CollectedHeap* g1 = G1CollectedHeap::heap();
  if (g1->is_in_cset_or_humongous(new_val)) {
    // 如果新值在收集集合中，记录到SATB队列
    G1ThreadLocalData::satb_mark_queue(Thread::current()).enqueue(new_val);
  }
}

class G1SATBMarkQueueSet : public SATBMarkQueueSet {
public:
  virtual void handle_completed_buffer(BufferNode* node) {
    G1ConcurrentMark* cm = G1CollectedHeap::heap()->concurrent_mark();
    
    // 处理SATB缓冲区中的引用
    oop* buffer = reinterpret_cast<oop*>(BufferNode::make_buffer_from_node(node));
    size_t size = BufferNode::make_size_from_node(node);
    
    for (size_t i = 0; i < size; ++i) {
      oop obj = buffer[i];
      if (obj != NULL && !cm->nextMarkBitMap()->isMarked((HeapWord*)obj)) {
        cm->grayRoot(obj);
      }
    }
  }
};
```

### 7.6.2 写屏障实现

**G1写屏障**：
```cpp
// src/hotspot/share/gc/g1/g1BarrierSet.hpp
class G1BarrierSet: public CardTableModRefBS {
public:
  template <DecoratorSet decorators, typename T>
  void write_ref_field_pre(T* field) {
    if (UseG1GC) {
      G1BarrierSetRuntime::write_ref_field_pre_entry(field, thread);
    }
  }
  
  template <DecoratorSet decorators, typename T>
  void write_ref_field_post(T* field, oop new_val) {
    if (UseG1GC) {
      G1BarrierSetRuntime::write_ref_field_post_entry(field, new_val, thread);
    }
  }
};
```

**卡表更新**：
```cpp
// src/hotspot/share/gc/g1/g1CardTable.cpp
void G1CardTable::g1_mark_as_young(const MemRegion& mr) {
  jbyte *const first = byte_for(mr.start());
  jbyte *const last = byte_after(mr.last());
  
  // 将卡表项标记为年轻代
  memset(first, g1_young_gen, pointer_delta(last, first, sizeof(jbyte)));
}

inline void G1CardTable::mark_card_deferred(size_t card_index) {
  jbyte val = _byte_map[card_index];
  if (val != g1_young_gen && val != dirty_card) {
    // 原子性更新卡表
    if (val == clean_card) {
      _byte_map[card_index] = dirty_card;
    }
  }
}
```

---

## 7.7 线程调度与性能优化

### 7.7.1 工作窃取算法

**工作队列实现**：
```cpp
// src/hotspot/share/gc/shared/workgroup.hpp
template<class E, MEMFLAGS F, unsigned int N = TASKQUEUE_SIZE>
class GenericTaskQueue: public TaskQueueSuper<N, F> {
private:
  volatile uint _bottom;               // 队列底部
  volatile uint _top;                  // 队列顶部
  E _elems[N];                        // 队列元素数组
  
public:
  bool push(E t) {
    uint localBot = _bottom;
    _elems[localBot & (N-1)] = t;
    OrderAccess::release_store(&_bottom, localBot + 1);
    return true;
  }
  
  bool pop_local(E& t) {
    uint localBot = _bottom;
    if (localBot == 0) return false;
    
    localBot--;
    _bottom = localBot;
    t = _elems[localBot & (N-1)];
    
    uint localTop = _top;
    if (localBot > localTop) {
      return true;  // 成功弹出
    }
    
    // 竞争情况处理
    _bottom = localBot + 1;
    return false;
  }
  
  bool pop_global(E& t) {
    uint localTop = _top;
    uint localBot = _bottom;
    
    if (localTop >= localBot) {
      return false;  // 队列为空
    }
    
    t = _elems[localTop & (N-1)];
    return Atomic::cmpxchg(localTop + 1, &_top, localTop) == localTop;
  }
};
```

**工作窃取调度**：
```cpp
// src/hotspot/share/gc/shared/workgroup.cpp
void AbstractWorkGang::run_task(AbstractGangTask* task) {
  // 分发任务到工作线程
  for (uint i = 0; i < active_workers(); i++) {
    GangWorker* worker = gang_worker(i);
    worker->run_task(task);
  }
  
  // 等待所有任务完成
  task->set_for_termination(active_workers());
  
  // 主线程也参与工作
  task->work(0);
  
  // 等待工作线程完成
  wait_for_gang();
}

void GangWorker::loop() {
  while (!should_terminate()) {
    WorkData data = wait_for_task();
    
    if (data.task() != NULL) {
      // 执行分配的任务
      data.task()->work(data.worker_id());
      
      // 尝试窃取其他线程的工作
      steal_work(data.task(), data.worker_id());
    }
  }
}
```

### 7.7.2 NUMA感知优化

**NUMA拓扑检测**：
```cpp
// src/hotspot/share/runtime/os.hpp
class os: AllStatic {
public:
  static bool numa_has_static_binding() { return _numa_has_static_binding; }
  static bool numa_has_group_homing()  { return _numa_has_group_homing; }
  
  static int numa_get_group_id();
  static int numa_get_leaf_groups(int *ids, int size);
  static bool numa_topology_changed() { return _numa_topology_changed; }
  
  // NUMA内存分配
  static char* numa_malloc(size_t size, int node_id, char* addr);
  static void numa_free(char* addr, size_t size);
  static bool numa_interleave_memory(char* addr, size_t size);
};
```

**NUMA感知分配**：
```cpp
// src/hotspot/share/gc/parallel/psParallelCompact.cpp
void PSParallelCompact::invoke_no_policy(bool maximum_heap_compaction) {
  // 根据NUMA拓扑分配工作
  uint parallel_gc_threads = ParallelGCThreads;
  
  if (UseNUMA && parallel_gc_threads > 1) {
    // NUMA感知的线程分配
    for (uint i = 0; i < parallel_gc_threads; i++) {
      int node_id = i % os::numa_get_groups_num();
      os::numa_make_local((char*)_space_info[i].new_top(), 
                         _space_info[i].space()->capacity_in_bytes(), 
                         node_id);
    }
  }
}
```

---

## 7.8 死锁检测与预防

### 7.8.1 死锁检测算法

**死锁检测器**：
```cpp
// src/hotspot/share/runtime/deadlockDetector.hpp
class DeadlockDetector : AllStatic {
public:
  static bool detect_deadlock(JavaThread* thread);
  static void print_deadlock(JavaThread* thread);
  
private:
  static bool find_deadlock_threads(ConcurrentLocksDump* concurrent_locks,
                                   DeadlockCycle* deadlocks);
  static int get_owner_thread_id(ObjectMonitor* monitor, JavaThread* owner);
};
```

**等待图构建**：
```cpp
// src/hotspot/share/services/threadService.cpp
ThreadDumpResult* ThreadService::dump_stack_traces(GrowableArray<instanceHandle>* threads,
                                                   int num_threads,
                                                   TRAPS) {
  // 构建线程等待图
  for (int i = 0; i < num_threads; i++) {
    JavaThread* jt = java_lang_Thread::thread(threads->at(i)());
    
    if (jt != NULL) {
      // 检查线程等待的监视器
      ObjectMonitor* waiting_monitor = jt->current_waiting_monitor();
      ObjectMonitor* pending_monitor = jt->current_pending_monitor();
      
      if (waiting_monitor != NULL) {
        // 记录等待关系
        record_waiting_relationship(jt, waiting_monitor);
      }
      
      if (pending_monitor != NULL) {
        // 记录阻塞关系
        record_blocking_relationship(jt, pending_monitor);
      }
    }
  }
  
  // 检测循环依赖
  return detect_deadlock_cycles();
}
```

### 7.8.2 锁排序策略

**全局锁排序**：
```cpp
// src/hotspot/share/runtime/mutexLocker.hpp
class MutexLocker: public StackObj {
private:
  Monitor* _mutex;
  
public:
  MutexLocker(Monitor* mutex, bool no_safepoint_check = false) : _mutex(mutex) {
    if (_mutex != NULL) {
      // 检查锁排序
      assert_lock_strong(_mutex);
      _mutex->lock_without_safepoint_check();
    }
  }
  
  ~MutexLocker() {
    if (_mutex != NULL) {
      _mutex->unlock();
    }
  }
};

// 锁层次检查
void assert_lock_strong(Monitor* lock) {
  if (lock->rank() != Mutex::special) {
    if (Thread::current()->is_VM_thread() || 
        Thread::current()->is_ConcurrentGC_thread()) {
      // VM线程和并发GC线程有特殊权限
      return;
    }
    
    // 检查锁排序
    Monitor* locks_owned = Thread::current()->owned_locks();
    while (locks_owned != NULL) {
      assert(locks_owned->rank() < lock->rank(), "lock ordering violation");
      locks_owned = locks_owned->next();
    }
  }
}
```

---

## 7.9 性能监控与调优

### 7.9.1 线程状态监控

**JFR事件记录**：
```cpp
// src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp
void JfrThreadState::serialize(JfrCheckpointWriter& writer) {
  writer.write_count(java_lang_Thread::NEW);
  writer.write("NEW");
  
  writer.write_count(java_lang_Thread::RUNNABLE);
  writer.write("RUNNABLE");
  
  writer.write_count(java_lang_Thread::BLOCKED);
  writer.write("BLOCKED");
  
  writer.write_count(java_lang_Thread::WAITING);
  writer.write("WAITING");
  
  writer.write_count(java_lang_Thread::TIMED_WAITING);
  writer.write("TIMED_WAITING");
  
  writer.write_count(java_lang_Thread::TERMINATED);
  writer.write("TERMINATED");
}
```

**线程统计信息**：
```cpp
// src/hotspot/share/services/threadService.hpp
class ThreadService : public AllStatic {
public:
  static int get_live_thread_count();
  static int get_peak_thread_count();
  static long get_total_thread_count();
  
  static void get_thread_info_array_with_stack_trace(typeArrayHandle ids,
                                                     int maxDepth,
                                                     bool infoOnly,
                                                     objArrayHandle result,
                                                     TRAPS);
  
  // 死锁检测
  static objArrayHandle find_deadlocks(bool object_monitors_only, TRAPS);
  static objArrayHandle find_deadlocked_threads(TRAPS);
};
```

### 7.9.2 锁竞争分析

**锁统计收集**：
```cpp
// src/hotspot/share/runtime/objectMonitor.cpp
void ObjectMonitor::enter_for_with_contention_mark(TRAPS) {
  // 记录锁竞争事件
  if (JvmtiExport::should_post_monitor_contended_enter()) {
    JvmtiExport::post_monitor_contended_enter(jt, this);
  }
  
  // 更新竞争统计
  if (ObjectMonitor::_sync_ContendedLockAttempts != NULL) {
    ObjectMonitor::_sync_ContendedLockAttempts->inc();
  }
  
  // 记录等待时间
  jlong start_time = os::javaTimeNanos();
  enter(THREAD);
  jlong end_time = os::javaTimeNanos();
  
  // 更新等待时间统计
  if (ObjectMonitor::_sync_Parks != NULL) {
    ObjectMonitor::_sync_Parks->inc();
  }
}
```

---

## 7.10 实验验证与性能分析

### 7.10.1 线程创建与切换开销

通过GDB调试验证线程管理开销：

```gdb
# 设置线程相关断点
break JavaThread::JavaThread
break JavaThread::run
break Thread::start

# 监控线程状态转换
watch JavaThread::_thread_state
break ThreadStateTransition::transition

# 跟踪线程调度
break os::pd_start_thread
```

### 7.10.2 锁性能验证

验证不同锁机制的性能：

```gdb
# 偏向锁相关断点
break BiasedLocking::revoke_and_rebias
break ObjectSynchronizer::fast_enter

# 轻量级锁断点
break ObjectSynchronizer::quick_enter
break ObjectSynchronizer::slow_enter

# 重量级锁断点
break ObjectSynchronizer::inflate
break ObjectMonitor::enter
```

### 7.10.3 内存屏障验证

验证内存屏障的插入和执行：

```gdb
# 内存屏障断点
break OrderAccess::fence
break OrderAccess::acquire
break OrderAccess::release

# volatile访问断点
break oopDesc::load_heap_oop_volatile
break oopDesc::store_heap_oop_volatile
```

---

## 7.11 并发编程最佳实践

### 7.11.1 锁优化策略

**锁粒度优化**：
1. **细粒度锁**：减少锁竞争范围
2. **读写锁**：区分读写操作
3. **无锁算法**：使用CAS操作

**锁消除优化**：
```java
// JIT编译器会自动消除不必要的同步
public void eliminateSync() {
    StringBuffer sb = new StringBuffer();  // 局部对象
    sb.append("Hello");                    // 同步会被消除
    sb.append(" World");
}
```

### 7.11.2 内存模型应用

**正确使用volatile**：
```java
public class VolatileExample {
    private volatile boolean flag = false;
    private int data = 0;
    
    public void writer() {
        data = 42;        // 1
        flag = true;      // 2，volatile写
    }
    
    public void reader() {
        if (flag) {       // 3，volatile读
            int value = data; // 4，保证能看到42
        }
    }
}
```

### 7.11.3 线程安全设计

**不可变对象**：
```java
public final class ImmutablePoint {
    private final int x;
    private final int y;
    
    public ImmutablePoint(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    // 只提供getter方法
    public int getX() { return x; }
    public int getY() { return y; }
}
```

---

## 7.12 故障诊断与调试

### 7.12.1 常见并发问题

1. **死锁**：循环等待资源
2. **活锁**：线程持续重试但无法进展
3. **饥饿**：线程长期无法获得资源
4. **竞态条件**：多线程访问共享数据

### 7.12.2 调试工具使用

**jstack分析**：
```bash
# 生成线程转储
jstack <pid> > threads.dump

# 分析死锁
grep -A 10 "Found deadlock" threads.dump
```

**JFR监控**：
```bash
# 启用JFR记录
java -XX:+FlightRecorder \
     -XX:StartFlightRecording=duration=60s,filename=app.jfr \
     Application

# 分析线程事件
jfr print --events JavaMonitorEnter,JavaMonitorWait app.jfr
```

---

## 7.13 章节总结

本章深入分析了OpenJDK 11中的并发机制和线程管理，主要包括：

### 7.13.1 核心技术要点

1. **线程模型**：
   - 1:1线程映射模型
   - 线程状态管理和转换
   - 线程本地存储机制

2. **同步机制**：
   - 对象监视器和锁膨胀
   - 偏向锁、轻量级锁、重量级锁
   - 内存屏障和volatile语义

3. **并发优化**：
   - 工作窃取算法
   - NUMA感知优化
   - 锁消除和锁粗化

### 7.13.2 性能优化策略

1. **锁优化**：选择合适的锁粒度和类型
2. **内存模型**：正确使用volatile和同步
3. **线程管理**：合理配置线程池和调度

### 7.13.3 实际应用价值

通过本章的学习，读者可以：
- 理解JVM并发机制的实现原理
- 掌握多线程性能优化的方法
- 具备并发问题的诊断和解决能力

并发机制是现代JVM的核心特性，深入理解其实现对于开发高性能、高并发的Java应用具有重要意义。下一章我们将继续分析JVM的其他重要机制。

---

**注意**：本章所有分析基于标准测试环境（-Xms=8GB -Xmx=8GB, G1GC, 非大页, 非NUMA），确保实验结果的一致性和可重现性。