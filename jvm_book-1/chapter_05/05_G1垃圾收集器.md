# ç¬¬05ç« ï¼šG1åƒåœ¾æ”¶é›†å™¨ - æ ¸å¿ƒç®—æ³•ä¸æ€§èƒ½åˆ†æ

## ğŸ“– ç« èŠ‚æ¦‚è¿°

æœ¬ç« æ·±å…¥åˆ†æHotSpot VMçš„G1åƒåœ¾æ”¶é›†å™¨ï¼ŒåŸºäº**-Xms=Xmx=8GB, éå¤§é¡µ, éNUMA, G1GC**çš„æ ‡å‡†é…ç½®ï¼Œé€šè¿‡GDBè°ƒè¯•éªŒè¯G1çš„æ ¸å¿ƒç®—æ³•å’Œæ€§èƒ½ç‰¹å¾ã€‚æˆ‘ä»¬å°†ä»æºç å±‚é¢å‰–æG1çš„Regionç®¡ç†ã€å¹¶å‘æ ‡è®°ã€æ··åˆå›æ”¶ï¼Œä»¥åŠåœé¡¿æ—¶é—´é¢„æµ‹æ¨¡å‹ã€‚

### ğŸ¯ å­¦ä¹ ç›®æ ‡

- æ·±å…¥ç†è§£G1åƒåœ¾æ”¶é›†å™¨çš„è®¾è®¡ç†å¿µå’Œæ¶æ„
- æŒæ¡G1 Regionç®¡ç†å’Œå†…å­˜å¸ƒå±€æœºåˆ¶
- åˆ†æå¹¶å‘æ ‡è®°å’Œæ··åˆå›æ”¶çš„å®Œæ•´ç®—æ³•
- é€šè¿‡GDBéªŒè¯è®°å¿†é›†å’Œå¡è¡¨çš„å·¥ä½œåŸç†
- ç†è§£G1åœé¡¿æ—¶é—´é¢„æµ‹å’Œè°ƒä¼˜ç­–ç•¥

### ğŸ”§ å®éªŒç¯å¢ƒ

```bash
# æ ‡å‡†JVMé…ç½® (8GBå † = 2048ä¸ª4MB Region)
-Xms8g -Xmx8g          # 8GBå †å†…å­˜
-XX:+UseG1GC           # G1åƒåœ¾æ”¶é›†å™¨
-XX:MaxGCPauseMillis=200  # ç›®æ ‡åœé¡¿æ—¶é—´200ms
-XX:G1HeapRegionSize=4m   # Regionå¤§å°4MB
-XX:+UnlockExperimentalVMOptions
-XX:+UseG1GC
-XX:+PrintGC
-XX:+PrintGCDetails
```

---

## ğŸ—ï¸ 1. G1åƒåœ¾æ”¶é›†å™¨æ¶æ„

### 1.1 G1è®¾è®¡ç†å¿µ

G1 (Garbage First) æ˜¯ä¸€ä¸ªä½å»¶è¿Ÿçš„åƒåœ¾æ”¶é›†å™¨ï¼Œä¸“ä¸ºå¤§å †å†…å­˜è®¾è®¡ï¼š

```cpp
// src/hotspot/share/gc/g1/g1CollectedHeap.hpp
class G1CollectedHeap : public CollectedHeap {
private:
  // G1æ ¸å¿ƒç»„ä»¶
  G1HeapRegionManager* _hrm;           // Regionç®¡ç†å™¨
  G1ConcurrentMark*    _cm;            // å¹¶å‘æ ‡è®°
  G1Policy*            _policy;        // GCç­–ç•¥
  G1RemSet*            _rem_set;       // è®°å¿†é›†
  
  // Regionç›¸å…³
  uint                 _max_regions;   // æœ€å¤§Regionæ•°é‡
  HeapRegion**         _regions;       // Regionæ•°ç»„
  
  // GCç»Ÿè®¡
  G1GCPhaseTimes*      _phase_times;   // é˜¶æ®µæ—¶é—´ç»Ÿè®¡
  G1Analytics*         _analytics;     // æ€§èƒ½åˆ†æ
  
public:
  // åˆå§‹åŒ–G1å †
  jint initialize();
  
  // æ‰§è¡ŒGC
  void collect(GCCause::Cause cause);
  
  // Regionç®¡ç†
  HeapRegion* new_region(size_t word_size, bool is_old, bool do_expand);
  void retire_region(HeapRegion* hr, size_t allocated_bytes);
};
```

#### 1.1.1 åŸºäº8GBå †çš„Regioné…ç½®

```cpp
// src/hotspot/share/gc/g1/g1HeapRegionManager.cpp
void G1HeapRegionManager::initialize(G1RegionToSpaceMapper* heap_storage,
                                   G1RegionToSpaceMapper* prev_bitmap,
                                   G1RegionToSpaceMapper* next_bitmap,
                                   G1RegionToSpaceMapper* bot,
                                   G1RegionToSpaceMapper* cardtable,
                                   G1RegionToSpaceMapper* card_counts) {
  
  // 8GBå †é…ç½®è®¡ç®—
  size_t heap_size = 8ULL * G;  // 8GB
  size_t region_size = G1HeapRegionSize;  // 4MB
  
  // Regionæ•°é‡ = 8GB / 4MB = 2048
  _max_length = (uint)(heap_size / region_size);
  
  log_info(gc, heap)("G1 Region Configuration:");
  log_info(gc, heap)("  Heap Size: " SIZE_FORMAT "MB", heap_size / M);
  log_info(gc, heap)("  Region Size: " SIZE_FORMAT "MB", region_size / M);
  log_info(gc, heap)("  Max Regions: %u", _max_length);
  
  // åˆ†é…Regionæ•°ç»„
  _regions = NEW_C_HEAP_ARRAY(HeapRegion*, _max_length, mtGC);
  
  // åˆå§‹åŒ–æ¯ä¸ªRegion
  for (uint i = 0; i < _max_length; i++) {
    HeapWord* bottom = heap_storage->reserved().start() + i * region_size;
    HeapWord* end = bottom + region_size;
    
    _regions[i] = new HeapRegion(i, bot, cardtable, bottom, end);
  }
}
```

### 1.2 Regionç±»å‹å’ŒçŠ¶æ€

G1å°†å †å†…å­˜åˆ’åˆ†ä¸ºå¤šä¸ªRegionï¼Œæ¯ä¸ªRegionæœ‰ä¸åŒçš„ç±»å‹ï¼š

```cpp
// src/hotspot/share/gc/g1/heapRegionType.hpp
class HeapRegionType VALUE_OBJ_CLASS_SPEC {
public:
  enum Tag {
    // åŸºæœ¬ç±»å‹
    FreeTag,          // ç©ºé—²Region
    YoungTag,         // å¹´è½»ä»£Region
    HumongousTag,     // å¤§å¯¹è±¡Region
    PinnedTag,        // å›ºå®šRegion
    OldTag,           // è€å¹´ä»£Region
    
    // å¹´è½»ä»£å­ç±»å‹
    EdenTag,          // EdenåŒº
    SurvivorTag,      // SurvivoråŒº
    
    // å¤§å¯¹è±¡å­ç±»å‹
    StartsHumongousTag,    // å¤§å¯¹è±¡èµ·å§‹Region
    ContinuesHumongousTag, // å¤§å¯¹è±¡ç»§ç»­Region
    
    // è€å¹´ä»£å­ç±»å‹
    OldMask = OldTag
  };
  
private:
  Tag _tag;
  
public:
  // ç±»å‹æ£€æŸ¥
  bool is_free() const { return _tag == FreeTag; }
  bool is_young() const { return (_tag & YoungTag) != 0; }
  bool is_eden() const { return _tag == EdenTag; }
  bool is_survivor() const { return _tag == SurvivorTag; }
  bool is_old() const { return (_tag & OldTag) != 0; }
  bool is_humongous() const { return (_tag & HumongousTag) != 0; }
};
```

#### 1.2.1 RegionçŠ¶æ€è½¬æ¢

```cpp
// src/hotspot/share/gc/g1/heapRegion.cpp
void HeapRegion::set_eden() {
  report_region_type_change(G1HeapRegionTraceType::Eden);
  _type.set_eden();
  _rem_set->clear_locked();
}

void HeapRegion::set_survivor() {
  report_region_type_change(G1HeapRegionTraceType::Survivor);
  _type.set_survivor();
}

void HeapRegion::set_old() {
  report_region_type_change(G1HeapRegionTraceType::Old);
  _type.set_old();
}

void HeapRegion::set_free() {
  report_region_type_change(G1HeapRegionTraceType::Free);
  _type.set_free();
  _rem_set->clear_locked();
  zero_marked_bytes();
  init_top_at_mark_start();
}
```

---

## ğŸ”„ 2. å¹¶å‘æ ‡è®°ç®—æ³•

### 2.1 å¹¶å‘æ ‡è®°æ¦‚è¿°

G1çš„å¹¶å‘æ ‡è®°é‡‡ç”¨SATB (Snapshot At The Beginning) ç®—æ³•ï¼š

```cpp
// src/hotspot/share/gc/g1/g1ConcurrentMark.hpp
class G1ConcurrentMark: public CHeapObj<mtGC> {
private:
  G1CollectedHeap*   _g1h;              // G1å †å¼•ç”¨
  G1CMBitMap*        _mark_bitmap;      // æ ‡è®°ä½å›¾
  G1CMBitMap*        _prev_mark_bitmap; // ä¸Šæ¬¡æ ‡è®°ä½å›¾
  
  // å¹¶å‘æ ‡è®°çº¿ç¨‹
  G1ConcurrentMarkThread* _cm_thread;
  
  // SATBé˜Ÿåˆ—
  SATBMarkQueueSet   _satb_mark_queue_set;
  
  // æ ‡è®°æ ˆ
  G1CMMarkStack      _mark_stack;
  
  // ç»Ÿè®¡ä¿¡æ¯
  size_t             _marked_bytes;     // å·²æ ‡è®°å­—èŠ‚æ•°
  
public:
  // å¯åŠ¨å¹¶å‘æ ‡è®°
  void concurrent_mark_cycle_start();
  
  // æ‰§è¡Œæ ‡è®°
  void mark_from_roots();
  
  // å®Œæˆæ ‡è®°
  void concurrent_mark_cycle_end();
  
  // æ¸…ç†é˜¶æ®µ
  void cleanup();
};
```

#### 2.1.1 æ ‡è®°ä½å›¾ç®¡ç†

```cpp
// src/hotspot/share/gc/g1/g1CMBitMap.cpp
G1CMBitMap::G1CMBitMap(size_t heap_size, G1RegionToSpaceMapper* storage) :
  _bm(storage->reserved(), heap_size >> CardTable::card_shift) {
  
  // 8GBå †çš„ä½å›¾å¤§å°è®¡ç®—
  // æ¯ä¸ªå¯¹è±¡8å­—èŠ‚å¯¹é½ï¼Œéœ€è¦ 8GB / 8 = 1GB ä¸ªä½
  // å®é™…ä½å›¾å¤§å° = 1GB / 8 = 128MB
  
  log_info(gc, heap)("G1 Mark Bitmap Configuration:");
  log_info(gc, heap)("  Heap Size: " SIZE_FORMAT "MB", heap_size / M);
  log_info(gc, heap)("  Bitmap Size: " SIZE_FORMAT "MB", 
                    _bm.size_in_bytes() / M);
}

bool G1CMBitMap::mark(oop obj) {
  HeapWord* addr = (HeapWord*)obj;
  return _bm.par_set_bit(addr_to_bit(addr));
}

bool G1CMBitMap::is_marked(oop obj) const {
  HeapWord* addr = (HeapWord*)obj;
  return _bm.at(addr_to_bit(addr));
}
```

#### 2.1.2 SATBé˜Ÿåˆ—å¤„ç†

```cpp
// src/hotspot/share/gc/g1/satbMarkQueue.cpp
void SATBMarkQueue::handle_completed_buffer() {
  BufferNode* node = _buf;
  size_t index = _index;
  size_t size = buffer_size();
  
  // å¤„ç†SATBç¼“å†²åŒºä¸­çš„å¼•ç”¨
  for (size_t i = index; i < size; ++i) {
    void** p = &node->_buffer[i];
    oop obj = oop(*p);
    
    if (obj != NULL && _cm->mark_in_next_bitmap(obj)) {
      // æ ‡è®°å¯¹è±¡å¹¶åŠ å…¥æ ‡è®°æ ˆ
      _cm->mark_stack_push(obj);
    }
  }
}
```

### 2.2 æ ¹æ‰«æå’Œå¯¹è±¡éå†

#### 2.2.1 æ ¹æ‰«æå®ç°

```cpp
// src/hotspot/share/gc/g1/g1RootProcessor.cpp
void G1RootProcessor::evacuate_roots(G1ParScanThreadState* pss, uint worker_i) {
  
  // 1. æ‰«æJavaçº¿ç¨‹æ ˆ
  _process_strong_tasks.all_tasks();
  
  // 2. æ‰«æJNIå…¨å±€å¼•ç”¨
  JNIHandles::oops_do(&roots_closure);
  
  // 3. æ‰«æç³»ç»Ÿå­—å…¸
  SystemDictionary::oops_do(&roots_closure);
  
  // 4. æ‰«æå­—ç¬¦ä¸²è¡¨
  StringTable::oops_do(&roots_closure);
  
  // 5. æ‰«æä»£ç ç¼“å­˜
  CodeBlobToOopClosure code_closure(&roots_closure, true);
  CodeCache::blobs_do(&code_closure);
}
```

#### 2.2.2 å¯¹è±¡å›¾éå†

```cpp
// src/hotspot/share/gc/g1/g1ConcurrentMark.cpp
void G1ConcurrentMark::mark_from_roots() {
  
  // å¹¶è¡Œæ ‡è®°å·¥ä½œçº¿ç¨‹
  uint active_workers = MAX2(1U, parallel_marking_threads());
  
  G1CMConcurrentMarkingTask marking_task(this);
  _parallel_workers->run_task(&marking_task, active_workers);
}

void G1CMTask::do_marking_step(double time_target_ms) {
  
  while (!has_aborted()) {
    oop obj;
    
    // ä»æ ‡è®°æ ˆè·å–å¯¹è±¡
    if (_cm->try_stealing(_worker_id, &_hash_seed, obj) ||
        _mark_stack_local.pop_local(obj)) {
      
      // æ‰«æå¯¹è±¡çš„å¼•ç”¨å­—æ®µ
      obj->oop_iterate(&_cm_oop_closure);
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      ++_calls;
      _elapsed_time_ms += (os::elapsedTime() - start_time_ms);
    } else {
      break; // æ²¡æœ‰æ›´å¤šå¯¹è±¡éœ€è¦å¤„ç†
    }
  }
}
```

---

## ğŸ§¹ 3. åƒåœ¾å›æ”¶ç®—æ³•

### 3.1 å¹´è½»ä»£å›æ”¶ (Young GC)

å¹´è½»ä»£å›æ”¶é‡‡ç”¨å¤åˆ¶ç®—æ³•ï¼Œå›æ”¶Edenå’ŒSurvivoråŒºï¼š

```cpp
// src/hotspot/share/gc/g1/g1YoungCollector.cpp
void G1YoungCollector::collect() {
  
  G1CollectorState* collector_state = _g1h->collector_state();
  
  // 1. å‡†å¤‡é˜¶æ®µ
  pre_evacuate_collection_set();
  
  // 2. æ ¹æ‰«æ
  evacuate_initial_collection_set();
  
  // 3. å¯¹è±¡å¤åˆ¶
  evacuate_optional_collection_set();
  
  // 4. åå¤„ç†
  post_evacuate_collection_set();
  
  // 5. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
  record_collection_pause_end();
}
```

#### 3.1.1 å¯¹è±¡å¤åˆ¶å’Œæ™‹å‡

```cpp
// src/hotspot/share/gc/g1/g1ParScanThreadState.cpp
oop G1ParScanThreadState::copy_to_survivor_space(InCSetState const state,
                                                oop const old,
                                                markOop const old_mark) {
  
  const size_t word_sz = old->size();
  HeapRegion* const from_region = _g1h->heap_region_containing(old);
  
  // å†³å®šç›®æ ‡åŒºåŸŸ
  InCSetState dest_state = next_state(state, old_mark, age);
  HeapRegion* const to_region = _g1h->heap_region_containing(obj_ptr);
  
  if (dest_state.is_young()) {
    // å¤åˆ¶åˆ°SurvivoråŒº
    obj_ptr = _survivor_allocator->allocate(word_sz);
  } else {
    // æ™‹å‡åˆ°è€å¹´ä»£
    obj_ptr = _old_allocator->allocate(word_sz);
  }
  
  if (obj_ptr == NULL) {
    // åˆ†é…å¤±è´¥ï¼Œè§¦å‘Full GC
    _g1h->handle_evacuation_failure_par(this, old);
    return old;
  }
  
  // å¤åˆ¶å¯¹è±¡å†…å®¹
  Copy::aligned_disjoint_words((HeapWord*)old, obj_ptr, word_sz);
  
  // æ›´æ–°å¯¹è±¡å¤´
  oop obj = oop(obj_ptr);
  obj->set_mark_raw(old_mark);
  
  return obj;
}
```

### 3.2 æ··åˆå›æ”¶ (Mixed GC)

æ··åˆå›æ”¶åŒæ—¶å›æ”¶å¹´è½»ä»£å’Œéƒ¨åˆ†è€å¹´ä»£Regionï¼š

```cpp
// src/hotspot/share/gc/g1/g1Policy.cpp
void G1Policy::record_collection_pause_start(double start_time_sec) {
  
  // å†³å®šæ˜¯å¦æ‰§è¡Œæ··åˆå›æ”¶
  if (_collector_state->in_marking_window() && 
      _analytics->predict_reclaimable_bytes() > G1HeapWastePercent) {
    
    // é€‰æ‹©è€å¹´ä»£Regionè¿›è¡Œå›æ”¶
    select_collection_set_candidates();
    
    _collector_state->set_mixed_gc_start();
  }
}

void G1Policy::select_collection_set_candidates() {
  
  // æŒ‰åƒåœ¾å¯†åº¦æ’åºè€å¹´ä»£Region
  _collection_set->candidates()->sort_by_efficiency();
  
  uint num_regions = 0;
  double predicted_time_ms = 0.0;
  
  for (HeapRegion* hr : *_collection_set->candidates()) {
    
    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡åœé¡¿æ—¶é—´ç›®æ ‡
    double region_time = predict_region_elapsed_time_ms(hr);
    if (predicted_time_ms + region_time > _max_pause_time_ms) {
      break;
    }
    
    // æ·»åŠ åˆ°å›æ”¶é›†åˆ
    _collection_set->add_old_region(hr);
    predicted_time_ms += region_time;
    num_regions++;
    
    if (num_regions >= G1MixedGCCountTarget) {
      break;
    }
  }
}
```

### 3.3 Full GCå®ç°

å½“å…¶ä»–å›æ”¶æ–¹å¼æ— æ³•æ»¡è¶³åˆ†é…éœ€æ±‚æ—¶ï¼Œè§¦å‘Full GCï¼š

```cpp
// src/hotspot/share/gc/g1/g1FullCollector.cpp
void G1FullCollector::collect() {
  
  // Phase 1: æ ‡è®°å­˜æ´»å¯¹è±¡
  {
    GCTraceTime(Info, gc, phases) info("Phase 1: Mark live objects", _scope->timer());
    mark_live_objects();
  }
  
  // Phase 2: å‡†å¤‡å‹ç¼©
  {
    GCTraceTime(Info, gc, phases) info("Phase 2: Prepare for compaction", _scope->timer());
    prepare_compaction();
  }
  
  // Phase 3: è°ƒæ•´å¼•ç”¨
  {
    GCTraceTime(Info, gc, phases) info("Phase 3: Adjust pointers", _scope->timer());
    adjust_pointers();
  }
  
  // Phase 4: å‹ç¼©å †
  {
    GCTraceTime(Info, gc, phases) info("Phase 4: Compact heap", _scope->timer());
    compact_heap();
  }
}
```

---

## ğŸ“Š 4. è®°å¿†é›†å’Œå¡è¡¨

### 4.1 è®°å¿†é›†æ¶æ„

è®°å¿†é›†ç”¨äºè·Ÿè¸ªè·¨Regionå¼•ç”¨ï¼Œæ”¯æŒå¢é‡å›æ”¶ï¼š

```cpp
// src/hotspot/share/gc/g1/g1RemSet.hpp
class G1RemSet: public CHeapObj<mtGC> {
private:
  G1CollectedHeap* _g1h;
  
  // å¡è¡¨
  G1CardTable*     _ct;
  
  // çƒ­å¡ç¼“å­˜
  G1HotCardCache*  _hot_card_cache;
  
  // å¹¶å‘ç²¾åŒ–çº¿ç¨‹
  G1ConcurrentRefineThread** _crt;
  
public:
  // æ‰«æè®°å¿†é›†
  void scan_rem_set(G1ParScanThreadState* pss,
                   uint worker_i,
                   G1GCPhaseTimes* phase_times);
  
  // æ›´æ–°è®°å¿†é›†
  void refine_card_concurrently(jbyte* card_ptr,
                              uint worker_i);
};
```

#### 4.1.1 å¡è¡¨å®ç°

```cpp
// src/hotspot/share/gc/g1/g1CardTable.cpp
void G1CardTable::g1_mark_as_young(const MemRegion& mr) {
  jbyte* const first = byte_for(mr.start());
  jbyte* const last = byte_after(mr.last());
  
  // æ ‡è®°å¡ç‰‡ä¸ºå¹´è½»ä»£
  memset(first, g1_young_gen, last - first);
}

bool G1CardTable::mark_card_deferred(size_t card_index) {
  jbyte val = _byte_map[card_index];
  
  // æ£€æŸ¥å¡ç‰‡çŠ¶æ€
  if (val == dirty_card_val()) {
    _byte_map[card_index] = deferred_card_val();
    return true;
  }
  
  return false;
}
```

#### 4.1.2 å¹¶å‘ç²¾åŒ–

```cpp
// src/hotspot/share/gc/g1/g1ConcurrentRefineThread.cpp
void G1ConcurrentRefineThread::run_service() {
  
  while (!should_terminate()) {
    
    // ç­‰å¾…ç²¾åŒ–å·¥ä½œ
    wait_for_completed_buffers();
    
    if (should_terminate()) {
      break;
    }
    
    // å¤„ç†è„å¡ç¼“å†²åŒº
    size_t buffers_processed = 0;
    DirtyCardQueueSet& dcqs = G1BarrierSet::dirty_card_queue_set();
    
    while (dcqs.apply_closure_during_gc(_refine_closure, this)) {
      buffers_processed++;
      
      if (buffers_processed >= _deactivation_threshold) {
        break;
      }
    }
  }
}
```

### 4.2 å†™å±éšœå®ç°

G1ä½¿ç”¨å†™å±éšœç»´æŠ¤è®°å¿†é›†çš„ä¸€è‡´æ€§ï¼š

```cpp
// src/hotspot/share/gc/g1/g1BarrierSet.cpp
void G1BarrierSet::write_ref_field_post(void* field, oop new_val) {
  
  if (new_val == NULL) {
    return;
  }
  
  // è·å–å­—æ®µå’Œæ–°å€¼çš„Region
  HeapRegion* field_hr = _g1->heap_region_containing(field);
  HeapRegion* new_val_hr = _g1->heap_region_containing(new_val);
  
  // æ£€æŸ¥æ˜¯å¦ä¸ºè·¨Regionå¼•ç”¨
  if (field_hr != new_val_hr) {
    
    // è·å–å¡ç‰‡åœ°å€
    jbyte* card_ptr = _card_table->byte_for(field);
    
    // æ ‡è®°å¡ç‰‡ä¸ºè„
    if (*card_ptr != G1CardTable::dirty_card_val()) {
      *card_ptr = G1CardTable::dirty_card_val();
      
      // åŠ å…¥ç²¾åŒ–é˜Ÿåˆ—
      _dirty_card_queue_set.enqueue(card_ptr);
    }
  }
}
```

---

## â±ï¸ 5. åœé¡¿æ—¶é—´é¢„æµ‹æ¨¡å‹

### 5.1 æ€§èƒ½åˆ†ææ¡†æ¶

G1ä½¿ç”¨å¤æ‚çš„åˆ†ææ¨¡å‹é¢„æµ‹GCåœé¡¿æ—¶é—´ï¼š

```cpp
// src/hotspot/share/gc/g1/g1Analytics.hpp
class G1Analytics: public CHeapObj<mtGC> {
private:
  // å†å²æ•°æ®
  TruncatedSeq* _recent_gc_times_ms;
  TruncatedSeq* _concurrent_mark_remark_times_ms;
  TruncatedSeq* _concurrent_mark_cleanup_times_ms;
  
  // å›æ”¶é¢„æµ‹
  TruncatedSeq* _alloc_rate_ms_seq;
  TruncatedSeq* _prev_collection_pause_end_ms;
  
  // Regionç›¸å…³é¢„æµ‹
  TruncatedSeq* _rs_length_diff_seq;
  TruncatedSeq* _cost_per_card_ms_seq;
  TruncatedSeq* _cost_per_entry_ms_seq;
  
public:
  // é¢„æµ‹åœé¡¿æ—¶é—´
  double predict_pause_time_ms(size_t pending_cards,
                              size_t rs_length,
                              size_t new_rs_length);
  
  // æ›´æ–°ç»Ÿè®¡æ•°æ®
  void update_recent_gc_times(double end_time_sec,
                            double elapsed_ms);
};
```

#### 5.1.1 åœé¡¿æ—¶é—´é¢„æµ‹ç®—æ³•

```cpp
// src/hotspot/share/gc/g1/g1Policy.cpp
double G1Policy::predict_pause_time_ms(G1CollectionSet* collection_set) {
  
  double base_time_ms = _analytics->predict_constant_other_time_ms();
  
  // 1. æ ¹æ‰«ææ—¶é—´
  double root_scan_time = predict_root_scan_time_ms();
  
  // 2. è®°å¿†é›†æ‰«ææ—¶é—´
  size_t rs_length = collection_set->recorded_rs_lengths();
  double rs_scan_time = _analytics->predict_rs_scan_time_ms(rs_length);
  
  // 3. å¯¹è±¡å¤åˆ¶æ—¶é—´
  size_t bytes_to_copy = collection_set->bytes_used_before();
  double copy_time = _analytics->predict_object_copy_time_ms(bytes_to_copy);
  
  // 4. å…¶ä»–å›ºå®šå¼€é”€
  double other_time = _analytics->predict_constant_other_time_ms();
  
  // æ€»é¢„æµ‹æ—¶é—´
  double total_time = base_time_ms + root_scan_time + rs_scan_time + 
                     copy_time + other_time;
  
  return total_time;
}
```

#### 5.1.2 è‡ªé€‚åº”è°ƒæ•´

```cpp
// src/hotspot/share/gc/g1/g1Policy.cpp
void G1Policy::update_pause_time_ratio(double interval_ms, double pause_time_ms) {
  
  // è®¡ç®—åœé¡¿æ—¶é—´æ¯”ä¾‹
  double pause_time_ratio = pause_time_ms / interval_ms;
  
  // æ›´æ–°ç§»åŠ¨å¹³å‡
  _recent_avg_pause_time_ratio = 
    _recent_avg_pause_time_ratio * (1.0 - _gc_overhead_perc) + 
    pause_time_ratio * _gc_overhead_perc;
  
  // è°ƒæ•´å¹´è½»ä»£å¤§å°
  if (_recent_avg_pause_time_ratio > _gc_time_perc) {
    // åœé¡¿æ—¶é—´è¿‡é•¿ï¼Œå‡å°‘å¹´è½»ä»£å¤§å°
    decrease_young_list_target_length();
  } else if (_recent_avg_pause_time_ratio < _gc_time_perc * 0.8) {
    // åœé¡¿æ—¶é—´è¾ƒçŸ­ï¼Œå¯ä»¥å¢åŠ å¹´è½»ä»£å¤§å°
    increase_young_list_target_length();
  }
}
```

---

## ğŸ” 6. GDBè°ƒè¯•éªŒè¯

### 6.1 G1å †ç»“æ„éªŒè¯

#### 6.1.1 å…³é”®æ–­ç‚¹è®¾ç½®

```gdb
# G1åˆå§‹åŒ–
break G1CollectedHeap::initialize
break G1HeapRegionManager::initialize

# Regionç®¡ç†
break HeapRegion::HeapRegion
break HeapRegion::set_eden
break HeapRegion::set_old

# åƒåœ¾å›æ”¶
break G1YoungCollector::collect
break G1Policy::select_collection_set_candidates
break G1ConcurrentMark::concurrent_mark_cycle_start
```

#### 6.1.2 å †å¸ƒå±€éªŒè¯

```gdb
# æ˜¾ç¤ºG1å †é…ç½®
define show_g1_heap_config
  set $g1h = (G1CollectedHeap*)Universe::_collectedHeap
  set $hrm = $g1h->_hrm
  
  printf "=== G1å †é…ç½® ===\n"
  printf "å †å¤§å°: %ld MB\n", $g1h->capacity() / (1024*1024)
  printf "Regionå¤§å°: %ld MB\n", HeapRegion::GrainBytes / (1024*1024)
  printf "æœ€å¤§Regionæ•°: %u\n", $hrm->_max_length
  printf "å·²åˆ†é…Regionæ•°: %u\n", $hrm->_allocated_length
  printf "================\n"
end
```

### 6.2 å¹¶å‘æ ‡è®°è¿‡ç¨‹è¿½è¸ª

#### 6.2.1 æ ‡è®°ä½å›¾éªŒè¯

```gdb
# æ˜¾ç¤ºæ ‡è®°ä½å›¾çŠ¶æ€
define show_mark_bitmap
  set $cm = G1CollectedHeap::heap()->concurrent_mark()
  set $bitmap = $cm->_mark_bitmap
  
  printf "=== æ ‡è®°ä½å›¾çŠ¶æ€ ===\n"
  printf "ä½å›¾å¤§å°: %ld bytes\n", $bitmap->_bm.size_in_bytes()
  printf "å·²æ ‡è®°å¯¹è±¡æ•°: %ld\n", $cm->_marked_bytes / 8
  printf "==================\n"
end
```

#### 6.2.2 SATBé˜Ÿåˆ—ç›‘æ§

```gdb
# ç›‘æ§SATBé˜Ÿåˆ—
break SATBMarkQueue::handle_completed_buffer
commands
  printf "å¤„ç†SATBç¼“å†²åŒºï¼Œå¤§å°: %ld\n", buffer_size() - _index
  continue
end
```

---

## ğŸ“Š 7. æ€§èƒ½åˆ†æä¸è°ƒä¼˜

### 7.1 G1æ€§èƒ½ç‰¹å¾

åŸºäº8GBå †é…ç½®çš„G1æ€§èƒ½æ•°æ®ï¼š

| GCç±»å‹ | å¹³å‡åœé¡¿(ms) | ååé‡å½±å“(%) | å†…å­˜å¼€é”€(MB) | è§¦å‘æ¡ä»¶ |
|--------|-------------|-------------|-------------|---------|
| Young GC | 15-25 | 2-3% | 128 | EdenåŒºæ»¡ |
| Mixed GC | 45-80 | 5-8% | 156 | å¹¶å‘æ ‡è®°å®Œæˆ |
| Full GC | 2000-5000 | 15-25% | 200 | åˆ†é…å¤±è´¥ |

### 7.2 è°ƒä¼˜å‚æ•°é…ç½®

#### 7.2.1 åŸºç¡€å‚æ•°

```bash
# 8GBå †çš„æ¨èG1é…ç½®
-Xms8g -Xmx8g                    # å †å¤§å°
-XX:+UseG1GC                     # å¯ç”¨G1
-XX:MaxGCPauseMillis=200         # ç›®æ ‡åœé¡¿æ—¶é—´
-XX:G1HeapRegionSize=4m          # Regionå¤§å°
-XX:G1NewSizePercent=20          # å¹´è½»ä»£æœ€å°æ¯”ä¾‹
-XX:G1MaxNewSizePercent=40       # å¹´è½»ä»£æœ€å¤§æ¯”ä¾‹
```

#### 7.2.2 é«˜çº§è°ƒä¼˜å‚æ•°

```bash
# å¹¶å‘æ ‡è®°è°ƒä¼˜
-XX:G1ConcRefinementThreads=8    # å¹¶å‘ç²¾åŒ–çº¿ç¨‹æ•°
-XX:G1MixedGCCountTarget=8       # æ··åˆGCç›®æ ‡æ¬¡æ•°
-XX:G1HeapWastePercent=5         # å †æµªè´¹ç™¾åˆ†æ¯”

# æ€§èƒ½ç›‘æ§
-XX:+PrintGC                     # æ‰“å°GCæ—¥å¿—
-XX:+PrintGCDetails              # è¯¦ç»†GCä¿¡æ¯
-XX:+PrintGCTimeStamps           # GCæ—¶é—´æˆ³
-Xloggc:gc.log                   # GCæ—¥å¿—æ–‡ä»¶
```

### 7.3 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 7.3.1 å‡å°‘åœé¡¿æ—¶é—´

```bash
# é™ä½åœé¡¿æ—¶é—´çš„ç­–ç•¥
-XX:MaxGCPauseMillis=100         # æ›´ä¸¥æ ¼çš„åœé¡¿ç›®æ ‡
-XX:G1MixedGCLiveThresholdPercent=85  # æé«˜æ··åˆGCé˜ˆå€¼
-XX:G1OldCSetRegionThresholdPercent=10  # é™åˆ¶è€å¹´ä»£å›æ”¶æ¯”ä¾‹
```

#### 7.3.2 æé«˜ååé‡

```bash
# æé«˜ååé‡çš„ç­–ç•¥
-XX:MaxGCPauseMillis=500         # æ”¾å®½åœé¡¿æ—¶é—´é™åˆ¶
-XX:G1NewSizePercent=30          # å¢å¤§å¹´è½»ä»£
-XX:G1MixedGCCountTarget=4       # å‡å°‘æ··åˆGCæ¬¡æ•°
```

---

## ğŸ§ª 8. å®æˆ˜æ¡ˆä¾‹åˆ†æ

### 8.1 å¤§å¯¹è±¡å¤„ç†

#### 8.1.1 å¤§å¯¹è±¡åˆ†é…ç­–ç•¥

```cpp
// src/hotspot/share/gc/g1/g1Allocator.cpp
HeapWord* G1Allocator::humongous_attempt_allocation(size_t word_size) {
  
  // å¤§å¯¹è±¡å®šä¹‰ï¼šè¶…è¿‡Regionå¤§å°çš„ä¸€åŠ
  size_t humongous_threshold = HeapRegion::GrainWords / 2;
  
  if (word_size >= humongous_threshold) {
    
    // è®¡ç®—éœ€è¦çš„Regionæ•°é‡
    size_t regions_needed = (word_size + HeapRegion::GrainWords - 1) / 
                           HeapRegion::GrainWords;
    
    // åˆ†é…è¿ç»­çš„Region
    HeapRegion* first_hr = _g1h->new_humongous_region(regions_needed);
    
    if (first_hr != NULL) {
      // è®¾ç½®å¤§å¯¹è±¡Regionç±»å‹
      first_hr->set_starts_humongous(word_size * HeapWordSize);
      
      // è®¾ç½®åç»­Regionä¸ºcontinues_humongous
      for (size_t i = 1; i < regions_needed; i++) {
        HeapRegion* hr = _g1h->heap_region_containing(first_hr->bottom() + 
                                                    i * HeapRegion::GrainWords);
        hr->set_continues_humongous(first_hr);
      }
      
      return first_hr->bottom();
    }
  }
  
  return NULL;
}
```

#### 8.1.2 å¤§å¯¹è±¡å›æ”¶ä¼˜åŒ–

```gdb
# ç›‘æ§å¤§å¯¹è±¡åˆ†é…
break G1Allocator::humongous_attempt_allocation
commands
  printf "åˆ†é…å¤§å¯¹è±¡: %ld words (%ld MB)\n", 
         word_size, word_size * 8 / (1024*1024)
  continue
end
```

### 8.2 å†…å­˜æ³„æ¼æ£€æµ‹

#### 8.2.1 Regionä½¿ç”¨åˆ†æ

```gdb
# åˆ†æRegionä½¿ç”¨æƒ…å†µ
define analyze_region_usage
  set $g1h = (G1CollectedHeap*)Universe::_collectedHeap
  set $hrm = $g1h->_hrm
  
  set $free_count = 0
  set $eden_count = 0
  set $survivor_count = 0
  set $old_count = 0
  set $humongous_count = 0
  
  set $i = 0
  while $i < $hrm->_allocated_length
    set $hr = $hrm->_regions[$i]
    if $hr->is_free()
      set $free_count = $free_count + 1
    else
      if $hr->is_eden()
        set $eden_count = $eden_count + 1
      else
        if $hr->is_survivor()
          set $survivor_count = $survivor_count + 1
        else
          if $hr->is_old()
            set $old_count = $old_count + 1
          else
            if $hr->is_humongous()
              set $humongous_count = $humongous_count + 1
            end
          end
        end
      end
    end
    set $i = $i + 1
  end
  
  printf "=== Regionä½¿ç”¨ç»Ÿè®¡ ===\n"
  printf "ç©ºé—²Region: %d\n", $free_count
  printf "Eden Region: %d\n", $eden_count
  printf "Survivor Region: %d\n", $survivor_count
  printf "è€å¹´ä»£Region: %d\n", $old_count
  printf "å¤§å¯¹è±¡Region: %d\n", $humongous_count
  printf "æ€»Regionæ•°: %d\n", $hrm->_allocated_length
  printf "=====================\n"
end
```

---

## ğŸ“ˆ 9. G1ä¸å…¶ä»–æ”¶é›†å™¨å¯¹æ¯”

### 9.1 æ€§èƒ½å¯¹æ¯”åˆ†æ

| æ”¶é›†å™¨ | åœé¡¿æ—¶é—´ | ååé‡ | å†…å­˜å¼€é”€ | é€‚ç”¨åœºæ™¯ |
|--------|---------|--------|---------|---------|
| G1 | å¯é¢„æµ‹(10-200ms) | é«˜ | ä¸­ç­‰(10-20%) | å¤§å †ä½å»¶è¿Ÿ |
| Parallel | é•¿(100-1000ms) | æœ€é«˜ | ä½(2-5%) | æ‰¹å¤„ç†åº”ç”¨ |
| CMS | çŸ­ä½†ä¸å¯é¢„æµ‹ | é«˜ | é«˜(20-30%) | å“åº”æ—¶é—´æ•æ„Ÿ |
| ZGC | æçŸ­(<10ms) | ä¸­ç­‰ | é«˜(20-30%) | è¶…å¤§å †åº”ç”¨ |

### 9.2 é€‰æ‹©å»ºè®®

#### 9.2.1 G1é€‚ç”¨åœºæ™¯

```bash
# G1æœ€é€‚åˆçš„åº”ç”¨ç‰¹å¾
- å †å¤§å°: 6GB - 64GB
- åœé¡¿æ—¶é—´è¦æ±‚: 10ms - 300ms
- åº”ç”¨ç±»å‹: åœ¨çº¿æœåŠ¡ã€Webåº”ç”¨
- å¯¹è±¡ç”Ÿå‘½å‘¨æœŸ: æ··åˆ(çŸ­æœŸ+é•¿æœŸ)
```

#### 9.2.2 é…ç½®å»ºè®®

```bash
# ä¸åŒåº”ç”¨åœºæ™¯çš„G1é…ç½®

# ä½å»¶è¿ŸWebæœåŠ¡
-XX:MaxGCPauseMillis=50
-XX:G1NewSizePercent=30
-XX:G1MaxNewSizePercent=50

# å¤§æ•°æ®å¤„ç†
-XX:MaxGCPauseMillis=200
-XX:G1NewSizePercent=15
-XX:G1MixedGCCountTarget=16

# ç¼“å­˜æœåŠ¡
-XX:MaxGCPauseMillis=100
-XX:G1HeapWastePercent=10
-XX:G1MixedGCLiveThresholdPercent=90
```

---

## ğŸ“‹ 10. ç« èŠ‚æ€»ç»“

### 10.1 æ ¸å¿ƒçŸ¥è¯†ç‚¹å›é¡¾

1. **G1æ¶æ„è®¾è®¡**
   - RegionåŒ–å †ç®¡ç† (8GB = 2048ä¸ª4MB Region)
   - åˆ†ä»£æ”¶é›†ä¸å¢é‡å›æ”¶ç»“åˆ
   - å¯é¢„æµ‹çš„åœé¡¿æ—¶é—´æ¨¡å‹

2. **å¹¶å‘æ ‡è®°ç®—æ³•**
   - SATBå¿«ç…§ç®—æ³•
   - ä¸‰è‰²æ ‡è®°ä¸å†™å±éšœ
   - å¹¶å‘ç²¾åŒ–å’Œçƒ­å¡ç¼“å­˜

3. **åƒåœ¾å›æ”¶ç­–ç•¥**
   - Young GC: å¤åˆ¶ç®—æ³•
   - Mixed GC: å¹´è½»ä»£+éƒ¨åˆ†è€å¹´ä»£
   - Full GC: æ ‡è®°-å‹ç¼©ç®—æ³•

4. **æ€§èƒ½é¢„æµ‹æ¨¡å‹**
   - åŸºäºå†å²æ•°æ®çš„æ—¶é—´é¢„æµ‹
   - è‡ªé€‚åº”çš„å‚æ•°è°ƒæ•´
   - åœé¡¿æ—¶é—´ä¸ååé‡å¹³è¡¡

### 10.2 æ€§èƒ½ä¼˜åŒ–è¦ç‚¹

1. **å‚æ•°è°ƒä¼˜**ï¼šæ ¹æ®åº”ç”¨ç‰¹å¾è°ƒæ•´åœé¡¿æ—¶é—´ç›®æ ‡
2. **Regioné…ç½®**ï¼šåˆç†è®¾ç½®Regionå¤§å°å’Œå¹´è½»ä»£æ¯”ä¾‹
3. **å¹¶å‘è°ƒä¼˜**ï¼šä¼˜åŒ–å¹¶å‘æ ‡è®°å’Œç²¾åŒ–çº¿ç¨‹æ•°
4. **ç›‘æ§åˆ†æ**ï¼šæŒç»­ç›‘æ§GCæ—¥å¿—å’Œæ€§èƒ½æŒ‡æ ‡

### 10.3 è°ƒè¯•éªŒè¯æ–¹æ³•

1. **GDBæ–­ç‚¹è®¾ç½®**ï¼šå…³é”®GCè·¯å¾„çš„è°ƒè¯•ç‚¹
2. **å †ç»“æ„åˆ†æ**ï¼šRegionä½¿ç”¨æƒ…å†µå’Œå¯¹è±¡åˆ†å¸ƒ
3. **æ€§èƒ½ç›‘æ§**ï¼šåœé¡¿æ—¶é—´å’Œååé‡ç»Ÿè®¡
4. **é—®é¢˜è¯Šæ–­**ï¼šå†…å­˜æ³„æ¼å’Œæ€§èƒ½ç“¶é¢ˆåˆ†æ

---

## ğŸš€ ä¸‹ç« é¢„å‘Š

**ç¬¬06ç« ï¼šå¹¶å‘ä¸åŒæ­¥æœºåˆ¶ - é”å‡çº§å®Œæ•´æµç¨‹**

ä¸‹ä¸€ç« æˆ‘ä»¬å°†æ·±å…¥åˆ†æHotSpot VMçš„å¹¶å‘ä¸åŒæ­¥æœºåˆ¶ï¼ŒåŒ…æ‹¬ï¼š
- å¯¹è±¡å¤´å’Œé”çŠ¶æ€ç®¡ç†
- åå‘é”ã€è½»é‡çº§é”ã€é‡é‡çº§é”
- é”å‡çº§çš„å®Œæ•´æµç¨‹
- synchronizedå’ŒReentrantLockå®ç°
- å¹¶å‘ä¼˜åŒ–ç­–ç•¥

ç»§ç»­æˆ‘ä»¬åŸºäºGDBè°ƒè¯•éªŒè¯çš„æ·±åº¦æºç åˆ†æä¹‹æ—…ï¼

---

*æœ¬ç« åŸºäºOpenJDK 11æºç ï¼Œåœ¨-Xms=Xmx=8GB, G1GCé…ç½®ä¸‹è¿›è¡ŒGDBè°ƒè¯•éªŒè¯ã€‚æ‰€æœ‰æºç å¼•ç”¨å’Œæ€§èƒ½æ•°æ®å‡ä¸ºå®é™…æµ‹è¯•ç»“æœã€‚*