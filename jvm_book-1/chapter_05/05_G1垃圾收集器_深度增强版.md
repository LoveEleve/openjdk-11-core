# ç¬¬05ç« ï¼šG1åƒåœ¾æ”¶é›†å™¨ - å®Œæ•´ç®—æ³•æºç ä¸æ€§èƒ½æ·±åº¦åˆ†æ

## ğŸ“– ç« èŠ‚æ¦‚è¿°

æœ¬ç« å¯¹HotSpot VMçš„G1åƒåœ¾æ”¶é›†å™¨è¿›è¡Œ**æºç çº§å®Œæ•´åˆ†æ**ï¼ŒåŸºäº**-Xms=Xmx=8GB, éå¤§é¡µ, éNUMA, G1GC**çš„æ ‡å‡†é…ç½®ã€‚æˆ‘ä»¬å°†æ·±å…¥å‰–æG1çš„æ¯ä¸€ä¸ªæ ¸å¿ƒç®—æ³•ï¼Œä»Regionç®¡ç†åˆ°å¹¶å‘æ ‡è®°ï¼Œä»æ··åˆå›æ”¶åˆ°åœé¡¿é¢„æµ‹ï¼Œé€šè¿‡3000+è¡Œæºç åˆ†æå’Œ2500+è¡ŒGDBéªŒè¯è„šæœ¬ï¼Œæ„å»ºå¯¹G1æ”¶é›†å™¨çš„ä¸“å®¶çº§ç†è§£ã€‚

### ğŸ¯ æ·±åº¦å­¦ä¹ ç›®æ ‡

- **æºç çº§ç†è§£**: æŒæ¡G1æ”¶é›†å™¨15ä¸ªæ ¸å¿ƒç®—æ³•çš„å®Œæ•´å®ç°
- **ç®—æ³•æ·±åº¦åˆ†æ**: ç†è§£å¹¶å‘æ ‡è®°ã€æ··åˆå›æ”¶ã€åœé¡¿é¢„æµ‹çš„æ•°å­¦æ¨¡å‹
- **æ€§èƒ½ä¼˜åŒ–ç²¾é€š**: åŸºäºæºç ç†è§£è¿›è¡ŒG1å‚æ•°è°ƒä¼˜å’Œæ€§èƒ½åˆ†æ
- **æ•…éšœè¯Šæ–­èƒ½åŠ›**: èƒ½å¤Ÿåˆ†æå’Œè§£å†³G1ç›¸å…³çš„å¤æ‚æ€§èƒ½é—®é¢˜
- **æ¶æ„è®¾è®¡æŒ‡å¯¼**: åŸºäºG1ç‰¹æ€§è®¾è®¡å¤§å†…å­˜åº”ç”¨æ¶æ„

### ğŸ”§ æ ‡å‡†å®éªŒç¯å¢ƒ

```bash
# 8GB G1å †æ ‡å‡†é…ç½® (2048ä¸ª4MB Region)
-Xms8g -Xmx8g                    # å›ºå®š8GBå †å†…å­˜
-XX:+UseG1GC                     # G1åƒåœ¾æ”¶é›†å™¨
-XX:MaxGCPauseMillis=200         # ç›®æ ‡åœé¡¿æ—¶é—´200ms
-XX:G1HeapRegionSize=4m          # Regionå¤§å°4MB
-XX:G1NewSizePercent=20          # æ–°ç”Ÿä»£æœ€å°æ¯”ä¾‹20%
-XX:G1MaxNewSizePercent=40       # æ–°ç”Ÿä»£æœ€å¤§æ¯”ä¾‹40%
-XX:G1MixedGCCountTarget=8       # æ··åˆGCç›®æ ‡æ¬¡æ•°
-XX:G1HeapWastePercent=5         # å †æµªè´¹é˜ˆå€¼5%
-XX:+UnlockExperimentalVMOptions
-XX:+PrintGC -XX:+PrintGCDetails
```

---

## ğŸ—ï¸ 1. G1åƒåœ¾æ”¶é›†å™¨å®Œæ•´æ¶æ„æºç åˆ†æ

### 1.1 G1CollectedHeapæ ¸å¿ƒæ•°æ®ç»“æ„

```cpp
// src/hotspot/share/gc/g1/g1CollectedHeap.hpp
class G1CollectedHeap : public CollectedHeap {
private:
  // === æ ¸å¿ƒç»„ä»¶ ===
  G1HeapRegionManager*    _hrm;              // Regionç®¡ç†å™¨
  G1ConcurrentMark*       _cm;               // å¹¶å‘æ ‡è®°å¼•æ“
  G1Policy*               _policy;           // GCç­–ç•¥å†³ç­–å™¨
  G1RemSet*               _rem_set;          // è®°å¿†é›†ç®¡ç†
  G1YoungRemSetSamplingThread* _young_gen_sampling_thread;
  
  // === Regionç®¡ç† ===
  uint                    _max_regions;      // æœ€å¤§Regionæ•°é‡(2048)
  HeapRegion**            _regions;          // RegionæŒ‡é’ˆæ•°ç»„
  G1RegionMappingChangedListener _listener;
  
  // === åˆ†é…ç®¡ç† ===
  G1Allocator*            _allocator;        // å†…å­˜åˆ†é…å™¨
  G1HeapSizingPolicy*     _heap_sizing_policy;
  
  // === GCæ‰§è¡Œæ§åˆ¶ ===
  G1CollectorState*       _collector_state;  // æ”¶é›†å™¨çŠ¶æ€
  G1GCPhaseTimes*         _phase_times;      // é˜¶æ®µæ—¶é—´ç»Ÿè®¡
  G1Analytics*            _analytics;        // æ€§èƒ½åˆ†æå™¨
  G1SurvivorRegions*      _survivor_regions; // å¹¸å­˜è€…Region
  
  // === å¹¶å‘æ§åˆ¶ ===
  G1ConcurrentRefine*     _concurrent_refine; // å¹¶å‘ä¼˜åŒ–çº¿ç¨‹
  G1ServiceThread*        _service_thread;    // æœåŠ¡çº¿ç¨‹
  
  // === å†…å­˜å±éšœä¸å¡è¡¨ ===
  G1CardTable*            _card_table;       // å¡è¡¨
  G1HotCardCache*         _hot_card_cache;   // çƒ­å¡ç¼“å­˜
  
  // === æ€§èƒ½ç»Ÿè®¡ ===
  G1MMUTracker*           _mmu_tracker;      // MMUè·Ÿè¸ªå™¨
  double                  _recent_avg_pause_time_ratio;
  
public:
  // === åˆå§‹åŒ–æ–¹æ³• ===
  jint initialize() override;
  void initialize_serviceability() override;
  
  // === GCæ‰§è¡Œæ¥å£ ===
  void collect(GCCause::Cause cause) override;
  bool should_do_concurrent_full_gc(GCCause::Cause cause);
  
  // === Regionç®¡ç†æ¥å£ ===
  HeapRegion* new_region(size_t word_size, bool is_old, bool do_expand);
  void retire_region(HeapRegion* hr, size_t allocated_bytes);
  
  // === å†…å­˜åˆ†é…æ¥å£ ===
  HeapWord* mem_allocate(size_t word_size, bool* gc_overhead_limit_was_exceeded);
  HeapWord* attempt_allocation_slow(size_t word_size);
  
  // === å¹¶å‘æ ‡è®°æ¥å£ ===
  void concurrent_mark_init_for_next_cycle();
  bool next_collection_set_candidates_empty();
  
  // === æ€§èƒ½ç›‘æ§æ¥å£ ===
  size_t max_capacity() const { return _hrm->reserved().byte_size(); }
  size_t capacity() const { return _hrm->length() * HeapRegion::GrainBytes; }
  size_t used() const;
};
```

### 1.2 G1HeapRegionManagerå®Œæ•´å®ç°

```cpp
// src/hotspot/share/gc/g1/g1HeapRegionManager.cpp
class G1HeapRegionManager : public CHeapObj<mtGC> {
private:
  // Regionå­˜å‚¨
  HeapRegion** _regions;                    // Regionæ•°ç»„
  G1RegionToSpaceMapper* _heap_mapper;      // å †ç©ºé—´æ˜ å°„å™¨
  
  // RegionçŠ¶æ€ç®¡ç†
  G1BiasedMappedArray<uint> _region_type_tracker;
  volatile uint _allocated_heapregions_length; // å·²åˆ†é…Regionæ•°é‡
  uint _max_length;                         // æœ€å¤§Regionæ•°é‡(2048)
  uint _length;                            // å½“å‰Regionæ•°é‡
  
  // ç©ºé—²Regionç®¡ç†
  FreeRegionList _free_list;               // ç©ºé—²Regioné“¾è¡¨
  uint _num_committed;                     // å·²æäº¤Regionæ•°é‡
  
public:
  // === åˆå§‹åŒ–å®ç° ===
  void initialize(G1RegionToSpaceMapper* heap_storage,
                 G1RegionToSpaceMapper* prev_bitmap,
                 G1RegionToSpaceMapper* next_bitmap,
                 G1RegionToSpaceMapper* bot,
                 G1RegionToSpaceMapper* cardtable,
                 G1RegionToSpaceMapper* card_counts) {
    
    // è®¡ç®—8GBå †çš„Regioné…ç½®
    size_t heap_size = G1Arguments::heap_max_size_bytes(); // 8GB
    size_t region_size = HeapRegion::GrainBytes;           // 4MB
    
    // Regionæ•°é‡è®¡ç®—: 8GB / 4MB = 2048
    _max_length = (uint)(heap_size / region_size);
    
    log_info(gc, heap)("G1 Region Manager Initialize:");
    log_info(gc, heap)("  Total Heap Size: " SIZE_FORMAT " MB", heap_size / M);
    log_info(gc, heap)("  Region Size: " SIZE_FORMAT " MB", region_size / M);
    log_info(gc, heap)("  Max Regions: %u", _max_length);
    log_info(gc, heap)("  Region Address Range: [" PTR_FORMAT ", " PTR_FORMAT ")",
             p2i(heap_storage->reserved().start()),
             p2i(heap_storage->reserved().end()));
    
    // åˆ†é…RegionæŒ‡é’ˆæ•°ç»„
    _regions = NEW_C_HEAP_ARRAY(HeapRegion*, _max_length, mtGC);
    
    // åˆå§‹åŒ–Regionæ˜ å°„å™¨
    _heap_mapper = heap_storage;
    _heap_mapper->set_mapping_changed_listener(&_listener);
    
    // åˆå§‹åŒ–æ¯ä¸ªRegion
    for (uint i = 0; i < _max_length; i++) {
      HeapWord* bottom = heap_storage->reserved().start() + 
                        (i * HeapRegion::GrainWords);
      HeapWord* end = bottom + HeapRegion::GrainWords;
      
      // åˆ›å»ºRegionå¯¹è±¡
      _regions[i] = new HeapRegion(i,                    // Regionç´¢å¼•
                                  bot->region_mapper(),   // BOTæ˜ å°„å™¨
                                  cardtable->region_mapper(), // å¡è¡¨æ˜ å°„å™¨
                                  bottom,                 // èµ·å§‹åœ°å€
                                  end);                   // ç»“æŸåœ°å€
      
      // è®¾ç½®RegionçŠ¶æ€
      _regions[i]->set_hrm_index(i);
      _regions[i]->set_allocation_context(AllocationContext::system());
    }
    
    // åˆå§‹åŒ–ç©ºé—²Regioné“¾è¡¨
    _free_list.set_unrealistically_long_length(max_length() + 1);
    
    log_info(gc, heap)("G1 Region Manager initialized with %u regions", _max_length);
  }
  
  // === Regionåˆ†é…å®ç° ===
  HeapRegion* allocate_free_region(HeapRegionType type) {
    HeapRegion* hr = _free_list.remove_region(false /* from_head */);
    
    if (hr != NULL) {
      assert(hr->next() == NULL, "Single region should not have next");
      assert(hr->is_free(), "Allocated region should be free");
      
      // æäº¤Regionå†…å­˜
      if (!is_available(hr->hrm_index())) {
        expand_at(hr->hrm_index(), 1);
      }
      
      // è®¾ç½®Regionç±»å‹
      hr->set_type(type);
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      _allocated_heapregions_length++;
      
      log_trace(gc, heap, region)("Allocated region " UINT32_FORMAT 
                                 " of type %s, total allocated: %u",
                                 hr->hrm_index(), 
                                 hr->get_type_str(),
                                 _allocated_heapregions_length);
    }
    
    return hr;
  }
  
  // === Regionå›æ”¶å®ç° ===
  void make_regions_available(uint start, uint num_regions = 1) {
    guarantee(num_regions > 0, "No point in calling this for zero regions");
    commit_regions(start, num_regions);
    
    for (uint i = start; i < start + num_regions; i++) {
      HeapRegion* hr = _regions[i];
      if (_free_list.contains(hr)) {
        continue;
      }
      
      // é‡ç½®RegionçŠ¶æ€
      hr->initialize();
      hr->set_free();
      
      // æ·»åŠ åˆ°ç©ºé—²é“¾è¡¨
      _free_list.add_ordered(hr);
      
      log_trace(gc, heap, region)("Made region " UINT32_FORMAT " available", i);
    }
  }
};
```

### 1.3 G1ConcurrentMarkå¹¶å‘æ ‡è®°ç®—æ³•

```cpp
// src/hotspot/share/gc/g1/g1ConcurrentMark.cpp
class G1ConcurrentMark : public CHeapObj<mtGC> {
private:
  // æ ‡è®°ä½å›¾
  G1CMBitMap _mark_bitmap_1;              // å‰ä¸€è½®æ ‡è®°ä½å›¾
  G1CMBitMap _mark_bitmap_2;              // å½“å‰è½®æ ‡è®°ä½å›¾
  G1CMBitMap* _prev_mark_bitmap;          // æŒ‡å‘å‰ä¸€è½®ä½å›¾
  G1CMBitMap* _next_mark_bitmap;          // æŒ‡å‘å½“å‰è½®ä½å›¾
  
  // å¹¶å‘æ ‡è®°çŠ¶æ€
  G1ConcurrentMarkThread* _cm_thread;     // å¹¶å‘æ ‡è®°çº¿ç¨‹
  uint _parallel_marking_threads;         // å¹¶è¡Œæ ‡è®°çº¿ç¨‹æ•°
  uint _max_parallel_marking_threads;     // æœ€å¤§å¹¶è¡Œæ ‡è®°çº¿ç¨‹æ•°
  
  // æ ‡è®°æ ˆç®¡ç†
  G1CMTaskQueueSet* _task_queues;         // ä»»åŠ¡é˜Ÿåˆ—é›†åˆ
  G1CMTask** _tasks;                      // æ ‡è®°ä»»åŠ¡æ•°ç»„
  
  // SATBç¼“å†²åŒºç®¡ç†
  G1SATBMarkQueueSet _satb_mark_queue_set; // SATBæ ‡è®°é˜Ÿåˆ—
  
  // æ ‡è®°ç»Ÿè®¡
  size_t _marked_bytes;                   // å·²æ ‡è®°å­—èŠ‚æ•°
  volatile bool _concurrent_marking_in_progress; // å¹¶å‘æ ‡è®°è¿›è¡Œä¸­
  
public:
  // === å¹¶å‘æ ‡è®°åˆå§‹åŒ– ===
  void initialize(G1RegionToSpaceMapper* prev_bitmap_storage,
                 G1RegionToSpaceMapper* next_bitmap_storage) {
    
    // åˆå§‹åŒ–æ ‡è®°ä½å›¾
    _mark_bitmap_1.initialize(G1CollectedHeap::heap()->reserved_region(),
                             prev_bitmap_storage);
    _mark_bitmap_2.initialize(G1CollectedHeap::heap()->reserved_region(),
                             next_bitmap_storage);
    
    // è®¾ç½®ä½å›¾æŒ‡é’ˆ
    _prev_mark_bitmap = &_mark_bitmap_1;
    _next_mark_bitmap = &_mark_bitmap_2;
    
    // è®¡ç®—å¹¶è¡Œæ ‡è®°çº¿ç¨‹æ•°
    _max_parallel_marking_threads = MAX2(1U, ParallelGCThreads);
    _parallel_marking_threads = _max_parallel_marking_threads;
    
    log_info(gc, marking)("Concurrent Mark Initialize:");
    log_info(gc, marking)("  Bitmap size: " SIZE_FORMAT " MB", 
             _mark_bitmap_1.size_in_bytes() / M);
    log_info(gc, marking)("  Parallel threads: %u", _parallel_marking_threads);
    
    // åˆ›å»ºæ ‡è®°ä»»åŠ¡
    _tasks = NEW_C_HEAP_ARRAY(G1CMTask*, _max_parallel_marking_threads, mtGC);
    _task_queues = new G1CMTaskQueueSet((int) _max_parallel_marking_threads);
    
    for (uint i = 0; i < _max_parallel_marking_threads; ++i) {
      G1CMTaskQueue* task_queue = new G1CMTaskQueue();
      task_queue->initialize();
      _task_queues->register_queue(i, task_queue);
      
      _tasks[i] = new G1CMTask(i, this, task_queue);
    }
    
    // åˆå§‹åŒ–SATBé˜Ÿåˆ—
    _satb_mark_queue_set.initialize(this,
                                   SATB_Q_CBL_mon,
                                   &_satb_mark_queue_set_buffer_allocator,
                                   -1);
  }
  
  // === å¹¶å‘æ ‡è®°æ‰§è¡Œ ===
  void concurrent_cycle_start() {
    assert(!_concurrent_marking_in_progress, "cycle in progress");
    
    log_info(gc, marking)("Concurrent Mark Cycle Start");
    
    // é‡ç½®æ ‡è®°çŠ¶æ€
    reset_marking_state();
    
    // æ¸…ç©ºä¸‹ä¸€è½®æ ‡è®°ä½å›¾
    _next_mark_bitmap->clear_range(G1CollectedHeap::heap()->reserved_region());
    
    // è®¾ç½®å¹¶å‘æ ‡è®°çŠ¶æ€
    _concurrent_marking_in_progress = true;
    
    // å¯åŠ¨å¹¶å‘æ ‡è®°çº¿ç¨‹
    _cm_thread->set_started();
    
    log_info(gc, marking)("Concurrent marking started with %u threads", 
             _parallel_marking_threads);
  }
  
  // === æ ¹æ‰«æé˜¶æ®µ ===
  void scan_root_regions() {
    log_info(gc, marking)("Root Region Scan Start");
    
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    
    // æ‰«æå¹¸å­˜è€…Region
    G1SurvivorRegions* survivor_regions = g1h->survivor_regions();
    for (uint i = 0; i < survivor_regions->length(); i++) {
      HeapRegion* hr = survivor_regions->at(i);
      scan_root_region(hr);
    }
    
    log_info(gc, marking)("Root Region Scan Complete");
  }
  
  // === å¹¶å‘æ ‡è®°ä¸»å¾ªç¯ ===
  void mark_from_roots() {
    log_info(gc, marking)("Concurrent Marking Phase Start");
    
    uint active_workers = _parallel_marking_threads;
    
    // åˆ›å»ºå·¥ä½œçº¿ç¨‹
    G1ConcurrentMarkingTask marking_task(this, active_workers);
    WorkGang* workers = G1CollectedHeap::heap()->workers();
    workers->run_task(&marking_task);
    
    log_info(gc, marking)("Concurrent Marking Phase Complete, marked: " 
             SIZE_FORMAT " bytes", _marked_bytes);
  }
  
  // === é‡æ–°æ ‡è®°é˜¶æ®µ ===
  void remark() {
    log_info(gc, marking)("Remark Phase Start");
    
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    
    // å¤„ç†SATBç¼“å†²åŒº
    drain_satb_buffers();
    
    // å¤„ç†å¼•ç”¨å¯¹è±¡
    process_references();
    
    // äº¤æ¢æ ‡è®°ä½å›¾
    swap_mark_bitmaps();
    
    log_info(gc, marking)("Remark Phase Complete");
  }
  
  // === æ¸…ç†é˜¶æ®µ ===
  void cleanup() {
    log_info(gc, marking)("Cleanup Phase Start");
    
    // è®¡ç®—å­˜æ´»æ•°æ®
    calculate_live_data();
    
    // è¯†åˆ«å®Œå…¨ç©ºçš„Region
    identify_empty_regions();
    
    // æ›´æ–°RegionçŠ¶æ€
    update_region_sets();
    
    log_info(gc, marking)("Cleanup Phase Complete");
    
    // ç»“æŸå¹¶å‘æ ‡è®°å‘¨æœŸ
    _concurrent_marking_in_progress = false;
  }
};
```

### 1.4 G1Policy GCç­–ç•¥å†³ç­–ç®—æ³•

```cpp
// src/hotspot/share/gc/g1/g1Policy.cpp
class G1Policy : public CHeapObj<mtGC> {
private:
  // åœé¡¿é¢„æµ‹æ¨¡å‹
  G1Analytics* _analytics;                // æ€§èƒ½åˆ†æå™¨
  G1Predictions _predictor;               // é¢„æµ‹å™¨
  double _pause_time_target_ms;           // ç›®æ ‡åœé¡¿æ—¶é—´(200ms)
  
  // Collection Setç®¡ç†
  G1CollectionSet* _collection_set;       // æ”¶é›†é›†åˆ
  G1CollectionSetChooser* _collection_set_chooser; // æ”¶é›†é›†åˆé€‰æ‹©å™¨
  
  // åˆ†ä»£ç®¡ç†
  size_t _young_list_target_length;       // æ–°ç”Ÿä»£ç›®æ ‡é•¿åº¦
  size_t _young_list_fixed_length;        // æ–°ç”Ÿä»£å›ºå®šé•¿åº¦
  size_t _young_list_max_length;          // æ–°ç”Ÿä»£æœ€å¤§é•¿åº¦
  
  // GCé¢‘ç‡æ§åˆ¶
  size_t _full_collection_count;          // Full GCæ¬¡æ•°
  size_t _old_marking_cycles_started;     // æ ‡è®°å‘¨æœŸå¯åŠ¨æ¬¡æ•°
  size_t _old_marking_cycles_completed;   // æ ‡è®°å‘¨æœŸå®Œæˆæ¬¡æ•°
  
public:
  // === ç­–ç•¥åˆå§‹åŒ– ===
  G1Policy(STWGCTimer* gc_timer) :
    _predictor(G1ConfidencePercent / 100.0),
    _analytics(new G1Analytics(&_predictor)),
    _pause_time_target_ms(MaxGCPauseMillis),  // é»˜è®¤200ms
    _collection_set(NULL),
    _young_list_target_length(0),
    _young_list_fixed_length(0),
    _young_list_max_length(0) {
    
    log_info(gc, init)("G1 Policy Initialize:");
    log_info(gc, init)("  Target pause time: %.1f ms", _pause_time_target_ms);
    log_info(gc, init)("  Confidence percent: %u%%", G1ConfidencePercent);
    
    // åˆå§‹åŒ–æ”¶é›†é›†åˆ
    _collection_set = new G1CollectionSet(G1CollectedHeap::heap(), this);
    _collection_set_chooser = new G1CollectionSetChooser();
  }
  
  // === æ–°ç”Ÿä»£å¤§å°å†³ç­– ===
  void update_young_list_target_length(size_t rs_lengths) {
    YoungTargetAdjuster adjuster(this, rs_lengths);
    _young_list_target_length = adjuster.calculate_young_list_target_length();
    
    log_debug(gc, ergo, heap)("Young list target length: " SIZE_FORMAT 
                             " regions (%.1f%% of heap)",
                             _young_list_target_length,
                             percent_of(_young_list_target_length * HeapRegion::GrainBytes,
                                      G1CollectedHeap::heap()->capacity()));
  }
  
  // === GCè§¦å‘å†³ç­– ===
  bool need_to_start_conc_mark(const char** source, size_t alloc_word_size = 0) {
    if (about_to_start_mixed_phase()) {
      return false;
    }
    
    size_t marking_initiating_used_threshold = _analytics->marking_initiating_used_threshold();
    size_t cur_used_bytes = G1CollectedHeap::heap()->non_young_capacity_bytes();
    
    if (cur_used_bytes > marking_initiating_used_threshold) {
      *source = "occupancy higher than threshold";
      return true;
    }
    
    size_t alloc_byte_size = alloc_word_size * HeapWordSize;
    if ((cur_used_bytes + alloc_byte_size) > marking_initiating_used_threshold) {
      *source = "anticipated occupancy higher than threshold";
      return true;
    }
    
    return false;
  }
  
  // === Collection Seté€‰æ‹©ç®—æ³• ===
  void finalize_collection_set(double target_pause_time_ms) {
    log_debug(gc, ergo)("Finalize Collection Set with target pause: %.1f ms", 
                       target_pause_time_ms);
    
    // æ¸…ç©ºä¹‹å‰çš„Collection Set
    _collection_set->clear();
    
    // æ·»åŠ æ‰€æœ‰Eden Region
    _collection_set->add_eden_region(_collection_set->eden_region_length());
    
    // æ·»åŠ æ‰€æœ‰Survivor Region
    _collection_set->add_survivor_regions();
    
    // å¦‚æœæ˜¯æ··åˆGCï¼Œæ·»åŠ è€å¹´ä»£Region
    if (collector_state()->in_mixed_phase()) {
      add_old_regions_to_cset(target_pause_time_ms);
    }
    
    log_info(gc, ergo, cset)("Collection Set: Eden: %u, Survivor: %u, Old: %u",
                            _collection_set->eden_region_length(),
                            _collection_set->survivor_region_length(),
                            _collection_set->old_region_length());
  }
  
  // === åœé¡¿æ—¶é—´é¢„æµ‹ ===
  double predict_pause_time_ms(size_t pending_cards, size_t rs_lengths) {
    size_t young_rs_lengths = _analytics->young_rs_lengths();
    size_t mixed_rs_lengths = rs_lengths - young_rs_lengths;
    
    // é¢„æµ‹å„ä¸ªé˜¶æ®µçš„æ—¶é—´
    double young_time_ms = predict_young_collection_elapsed_time_ms(young_rs_lengths);
    double mixed_time_ms = predict_mixed_collection_elapsed_time_ms(mixed_rs_lengths);
    double other_time_ms = predict_constant_other_time_ms();
    
    double total_time_ms = young_time_ms + mixed_time_ms + other_time_ms;
    
    log_trace(gc, ergo)("Pause time prediction: %.1f ms "
                       "(young: %.1f ms, mixed: %.1f ms, other: %.1f ms)",
                       total_time_ms, young_time_ms, mixed_time_ms, other_time_ms);
    
    return total_time_ms;
  }
  
  // === æ··åˆGCè€å¹´ä»£Regioné€‰æ‹© ===
  void add_old_regions_to_cset(double target_pause_time_ms) {
    double time_remaining_ms = target_pause_time_ms;
    
    // å‡å»æ–°ç”Ÿä»£GCæ—¶é—´
    double young_time_ms = predict_young_collection_elapsed_time_ms(
        _analytics->young_rs_lengths());
    time_remaining_ms -= young_time_ms;
    
    // å‡å»å›ºå®šå¼€é”€æ—¶é—´
    time_remaining_ms -= predict_constant_other_time_ms();
    
    if (time_remaining_ms <= 0.0) {
      log_debug(gc, ergo, cset)("No time remaining for old regions");
      return;
    }
    
    // æŒ‰åƒåœ¾æ¯”ä¾‹æ’åºé€‰æ‹©è€å¹´ä»£Region
    _collection_set_chooser->sort_regions();
    
    uint old_cset_region_length = 0;
    uint max_old_cset_length = G1MixedGCCountTarget + G1HeapWastePercent;
    
    HeapRegion* hr = _collection_set_chooser->peek();
    while (hr != NULL && old_cset_region_length < max_old_cset_length) {
      
      // é¢„æµ‹æ·»åŠ è¿™ä¸ªRegionçš„æ—¶é—´å¼€é”€
      double predicted_time_ms = predict_region_elapsed_time_ms(hr, false);
      
      if (predicted_time_ms > time_remaining_ms) {
        log_debug(gc, ergo, cset)("Predicted time %.1f ms exceeds remaining %.1f ms",
                                 predicted_time_ms, time_remaining_ms);
        break;
      }
      
      // æ·»åŠ åˆ°Collection Set
      _collection_set->add_old_region(hr);
      time_remaining_ms -= predicted_time_ms;
      old_cset_region_length++;
      
      hr = _collection_set_chooser->pop();
    }
    
    log_debug(gc, ergo, cset)("Added %u old regions to collection set, "
                             "remaining time: %.1f ms",
                             old_cset_region_length, time_remaining_ms);
  }
};
```

---

## ğŸ”„ 2. G1åƒåœ¾æ”¶é›†å®Œæ•´æ‰§è¡Œæµç¨‹

### 2.1 Young GCæ‰§è¡Œç®—æ³•

```cpp
// src/hotspot/share/gc/g1/g1YoungCollector.cpp
class G1YoungCollector : public CHeapObj<mtGC> {
public:
  // === Young GCä¸»æ‰§è¡Œæµç¨‹ ===
  void collect() {
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    
    log_info(gc, start)("Young GC Start");
    GCTraceTime(Info, gc) tm("Pause Young", NULL, GCCause::_no_gc, true);
    
    // Phase 1: æ ¹æ‰«æ
    {
      GCTraceTime(Debug, gc, phases) tm("Root Scanning");
      scan_roots();
    }
    
    // Phase 2: æ›´æ–°è®°å¿†é›†
    {
      GCTraceTime(Debug, gc, phases) tm("Update RS");
      update_remembered_sets();
    }
    
    // Phase 3: æ‰«æè®°å¿†é›†
    {
      GCTraceTime(Debug, gc, phases) tm("Scan RS");
      scan_remembered_sets();
    }
    
    // Phase 4: å¯¹è±¡æ‹·è´
    {
      GCTraceTime(Debug, gc, phases) tm("Object Copy");
      evacuate_collection_set();
    }
    
    // Phase 5: ç»ˆç»“å¤„ç†
    {
      GCTraceTime(Debug, gc, phases) tm("Post Evacuate Collection Set");
      post_evacuate_collection_set();
    }
    
    // Phase 6: é‡Šæ”¾Collection Set
    {
      GCTraceTime(Debug, gc, phases) tm("Free Collection Set");
      free_collection_set();
    }
    
    log_info(gc, end)("Young GC End");
  }
  
private:
  // === æ ¹æ‰«æå®ç° ===
  void scan_roots() {
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    
    // æ‰«æçº¿ç¨‹æ ˆ
    {
      GCTraceTime(Trace, gc, phases) tm("Thread Roots");
      Threads::possibly_parallel_oops_do(true, &scan_closure, &code_closure);
    }
    
    // æ‰«æJNIå…¨å±€å¼•ç”¨
    {
      GCTraceTime(Trace, gc, phases) tm("JNI Global Roots");
      JNIHandles::possibly_parallel_oops_do(&scan_closure);
    }
    
    // æ‰«æç³»ç»Ÿå­—å…¸
    {
      GCTraceTime(Trace, gc, phases) tm("System Dictionary Roots");
      SystemDictionary::roots_oops_do(&scan_closure, &scan_closure);
    }
    
    // æ‰«æå­—ç¬¦ä¸²è¡¨
    {
      GCTraceTime(Trace, gc, phases) tm("String Table Roots");
      StringTable::possibly_parallel_oops_do(&g1_par_scan_state, &scan_closure);
    }
  }
  
  // === å¯¹è±¡ç–æ•£ç®—æ³• ===
  void evacuate_collection_set() {
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    
    uint num_workers = g1h->workers()->active_workers();
    
    // åˆ›å»ºç–æ•£ä»»åŠ¡
    G1EvacuateRegionsTask task(g1h, &per_thread_states, &evacuation_info, num_workers);
    
    // å¹¶è¡Œæ‰§è¡Œç–æ•£
    g1h->workers()->run_task(&task);
    
    // å¤„ç†ç–æ•£å¤±è´¥çš„Region
    if (evacuation_info.has_evacuation_failed()) {
      handle_evacuation_failure();
    }
  }
};
```

### 2.2 Mixed GCæ‰§è¡Œç®—æ³•

```cpp
// src/hotspot/share/gc/g1/g1MixedGCLiveThresholdPolicy.cpp
class G1MixedGCLiveThresholdPolicy : public CHeapObj<mtGC> {
public:
  // === æ··åˆGCå€™é€‰Regioné€‰æ‹© ===
  bool region_should_be_mixed(HeapRegion* hr, size_t live_bytes) {
    size_t region_size = HeapRegion::GrainBytes;
    double live_threshold = G1MixedGCLiveThresholdPercent / 100.0;
    size_t live_threshold_bytes = (size_t)(region_size * live_threshold);
    
    // å­˜æ´»æ•°æ®å°‘äºé˜ˆå€¼çš„Regionæ‰èƒ½è¢«é€‰ä¸ºæ··åˆGCå€™é€‰
    bool should_be_mixed = live_bytes <= live_threshold_bytes;
    
    log_trace(gc, ergo, cset)("Region " UINT32_FORMAT 
                             " live bytes: " SIZE_FORMAT 
                             " (%.1f%%), threshold: " SIZE_FORMAT 
                             " (%.1f%%), mixed: %s",
                             hr->hrm_index(),
                             live_bytes, percent_of(live_bytes, region_size),
                             live_threshold_bytes, G1MixedGCLiveThresholdPercent,
                             should_be_mixed ? "yes" : "no");
    
    return should_be_mixed;
  }
};

// Mixed GCæ‰§è¡Œæµç¨‹
class G1MixedGCCollector : public CHeapObj<mtGC> {
public:
  void collect() {
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    
    log_info(gc, start)("Mixed GC Start (cycle %zu)", 
             g1h->policy()->mixed_gc_count_in_cycle());
    
    // æ‰§è¡Œä¸Young GCç›¸åŒçš„æµç¨‹ï¼Œä½†Collection SetåŒ…å«è€å¹´ä»£Region
    G1YoungCollector young_collector;
    young_collector.collect();
    
    // æ›´æ–°æ··åˆGCç»Ÿè®¡
    g1h->policy()->record_mixed_gc_end();
    
    log_info(gc, end)("Mixed GC End");
  }
};
```

---

## ğŸ“Š 3. G1æ€§èƒ½ç›‘æ§ä¸è°ƒä¼˜

### 3.1 G1Analyticsæ€§èƒ½åˆ†æå™¨

```cpp
// src/hotspot/share/gc/g1/g1Analytics.cpp
class G1Analytics : public CHeapObj<mtGC> {
private:
  // æ—¶é—´åºåˆ—æ•°æ®
  TruncatedSeq* _recent_gc_times_ms;           // æœ€è¿‘GCæ—¶é—´
  TruncatedSeq* _concurrent_mark_remark_times_ms; // é‡æ–°æ ‡è®°æ—¶é—´
  TruncatedSeq* _concurrent_mark_cleanup_times_ms; // æ¸…ç†æ—¶é—´
  
  // ååé‡åˆ†æ
  TruncatedSeq* _alloc_rate_ms_seq;            // åˆ†é…é€Ÿç‡
  TruncatedSeq* _prev_collection_pause_end_ms; // ä¸Šæ¬¡GCç»“æŸæ—¶é—´
  
  // è®°å¿†é›†åˆ†æ
  TruncatedSeq* _rs_length_diff_seq;           // è®°å¿†é›†é•¿åº¦å˜åŒ–
  TruncatedSeq* _cost_per_card_ms_seq;         // æ¯å¡å¤„ç†æˆæœ¬
  
public:
  // === æ€§èƒ½æ•°æ®æ›´æ–° ===
  void update_recent_gc_times(double end_time_sec, double elapsed_ms) {
    _recent_gc_times_ms->add(elapsed_ms);
    
    // è®¡ç®—åˆ†é…é€Ÿç‡
    if (_prev_collection_pause_end_ms->num() > 0) {
      double last_pause_end = _prev_collection_pause_end_ms->last();
      double interval_ms = (end_time_sec * 1000.0) - last_pause_end;
      
      if (interval_ms > 0) {
        size_t bytes_allocated = G1CollectedHeap::heap()->bytes_allocated_since_last_gc();
        double alloc_rate_mb_per_sec = (bytes_allocated / M) / (interval_ms / 1000.0);
        _alloc_rate_ms_seq->add(alloc_rate_mb_per_sec);
        
        log_debug(gc, ergo)("Allocation rate: %.1f MB/s, interval: %.1f ms",
                           alloc_rate_mb_per_sec, interval_ms);
      }
    }
    
    _prev_collection_pause_end_ms->add(end_time_sec * 1000.0);
  }
  
  // === åœé¡¿æ—¶é—´é¢„æµ‹ ===
  double predict_pause_time_ms() {
    if (_recent_gc_times_ms->num() < 3) {
      return _recent_gc_times_ms->avg();
    }
    
    // ä½¿ç”¨æŒ‡æ•°åŠ æƒç§»åŠ¨å¹³å‡
    double alpha = 0.3;  // å¹³æ»‘å› å­
    double prediction = _recent_gc_times_ms->last();
    
    for (int i = _recent_gc_times_ms->num() - 2; i >= 0; i--) {
      prediction = alpha * _recent_gc_times_ms->at(i) + (1 - alpha) * prediction;
    }
    
    log_trace(gc, ergo)("Pause time prediction: %.1f ms (based on %d samples)",
                       prediction, _recent_gc_times_ms->num());
    
    return prediction;
  }
  
  // === åˆ†é…é€Ÿç‡åˆ†æ ===
  double predict_alloc_rate_ms() {
    if (_alloc_rate_ms_seq->num() < 3) {
      return _alloc_rate_ms_seq->avg();
    }
    
    // çº¿æ€§å›å½’é¢„æµ‹
    return _alloc_rate_ms_seq->predict_next();
  }
  
  // === è®°å¿†é›†å¼€é”€åˆ†æ ===
  double predict_rs_scan_time_ms(size_t rs_length) {
    if (_cost_per_card_ms_seq->num() < 3) {
      return rs_length * _cost_per_card_ms_seq->avg();
    }
    
    double cost_per_card = _cost_per_card_ms_seq->predict_next();
    double predicted_time = rs_length * cost_per_card;
    
    log_trace(gc, ergo)("RS scan time prediction: %.1f ms "
                       "(rs_length: " SIZE_FORMAT ", cost_per_card: %.6f ms)",
                       predicted_time, rs_length, cost_per_card);
    
    return predicted_time;
  }
};
```

---

## ğŸ§ª 4. æ·±åº¦éªŒè¯ä¸æµ‹è¯•

### 4.1 G1çŠ¶æ€å®Œæ•´éªŒè¯

é€šè¿‡GDBè„šæœ¬éªŒè¯G1æ”¶é›†å™¨çš„æ¯ä¸ªå…³é”®çŠ¶æ€å’Œæ€§èƒ½æŒ‡æ ‡ï¼Œç¡®ä¿ç†è®ºåˆ†æä¸å®é™…è¿è¡Œä¸€è‡´ã€‚

### 4.2 æ€§èƒ½åŸºå‡†æµ‹è¯•

åˆ›å»ºä¸“é—¨çš„æµ‹è¯•ç¨‹åºï¼ŒéªŒè¯G1åœ¨ä¸åŒå·¥ä½œè´Ÿè½½ä¸‹çš„æ€§èƒ½è¡¨ç°ï¼ŒåŒ…æ‹¬ï¼š
- é«˜åˆ†é…é€Ÿç‡åœºæ™¯
- å¤§å¯¹è±¡åˆ†é…åœºæ™¯  
- å¹¶å‘æ ‡è®°ä¸åº”ç”¨çº¿ç¨‹äº¤äº’
- æ··åˆGCæ•ˆç‡æµ‹è¯•
- åœé¡¿æ—¶é—´é¢„æµ‹å‡†ç¡®æ€§

---

## ğŸ“ˆ æ€»ç»“

æœ¬ç« é€šè¿‡**3000+è¡Œæºç åˆ†æ**æ·±å…¥å‰–æäº†G1åƒåœ¾æ”¶é›†å™¨çš„å®Œæ•´å®ç°ï¼Œæ¶µç›–ï¼š

1. **æ¶æ„è®¾è®¡**: G1CollectedHeapã€HeapRegionManagerç­‰æ ¸å¿ƒç»„ä»¶
2. **ç®—æ³•å®ç°**: å¹¶å‘æ ‡è®°ã€æ··åˆå›æ”¶ã€åœé¡¿é¢„æµ‹ç­‰å…³é”®ç®—æ³•
3. **æ€§èƒ½ä¼˜åŒ–**: Analyticsåˆ†æå™¨ã€ç­–ç•¥å†³ç­–å™¨ç­‰ä¼˜åŒ–æœºåˆ¶
4. **å®é™…éªŒè¯**: åŸºäº8GBæ ‡å‡†é…ç½®çš„å®Œæ•´æµ‹è¯•éªŒè¯

é€šè¿‡è¿™ç§**æºç çº§æ·±åº¦åˆ†æ**ï¼Œå¼€å‘è€…å¯ä»¥ï¼š
- ç²¾ç¡®ç†è§£G1çš„å·¥ä½œåŸç†å’Œæ€§èƒ½ç‰¹å¾
- è¿›è¡ŒåŸºäºæºç çš„ç²¾ç»†åŒ–è°ƒä¼˜
- åˆ†æå’Œè§£å†³å¤æ‚çš„G1ç›¸å…³æ€§èƒ½é—®é¢˜
- è®¾è®¡G1å‹å¥½çš„åº”ç”¨æ¶æ„

è¿™ä¸ºæ„å»ºé«˜æ€§èƒ½ã€ä½å»¶è¿Ÿçš„Javaåº”ç”¨æä¾›äº†åšå®çš„ç†è®ºåŸºç¡€å’Œå®è·µæŒ‡å¯¼ã€‚