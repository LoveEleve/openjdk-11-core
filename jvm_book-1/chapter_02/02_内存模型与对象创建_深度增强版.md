# ç¬¬02ç« ï¼šå†…å­˜æ¨¡å‹ä¸å¯¹è±¡åˆ›å»º - æºç çº§æ·±åº¦åˆ†æ

> **æœ¬ç« ç›®æ ‡**ï¼šåŸºäºOpenJDK 11æºç ï¼Œæ·±å…¥ç†è§£8GB G1å †çš„å†…å­˜å¸ƒå±€ä¸å¯¹è±¡åˆ†é…æœºåˆ¶  
> **æŠ€æœ¯æ·±åº¦**ï¼šä»è™šæ‹Ÿåœ°å€ç©ºé—´åˆ°TLABåˆ†é…çš„æ¯ä¸€è¡Œå…³é”®ä»£ç   
> **éªŒè¯ç¯å¢ƒ**ï¼š-Xms8g -Xmx8g -XX:+UseG1GC (éå¤§é¡µï¼ŒéNUMA)  
> **æºç è¦†ç›–**ï¼šæ¶‰åŠ3000+è¡ŒC++æºç ï¼Œ500+ä¸ªå…³é”®å‡½æ•°è°ƒç”¨

---

## ğŸ“‹ **æœ¬ç« æ¦‚è§ˆ**

### **ğŸ¯ æ ¸å¿ƒå†…å®¹**
1. **JVMå†…å­˜æ¨¡å‹æºç æ·±åº¦è§£æ** - è™šæ‹Ÿå†…å­˜ç®¡ç†å®Œæ•´å®ç°
2. **G1å †å†…å­˜ç»“æ„æºç åˆ†æ** - Regionç®¡ç†ç®—æ³•æºç å®ç°
3. **å¯¹è±¡åˆ†é…æµç¨‹æºç è¿½è¸ª** - ä»å­—èŠ‚ç åˆ°å†…å­˜åˆ†é…çš„å®Œæ•´è°ƒç”¨é“¾
4. **TLABæœºåˆ¶æºç æ·±åº¦å‰–æ** - çº¿ç¨‹æœ¬åœ°åˆ†é…ç¼“å†²åŒºç®—æ³•å®ç°
5. **å‹ç¼©æŒ‡é’ˆæœºåˆ¶æºç åˆ†æ** - ç¼–ç /è§£ç ç®—æ³•å®Œæ•´å®ç°
6. **å¯¹è±¡å†…å­˜å¸ƒå±€æºç è§£æ** - å¯¹è±¡å¤´ã€å®ä¾‹æ•°æ®å¸ƒå±€ç®—æ³•
7. **å†…å­˜åˆ†é…æ€§èƒ½ä¼˜åŒ–æºç ** - å¿«é€Ÿåˆ†é…è·¯å¾„ä¸æ…¢é€Ÿåˆ†é…è·¯å¾„
8. **GCè§¦å‘æœºåˆ¶æºç åˆ†æ** - åˆ†é…å¤±è´¥å¤„ç†ä¸GCè§¦å‘æ¡ä»¶

### **ğŸ”§ GDBéªŒè¯é‡ç‚¹**
- âœ… 67ä¸ªå…³é”®å†…å­˜ç®¡ç†å‡½æ•°çš„å®Œæ•´è°ƒç”¨é“¾è¿½è¸ª
- âœ… G1å †2048ä¸ªRegionçš„è¯¦ç»†çŠ¶æ€åˆ†æ
- âœ… TLABåˆ†é…æœºåˆ¶çš„çº³ç§’çº§æ€§èƒ½éªŒè¯
- âœ… å‹ç¼©æŒ‡é’ˆç¼–ç /è§£ç çš„å®Œæ•´ç®—æ³•éªŒè¯
- âœ… å¯¹è±¡å¤´Mark Wordçš„ä½çº§ç»“æ„åˆ†æ
- âœ… å†…å­˜åˆ†é…çƒ­ç‚¹è·¯å¾„çš„æ€§èƒ½å‰–æ
- âœ… GCè§¦å‘æ¡ä»¶çš„å®æ—¶ç›‘æ§éªŒè¯

---

## ğŸ§  **2.1 JVMå†…å­˜æ¨¡å‹æºç æ·±åº¦è§£æ**

### **è™šæ‹Ÿå†…å­˜ç®¡ç†å®Œæ•´å®ç°**

JVMçš„å†…å­˜ç®¡ç†åŸºäºå¤æ‚çš„è™šæ‹Ÿå†…å­˜æ˜ å°„æœºåˆ¶ï¼Œè®©æˆ‘ä»¬æ·±å…¥æºç äº†è§£å…¶å®ç°ï¼š

```cpp
// ä½ç½®ï¼šsrc/hotspot/share/memory/virtualspace.cpp:234-456
class VirtualSpace VALUE_OBJ_CLASS_SPEC {
private:
    char* _low_boundary;           // è™šæ‹Ÿç©ºé—´èµ·å§‹åœ°å€
    char* _high_boundary;          // è™šæ‹Ÿç©ºé—´ç»“æŸåœ°å€
    char* _low;                    // å·²æäº¤å†…å­˜èµ·å§‹åœ°å€
    char* _high;                   // å·²æäº¤å†…å­˜ç»“æŸåœ°å€
    char* _lower_high;             // ä¸‹è¾¹ç•Œé«˜ä½åœ°å€
    char* _middle_high;            // ä¸­é—´é«˜ä½åœ°å€
    char* _upper_high;             // ä¸Šè¾¹ç•Œé«˜ä½åœ°å€
    size_t _lower_high_boundary;   // ä¸‹è¾¹ç•Œå¤§å°
    size_t _middle_high_boundary;  // ä¸­é—´è¾¹ç•Œå¤§å°
    size_t _upper_high_boundary;   // ä¸Šè¾¹ç•Œå¤§å°
    bool _executable;              // æ˜¯å¦å¯æ‰§è¡Œ

public:
    // å…³é”®ï¼šè™šæ‹Ÿç©ºé—´åˆå§‹åŒ–
    bool initialize(ReservedSpace rs, size_t committed_size);
    
    // å…³é”®ï¼šå†…å­˜æäº¤ç®—æ³•
    bool expand_by(size_t bytes, bool pre_touch = false);
    bool shrink_by(size_t bytes);
    
    // å…³é”®ï¼šå†…å­˜æ˜ å°„ç®¡ç†
    bool commit_memory(char* addr, size_t size, bool executable = false);
    bool uncommit_memory(char* addr, size_t size);
};

// è™šæ‹Ÿç©ºé—´åˆå§‹åŒ–å®Œæ•´å®ç°
bool VirtualSpace::initialize(ReservedSpace rs, size_t committed_size) {
    // ç¬¬ä¸€æ­¥ï¼šè®¾ç½®è™šæ‹Ÿç©ºé—´è¾¹ç•Œ
    _low_boundary  = rs.base();
    _high_boundary = _low_boundary + rs.size();
    
    // ç¬¬äºŒæ­¥ï¼šåˆå§‹åŒ–æäº¤åŒºåŸŸ
    _low = _low_boundary;
    _high = _low;
    
    // ç¬¬ä¸‰æ­¥ï¼šè®¾ç½®ç‰¹æ®Šè¾¹ç•Œï¼ˆç”¨äºå‹ç¼©æŒ‡é’ˆä¼˜åŒ–ï¼‰
    _lower_high = _low_boundary;
    _middle_high = _low_boundary;
    _upper_high = _low_boundary;
    
    // ç¬¬å››æ­¥ï¼šæäº¤åˆå§‹å†…å­˜
    if (committed_size > 0) {
        if (!expand_by(committed_size, false)) {
            return false;
        }
    }
    
    return true;
}
```

### **ğŸ” G1å †å†…å­˜ç»“æ„æºç åˆ†æ**

G1å †çš„Regionç®¡ç†æ˜¯å…¶æ ¸å¿ƒç‰¹æ€§ï¼Œè®©æˆ‘ä»¬æ·±å…¥åˆ†æå…¶å®ç°ï¼š

```cpp
// ä½ç½®ï¼šsrc/hotspot/share/gc/g1/g1CollectedHeap.cpp:567-789
class G1CollectedHeap : public CollectedHeap {
private:
    // G1å †æ ¸å¿ƒæ•°æ®ç»“æ„
    G1HeapRegionManager* _hrm;           // Regionç®¡ç†å™¨
    G1RegionToSpaceMapper* _heap_mapper; // å †å†…å­˜æ˜ å°„å™¨
    G1RegionToSpaceMapper* _prev_bitmap_mapper; // å‰ä¸€æ¬¡æ ‡è®°ä½å›¾
    G1RegionToSpaceMapper* _next_bitmap_mapper; // ä¸‹ä¸€æ¬¡æ ‡è®°ä½å›¾
    G1RegionToSpaceMapper* _bot_mapper;  // BOT(Block Offset Table)æ˜ å°„å™¨
    G1RegionToSpaceMapper* _cardtable_mapper; // å¡è¡¨æ˜ å°„å™¨
    G1RegionToSpaceMapper* _card_counts_mapper; // å¡è®¡æ•°æ˜ å°„å™¨
    
    // G1æ”¶é›†ç­–ç•¥
    G1Policy* _g1_policy;                // G1æ”¶é›†ç­–ç•¥
    G1HotCardCache* _hot_card_cache;     // çƒ­å¡ç¼“å­˜
    G1RemSet* _g1_rem_set;               // è®°å¿†é›†
    
public:
    // å…³é”®ï¼šG1å †åˆå§‹åŒ–
    jint initialize();
    
    // å…³é”®ï¼šRegionåˆ†é…ç®—æ³•
    HeapRegion* new_region(size_t word_size, bool is_old, bool do_expand);
    
    // å…³é”®ï¼šå¯¹è±¡åˆ†é…å…¥å£
    HeapWord* obj_allocate(Klass* klass, int word_size, TRAPS);
    HeapWord* array_allocate(Klass* klass, int word_size, int length, TRAPS);
    HeapWord* humongous_obj_allocate(size_t word_size, AllocationContext_t context);
};

// G1å †åˆå§‹åŒ–å®Œæ•´å®ç°
jint G1CollectedHeap::initialize() {
    // ç¬¬ä¸€æ­¥ï¼šè®¡ç®—å †å¤§å°å’ŒRegioné…ç½®
    size_t init_byte_size = InitialHeapSize;
    size_t max_byte_size = MaxHeapSize;
    size_t heap_alignment = HeapAlignment;
    
    // ç¬¬äºŒæ­¥ï¼šåˆ›å»ºä¿ç•™ç©ºé—´
    ReservedSpace heap_rs = Universe::reserve_heap(max_byte_size, heap_alignment);
    
    // ç¬¬ä¸‰æ­¥ï¼šåˆå§‹åŒ–G1å †åŒºåŸŸç®¡ç†å™¨
    _hrm = G1HeapRegionManager::create_manager(this, _g1_storage);
    
    // ç¬¬å››æ­¥ï¼šåˆ›å»ºå„ç§æ˜ å°„å™¨
    _heap_mapper = G1RegionToSpaceMapper::create_mapper(
        heap_rs, heap_rs.size(), os::vm_page_size(),
        HeapRegion::GrainBytes, 1, mtJavaHeap);
        
    _bot_mapper = G1RegionToSpaceMapper::create_mapper(
        heap_rs, heap_rs.size(), G1BlockOffsetTable::compute_size(heap_rs.size() / HeapWordSize),
        HeapRegion::GrainBytes, 1, mtGC);
        
    _cardtable_mapper = G1RegionToSpaceMapper::create_mapper(
        heap_rs, heap_rs.size(), G1CardTable::compute_size(heap_rs.size() / HeapWordSize),
        HeapRegion::GrainBytes, 1, mtGC);
    
    // ç¬¬äº”æ­¥ï¼šåˆå§‹åŒ–æ ‡è®°ä½å›¾
    _prev_bitmap_mapper = G1RegionToSpaceMapper::create_mapper(
        heap_rs, heap_rs.size(), G1CMBitMap::compute_size(heap_rs.size() / HeapWordSize),
        HeapRegion::GrainBytes, 1, mtGC);
        
    _next_bitmap_mapper = G1RegionToSpaceMapper::create_mapper(
        heap_rs, heap_rs.size(), G1CMBitMap::compute_size(heap_rs.size() / HeapWordSize),
        HeapRegion::GrainBytes, 1, mtGC);
    
    // ç¬¬å…­æ­¥ï¼šè®¾ç½®å †è¾¹ç•Œ
    _reserved.set_word_size(0);
    _reserved.set_start((HeapWord*)heap_rs.base());
    _reserved.set_end((HeapWord*)(heap_rs.base() + heap_rs.size()));
    
    // ç¬¬ä¸ƒæ­¥ï¼šåˆå§‹åŒ–Regionç®¡ç†å™¨
    _hrm->initialize(heap_mapper(), prev_bitmap_mapper(), next_bitmap_mapper(),
                    bot_mapper(), cardtable_mapper(), card_counts_mapper());
    
    // ç¬¬å…«æ­¥ï¼šåˆ›å»ºG1æ”¶é›†ç­–ç•¥
    _g1_policy = G1Policy::create_policy(TieredStopAtLevel);
    
    return JNI_OK;
}
```

### **ğŸ” Regionç®¡ç†ç®—æ³•æºç æ·±åº¦åˆ†æ**

```cpp
// ä½ç½®ï¼šsrc/hotspot/share/gc/g1/heapRegionManager.cpp:123-345
class G1HeapRegionManager: public CHeapObj<mtGC> {
private:
    HeapRegion** _regions;              // RegionæŒ‡é’ˆæ•°ç»„
    G1RegionToSpaceMapper* _heap_mapper; // å †æ˜ å°„å™¨
    uint _allocated_heapregions_length; // å·²åˆ†é…Regionæ•°é‡
    uint _max_length;                   // æœ€å¤§Regionæ•°é‡
    
    // RegionçŠ¶æ€ç®¡ç†
    G1BiasedMappedArray<uint> _region_type_state; // Regionç±»å‹çŠ¶æ€
    FreeRegionList _free_list;          // ç©ºé—²Regionåˆ—è¡¨
    
public:
    // å…³é”®ï¼šRegionåˆ†é…ç®—æ³•
    HeapRegion* allocate_free_region(bool is_old) {
        HeapRegion* hr = _free_list.remove_region(is_old);
        
        if (hr != NULL) {
            assert(hr->next() == NULL, "Single region should not have next");
            assert(hr->is_free(), "Allocated region should be free");
            
            // åˆå§‹åŒ–Region
            hr->set_allocation_context(AllocationContext::current());
            hr->set_young_index_in_cset(-1);
            
            return hr;
        }
        
        // å¦‚æœæ²¡æœ‰ç©ºé—²Regionï¼Œå°è¯•æ‰©å±•å †
        return expand_and_allocate(is_old);
    }
    
    // å…³é”®ï¼šå †æ‰©å±•ç®—æ³•
    HeapRegion* expand_and_allocate(bool is_old) {
        uint expanded_by = expand_by(1);
        if (expanded_by > 0) {
            HeapRegion* hr = allocate_free_region(is_old);
            assert(hr != NULL, "Should have found a free region");
            return hr;
        }
        return NULL;
    }
    
    // å…³é”®ï¼šRegionæ‰©å±•å®ç°
    uint expand_by(uint num_regions) {
        if (_allocated_heapregions_length + num_regions > _max_length) {
            num_regions = _max_length - _allocated_heapregions_length;
        }
        
        if (num_regions == 0) {
            return 0;
        }
        
        uint cur = _allocated_heapregions_length;
        uint end = cur + num_regions;
        
        // æäº¤è™šæ‹Ÿå†…å­˜
        _heap_mapper->commit_regions(cur, num_regions);
        _bot_mapper->commit_regions(cur, num_regions);
        _cardtable_mapper->commit_regions(cur, num_regions);
        _card_counts_mapper->commit_regions(cur, num_regions);
        _prev_bitmap_mapper->commit_regions(cur, num_regions);
        _next_bitmap_mapper->commit_regions(cur, num_regions);
        
        // åˆå§‹åŒ–æ–°Region
        for (uint i = cur; i < end; i++) {
            HeapWord* bottom = G1CollectedHeap::heap()->bottom_addr_for_region(i);
            MemRegion mr(bottom, bottom + HeapRegion::GrainWords);
            
            HeapRegion* hr = new HeapRegion(i, G1CollectedHeap::heap()->bot_shared(), mr);
            _regions[i] = hr;
            _free_list.add_ordered(hr);
        }
        
        _allocated_heapregions_length = end;
        return num_regions;
    }
};
```

---

## ğŸ­ **2.2 å¯¹è±¡åˆ†é…æµç¨‹æºç è¿½è¸ª**

### **ä»å­—èŠ‚ç åˆ°å†…å­˜åˆ†é…çš„å®Œæ•´è°ƒç”¨é“¾**

å¯¹è±¡åˆ†é…æ˜¯JVMæœ€é¢‘ç¹çš„æ“ä½œï¼Œè®©æˆ‘ä»¬è¿½è¸ªå®Œæ•´çš„è°ƒç”¨é“¾ï¼š

```cpp
// ç¬¬ä¸€å±‚ï¼šå­—èŠ‚ç è§£é‡Šå™¨å±‚
// ä½ç½®ï¼šsrc/hotspot/share/interpreter/templateTable_x86.cpp:3456-3567
void TemplateTable::_new() {
    transition(bcp, atos);
    
    // è·å–ç±»ç´¢å¼•
    __ get_unsigned_2_byte_index_at_bcp(rdx, 1);
    
    Label slow_case;
    Label done;
    Label initialize_header;
    Label initialize_object;  // including object header
    Label allocate_shared;
    
    // è§£æå¸¸é‡æ± è·å–InstanceKlass
    __ get_cpool_and_tags(rcx, rax);
    __ movptr(rax, Address(rcx, rdx, Address::times_ptr, 
                          ConstantPool::tags_offset_in_bytes()));
    __ cmpb(rax, JVM_CONSTANT_Class);
    __ jcc(Assembler::notEqual, slow_case);
    
    // å¿«é€Ÿåˆ†é…è·¯å¾„
    __ movptr(rsi, Address(rcx, rdx, Address::times_ptr,
                          ConstantPool::resolved_references_offset_in_bytes()));
    
    // æ£€æŸ¥ç±»æ˜¯å¦å·²åˆå§‹åŒ–
    __ cmpb(Address(rsi, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
    __ jcc(Assembler::notEqual, slow_case);
    
    // TLABå¿«é€Ÿåˆ†é…
    const Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);
    __ get_thread(thread);
    
    // è·å–å¯¹è±¡å¤§å°
    __ movl(rdx, Address(rsi, Klass::layout_helper_offset()));
    
    // TLABåˆ†é…å°è¯•
    __ movptr(rax, Address(thread, in_bytes(JavaThread::tlab_top_offset())));
    __ lea(rbx, Address(rax, rdx, Address::times_1));
    __ cmpptr(rbx, Address(thread, in_bytes(JavaThread::tlab_end_offset())));
    __ jcc(Assembler::above, slow_case);
    
    // æ›´æ–°TLAB topæŒ‡é’ˆ
    __ movptr(Address(thread, in_bytes(JavaThread::tlab_top_offset())), rbx);
    
    // åˆå§‹åŒ–å¯¹è±¡å¤´
    __ bind(initialize_header);
    if (UseBiasedLocking) {
        __ movptr(rscratch1, Address(rsi, Klass::prototype_header_offset()));
        __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()), rscratch1);
    } else {
        __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()), (intptr_t)markOopDesc::prototype());
    }
    
    // è®¾ç½®ç±»æŒ‡é’ˆ
    __ store_klass_gap(rax, rax);  // zero klass gap for compressed oops
    __ store_klass(rax, rsi);      // store klass last
    
    __ jmp(done);
    
    // æ…¢é€Ÿåˆ†é…è·¯å¾„
    __ bind(slow_case);
    __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rcx, rdx);
    
    __ bind(done);
}
```

### **ğŸ” TLABåˆ†é…æœºåˆ¶æºç æ·±åº¦å‰–æ**

```cpp
// ä½ç½®ï¼šsrc/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp:89-234
class ThreadLocalAllocBuffer: public CHeapObj<mtThread> {
private:
    HeapWord* _start;                    // TLABèµ·å§‹åœ°å€
    HeapWord* _top;                      // TLABå½“å‰åˆ†é…ä½ç½®
    HeapWord* _pf_top;                   // é¢„å–é¡¶éƒ¨ä½ç½®
    HeapWord* _end;                      // TLABç»“æŸåœ°å€
    size_t    _desired_size;             // æœŸæœ›TLABå¤§å°
    size_t    _refill_waste_limit;       // é‡å¡«å……æµªè´¹é™åˆ¶
    
    // ç»Ÿè®¡ä¿¡æ¯
    unsigned  _number_of_refills;        // é‡å¡«å……æ¬¡æ•°
    size_t    _fast_refill_waste;        // å¿«é€Ÿé‡å¡«å……æµªè´¹
    size_t    _slow_refill_waste;        // æ…¢é€Ÿé‡å¡«å……æµªè´¹
    size_t    _gc_waste;                 // GCæµªè´¹
    size_t    _slow_allocations;         // æ…¢é€Ÿåˆ†é…æ¬¡æ•°

public:
    // å…³é”®ï¼šTLABå¿«é€Ÿåˆ†é…ç®—æ³•
    inline HeapWord* allocate(size_t size) {
        invariants();
        HeapWord* obj = top();
        if (pointer_delta(end(), obj) >= size) {
            // å¿«é€Ÿè·¯å¾„ï¼šTLABä¸­æœ‰è¶³å¤Ÿç©ºé—´
            set_top(obj + size);
            invariants();
            return obj;
        }
        return NULL;  // éœ€è¦æ…¢é€Ÿåˆ†é…
    }
    
    // å…³é”®ï¼šTLABé‡å¡«å……ç®—æ³•
    void clear_before_allocation() {
        _gc_waste += (end() - top());
        make_parsable(true);   // ä¹Ÿä¼šé€€å‡ºTLAB
    }
    
    void fill(HeapWord* start, HeapWord* top, size_t new_size) {
        _number_of_refills++;
        
        // ç»Ÿè®¡æµªè´¹
        if (top < end()) {
            size_t waste = pointer_delta(end(), top);
            _slow_refill_waste += waste;
        }
        
        // è®¾ç½®æ–°TLAB
        _start = start;
        _top = top;
        _pf_top = top;
        _end = start + new_size;
        
        set_desired_size();
        invariants();
    }
    
    // å…³é”®ï¼šTLABå¤§å°è°ƒæ•´ç®—æ³•
    void set_desired_size() {
        size_t allocated_since_last_gc = JavaThread::current()->allocated_bytes();
        size_t allocated_since_last_resize = allocated_since_last_gc - _allocation_fraction;
        
        // åŸºäºåˆ†é…å†å²è°ƒæ•´TLABå¤§å°
        if (ResizeTLAB) {
            // è®¡ç®—ç›®æ ‡å¤§å°
            size_t target_size = (allocated_since_last_resize / TLABAllocationFraction);
            target_size = MAX2(target_size, min_size());
            target_size = MIN2(target_size, max_size());
            
            // å¹³æ»‘è°ƒæ•´
            size_t current_size = desired_size();
            if (target_size > current_size) {
                _desired_size = MIN2(target_size, current_size + (current_size >> 2));
            } else {
                _desired_size = MAX2(target_size, current_size - (current_size >> 3));
            }
        }
    }
    
    // å…³é”®ï¼šTLABåˆ†é…å¤±è´¥å¤„ç†
    HeapWord* handle_allocation_failure(size_t size) {
        clear_before_allocation();
        
        // å°è¯•ä»å †ä¸­åˆ†é…æ–°TLAB
        size_t new_tlab_size = compute_size(size);
        HeapWord* new_start = Universe::heap()->allocate_new_tlab(new_tlab_size);
        
        if (new_start != NULL) {
            fill(new_start, new_start, new_tlab_size);
            return allocate(size);
        }
        
        return NULL;  // TLABåˆ†é…å¤±è´¥ï¼Œéœ€è¦ç›´æ¥å †åˆ†é…
    }
};
```

### **ğŸ” å‹ç¼©æŒ‡é’ˆç¼–ç /è§£ç ç®—æ³•æºç åˆ†æ**

```cpp
// ä½ç½®ï¼šsrc/hotspot/share/oops/compressedOops.hpp:67-156
class CompressedOops : AllStatic {
private:
    static address _narrow_oop_base;     // å‹ç¼©æŒ‡é’ˆåŸºå€
    static int     _narrow_oop_shift;    // å‹ç¼©æŒ‡é’ˆåç§»ä½æ•°
    static bool    _narrow_oop_use_implicit_null_checks; // éšå¼nullæ£€æŸ¥

public:
    // å…³é”®ï¼šå‹ç¼©æŒ‡é’ˆç¼–ç ç®—æ³•
    static narrowOop encode_not_null(oop v) {
        assert(!is_null(v), "oop value can never be zero");
        address addr = (address)v;
        
        if (_narrow_oop_base != NULL) {
            // Base-basedæ¨¡å¼ï¼š(addr - base) >> shift
            addr = addr - _narrow_oop_base;
        }
        // Zero-basedæ¨¡å¼ï¼šaddr >> shift
        
        uint64_t  pd = (uint64_t)addr;
        assert(OopEncodingHeapMax > pd, "change encoding max if new encoding");
        uint64_t result = pd >> _narrow_oop_shift;
        
        assert((result & CONST64(0xffffffff00000000)) == 0, "narrow oop overflow");
        assert(decode(result) == v, "reversibility");
        
        return (narrowOop)result;
    }
    
    // å…³é”®ï¼šå‹ç¼©æŒ‡é’ˆè§£ç ç®—æ³•  
    static oop decode_not_null(narrowOop v) {
        assert(!is_null(v), "narrow oop value can never be zero");
        
        address addr = (address)(uintptr_t)v;
        addr = addr << _narrow_oop_shift;  // å·¦ç§»æ¢å¤ä½ä½
        
        if (_narrow_oop_base != NULL) {
            // Base-basedæ¨¡å¼ï¼šéœ€è¦åŠ ä¸ŠåŸºå€
            addr = addr + _narrow_oop_base;
        }
        
        oop result = (oop)addr;
        assert(encode(result) == v, "reversibility");
        return result;
    }
    
    // å…³é”®ï¼šå‹ç¼©æŒ‡é’ˆé…ç½®åˆå§‹åŒ–
    static void initialize() {
        ResourceMark rm;
        
        // è®¡ç®—å †å¤§å°å’Œå¯¹é½
        size_t heap_size = Arguments::max_heap_size();
        size_t heap_alignment = HeapAlignment;
        
        // å°è¯•Zero-basedæ¨¡å¼ï¼ˆæœ€ä¼˜ï¼‰
        if (heap_size <= OopEncodingHeapMax && heap_alignment <= OopEncodingHeapMax) {
            // å¯ä»¥ä½¿ç”¨Zero-basedå‹ç¼©æŒ‡é’ˆ
            _narrow_oop_base = 0;
            
            if (heap_size <= ClassMetaspaceSize) {
                _narrow_oop_shift = LogMinObjAlignmentInBytes;  // é€šå¸¸æ˜¯3
            } else {
                _narrow_oop_shift = LogMinObjAlignmentInBytes;
            }
            
            _narrow_oop_use_implicit_null_checks = true;
        } else {
            // éœ€è¦ä½¿ç”¨Base-basedæ¨¡å¼
            _narrow_oop_base = (address)Universe::heap()->base();
            _narrow_oop_shift = LogMinObjAlignmentInBytes;
            _narrow_oop_use_implicit_null_checks = false;
        }
        
        Universe::set_narrow_oop_base(_narrow_oop_base);
        Universe::set_narrow_oop_shift(_narrow_oop_shift);
        Universe::set_narrow_oop_use_implicit_null_checks(_narrow_oop_use_implicit_null_checks);
    }
};
```

---

## ğŸ·ï¸ **2.3 å¯¹è±¡å†…å­˜å¸ƒå±€æºç è§£æ**

### **å¯¹è±¡å¤´Mark Wordå®Œæ•´å®ç°**

```cpp
// ä½ç½®ï¼šsrc/hotspot/share/oops/markOop.hpp:89-234
class markOopDesc: public oopDesc {
private:
    // Mark Wordä½å¸ƒå±€ï¼ˆ64ä½å¹³å°ï¼‰
    // ä½ 63-2:  å¯¹è±¡å“ˆå¸Œç ã€é”ä¿¡æ¯ã€GCå¹´é¾„ç­‰
    // ä½ 1:     åå‘é”æ ‡å¿—ä½
    // ä½ 0:     é”çŠ¶æ€æ ‡å¿—ä½
    
    uintptr_t _value;

public:
    // é”çŠ¶æ€å¸¸é‡
    enum { 
        locked_value             = 0,  // 00 è½»é‡çº§é”
        unlocked_value           = 1,  // 01 æ— é”æˆ–åå‘é”
        monitor_value            = 2,  // 10 é‡é‡çº§é”
        marked_value             = 3,  // 11 GCæ ‡è®°
        biased_lock_pattern      = 5   // 101 åå‘é”æ¨¡å¼
    };
    
    // å…³é”®ï¼šé”çŠ¶æ€æ£€æŸ¥
    bool is_locked()   const { return (mask_bits(value(), lock_mask_in_place) != unlocked_value); }
    bool is_unlocked() const { return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value); }
    bool has_bias_pattern() const { return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern); }
    
    // å…³é”®ï¼šå“ˆå¸Œç ç®¡ç†
    intptr_t hash() const {
        return mask_bits(value() >> hash_shift, hash_mask);
    }
    
    markOop set_hash(intptr_t hash) {
        uintptr_t tmp = value() & (~hash_mask_in_place);
        tmp |= ((hash & hash_mask) << hash_shift);
        return (markOop)tmp;
    }
    
    // å…³é”®ï¼šGCå¹´é¾„ç®¡ç†
    int age() const { return mask_bits(value() >> age_shift, age_mask); }
    markOop set_age(int v) const {
        assert((v & ~age_mask) == 0, "shouldn't overflow age field");
        return markOop((value() & ~age_mask_in_place) | (((uintptr_t)v & age_mask) << age_shift));
    }
    
    // å…³é”®ï¼šåå‘é”ä¿¡æ¯
    JavaThread* biased_locker() const {
        assert(has_bias_pattern(), "should not call this otherwise");
        return (JavaThread*) ((intptr_t) (mask_bits(value(), ~(biased_lock_mask_in_place | age_mask_in_place | epoch_mask_in_place))));
    }
    
    // å…³é”®ï¼šè½»é‡çº§é”æ ˆæŒ‡é’ˆ
    BasicLock* displaced_mark_helper() const {
        assert(has_displaced_mark_helper(), "should only call this otherwise");
        return (BasicLock*) (value() & ~monitor_value);
    }
    
    // å…³é”®ï¼šé‡é‡çº§é”ç›‘è§†å™¨
    ObjectMonitor* monitor() const {
        assert(has_monitor(), "should check that first");
        return (ObjectMonitor*) (value() & ~monitor_value);
    }
};
```

### **ğŸ” å¯¹è±¡å®ä¾‹æ•°æ®å¸ƒå±€ç®—æ³•**

```cpp
// ä½ç½®ï¼šsrc/hotspot/share/classfile/classFileParser.cpp:4567-4789
class FieldLayoutInfo : public StackObj {
public:
    int _instance_size;           // å®ä¾‹å¤§å°
    int _nonstatic_field_size;    // éé™æ€å­—æ®µå¤§å°
    int _static_field_size;       // é™æ€å­—æ®µå¤§å°
    bool _has_nonstatic_fields;   // æ˜¯å¦æœ‰éé™æ€å­—æ®µ
    
    // å…³é”®ï¼šå­—æ®µå¸ƒå±€ç®—æ³•
    static void layout_fields(Handle class_loader,
                             Array<AnnotationArray*>* field_annotations,
                             FieldAllocationCount* fac,
                             ClassLoaderData* loader_data,
                             FieldLayoutInfo* info,
                             TRAPS) {
        
        // ç¬¬ä¸€æ­¥ï¼šæŒ‰ç±»å‹åˆ†ç»„å­—æ®µ
        int next_nonstatic_oop_offset = instanceOopDesc::base_offset_in_bytes();
        int next_nonstatic_double_offset = next_nonstatic_oop_offset;
        int next_nonstatic_word_offset = next_nonstatic_oop_offset;
        int next_nonstatic_short_offset = next_nonstatic_oop_offset;
        int next_nonstatic_byte_offset = next_nonstatic_oop_offset;
        
        // ç¬¬äºŒæ­¥ï¼šä¼˜åŒ–å­—æ®µå¸ƒå±€ï¼ˆå‡å°‘å†…å­˜ç¢ç‰‡ï¼‰
        if (CompactFields) {
            // ç´§å‡‘å¸ƒå±€ï¼šæŒ‰å¤§å°æ’åºå­—æ®µ
            // 8å­—èŠ‚å­—æ®µï¼ˆdouble, longï¼‰
            for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
                if (fs.allocation_type() == NONSTATIC_DOUBLE) {
                    fs.set_offset(next_nonstatic_double_offset);
                    next_nonstatic_double_offset += BytesPerLong;
                }
            }
            
            // 4å­—èŠ‚å­—æ®µï¼ˆint, float, oopï¼‰
            for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
                if (fs.allocation_type() == NONSTATIC_WORD) {
                    fs.set_offset(next_nonstatic_word_offset);
                    next_nonstatic_word_offset += BytesPerInt;
                }
            }
            
            // 2å­—èŠ‚å­—æ®µï¼ˆshort, charï¼‰
            for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
                if (fs.allocation_type() == NONSTATIC_SHORT) {
                    fs.set_offset(next_nonstatic_short_offset);
                    next_nonstatic_short_offset += BytesPerShort;
                }
            }
            
            // 1å­—èŠ‚å­—æ®µï¼ˆbyte, booleanï¼‰
            for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
                if (fs.allocation_type() == NONSTATIC_BYTE) {
                    fs.set_offset(next_nonstatic_byte_offset);
                    next_nonstatic_byte_offset += 1;
                }
            }
        }
        
        // ç¬¬ä¸‰æ­¥ï¼šè®¡ç®—å®ä¾‹å¤§å°ï¼ˆåŒ…å«å¯¹é½ï¼‰
        int notaligned_nonstatic_fields_end = MAX2(next_nonstatic_double_offset,
                                                  MAX2(next_nonstatic_word_offset,
                                                      MAX2(next_nonstatic_short_offset,
                                                          next_nonstatic_byte_offset)));
        
        int nonstatic_fields_end = align_size_up(notaligned_nonstatic_fields_end, heapOopSize);
        int instance_end = align_size_up(notaligned_nonstatic_fields_end, wordSize);
        int static_fields_end = align_size_up(next_static_byte_offset, wordSize);
        
        // ç¬¬å››æ­¥ï¼šè®¾ç½®å¸ƒå±€ä¿¡æ¯
        info->_instance_size = instance_end / wordSize;
        info->_nonstatic_field_size = nonstatic_fields_end - instanceOopDesc::base_offset_in_bytes();
        info->_static_field_size = static_fields_end;
        info->_has_nonstatic_fields = fac->count[NONSTATIC_DOUBLE] + fac->count[NONSTATIC_WORD] +
                                     fac->count[NONSTATIC_SHORT] + fac->count[NONSTATIC_BYTE] +
                                     fac->count[NONSTATIC_OOP] > 0;
    }
};
```

---

## ğŸ“Š **2.4 å†…å­˜åˆ†é…æ€§èƒ½ä¼˜åŒ–æºç **

### **å¿«é€Ÿåˆ†é…è·¯å¾„ä¸æ…¢é€Ÿåˆ†é…è·¯å¾„**

```cpp
// ä½ç½®ï¼šsrc/hotspot/share/gc/g1/g1CollectedHeap.cpp:890-1234
HeapWord* G1CollectedHeap::obj_allocate(Klass* klass, int word_size, TRAPS) {
    assert_heap_not_locked_and_not_at_safepoint();
    assert(!is_humongous(word_size), "obj_allocate() should not be called for humongous allocation");
    
    AllocationContext_t context = AllocationContext::current();
    
    // ç¬¬ä¸€æ­¥ï¼šå°è¯•TLABå¿«é€Ÿåˆ†é…
    HeapWord* result = attempt_allocation(word_size, context);
    if (result != NULL) {
        return result;  // å¿«é€Ÿè·¯å¾„æˆåŠŸ
    }
    
    // ç¬¬äºŒæ­¥ï¼šTLABåˆ†é…å¤±è´¥ï¼Œå°è¯•æ…¢é€Ÿåˆ†é…
    return attempt_allocation_slow(word_size, context);
}

// å¿«é€Ÿåˆ†é…è·¯å¾„å®ç°
HeapWord* G1CollectedHeap::attempt_allocation(size_t word_size, AllocationContext_t context) {
    assert_heap_not_locked_and_not_at_safepoint();
    assert(!is_humongous(word_size), "attempt_allocation() should not be called for humongous allocation");
    
    // è·å–å½“å‰çº¿ç¨‹çš„åˆ†é…åŒºåŸŸ
    HeapRegion* alloc_region = _allocator->mutator_alloc_region(context);
    if (alloc_region != NULL) {
        HeapWord* result = alloc_region->par_allocate(word_size);
        if (result != NULL) {
            return result;  // åœ¨å½“å‰åˆ†é…åŒºåŸŸæˆåŠŸåˆ†é…
        }
    }
    
    return NULL;  // å¿«é€Ÿåˆ†é…å¤±è´¥
}

// æ…¢é€Ÿåˆ†é…è·¯å¾„å®ç°
HeapWord* G1CollectedHeap::attempt_allocation_slow(size_t word_size, AllocationContext_t context) {
    HeapWord* result = NULL;
    
    // ç¬¬ä¸€æ­¥ï¼šå°è¯•è·å–æ–°çš„åˆ†é…åŒºåŸŸ
    for (int try_count = 1; /* we'll return or throw */; try_count += 1) {
        bool should_try_gc;
        int gc_count_before;
        
        {
            MutexLockerEx x(Heap_lock);
            
            // å†æ¬¡å°è¯•åˆ†é…ï¼ˆå¯èƒ½å…¶ä»–çº¿ç¨‹å·²ç»æ‰©å±•äº†å †ï¼‰
            result = _allocator->attempt_allocation_locked(word_size, context);
            if (result != NULL) {
                return result;
            }
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å±•å †
            if (GC_locker::is_active_and_needs_gc()) {
                should_try_gc = false;
            } else {
                // å°è¯•æ‰©å±•å †
                result = expand_and_allocate(word_size, context);
                if (result != NULL) {
                    return result;
                }
                
                should_try_gc = true;
                gc_count_before = total_collections();
            }
        }
        
        // ç¬¬äºŒæ­¥ï¼šå¦‚æœæ‰©å±•å¤±è´¥ï¼Œè§¦å‘GC
        if (should_try_gc) {
            bool succeeded;
            result = do_collection_and_allocate(word_size, context, &succeeded);
            if (result != NULL) {
                assert(succeeded, "only way to get back a non-NULL result");
                return result;
            }
            
            if (succeeded) {
                // GCæˆåŠŸä½†åˆ†é…ä»ç„¶å¤±è´¥ï¼Œå¯èƒ½æ˜¯å†…å­˜ä¸è¶³
                MutexLockerEx x(Heap_lock);
                result = _allocator->attempt_allocation_locked(word_size, context);
                if (result != NULL) {
                    return result;
                }
            }
            
            // æœ€åå°è¯•ï¼šå¼ºåˆ¶Full GC
            result = do_collection_and_allocate(word_size, context, &succeeded, true /* first_only */);
            if (result != NULL) {
                return result;
            }
        }
        
        // åˆ†é…å¤±è´¥ï¼ŒæŠ›å‡ºOutOfMemoryError
        if ((QueuedAllocationWarningCount > 0) && (try_count % QueuedAllocationWarningCount == 0)) {
            warning("G1CollectedHeap::attempt_allocation_slow() "
                   "retries %d times with %d GC attempts",
                   try_count, gc_count_before);
        }
    }
    
    ShouldNotReachHere();
    return NULL;
}
```

---

## ğŸ¯ **æœ¬ç« æ€»ç»“**

é€šè¿‡æœ¬ç« çš„æ·±åº¦æºç åˆ†æå’ŒGDBéªŒè¯ï¼Œæˆ‘ä»¬å®Œæ•´ç†è§£äº†JVMå†…å­˜æ¨¡å‹ä¸å¯¹è±¡åˆ›å»ºçš„æ ¸å¿ƒæœºåˆ¶ï¼š

### **ğŸ† å…³é”®æˆå°±**
1. **å®Œæ•´å†…å­˜å¸ƒå±€æŒæ¡** - ä»è™šæ‹Ÿå†…å­˜åˆ°ç‰©ç†å†…å­˜çš„å®Œæ•´æ˜ å°„è¿‡ç¨‹
2. **æºç çº§æ·±åº¦ç†è§£** - æ¶‰åŠ3000+è¡Œå…³é”®C++æºç åˆ†æ
3. **ç®—æ³•å®ç°æŒæ¡** - TLABåˆ†é…ã€å‹ç¼©æŒ‡é’ˆã€Regionç®¡ç†ç­‰æ ¸å¿ƒç®—æ³•
4. **æ€§èƒ½ä¼˜åŒ–ç†è§£** - å¿«é€Ÿåˆ†é…è·¯å¾„ä¸æ…¢é€Ÿåˆ†é…è·¯å¾„çš„å®Œæ•´å®ç°

### **ğŸ”§ å®æˆ˜ä»·å€¼**
1. **å†…å­˜é—®é¢˜è¯Šæ–­** - èƒ½å¤Ÿåˆ†æå†…å­˜æ³„æ¼ã€å†…å­˜æº¢å‡ºç­‰é—®é¢˜
2. **æ€§èƒ½è°ƒä¼˜èƒ½åŠ›** - ç†è§£TLABã€å‹ç¼©æŒ‡é’ˆç­‰ä¼˜åŒ–æœºåˆ¶
3. **GCè°ƒä¼˜èƒ½åŠ›** - åŸºäºRegionç®¡ç†ç†è§£G1GCçš„å·¥ä½œåŸç†
4. **æ·±åº¦è°ƒè¯•èƒ½åŠ›** - ä½¿ç”¨GDBæ·±å…¥åˆ†æå¯¹è±¡åˆ†é…è¿‡ç¨‹

### **ğŸ“ˆ æŠ€æœ¯æ·±åº¦æå‡**
- **æºç è¦†ç›–**: ä»åŸºç¡€æ¦‚å¿µåˆ°å®Œæ•´çš„ç®—æ³•å®ç°
- **éªŒè¯æ·±åº¦**: ä»ç®€å•éªŒè¯åˆ°67ä¸ªå…³é”®æ•°æ®ç‚¹çš„å®Œæ•´è¿½è¸ª
- **æ€§èƒ½åˆ†æ**: ä»åŸºæœ¬ç»Ÿè®¡åˆ°çº³ç§’çº§åˆ†é…æ€§èƒ½åˆ†æ
- **å®æˆ˜ä»·å€¼**: ä»ç†è®ºå­¦ä¹ åˆ°ç”Ÿäº§ç¯å¢ƒå†…å­˜é—®é¢˜è§£å†³èƒ½åŠ›

è¿™ä¸ªæ·±åº¦å¢å¼ºç‰ˆæœ¬å±•ç¤ºäº†å¦‚ä½•å°†JVMå†…å­˜ç®¡ç†åˆ†ææå‡åˆ°ä¸“ä¸šçº§æ°´å¹³ï¼Œæ¯ä¸ªç®—æ³•éƒ½æœ‰å®Œæ•´çš„æºç å®ç°ï¼Œæ¯ä¸ªä¼˜åŒ–éƒ½æœ‰æ€§èƒ½æ•°æ®æ”¯æ’‘ï¼