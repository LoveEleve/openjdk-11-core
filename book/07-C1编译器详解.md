# ç¬¬7ç« ï¼šC1ç¼–è¯‘å™¨è¯¦è§£ - å¿«é€Ÿç¼–è¯‘çš„è‰ºæœ¯

> **æœ¬ç« å¯¼è¯»**ï¼šC1ç¼–è¯‘å™¨ï¼ˆClient Compilerï¼‰æ˜¯HotSpotçš„å¿«é€Ÿç¼–è¯‘å™¨ï¼Œè´Ÿè´£åœ¨åˆ†å±‚ç¼–è¯‘ä¸­å¿«é€Ÿç”Ÿæˆä¸­ç­‰è´¨é‡çš„ä»£ç ã€‚æœ¬ç« åŸºäº`src/hotspot/share/c1/`ç›®å½•ä¸‹çš„çœŸå®æºç ï¼Œæ·±å…¥è®²è§£C1çš„ç¼–è¯‘æµç¨‹ã€IRè®¾è®¡å’Œå¯„å­˜å™¨åˆ†é…ã€‚

---

## 7.1 C1ç¼–è¯‘å™¨æ¦‚è¿°

### 7.1.1 C1çš„è®¾è®¡ç›®æ ‡

| ç›®æ ‡ | è¯´æ˜ |
|------|------|
| **å¿«é€Ÿç¼–è¯‘** | ç¼–è¯‘æ—¶é—´çŸ­ï¼Œé€‚åˆå¯åŠ¨é˜¶æ®µ |
| **ä¸­ç­‰ä¼˜åŒ–** | åŸºæœ¬ä¼˜åŒ–ï¼Œä¸åšæ¿€è¿›å˜æ¢ |
| **æ”¶é›†Profile** | ä¸ºC2ç¼–è¯‘æ”¶é›†è¿è¡Œæ—¶ä¿¡æ¯ |
| **ä»£ç è´¨é‡** | æ¯”è§£é‡Šå™¨å¿«5-10å€ |

### 7.1.2 C1æºç ç»“æ„

```
src/hotspot/share/c1/
â”œâ”€â”€ c1_Compilation.hpp/cpp      # ç¼–è¯‘å…¥å£å’Œæµç¨‹æ§åˆ¶
â”œâ”€â”€ c1_IR.hpp/cpp               # é«˜çº§IRï¼ˆHIRï¼‰
â”œâ”€â”€ c1_Instruction.hpp/cpp      # HIRæŒ‡ä»¤å®šä¹‰
â”œâ”€â”€ c1_ValueStack.hpp/cpp       # å€¼æ ˆï¼ˆæ“ä½œæ•°æ ˆæŠ½è±¡ï¼‰
â”œâ”€â”€ c1_LIR.hpp/cpp              # ä½çº§IRï¼ˆLIRï¼‰
â”œâ”€â”€ c1_LIRGenerator.hpp/cpp     # HIRâ†’LIRè½¬æ¢
â”œâ”€â”€ c1_LinearScan.hpp/cpp       # çº¿æ€§æ‰«æå¯„å­˜å™¨åˆ†é…
â”œâ”€â”€ c1_LIRAssembler.hpp/cpp     # LIRâ†’æœºå™¨ç 
â”œâ”€â”€ c1_Optimizer.hpp/cpp        # HIRä¼˜åŒ–
â”œâ”€â”€ c1_RangeCheckElimination.hpp/cpp  # èŒƒå›´æ£€æŸ¥æ¶ˆé™¤
â””â”€â”€ c1_ValueMap.hpp/cpp         # å€¼ç¼–å·ï¼ˆGVNï¼‰
```

---

## 7.2 ç¼–è¯‘æµç¨‹

### 7.2.1 ç¼–è¯‘é˜¶æ®µå®šä¹‰

```cpp
// src/hotspot/share/c1/c1_Compilation.cpp
typedef enum {
  _t_compile,
    _t_setup,
    _t_buildIR,
      _t_hir_parse,        // å­—èŠ‚ç è§£æï¼Œæ„å»ºHIR
      _t_gvn,              // å…¨å±€å€¼ç¼–å·
      _t_optimize_blocks,  // åŸºæœ¬å—ä¼˜åŒ–
      _t_optimize_null_checks,  // ç©ºæ£€æŸ¥æ¶ˆé™¤
      _t_rangeCheckElimination, // èŒƒå›´æ£€æŸ¥æ¶ˆé™¤
    _t_emit_lir,
      _t_linearScan,       // çº¿æ€§æ‰«æå¯„å­˜å™¨åˆ†é…
      _t_lirGeneration,    // HIRâ†’LIRè½¬æ¢
    _t_codeemit,           // LIRâ†’æœºå™¨ç 
    _t_codeinstall,        // å®‰è£…nmethod
  max_phase_timers
} TimerName;
```

### 7.2.2 ç¼–è¯‘ä¸»æµç¨‹

```cpp
// src/hotspot/share/c1/c1_Compilation.cpp
void Compilation::compile_method() {
  // 1. åˆå§‹åŒ–ç¼–è¯‘ç¯å¢ƒ
  initialize();
  
  // 2. æ„å»ºHIRï¼ˆé«˜çº§IRï¼‰
  {
    PhaseTraceTime timeit(_t_buildIR);
    build_hir();
  }
  
  // 3. ç”ŸæˆLIRï¼ˆä½çº§IRï¼‰
  {
    PhaseTraceTime timeit(_t_emit_lir);
    emit_lir();
  }
  
  // 4. ç”Ÿæˆæœºå™¨ç 
  {
    PhaseTraceTime timeit(_t_codeemit);
    emit_code_body();
  }
  
  // 5. å®‰è£…åˆ°CodeCache
  {
    PhaseTraceTime timeit(_t_codeinstall);
    install_code();
  }
}
```

**æµç¨‹å›¾**ï¼š
```
å­—èŠ‚ç 
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ build_hir()                             â”‚
â”‚   â”œâ”€ è§£æå­—èŠ‚ç  â†’ HIRå›¾                 â”‚
â”‚   â”œâ”€ GVNï¼ˆå…¨å±€å€¼ç¼–å·ï¼‰                   â”‚
â”‚   â”œâ”€ ç©ºæ£€æŸ¥æ¶ˆé™¤                          â”‚
â”‚   â””â”€ èŒƒå›´æ£€æŸ¥æ¶ˆé™¤                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ emit_lir()                              â”‚
â”‚   â”œâ”€ HIR â†’ LIRè½¬æ¢                      â”‚
â”‚   â””â”€ çº¿æ€§æ‰«æå¯„å­˜å™¨åˆ†é…                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ emit_code_body()                        â”‚
â”‚   â””â”€ LIR â†’ æœºå™¨ç                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
nmethod
```

---

## 7.3 HIRï¼ˆHigh-level IRï¼‰

### 7.3.1 HIRæŒ‡ä»¤å±‚æ¬¡ç»“æ„

```cpp
// src/hotspot/share/c1/c1_Instruction.hpp
// æŒ‡ä»¤ç±»å±‚æ¬¡ç»“æ„

class Instruction;
class   Phi;                    // Ï†å‡½æ•°ï¼ˆSSAï¼‰
class   Local;                  // å±€éƒ¨å˜é‡
class   Constant;               // å¸¸é‡
class   AccessField;            // å­—æ®µè®¿é—®
class     LoadField;            //   è¯»å–å­—æ®µ
class     StoreField;           //   å†™å…¥å­—æ®µ
class   AccessArray;            // æ•°ç»„è®¿é—®
class     ArrayLength;          //   æ•°ç»„é•¿åº¦
class     AccessIndexed;        //   ç´¢å¼•è®¿é—®
class       LoadIndexed;        //     è¯»å–å…ƒç´ 
class       StoreIndexed;       //     å†™å…¥å…ƒç´ 
class   NegateOp;               // å–è´Ÿ
class   Op2;                    // äºŒå…ƒæ“ä½œ
class     ArithmeticOp;         //   ç®—æœ¯è¿ç®—
class     ShiftOp;              //   ç§»ä½è¿ç®—
class     LogicOp;              //   é€»è¾‘è¿ç®—
class     CompareOp;            //   æ¯”è¾ƒè¿ç®—
class     IfOp;                 //   æ¡ä»¶é€‰æ‹©
class   Convert;                // ç±»å‹è½¬æ¢
class   NullCheck;              // ç©ºæ£€æŸ¥
class   StateSplit;             // çŠ¶æ€åˆ†è£‚ç‚¹
class     Invoke;               //   æ–¹æ³•è°ƒç”¨
class     NewInstance;          //   åˆ›å»ºå®ä¾‹
class     NewArray;             //   åˆ›å»ºæ•°ç»„
class     TypeCheck;            //   ç±»å‹æ£€æŸ¥
class       CheckCast;          //     å¼ºåˆ¶è½¬æ¢
class       InstanceOf;         //     ç±»å‹åˆ¤æ–­
class     AccessMonitor;        //   ç›‘è§†å™¨è®¿é—®
class       MonitorEnter;       //     åŠ é”
class       MonitorExit;        //     è§£é”
class     Intrinsic;            //   å†…ç½®æ–¹æ³•
class     BlockBegin;           //   åŸºæœ¬å—å¼€å§‹
class     BlockEnd;             //   åŸºæœ¬å—ç»“æŸ
class       Goto;               //     æ— æ¡ä»¶è·³è½¬
class       If;                 //     æ¡ä»¶è·³è½¬
class       Switch;             //     switchè·³è½¬
class       Return;             //     è¿”å›
class       Throw;              //     æŠ›å¼‚å¸¸
```

### 7.3.2 InstructionåŸºç±»

```cpp
// src/hotspot/share/c1/c1_Instruction.hpp
class Instruction: public CompilationResourceObj {
private:
  int          _id;              // æŒ‡ä»¤å”¯ä¸€ID
  int          _use_count;       // ä½¿ç”¨è®¡æ•°
  int          _pin_state;       // å›ºå®šçŠ¶æ€ï¼ˆä¸å¯ç§»åŠ¨ï¼‰
  int          _bci;             // å¯¹åº”çš„å­—èŠ‚ç ç´¢å¼•
  ValueType*   _type;            // å€¼ç±»å‹
  Instruction* _next;            // ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼ˆé“¾è¡¨ï¼‰
  Instruction* _subst;           // æ›¿æ¢æŒ‡ä»¤ï¼ˆä¼˜åŒ–ç”¨ï¼‰
  LIR_Opr      _operand;         // å¯¹åº”çš„LIRæ“ä½œæ•°
  
  ValueStack*  _state_before;    // æ‰§è¡Œå‰çš„å€¼æ ˆçŠ¶æ€
  
public:
  // ç±»å‹æ£€æŸ¥
  virtual Phi*        as_Phi()        { return NULL; }
  virtual Constant*   as_Constant()   { return NULL; }
  virtual LoadField*  as_LoadField()  { return NULL; }
  virtual Invoke*     as_Invoke()     { return NULL; }
  // ... æ›´å¤šç±»å‹è½¬æ¢æ–¹æ³•
  
  // è®¿é—®è€…æ¨¡å¼
  virtual void visit(InstructionVisitor* v) = 0;
};
```

### 7.3.3 åŸºæœ¬å—ï¼ˆBlockBeginï¼‰

```cpp
// src/hotspot/share/c1/c1_Instruction.hpp
class BlockBegin: public StateSplit {
private:
  int        _block_id;          // å—ID
  int        _bci;               // èµ·å§‹BCI
  int        _depth_first_number; // DFSåºå·
  int        _linear_scan_number; // çº¿æ€§æ‰«æåºå·
  
  BlockEnd*  _end;               // å—ç»“æŸæŒ‡ä»¤
  BlockList  _predecessors;      // å‰é©±å—åˆ—è¡¨
  BlockList  _successors;        // åç»§å—åˆ—è¡¨
  BlockList  _exception_handlers; // å¼‚å¸¸å¤„ç†å™¨
  
  ValueStack* _state;            // å—å…¥å£çŠ¶æ€
  
public:
  enum Flag {
    std_entry_flag,              // æ ‡å‡†å…¥å£
    osr_entry_flag,              // OSRå…¥å£
    exception_entry_flag,        // å¼‚å¸¸å…¥å£
    subroutine_entry_flag,       // å­ç¨‹åºå…¥å£
    backward_branch_target_flag, // åå‘åˆ†æ”¯ç›®æ ‡
    is_on_work_list_flag,        // åœ¨å·¥ä½œåˆ—è¡¨ä¸­
    was_visited_flag,            // å·²è®¿é—®
    parser_loop_header_flag,     // å¾ªç¯å¤´
    // ...
  };
};
```

### 7.3.4 å€¼æ ˆï¼ˆValueStackï¼‰

```cpp
// src/hotspot/share/c1/c1_ValueStack.hpp
class ValueStack: public CompilationResourceObj {
private:
  IRScope* _scope;               // æ‰€å±ä½œç”¨åŸŸ
  ValueStack* _caller_state;     // è°ƒç”¨è€…çŠ¶æ€
  
  int      _bci;                 // å½“å‰BCI
  Kind     _kind;                // çŠ¶æ€ç±»å‹
  
  Values   _locals;              // å±€éƒ¨å˜é‡è¡¨
  Values   _stack;               // æ“ä½œæ•°æ ˆ
  Values   _locks;               // é”åˆ—è¡¨
  
public:
  enum Kind {
    Parsing,                     // è§£æä¸­
    CallerState,                 // è°ƒç”¨è€…çŠ¶æ€
    StateBefore,                 // æŒ‡ä»¤æ‰§è¡Œå‰
    StateAfter,                  // æŒ‡ä»¤æ‰§è¡Œå
    ExceptionState,              // å¼‚å¸¸çŠ¶æ€
    EmptyExceptionState,         // ç©ºå¼‚å¸¸çŠ¶æ€
    BlockBeginState              // å—å¼€å§‹çŠ¶æ€
  };
  
  // æ ˆæ“ä½œ
  void push(ValueType* type, Value x);
  Value pop(ValueType* type);
  
  // å±€éƒ¨å˜é‡æ“ä½œ
  void store_local(int i, Value x);
  Value local_at(int i);
};
```

---

## 7.4 HIRæ„å»º

### 7.4.1 å­—èŠ‚ç è§£æ

```cpp
// src/hotspot/share/c1/c1_Compilation.cpp
void Compilation::build_hir() {
  // 1. åˆ›å»ºIRå¯¹è±¡
  _hir = new IR(this, method(), osr_bci());
  
  // 2. è§£æå­—èŠ‚ç ï¼Œæ„å»ºHIRå›¾
  {
    PhaseTraceTime timeit(_t_hir_parse);
    _hir->parse();
  }
  
  // 3. å…¨å±€å€¼ç¼–å·ï¼ˆGVNï¼‰
  {
    PhaseTraceTime timeit(_t_gvn);
    ValueMap* map = new ValueMap();
    map->apply(_hir->start());
  }
  
  // 4. ä¼˜åŒ–
  {
    PhaseTraceTime timeit(_t_optimize_blocks);
    _hir->optimize_blocks();
  }
  
  // 5. ç©ºæ£€æŸ¥æ¶ˆé™¤
  {
    PhaseTraceTime timeit(_t_optimize_null_checks);
    _hir->eliminate_null_checks();
  }
  
  // 6. èŒƒå›´æ£€æŸ¥æ¶ˆé™¤
  {
    PhaseTraceTime timeit(_t_rangeCheckElimination);
    RangeCheckElimination::do_range_check(_hir);
  }
}
```

### 7.4.2 GraphBuilder

```cpp
// src/hotspot/share/c1/c1_GraphBuilder.cpp
void GraphBuilder::iterate_bytecodes_for_block(int bci) {
  while (bci < limit) {
    Bytecodes::Code code = stream()->next();
    
    switch (code) {
      case Bytecodes::_iconst_0:
      case Bytecodes::_iconst_1:
      case Bytecodes::_iconst_2:
        // å¸¸é‡å…¥æ ˆ
        ipush(append(new Constant(new IntConstant(code - Bytecodes::_iconst_0))));
        break;
        
      case Bytecodes::_iload:
        // åŠ è½½å±€éƒ¨å˜é‡
        load_local(intType, stream()->get_index());
        break;
        
      case Bytecodes::_istore:
        // å­˜å‚¨å±€éƒ¨å˜é‡
        store_local(intType, stream()->get_index());
        break;
        
      case Bytecodes::_iadd:
        // æ•´æ•°åŠ æ³•
        arithmetic_op(intType, Bytecodes::_iadd);
        break;
        
      case Bytecodes::_if_icmpeq:
        // æ¡ä»¶è·³è½¬
        if_same(intType, If::eql);
        break;
        
      case Bytecodes::_invokevirtual:
        // è™šæ–¹æ³•è°ƒç”¨
        invoke(Bytecodes::_invokevirtual);
        break;
        
      // ... æ›´å¤šå­—èŠ‚ç å¤„ç†
    }
  }
}
```

### 7.4.3 HIRç¤ºä¾‹

**Javaä»£ç **ï¼š
```java
public int add(int a, int b) {
    return a + b;
}
```

**HIRå›¾**ï¼š
```
BlockBegin B0 [bci: 0]
  i1: Local[0] (int)      // this
  i2: Local[1] (int)      // a
  i3: Local[2] (int)      // b
  i4: ArithmeticOp(+) i2 i3  // a + b
  i5: Return i4           // return
BlockEnd
```

---

## 7.5 HIRä¼˜åŒ–

### 7.5.1 å…¨å±€å€¼ç¼–å·ï¼ˆGVNï¼‰

```cpp
// src/hotspot/share/c1/c1_ValueMap.cpp
class ValueMap: public CompilationResourceObj {
private:
  ValueMapEntry* _table[size];   // å“ˆå¸Œè¡¨
  int _nesting;                  // åµŒå¥—æ·±åº¦
  
public:
  // æŸ¥æ‰¾æˆ–æ’å…¥å€¼
  Value find_insert(Value x) {
    uint hash = x->hash();
    int index = hash % size;
    
    // æŸ¥æ‰¾å·²æœ‰çš„ç­‰ä»·å€¼
    for (ValueMapEntry* e = _table[index]; e != NULL; e = e->next()) {
      if (e->hash() == hash && e->value()->is_equal(x)) {
        return e->value();  // æ‰¾åˆ°ç­‰ä»·å€¼ï¼Œå¤ç”¨
      }
    }
    
    // æœªæ‰¾åˆ°ï¼Œæ’å…¥æ–°å€¼
    _table[index] = new ValueMapEntry(hash, x, _table[index]);
    return x;
  }
};
```

**GVNç¤ºä¾‹**ï¼š
```java
// ä¼˜åŒ–å‰
int x = a + b;
int y = a + b;  // é‡å¤è®¡ç®—

// ä¼˜åŒ–åï¼ˆGVNï¼‰
int x = a + b;
int y = x;      // å¤ç”¨xçš„å€¼
```

### 7.5.2 ç©ºæ£€æŸ¥æ¶ˆé™¤

```cpp
// src/hotspot/share/c1/c1_Optimizer.cpp
void Optimizer::eliminate_null_checks() {
  // ä½¿ç”¨æ•°æ®æµåˆ†æï¼Œè·Ÿè¸ªéç©ºå€¼
  NullCheckVisitor visitor;
  
  for (int i = 0; i < _hir->number_of_blocks(); i++) {
    BlockBegin* block = _hir->block_at(i);
    
    for (Instruction* instr = block; instr != NULL; instr = instr->next()) {
      if (instr->as_NullCheck() != NULL) {
        NullCheck* nc = instr->as_NullCheck();
        
        // æ£€æŸ¥æ˜¯å¦å·²çŸ¥éç©º
        if (visitor.is_non_null(nc->obj())) {
          // æ¶ˆé™¤ç©ºæ£€æŸ¥
          nc->unpin(Instruction::PinNullCheck);
        }
      }
    }
  }
}
```

### 7.5.3 èŒƒå›´æ£€æŸ¥æ¶ˆé™¤

```cpp
// src/hotspot/share/c1/c1_RangeCheckElimination.cpp
void RangeCheckElimination::do_range_check(IR* ir) {
  // åˆ†æå¾ªç¯ä¸­çš„æ•°ç»„è®¿é—®
  for (int i = 0; i < ir->number_of_blocks(); i++) {
    BlockBegin* block = ir->block_at(i);
    
    if (block->is_set(BlockBegin::parser_loop_header_flag)) {
      // è¿™æ˜¯ä¸€ä¸ªå¾ªç¯å¤´
      analyze_loop(block);
    }
  }
}

void RangeCheckElimination::analyze_loop(BlockBegin* loop_header) {
  // æŸ¥æ‰¾å¾ªç¯ä¸­çš„æ•°ç»„è®¿é—®
  // å¦‚æœç´¢å¼•åœ¨[0, array.length)èŒƒå›´å†…ï¼Œæ¶ˆé™¤èŒƒå›´æ£€æŸ¥
  
  for (Instruction* instr = loop_header; instr != NULL; instr = instr->next()) {
    if (instr->as_AccessIndexed() != NULL) {
      AccessIndexed* ai = instr->as_AccessIndexed();
      
      // æ£€æŸ¥ç´¢å¼•æ˜¯å¦åœ¨å®‰å…¨èŒƒå›´
      if (is_index_in_bounds(ai->index(), ai->array())) {
        ai->set_flag(Instruction::NeedsRangeCheckFlag, false);
      }
    }
  }
}
```

---

## 7.6 LIRï¼ˆLow-level IRï¼‰

### 7.6.1 LIRæ“ä½œæ•°

```cpp
// src/hotspot/share/c1/c1_LIR.hpp
class LIR_OprDesc {
public:
  enum OprKind {
    pointer_value     = 0,    // æŒ‡é’ˆ
    stack_value       = 1,    // æ ˆä½ç½®
    cpu_register      = 3,    // CPUå¯„å­˜å™¨
    fpu_register      = 5,    // FPUå¯„å­˜å™¨
    xmm_register      = 7,    // XMMå¯„å­˜å™¨ï¼ˆSSEï¼‰
    virtual_cpu       = 9,    // è™šæ‹ŸCPUå¯„å­˜å™¨
    virtual_fpu       = 11,   // è™šæ‹ŸFPUå¯„å­˜å™¨
    virtual_xmm       = 13,   // è™šæ‹ŸXMMå¯„å­˜å™¨
  };
  
  // ç±»å‹æ£€æŸ¥
  bool is_register()    const;
  bool is_virtual()     const;
  bool is_stack()       const;
  bool is_constant()    const;
  
  // è·å–å¯„å­˜å™¨ç¼–å·
  int cpu_regnr()       const;
  int fpu_regnr()       const;
  int xmm_regnr()       const;
};

// å¸¸é‡
class LIR_Const: public LIR_OprPtr {
private:
  JavaValue _value;
  
public:
  LIR_Const(jint i)    { _value.set_type(T_INT);    _value.set_jint(i); }
  LIR_Const(jlong l)   { _value.set_type(T_LONG);   _value.set_jlong(l); }
  LIR_Const(jfloat f)  { _value.set_type(T_FLOAT);  _value.set_jfloat(f); }
  LIR_Const(jdouble d) { _value.set_type(T_DOUBLE); _value.set_jdouble(d); }
  LIR_Const(jobject o) { _value.set_type(T_OBJECT); _value.set_jobject(o); }
};

// åœ°å€
class LIR_Address: public LIR_OprPtr {
private:
  LIR_Opr   _base;      // åŸºå€å¯„å­˜å™¨
  LIR_Opr   _index;     // ç´¢å¼•å¯„å­˜å™¨
  Scale     _scale;     // ç¼©æ”¾å› å­
  int       _disp;      // åç§»é‡
  BasicType _type;      // ç±»å‹
  
public:
  // åœ°å€è®¡ç®—ï¼šbase + index * scale + disp
};
```

### 7.6.2 LIRæ“ä½œ

```cpp
// src/hotspot/share/c1/c1_LIR.hpp
class LIR_Op: public CompilationResourceObj {
protected:
  LIR_Opr       _result;     // ç»“æœæ“ä½œæ•°
  LIR_Code      _code;       // æ“ä½œç 
  CodeEmitInfo* _info;       // è°ƒè¯•ä¿¡æ¯
  
public:
  enum LIR_Code {
    lir_none,
    
    // æ•°æ®ç§»åŠ¨
    lir_move,
    lir_volatile_move,
    
    // ç®—æœ¯è¿ç®—
    lir_add, lir_sub, lir_mul, lir_div, lir_rem,
    lir_neg,
    
    // ä½è¿ç®—
    lir_shl, lir_shr, lir_ushr,
    lir_and, lir_or, lir_xor,
    
    // æ¯”è¾ƒ
    lir_cmp,
    
    // åˆ†æ”¯
    lir_branch,
    lir_cond_float_branch,
    
    // è°ƒç”¨
    lir_static_call,
    lir_optvirtual_call,
    lir_icvirtual_call,
    lir_virtual_call,
    lir_dynamic_call,
    
    // è¿”å›
    lir_return,
    
    // å†…å­˜å±éšœ
    lir_membar,
    lir_membar_acquire,
    lir_membar_release,
    
    // å®‰å…¨ç‚¹
    lir_safepoint,
    
    // ...æ›´å¤šæ“ä½œç 
  };
};
```

### 7.6.3 LIRåˆ—è¡¨

```cpp
// src/hotspot/share/c1/c1_LIR.hpp
class LIR_List: public CompilationResourceObj {
private:
  LIR_OpList _operations;    // æ“ä½œåˆ—è¡¨
  BlockBegin* _block;        // æ‰€å±åŸºæœ¬å—
  
public:
  // æ·»åŠ æ“ä½œ
  void move(LIR_Opr src, LIR_Opr dest);
  void add(LIR_Opr left, LIR_Opr right, LIR_Opr dest);
  void sub(LIR_Opr left, LIR_Opr right, LIR_Opr dest);
  void mul(LIR_Opr left, LIR_Opr right, LIR_Opr dest);
  
  void branch(LIR_Condition cond, BlockBegin* block);
  void call_static(ciMethod* method, LIR_Opr result, ...);
  
  void safepoint(LIR_Opr tmp, CodeEmitInfo* info);
};
```

---

## 7.7 HIRåˆ°LIRçš„è½¬æ¢

### 7.7.1 LIRGenerator

```cpp
// src/hotspot/share/c1/c1_LIRGenerator.hpp
class LIRGenerator: public InstructionVisitor {
private:
  Compilation*  _compilation;
  ciMethod*     _method;
  BlockBegin*   _block;
  LIR_List*     _lir;
  
public:
  // è®¿é—®è€…æ¨¡å¼å¤„ç†æ¯ç§HIRæŒ‡ä»¤
  virtual void do_Phi(Phi* x);
  virtual void do_Local(Local* x);
  virtual void do_Constant(Constant* x);
  virtual void do_LoadField(LoadField* x);
  virtual void do_StoreField(StoreField* x);
  virtual void do_ArrayLength(ArrayLength* x);
  virtual void do_LoadIndexed(LoadIndexed* x);
  virtual void do_StoreIndexed(StoreIndexed* x);
  virtual void do_ArithmeticOp(ArithmeticOp* x);
  virtual void do_Invoke(Invoke* x);
  virtual void do_If(If* x);
  virtual void do_Return(Return* x);
  // ...æ›´å¤šæ–¹æ³•
};
```

### 7.7.2 ç®—æœ¯è¿ç®—è½¬æ¢

```cpp
// src/hotspot/share/c1/c1_LIRGenerator.cpp
void LIRGenerator::do_ArithmeticOp(ArithmeticOp* x) {
  // 1. åŠ è½½æ“ä½œæ•°
  LIRItem left(x->x(), this);
  LIRItem right(x->y(), this);
  left.load_item();
  right.load_item();
  
  // 2. åˆ†é…ç»“æœå¯„å­˜å™¨
  LIR_Opr result = rlock_result(x);
  
  // 3. ç”ŸæˆLIRæ“ä½œ
  switch (x->op()) {
    case Bytecodes::_iadd:
      __ add(left.result(), right.result(), result);
      break;
    case Bytecodes::_isub:
      __ sub(left.result(), right.result(), result);
      break;
    case Bytecodes::_imul:
      __ mul(left.result(), right.result(), result);
      break;
    case Bytecodes::_idiv:
      // é™¤æ³•éœ€è¦ç‰¹æ®Šå¤„ç†ï¼ˆå¯èƒ½æŠ›å¼‚å¸¸ï¼‰
      arithmetic_op_int(x->op(), result, left.result(), right.result(), ...);
      break;
  }
}
```

### 7.7.3 æ–¹æ³•è°ƒç”¨è½¬æ¢

```cpp
// src/hotspot/share/c1/c1_LIRGenerator.cpp
void LIRGenerator::do_Invoke(Invoke* x) {
  // 1. å‡†å¤‡å‚æ•°
  CallingConvention* cc = frame_map()->calling_convention(x);
  
  // 2. å°†å‚æ•°ç§»åŠ¨åˆ°æ­£ç¡®ä½ç½®
  for (int i = 0; i < x->number_of_arguments(); i++) {
    LIRItem param(x->argument_at(i), this);
    param.load_item_force(cc->at(i));
  }
  
  // 3. ç”Ÿæˆè°ƒç”¨
  LIR_Opr result = rlock_result(x);
  
  switch (x->code()) {
    case Bytecodes::_invokevirtual:
      __ call_virtual(x->target(), receiver, result, ...);
      break;
    case Bytecodes::_invokestatic:
      __ call_static(x->target(), result, ...);
      break;
    case Bytecodes::_invokeinterface:
      __ call_interface(x->target(), receiver, result, ...);
      break;
  }
  
  // 4. å®‰å…¨ç‚¹ï¼ˆè°ƒç”¨åå¯èƒ½è§¦å‘GCï¼‰
  __ safepoint(safepoint_poll_register(), info);
}
```

---

## 7.8 çº¿æ€§æ‰«æå¯„å­˜å™¨åˆ†é…

### 7.8.1 LinearScanç±»

```cpp
// src/hotspot/share/c1/c1_LinearScan.hpp
class LinearScan : public CompilationResourceObj {
private:
  Compilation*    _compilation;
  IR*             _ir;
  LIR_OpList*     _lir_ops;           // æ‰€æœ‰LIRæ“ä½œ
  IntervalList    _intervals;          // æ‰€æœ‰æ´»è·ƒåŒºé—´
  
  // å¯„å­˜å™¨æ•°é‡ï¼ˆx86-64ï¼‰
  enum {
    nof_cpu_regs = pd_nof_cpu_regs_linearscan,  // 16
    nof_fpu_regs = pd_nof_fpu_regs_linearscan,  // 8
    nof_xmm_regs = pd_nof_xmm_regs_linearscan,  // 16
  };
  
public:
  void do_linear_scan();
  
private:
  // çº¿æ€§æ‰«ææ­¥éª¤
  void number_instructions();      // 1. æŒ‡ä»¤ç¼–å·
  void compute_local_live_sets();  // 2. è®¡ç®—å±€éƒ¨æ´»è·ƒé›†
  void compute_global_live_sets(); // 3. è®¡ç®—å…¨å±€æ´»è·ƒé›†
  void build_intervals();          // 4. æ„å»ºæ´»è·ƒåŒºé—´
  void sort_intervals_before_allocation(); // 5. æ’åºåŒºé—´
  void allocate_registers();       // 6. åˆ†é…å¯„å­˜å™¨
  void resolve_data_flow();        // 7. è§£å†³æ•°æ®æµ
  void assign_reg_num();           // 8. åˆ†é…å¯„å­˜å™¨ç¼–å·
};
```

### 7.8.2 æ´»è·ƒåŒºé—´ï¼ˆIntervalï¼‰

```cpp
// src/hotspot/share/c1/c1_LinearScan.hpp
enum IntervalState {
  unhandledState = 0,  // æœªå¤„ç†
  activeState   = 1,   // æ´»è·ƒï¼ˆåœ¨å¯„å­˜å™¨ä¸­ï¼‰
  inactiveState = 2,   // ä¸æ´»è·ƒï¼ˆåœ¨ç”Ÿå‘½å‘¨æœŸç©ºæ´ä¸­ï¼‰
  handledState  = 3    // å·²å¤„ç†ï¼ˆæº¢å‡ºæˆ–ç”Ÿå‘½å‘¨æœŸç»“æŸï¼‰
};

class Interval : public CompilationResourceObj {
private:
  int           _reg_num;          // è™šæ‹Ÿå¯„å­˜å™¨ç¼–å·
  BasicType     _type;             // ç±»å‹
  Range*        _first;            // ç¬¬ä¸€ä¸ªèŒƒå›´
  Range*        _current;          // å½“å‰èŒƒå›´
  UsePosition*  _use_positions;    // ä½¿ç”¨ä½ç½®åˆ—è¡¨
  
  int           _assigned_reg;     // åˆ†é…çš„ç‰©ç†å¯„å­˜å™¨
  int           _assigned_regHi;   // é«˜ä½å¯„å­˜å™¨ï¼ˆlong/doubleï¼‰
  int           _spill_slot;       // æº¢å‡ºæ§½ä½
  
  IntervalState _state;            // å½“å‰çŠ¶æ€
  
public:
  int from() const { return _first->from(); }
  int to()   const { return _first->to(); }
  
  bool covers(int op_id) const;    // æ˜¯å¦è¦†ç›–æŸä½ç½®
  bool intersects(Interval* i) const; // æ˜¯å¦ä¸å¦ä¸€åŒºé—´ç›¸äº¤
};
```

### 7.8.3 å¯„å­˜å™¨åˆ†é…ç®—æ³•

```cpp
// src/hotspot/share/c1/c1_LinearScan.cpp
void LinearScan::allocate_registers() {
  // çº¿æ€§æ‰«æç®—æ³•
  IntervalWalker walker(this, unhandled_first, active_first, inactive_first);
  
  while (walker.current() != NULL) {
    Interval* current = walker.current();
    int position = current->from();
    
    // 1. è¿‡æœŸæ—§åŒºé—´
    walker.walk_to(position);
    
    // 2. å°è¯•åˆ†é…å¯„å­˜å™¨
    if (!try_allocate_free_reg(current)) {
      // 3. æ²¡æœ‰ç©ºé—²å¯„å­˜å™¨ï¼Œéœ€è¦æº¢å‡º
      allocate_blocked_reg(current);
    }
    
    // 4. å¦‚æœåˆ†é…äº†å¯„å­˜å™¨ï¼ŒåŠ å…¥æ´»è·ƒåˆ—è¡¨
    if (current->assigned_reg() != any_reg) {
      walker.activate_current();
    }
    
    walker.next();
  }
}

bool LinearScan::try_allocate_free_reg(Interval* current) {
  // æŸ¥æ‰¾ç©ºé—²å¯„å­˜å™¨
  int reg = find_free_reg(current);
  
  if (reg != any_reg) {
    current->assign_reg(reg);
    return true;
  }
  return false;
}

void LinearScan::allocate_blocked_reg(Interval* current) {
  // é€‰æ‹©ä¸€ä¸ªåŒºé—´æº¢å‡º
  Interval* spill = find_spill_candidate(current);
  
  if (spill == current) {
    // å½“å‰åŒºé—´æº¢å‡º
    current->assign_spill_slot(allocate_spill_slot());
  } else {
    // æº¢å‡ºå…¶ä»–åŒºé—´ï¼Œå½“å‰åŒºé—´è·å¾—å¯„å­˜å™¨
    current->assign_reg(spill->assigned_reg());
    spill->assign_spill_slot(allocate_spill_slot());
  }
}
```

### 7.8.4 æº¢å‡ºå¤„ç†

```cpp
// src/hotspot/share/c1/c1_LinearScan.cpp
int LinearScan::allocate_spill_slot(BasicType type) {
  // åˆ†é…æ ˆæ§½ä½
  int slot = _max_spills;
  _max_spills += type2size[type];
  return slot;
}

void LinearScan::insert_spill_move(Interval* interval, int from_op_id) {
  // åœ¨æŒ‡å®šä½ç½®æ’å…¥æº¢å‡ºç§»åŠ¨
  LIR_Opr from_opr = interval->assigned_opr();
  LIR_Opr to_opr = interval->spill_slot_opr();
  
  // æ’å…¥ move from_opr -> to_opr
  insert_move(from_op_id, from_opr, to_opr);
}

void LinearScan::insert_reload_move(Interval* interval, int to_op_id) {
  // åœ¨æŒ‡å®šä½ç½®æ’å…¥é‡æ–°åŠ è½½
  LIR_Opr from_opr = interval->spill_slot_opr();
  LIR_Opr to_opr = interval->assigned_opr();
  
  // æ’å…¥ move from_opr -> to_opr
  insert_move(to_op_id, from_opr, to_opr);
}
```

---

## 7.9 ä»£ç ç”Ÿæˆ

### 7.9.1 LIRAssembler

```cpp
// src/hotspot/share/c1/c1_LIRAssembler.hpp
class LIR_Assembler: public CompilationResourceObj {
private:
  Compilation*     _compilation;
  C1_MacroAssembler* _masm;
  CodeOffsets      _offsets;
  
public:
  void emit_code(BlockList* hir);
  
private:
  // ç”Ÿæˆå„ç§LIRæ“ä½œçš„æœºå™¨ç 
  void emit_op0(LIR_Op0* op);
  void emit_op1(LIR_Op1* op);
  void emit_op2(LIR_Op2* op);
  void emit_op3(LIR_Op3* op);
  void emit_opBranch(LIR_OpBranch* op);
  void emit_call(LIR_OpJavaCall* op);
  
  // å¹³å°ç›¸å…³çš„ä»£ç ç”Ÿæˆ
  void emit_move(LIR_Opr src, LIR_Opr dest);
  void emit_add(LIR_Opr left, LIR_Opr right, LIR_Opr dest);
  void emit_compare_and_branch(LIR_OpBranch* op);
};
```

### 7.9.2 x86-64ä»£ç ç”Ÿæˆç¤ºä¾‹

```cpp
// src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp
void LIR_Assembler::emit_op2(LIR_Op2* op) {
  switch (op->code()) {
    case lir_add:
      if (op->in_opr1()->is_cpu_register() && op->in_opr2()->is_cpu_register()) {
        // reg + reg
        __ addq(op->result_opr()->as_register(), op->in_opr2()->as_register());
      } else if (op->in_opr2()->is_constant()) {
        // reg + const
        __ addq(op->result_opr()->as_register(), op->in_opr2()->as_constant_ptr()->as_jint());
      }
      break;
      
    case lir_sub:
      __ subq(op->result_opr()->as_register(), op->in_opr2()->as_register());
      break;
      
    case lir_mul:
      __ imulq(op->result_opr()->as_register(), op->in_opr2()->as_register());
      break;
  }
}

void LIR_Assembler::emit_call(LIR_OpJavaCall* op) {
  // ç”Ÿæˆæ–¹æ³•è°ƒç”¨
  switch (op->code()) {
    case lir_static_call:
      __ call(op->addr());
      break;
      
    case lir_virtual_call:
      // ä»vtableåŠ è½½æ–¹æ³•åœ°å€
      __ movq(rax, Address(receiver, Klass::vtable_start_offset() + vtable_index * wordSize));
      __ call(rax);
      break;
  }
  
  // è®°å½•å®‰å…¨ç‚¹ä¿¡æ¯
  add_call_info(op->info());
}
```

---

## 7.10 ä¸G1 GCçš„åä½œ

### 7.10.1 å†™å±éšœç”Ÿæˆ

```cpp
// src/hotspot/share/c1/c1_LIRGenerator.cpp
void LIRGenerator::do_StoreField(StoreField* x) {
  // 1. åŠ è½½å¯¹è±¡å’Œå€¼
  LIRItem object(x->obj(), this);
  LIRItem value(x->value(), this);
  object.load_item();
  value.load_item();
  
  // 2. å†™å…¥å­—æ®µ
  LIR_Opr addr = new_pointer_register();
  __ add(object.result(), LIR_OprFact::intConst(x->offset()), addr);
  
  // 3. G1å†™å±éšœï¼ˆPre-Barrierï¼‰
  if (UseG1GC) {
    pre_barrier(addr, LIR_OprFact::illegalOpr, true, false, ...);
  }
  
  // 4. å®é™…å†™å…¥
  __ move(value.result(), addr);
  
  // 5. G1å†™å±éšœï¼ˆPost-Barrierï¼‰
  if (UseG1GC) {
    post_barrier(object.result(), value.result());
  }
}
```

### 7.10.2 å®‰å…¨ç‚¹ç”Ÿæˆ

```cpp
// src/hotspot/share/c1/c1_LIRGenerator.cpp
void LIRGenerator::do_Return(Return* x) {
  // 1. å‡†å¤‡è¿”å›å€¼
  if (x->type()->tag() != voidTag) {
    LIRItem result(x->result(), this);
    result.load_item_force(return_opr);
  }
  
  // 2. å®‰å…¨ç‚¹è½®è¯¢
  __ safepoint(safepoint_poll_register(), new CodeEmitInfo(scope(), ...));
  
  // 3. è¿”å›
  __ return_op(return_opr);
}
```

---

## 7.11 Profilingæ”¯æŒ

### 7.11.1 æ–¹æ³•è°ƒç”¨è®¡æ•°

```cpp
// src/hotspot/share/c1/c1_LIRGenerator.cpp
void LIRGenerator::profile_invocation(ciMethod* method) {
  if (compilation()->count_invocations()) {
    // å¢åŠ è°ƒç”¨è®¡æ•°
    LIR_Opr counter = new_register(T_INT);
    LIR_Address* addr = new LIR_Address(method_data_opr, 
                                        MethodData::invocation_counter_offset(),
                                        T_INT);
    __ move(addr, counter);
    __ add(counter, LIR_OprFact::intConst(1), counter);
    __ move(counter, addr);
  }
}
```

### 7.11.2 åˆ†æ”¯Profiling

```cpp
// src/hotspot/share/c1/c1_LIRGenerator.cpp
void LIRGenerator::do_If(If* x) {
  // 1. æ¯”è¾ƒ
  LIRItem left(x->x(), this);
  LIRItem right(x->y(), this);
  left.load_item();
  right.load_item();
  
  // 2. åˆ†æ”¯Profiling
  if (compilation()->profile_branches()) {
    // è®°å½•åˆ†æ”¯èµ°å‘
    profile_branch(x, x->taken_count(), x->not_taken_count());
  }
  
  // 3. æ¡ä»¶è·³è½¬
  __ cmp(left.result(), right.result());
  __ branch(x->cond(), x->tsux());
}
```

---

## 7.12 å®æˆ˜æ¡ˆä¾‹ï¼šè¿½è¸ªC1ç¼–è¯‘

### 7.12.1 Javaä»£ç 

```java
public class C1Example {
    public static int sum(int n) {
        int result = 0;
        for (int i = 0; i < n; i++) {
            result += i;
        }
        return result;
    }
}
```

### 7.12.2 HIR

```
BlockBegin B0 [bci: 0]
  i1: Constant(0)           // result = 0
  i2: Constant(0)           // i = 0
  goto B1

BlockBegin B1 [bci: 2] (loop header)
  i3: Phi(i1, i6)           // result
  i4: Phi(i2, i7)           // i
  i5: If(i4 < n) B2 else B3

BlockBegin B2 [bci: 5]
  i6: ArithmeticOp(+) i3 i4 // result += i
  i7: ArithmeticOp(+) i4 1  // i++
  goto B1

BlockBegin B3 [bci: 11]
  i8: Return i3             // return result
```

### 7.12.3 LIR

```
B0:
  lir_move [int:0] -> R10   // result = 0
  lir_move [int:0] -> R11   // i = 0
  lir_branch B1

B1:
  lir_cmp R11, R12          // i < n
  lir_branch ge B3

B2:
  lir_add R10, R11 -> R10   // result += i
  lir_add R11, [int:1] -> R11 // i++
  lir_branch B1

B3:
  lir_move R10 -> RAX       // è¿”å›å€¼æ”¾å…¥rax
  lir_safepoint
  lir_return
```

### 7.12.4 ç”Ÿæˆçš„æœºå™¨ç 

```assembly
; B0
  xor    r10d, r10d         ; result = 0
  xor    r11d, r11d         ; i = 0
  jmp    B1

; B1
  cmp    r11d, r12d         ; i < n
  jge    B3

; B2
  add    r10d, r11d         ; result += i
  inc    r11d               ; i++
  jmp    B1

; B3
  mov    eax, r10d          ; è¿”å›å€¼
  test   [rip + polling_page], eax  ; å®‰å…¨ç‚¹è½®è¯¢
  ret
```

---

## 7.13 æœ¬ç« å°ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **ç¼–è¯‘æµç¨‹**ï¼šå­—èŠ‚ç  â†’ HIR â†’ LIR â†’ æœºå™¨ç 
2. **HIR**ï¼šé«˜çº§SSAå½¢å¼IRï¼Œä¿ç•™ç¨‹åºç»“æ„
3. **HIRä¼˜åŒ–**ï¼šGVNã€ç©ºæ£€æŸ¥æ¶ˆé™¤ã€èŒƒå›´æ£€æŸ¥æ¶ˆé™¤
4. **LIR**ï¼šä½çº§IRï¼Œæ¥è¿‘æœºå™¨æŒ‡ä»¤
5. **çº¿æ€§æ‰«æ**ï¼šO(n)æ—¶é—´å¤æ‚åº¦çš„å¯„å­˜å™¨åˆ†é…
6. **å†™å±éšœ**ï¼šG1çš„Pre/Post Barrieré›†æˆ
7. **Profiling**ï¼šä¸ºC2æ”¶é›†è¿è¡Œæ—¶ä¿¡æ¯

### C1ç¼–è¯‘é˜¶æ®µè€—æ—¶

```
å…¸å‹æ–¹æ³•çš„C1ç¼–è¯‘è€—æ—¶åˆ†å¸ƒï¼š
- HIRæ„å»ºï¼š30%
- HIRä¼˜åŒ–ï¼š15%
- LIRç”Ÿæˆï¼š20%
- å¯„å­˜å™¨åˆ†é…ï¼š25%
- ä»£ç ç”Ÿæˆï¼š10%
```

### ä¸åç»­ç« èŠ‚çš„è”ç³»

- **ç¬¬8ç« ï¼ˆC2ç¼–è¯‘å™¨ï¼‰**ï¼šæ›´æ¿€è¿›çš„ä¼˜åŒ–ï¼ŒSea-of-Nodes IR
- **ç¬¬12ç« ï¼ˆG1ï¼‰**ï¼šå†™å±éšœçš„å®Œæ•´å®ç°

---

## 7.14 è¿›é˜¶é˜…è¯»

**æºç æ–‡ä»¶**ï¼š
```
src/hotspot/share/c1/
â”œâ”€â”€ c1_Compilation.cpp       [ç¼–è¯‘å…¥å£]
â”œâ”€â”€ c1_GraphBuilder.cpp      [HIRæ„å»º]
â”œâ”€â”€ c1_Instruction.hpp       [HIRæŒ‡ä»¤å®šä¹‰]
â”œâ”€â”€ c1_Optimizer.cpp         [HIRä¼˜åŒ–]
â”œâ”€â”€ c1_LIR.hpp               [LIRå®šä¹‰]
â”œâ”€â”€ c1_LIRGenerator.cpp      [HIRâ†’LIR]
â”œâ”€â”€ c1_LinearScan.cpp        [å¯„å­˜å™¨åˆ†é…]
â””â”€â”€ c1_LIRAssembler_x86.cpp  [x86ä»£ç ç”Ÿæˆ]
```

**æ¨èå®éªŒ**ï¼š
1. ä½¿ç”¨`-XX:+PrintC1Statistics`æŸ¥çœ‹C1ç»Ÿè®¡
2. ä½¿ç”¨`-XX:+PrintLIR`æŸ¥çœ‹LIR
3. ä½¿ç”¨`-XX:+PrintCFGToFile`è¾“å‡ºCFGå›¾

---

**ä¸‹ä¸€ç« é¢„å‘Š**ï¼š  
ã€Šç¬¬8ç« ï¼šC2ç¼–è¯‘å™¨è¯¦è§£ã€‹å°†æ·±å…¥C2çš„Sea-of-Nodes IRã€æ¿€è¿›ä¼˜åŒ–æŠ€æœ¯ã€é€ƒé€¸åˆ†æå®ç°ï¼Œä»¥åŠADLCæŒ‡ä»¤æè¿°è¯­è¨€ã€‚

å…„å¼Ÿï¼Œå‡†å¤‡å¥½è¿›å…¥C2çš„ä¸–ç•Œäº†å—ï¼ŸğŸš€
