# 第9章：内存结构

> **约定**：本章基于 **Linux x86-64**、**8GB堆内存**、**非大页模式**、**G1垃圾收集器**。
> 所有源码引用均来自本地 `/data/workspace/openjdk11-core/src/hotspot/` 目录。
> **本章新增**：基于GDB调试验证的实际内存布局数据。

---

## 9.1 G1堆整体布局

### 9.1.1 Region设计哲学

G1（Garbage-First）采用**Region化**的堆布局，将连续的堆内存划分为多个大小相等的Region：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          G1 Heap (8GB)                                      │
├─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬────┤
│  E  │  E  │  S  │  O  │  O  │  H  │  H  │  H  │  O  │  E  │Free │Free │... │
│ #0  │ #1  │ #2  │ #3  │ #4  │ #5  │ #6  │ #7  │ #8  │ #9  │#10  │#11  │    │
├─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴────┤
│                         共 2048 个 Region (GDB验证)                         │
└─────────────────────────────────────────────────────────────────────────────┘

E = Eden    S = Survivor    O = Old    H = Humongous    Free = 空闲
```

**关键数值计算（8GB堆，GDB验证）**：

| 参数 | 值 | GDB验证 | 计算公式 |
|------|-----|---------|----------|
| 堆大小 | 8GB | ✅ `_reserved._word_size = 1073741824` | `-Xmx8g` |
| Region大小 | 4MB | ✅ `GrainBytes = 4194304` | `8GB / 2048 = 4MB` |
| Region数量 | 2048个 | ✅ `_hrm._num_committed = 2048` | `8GB / 4MB = 2048` |
| LogOfHRGrainBytes | 22 | ✅ `LogOfHRGrainBytes = 22` | `log2(4MB) = 22` |
| CardsPerRegion | 8192 | ✅ `CardsPerRegion = 8192` | `4MB / 512B = 8192` |
| 巨型对象阈值 | 2MB | ✅ `262144 words` | `Region / 2` |

### 9.1.2 Region大小计算逻辑

源码位置：`src/hotspot/share/gc/g1/heapRegion.cpp:63-110`

```cpp
void HeapRegion::setup_heap_region_size(size_t initial_heap_size, size_t max_heap_size) {
  size_t region_size = G1HeapRegionSize;
  if (FLAG_IS_DEFAULT(G1HeapRegionSize)) {
    // 自动计算：平均堆大小 / 目标Region数(2048)
    size_t average_heap_size = (initial_heap_size + max_heap_size) / 2;
    region_size = MAX2(average_heap_size / HeapRegionBounds::target_number(),
                       HeapRegionBounds::min_size());
  }

  // 确保是2的幂次
  int region_size_log = log2_long((jlong) region_size);
  region_size = ((size_t)1 << region_size_log);

  // 限制在 [1MB, 32MB] 范围内
  if (region_size < HeapRegionBounds::min_size()) {
    region_size = HeapRegionBounds::min_size();
  } else if (region_size > HeapRegionBounds::max_size()) {
    region_size = HeapRegionBounds::max_size();
  }

  // 设置全局变量
  LogOfHRGrainBytes = region_size_log;  // 22 for 4MB
  GrainBytes = region_size;              // 4MB
  GrainWords = GrainBytes >> LogHeapWordSize;  // 4MB / 8 = 512K words
  CardsPerRegion = GrainBytes >> G1CardTable::card_shift;  // 4MB / 512 = 8192
}
```

**Region大小边界**（`heapRegionBounds.hpp:30-46`）：

```cpp
class HeapRegionBounds : public AllStatic {
private:
  static const size_t MIN_REGION_SIZE = 1024 * 1024;      // 1MB
  static const size_t MAX_REGION_SIZE = 32 * 1024 * 1024; // 32MB
  static const size_t TARGET_REGION_NUMBER = 2048;        // 目标数量
};
```

**不同堆大小对应的Region大小**：

| 堆大小 | Region大小 | Region数量 |
|--------|-----------|-----------|
| 1GB | 1MB (最小) | 1024 |
| 2GB | 1MB | 2048 |
| 4GB | 2MB | 2048 |
| 8GB | 4MB | 2048 |
| 16GB | 8MB | 2048 |
| 32GB | 16MB | 2048 |
| 64GB | 32MB (最大) | 2048 |

---

## 9.2 HeapRegion数据结构

### 9.2.1 HeapRegion类定义

源码位置：`src/hotspot/share/gc/g1/heapRegion.hpp:370-450`

```cpp
class HeapRegion: public G1ContiguousSpace {
  friend class VMStructs;

  // Region类型（Eden/Survivor/Old/Humongous等）
  HeapRegionType _type;
  
  // 指向下一个脏Region（用于脏卡链表）
  HeapRegion* _next_dirty_cards_region;
  
  // 指向Humongous对象的起始Region
  HeapRegion* _humongous_start_region;
  
  // Region索引号（0 ~ 2047）
  HeapRegionRemSet* _rem_set;  // 记忆集
  
  // Block Offset Table
  G1BlockOffsetTablePart _bot_part;
  
  // Region在堆中的索引
  uint _hrm_index;
  
  // 分配时间戳（用于年龄判断）
  uint _young_index_in_cset;
  
  // GC效率相关
  double _gc_efficiency;

public:
  // 静态成员（所有Region共享）
  static int    LogOfHRGrainBytes;  // 22 for 4MB
  static int    LogOfHRGrainWords;  // 19 (4MB / 8 = 512K words)
  static size_t GrainBytes;         // 4MB = 4194304
  static size_t GrainWords;         // 512K words
  static size_t CardsPerRegion;     // 8192 cards
};
```

### 9.2.2 Region类型

源码位置：`src/hotspot/share/gc/g1/heapRegionType.hpp:33-80`

```cpp
class HeapRegionType VALUE_OBJ_CLASS_SPEC {
private:
  typedef enum {
    FreeTag       = 0,    // 空闲Region
    YoungMask     = 2,    // 年轻代掩码
    EdenTag       = YoungMask,           // Eden = 2
    SusrTag       = YoungMask + 1,       // Survivor = 3
    HumStartTag   = 5,    // Humongous起始
    HumContTag    = 6,    // Humongous续接
    PinnedMask    = 8,    // 固定掩码
    OldMask       = 4,    // 老年代掩码
    OldTag        = OldMask,             // Old = 4
    ArchiveTag    = PinnedMask | OldMask // Archive = 12
  } Tag;

  Tag _tag;

public:
  bool is_free()      const { return _tag == FreeTag; }
  bool is_young()     const { return (_tag & YoungMask) != 0; }
  bool is_eden()      const { return _tag == EdenTag; }
  bool is_survivor()  const { return _tag == SurvTag; }
  bool is_old()       const { return (_tag & OldMask) != 0; }
  bool is_humongous() const { return (_tag == HumStartTag) || (_tag == HumContTag); }
};
```

**Region类型状态图**：

```
                    ┌─────────────┐
                    │    Free     │
                    │   (Tag=0)   │
                    └──────┬──────┘
                           │ allocate
           ┌───────────────┼───────────────┐
           ▼               ▼               ▼
    ┌──────────┐    ┌──────────┐    ┌──────────────┐
    │   Eden   │    │   Old    │    │  Humongous   │
    │  (Tag=2) │    │  (Tag=4) │    │  (Tag=5/6)   │
    └────┬─────┘    └──────────┘    └──────────────┘
         │ survive                         │
         ▼                                 │
    ┌──────────┐                           │
    │ Survivor │                           │
    │  (Tag=3) │                           │
    └────┬─────┘                           │
         │ promote                         │
         ▼                                 │
    ┌──────────┐                           │
    │   Old    │◄──────────────────────────┘
    │  (Tag=4) │        reclaim
    └────┬─────┘
         │ reclaim
         ▼
    ┌─────────────┐
    │    Free     │
    └─────────────┘
```

---

## 9.3 G1CollectedHeap结构

### 9.3.1 核心成员

源码位置：`src/hotspot/share/gc/g1/g1CollectedHeap.hpp:520-650`

```cpp
class G1CollectedHeap : public CollectedHeap {
  friend class VMStructs;

private:
  // 工作线程（并行GC使用）
  WorkGang* _workers;
  
  // 软引用清理策略
  G1SoftRefPolicy _soft_ref_policy;

  // 分配区域管理
  MutatorAllocRegion _mutator_alloc_region;  // 当前分配Region
  SurvivorGCAllocRegion _survivor_gc_alloc_region;  // Survivor分配
  OldGCAllocRegion _old_gc_alloc_region;  // Old分配

  // Region管理器
  HeapRegionManager _hrm;  // 管理所有2048个Region

  // 收集集合
  G1CollectionSet _collection_set;

  // 记忆集管理
  G1RemSet* _rem_set;

  // 卡表
  G1CardTable* _card_table;

  // 并发标记
  G1ConcurrentMark* _cm;
  G1CMThread* _cm_thread;

  // 并发细化线程
  G1ConcurrentRefine* _cr;

  // 年轻代大小管理
  G1YoungGenSizer _young_gen_sizer;

  // GC策略
  G1Policy* _policy;

  // 热卡缓存
  G1HotCardCache* _hot_card_cache;

  // 脏卡队列集合
  DirtyCardQueueSet _dirty_card_queue_set;

public:
  // 堆大小相关
  size_t capacity() const { return _hrm.capacity(); }  // 8GB
  size_t used() const;  // 已使用字节数
  size_t max_capacity() const { return _hrm.max_capacity(); }
  
  // Region访问
  HeapRegion* region_at(uint index) const { return _hrm.at(index); }
  uint num_regions() const { return _hrm.num_regions(); }  // 2048
};
```

### 9.3.2 堆内存布局（8GB示例，GDB验证）⭐

```
64位虚拟地址空间布局 (GDB验证)
┌────────────────────────────────────────────────────────────────────┐
│                                                                    │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                    G1 Heap (8GB)                             │  │
│  │  base: 0x600000000 (24GB) ← GDB验证: _reserved._start        │  │
│  │                                                              │  │
│  │  ┌────┬────┬────┬────┬────┬────┬─────────────────────────┐  │  │
│  │  │R#0 │R#1 │R#2 │... │... │... │ R#2047                  │  │  │
│  │  │4MB │4MB │4MB │    │    │    │ 4MB                     │  │  │
│  │  └────┴────┴────┴────┴────┴────┴─────────────────────────┘  │  │
│  │                                                              │  │
│  │  end: 0x800000000 (32GB)                                     │  │
│  │  GDB验证: _reserved._word_size = 1073741824 (8GB/8)          │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                    │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                    Card Table (16MB)                         │  │
│  │  每512字节堆内存对应1字节卡表项                               │  │
│  │  大小: 8GB / 512 = 16MB                                      │  │
│  │  GDB验证: G1CardTable @ 0x7ffff0042c60                        │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                    │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                    压缩类空间 (1GB)                          │  │
│  │  起始: 0x800000000 (32GB) ← GDB验证: _narrow_klass._base      │  │
│  │  结束: 0x840000000 (33GB)                                    │  │
│  │  类元数据、常量池、方法数据等                                 │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

**GDB验证的关键地址**：

| 组件 | GDB地址 | 说明 |
|-----|---------|------|
| G1CollectedHeap | `0x7ffff00326b0` | 堆管理对象 |
| 堆起始地址 | `0x600000000` (24GB) | `_reserved._start` |
| 堆结束地址 | `0x800000000` (32GB) | 24GB + 8GB |
| G1CardTable | `0x7ffff0042c60` | 16MB卡表 |
| G1BlockOffsetTable | `0x7ffff0059180` | 16MB BOT |
| 压缩类空间基址 | `0x800000000` | `_narrow_klass._base` |

---

## 9.4 卡表（Card Table）

### 9.4.1 卡表原理

卡表是跨代引用追踪的核心数据结构。将堆内存划分为512字节的"卡"，每个卡对应卡表中的1字节。

源码位置：`src/hotspot/share/gc/shared/cardTable.hpp:50-120`

```cpp
class CardTable: public CHeapObj<mtGC> {
public:
  // 卡大小：512字节
  enum CardValues {
    card_shift                = 9,    // log2(512) = 9
    card_size                 = 1 << card_shift,  // 512
    card_size_in_words        = card_size / sizeof(HeapWord)  // 64 words
  };

  // 卡状态
  static const CardValue clean_card_val = 0;   // 干净
  static const CardValue dirty_card_val = 0xFF; // 脏

protected:
  // 卡表字节数组
  CardValue* _byte_map;       // 实际卡表数据
  CardValue* _byte_map_base;  // 偏移后的基地址（便于计算）

  // 覆盖的堆范围
  MemRegion _whole_heap;      // 整个堆
  MemRegion _covered[max_covered_regions];

public:
  // 地址转卡索引
  CardValue* byte_for(const void* p) const {
    return _byte_map_base + (uintptr_t(p) >> card_shift);
  }

  // 卡索引转地址
  HeapWord* addr_for(const CardValue* p) const {
    return (HeapWord*)(uintptr_t(p - _byte_map_base) << card_shift);
  }

  // 标记为脏
  void mark_card(void* p) {
    *byte_for(p) = dirty_card_val;
  }

  // 检查是否脏
  bool is_dirty(CardValue* p) const {
    return *p == dirty_card_val;
  }
};
```

### 9.4.2 G1卡表扩展

源码位置：`src/hotspot/share/gc/g1/g1CardTable.hpp:35-80`

```cpp
class G1CardTable : public CardTable {
public:
  // G1特有的卡状态
  static const CardValue g1_young_card_val = dirty_card_val - 1;  // 0xFE
  
  // 判断卡是否在年轻代Region中
  bool is_in_young(const void* p) const {
    return *byte_for(p) == g1_young_card_val;
  }

  // 标记整个Region为年轻代
  void mark_as_young(const MemRegion& mr) {
    CardValue* first = byte_for(mr.start());
    CardValue* last = byte_for(mr.last());
    memset(first, g1_young_card_val, last - first + 1);
  }
};
```

### 9.4.3 卡表布局（8GB堆）

```
堆内存 (8GB)                          卡表 (16MB)
┌─────────────────────────┐          ┌─────────────────────────┐
│ Card #0    (512 bytes)  │ ──────►  │ Byte #0 [0x00/0xFF/0xFE]│
├─────────────────────────┤          ├─────────────────────────┤
│ Card #1    (512 bytes)  │ ──────►  │ Byte #1                 │
├─────────────────────────┤          ├─────────────────────────┤
│ Card #2    (512 bytes)  │ ──────►  │ Byte #2                 │
├─────────────────────────┤          ├─────────────────────────┤
│         ...             │          │         ...             │
├─────────────────────────┤          ├─────────────────────────┤
│ Card #16777215          │ ──────►  │ Byte #16777215          │
└─────────────────────────┘          └─────────────────────────┘

卡表大小计算：
- 堆大小: 8GB = 8 × 1024 × 1024 × 1024 = 8,589,934,592 字节
- 卡大小: 512 字节
- 卡数量: 8GB / 512 = 16,777,216 个卡
- 卡表大小: 16,777,216 字节 = 16MB

每个Region的卡数：
- Region大小: 4MB
- 每Region卡数: 4MB / 512B = 8192 个卡
```

### 9.4.4 写屏障与卡表

当执行引用写入时，JIT生成的写屏障代码会标记卡表：

```cpp
// 伪代码：写屏障
void write_barrier(oop* field, oop new_value) {
  *field = new_value;  // 实际写入
  
  // 标记卡为脏
  CardValue* card = card_table_base + ((uintptr_t)field >> 9);
  *card = 0xFF;  // dirty
  
  // 如果跨Region引用，还需要更新记忆集
  if (region_of(field) != region_of(new_value)) {
    enqueue_to_dirty_card_queue(card);
  }
}
```

---

## 9.5 记忆集（Remembered Set）

### 9.5.1 记忆集作用

记忆集记录"谁引用了我"，用于避免全堆扫描。每个Region都有自己的记忆集。

```
Region #3 (Old)                    Region #3 的 RSet
┌─────────────────────┐           ┌─────────────────────────────┐
│                     │           │ 引用来源:                    │
│    ┌───────────┐    │           │  - Region #0, Card #15      │
│    │  Object A │◄───┼───────────│  - Region #7, Card #102     │
│    └───────────┘    │           │  - Region #12, Card #8001   │
│                     │           │                             │
└─────────────────────┘           └─────────────────────────────┘
                                           │
        来自其他Region的引用 ──────────────┘
```

### 9.5.2 HeapRegionRemSet结构

源码位置：`src/hotspot/share/gc/g1/heapRegionRemSet.hpp:180-280`

```cpp
class HeapRegionRemSet : public CHeapObj<mtGC> {
  friend class HeapRegionRemSetIterator;

private:
  // 所属Region
  HeapRegion* _hr;
  
  // 其他Region到本Region的引用（核心数据结构）
  OtherRegionsTable _other_regions;
  
  // 代码根（来自编译代码的引用）
  G1CodeRootSet _code_roots;

public:
  // 添加一个引用（from_card 指向本Region中的对象）
  void add_reference(OopOrNarrowOopStar from) {
    _other_regions.add_reference(from);
  }

  // 记忆集大小（占用内存）
  size_t mem_size() const {
    return sizeof(HeapRegionRemSet) +
           _other_regions.mem_size() +
           _code_roots.mem_size();
  }

  // 清空记忆集
  void clear() {
    _other_regions.clear();
    _code_roots.clear();
  }

  // 遍历记忆集
  void iterate(CardClosure* cl);
};
```

### 9.5.3 OtherRegionsTable（PRT层次结构）

记忆集采用三层结构以平衡空间和时间：

源码位置：`src/hotspot/share/gc/g1/heapRegionRemSet.hpp:70-170`

```cpp
class OtherRegionsTable VALUE_OBJ_CLASS_SPEC {
  friend class HeapRegionRemSetIterator;

private:
  HeapRegion*      _hr;
  
  // 粗粒度位图：每个Region一位
  // 如果位为1，表示该Region中可能有引用指向本Region
  BitMap           _coarse_map;  // 2048 bits = 256 bytes
  size_t           _n_coarse_entries;  // 粗粒度条目数
  
  // 细粒度PRT数组：每个条目对应一个Region的详细卡信息
  PerRegionTable** _fine_grain_regions;
  size_t           _n_fine_entries;
  size_t           _fine_eviction_start;  // LRU淘汰起点
  
  // 稀疏PRT：用于引用很少的Region
  SparsePRT        _sparse_table;

public:
  // 添加引用
  void add_reference(OopOrNarrowOopStar from);
  
  // 内存占用
  size_t mem_size() const;
  
  // 清空
  void clear();
};
```

**三层结构示意**：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        OtherRegionsTable                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 第1层：Sparse Table（稀疏表）                                        │   │
│  │ 适用于：引用很少的Region（< 某阈值）                                  │   │
│  │ 格式：(RegionIdx, CardIdx) 对                                        │   │
│  │ 示例：[(Region#5, Card#100), (Region#12, Card#200)]                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                              │ 超过阈值                                     │
│                              ▼                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 第2层：Fine-Grain PRT（细粒度表）                                    │   │
│  │ 适用于：引用较多的Region                                             │   │
│  │ 格式：每个Region一个PerRegionTable，包含卡位图                        │   │
│  │ 示例：Region#5 -> BitMap[8192 bits] (每个Region 8192张卡)           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                              │ 空间不足                                     │
│                              ▼                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 第3层：Coarse Map（粗粒度位图）                                      │   │
│  │ 适用于：空间压力大时的降级                                           │   │
│  │ 格式：每个Region一位                                                 │   │
│  │ 大小：2048 bits = 256 bytes                                         │   │
│  │ 含义：位为1表示整个Region需要扫描                                    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.5.4 记忆集内存开销估算

```
假设：8GB堆，2048个Region，平均每个Region有100个跨Region引用

Sparse模式（引用少）：
- 每个条目：8字节（RegionIdx + CardIdx）
- 100个引用：800字节/Region

Fine-Grain模式（引用多）：
- 每个Region的卡位图：8192 bits = 1KB
- 假设20%的Region使用Fine-Grain：2048 × 0.2 × 1KB = 400KB

Coarse模式（降级）：
- 粗粒度位图：2048 bits = 256 bytes/Region
- 全部降级：2048 × 256B = 512KB

实际总开销（混合模式）：
- 估计：每Region平均 2-4KB
- 总计：2048 × 3KB = 6MB（约占堆的0.07%）
```

---

## 9.6 TLAB（Thread Local Allocation Buffer）

### 9.6.1 TLAB原理

TLAB是每个线程私有的分配缓冲区，避免多线程分配时的锁竞争。

源码位置：`src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp:35-120`

```cpp
class ThreadLocalAllocBuffer: public CHeapObj<mtThread> {
  friend class VMStructs;
  friend class JVMCIVMStructs;

private:
  // TLAB边界
  HeapWord* _start;    // TLAB起始地址
  HeapWord* _top;      // 当前分配位置
  HeapWord* _end;      // TLAB结束地址
  
  // 期望大小（动态调整）
  size_t    _desired_size;
  
  // 慢速分配计数（用于调整大小）
  size_t    _refill_waste_limit;  // 浪费阈值
  size_t    _slow_allocations;    // 慢速分配次数

  // 统计信息
  unsigned  _number_of_refills;   // 重填次数
  size_t    _fast_refill_waste;   // 快速重填浪费
  size_t    _slow_refill_waste;   // 慢速重填浪费
  size_t    _gc_waste;            // GC时浪费

public:
  // 快速分配（无锁）
  HeapWord* allocate(size_t size) {
    HeapWord* obj = _top;
    if (pointer_delta(_end, _top) >= size) {
      _top = _top + size;
      return obj;
    }
    return NULL;  // TLAB空间不足，需要慢速路径
  }

  // TLAB剩余空间
  size_t free() const { return pointer_delta(_end, _top); }

  // TLAB已用空间
  size_t used() const { return pointer_delta(_top, _start); }
};
```

### 9.6.2 TLAB分配流程

```
线程分配对象
      │
      ▼
┌─────────────────┐
│ TLAB快速分配    │ ──► top += size, 返回对象地址
│ (无锁，99%情况) │
└────────┬────────┘
         │ TLAB空间不足
         ▼
┌─────────────────┐
│ 检查剩余空间    │
│ vs 浪费阈值    │
└────────┬────────┘
         │
    ┌────┴────┐
    │         │
    ▼         ▼
剩余 < 阈值  剩余 >= 阈值
    │         │
    ▼         ▼
┌─────────┐  ┌──────────────┐
│ 申请新  │  │ 在TLAB外直接 │
│ TLAB    │  │ 分配（慢速） │
└────┬────┘  └──────────────┘
     │
     ▼
┌─────────────────┐
│ 从Eden Region   │
│ 分配新TLAB      │
│ (需要CAS或锁)   │
└─────────────────┘
```

### 9.6.3 TLAB大小计算

```cpp
// 默认TLAB大小计算（简化）
size_t initial_tlab_size() {
  // 基于Eden大小和线程数
  size_t eden_size = ...;
  size_t thread_count = ...;
  
  // 每个线程的期望TLAB大小
  size_t tlab_size = eden_size / (thread_count * target_refills);
  
  // 限制在合理范围
  tlab_size = MAX2(tlab_size, min_tlab_size);
  tlab_size = MIN2(tlab_size, max_tlab_size);
  
  return tlab_size;
}
```

**典型TLAB大小**：

| 场景 | TLAB大小 |
|------|----------|
| 默认 | 约256KB - 1MB |
| 小对象密集 | 可能更大 |
| 线程很多 | 可能更小 |

---

## 9.7 PLAB（Promotion Local Allocation Buffer）

### 9.7.1 PLAB作用

PLAB是GC线程私有的分配缓冲区，用于对象晋升（从Young到Old）时避免锁竞争。

源码位置：`src/hotspot/share/gc/shared/plab.hpp:35-100`

```cpp
class PLAB: public CHeapObj<mtGC> {
protected:
  // 缓冲区边界
  HeapWord* _word_sz;      // 缓冲区大小（字）
  HeapWord* _bottom;       // 起始地址
  HeapWord* _top;          // 当前分配位置
  HeapWord* _end;          // 结束地址
  HeapWord* _hard_end;     // 硬边界
  
  // 对齐填充
  size_t    _alignment_reserve;

public:
  // 在PLAB中分配
  HeapWord* allocate(size_t word_sz) {
    HeapWord* res = _top;
    if (pointer_delta(_end, _top) >= word_sz) {
      _top = _top + word_sz;
      return res;
    }
    return NULL;
  }

  // 设置新缓冲区
  void set_buf(HeapWord* buf, size_t word_sz) {
    _bottom = buf;
    _top = buf;
    _hard_end = buf + word_sz;
    _end = _hard_end - _alignment_reserve;
    _word_sz = word_sz;
  }
};
```

### 9.7.2 TLAB vs PLAB

| 特性 | TLAB | PLAB |
|------|------|------|
| 所有者 | 应用线程 | GC线程 |
| 用途 | 新对象分配 | 对象晋升/复制 |
| 位置 | Eden Region | Survivor/Old Region |
| 生命周期 | 线程存活期间 | 单次GC期间 |
| 大小 | 较大（256KB-1MB） | 较小（4KB-64KB） |

---

## 9.8 压缩指针 (GDB验证) ⭐

### 9.8.1 压缩对象指针 (Compressed Oops)

**GDB验证数据**：
```gdb
Universe::_narrow_oop = {
  _base = 0x0,                      # Zero-based模式
  _shift = 3,                       # 左移3位(×8)
  _use_implicit_null_checks = true  # 启用隐式空检查
}
```

**解码公式**: `实际地址 = narrow_oop << 3`

**压缩模式选择**：

| 模式 | _base | _shift | 条件 | 地址计算 |
|------|-------|--------|------|---------|
| Unscaled | 0 | 0 | 堆 < 4GB | `addr = narrow_oop` |
| **Zero-based** ✅ | 0 | 3 | 堆 < 32GB | `addr = narrow_oop << 3` |
| Disjoint | 32GB对齐 | 3 | 堆 > 32GB | `addr = narrow_oop << 3 \| base` |
| Heap-based | 非0 | 3 | 其他 | `addr = (narrow_oop << 3) + base` |

**8GB堆使用Zero-based模式**：堆结束地址 `0x800000000` (32GB) ≤ OopEncodingHeapMax(32GB)

### 9.8.2 压缩类指针 (Compressed Class Pointers)

**GDB验证数据**：
```gdb
Universe::_narrow_klass = {
  _base = 0x800000000,              # 32GB位置（紧接堆后）
  _shift = 0,                       # 无需位移
  _use_implicit_null_checks = true
}
```

**解码公式**: `实际地址 = narrow_klass + 0x800000000`

---

## 9.9 Humongous对象

### 9.8.1 Humongous对象定义

大于Region大小50%的对象被视为Humongous对象，直接分配在Old区的连续Region中。

```cpp
// 判断是否为Humongous对象
bool is_humongous(size_t word_size) {
  // word_size > Region大小的一半
  return word_size > HeapRegion::GrainWords / 2;
  // 8GB堆：4MB / 2 = 2MB，即 > 256K words
}
```

**8GB堆的Humongous阈值**：
- Region大小：4MB
- Humongous阈值：4MB / 2 = 2MB
- 大于2MB的对象 → Humongous

### 9.8.2 Humongous分配

```
Humongous对象分配（假设对象大小 = 10MB）

需要Region数：ceil(10MB / 4MB) = 3个

┌─────────────────────────────────────────────────────────────────┐
│                      寻找连续空闲Region                          │
├─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬────┤
│ E   │ E   │ O   │Free │Free │Free │ O   │ E   │Free │Free │... │
│ #0  │ #1  │ #2  │ #3  │ #4  │ #5  │ #6  │ #7  │ #8  │ #9  │    │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴────┘
                    │     │     │
                    └─────┴─────┘
                    找到3个连续空闲Region (#3, #4, #5)

分配后：
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬────┐
│ E   │ E   │ O   │ HS  │ HC  │ HC  │ O   │ E   │Free │Free │... │
│ #0  │ #1  │ #2  │ #3  │ #4  │ #5  │ #6  │ #7  │ #8  │ #9  │    │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴────┘
                    │     │     │
                    HS = Humongous Start (Tag=5)
                    HC = Humongous Continues (Tag=6)
```

### 9.8.3 Humongous对象的GC特点

1. **不参与Young GC**：Humongous对象不会被Young GC移动
2. **Eager Reclaim**：如果Humongous对象不可达，可以在Young GC时直接回收
3. **Full GC压缩**：只有Full GC才会压缩Humongous区域

---

## 9.9 元空间（Metaspace）

### 9.9.1 元空间结构

元空间存储类元数据，位于本地内存（非堆）。

源码位置：`src/hotspot/share/memory/metaspace.hpp:90-180`

```cpp
class Metaspace : public AllStatic {
public:
  // 元空间类型
  enum MetaspaceType {
    StandardMetaspaceType,      // 普通类
    BootMetaspaceType,          // 启动类
    UnsafeAnonymousMetaspaceType, // 匿名类
    ReflectionMetaspaceType     // 反射类
  };

private:
  // 类元空间（存储Klass结构）
  static VirtualSpaceList* _class_space_list;
  
  // 非类元空间（存储方法、常量池等）
  static VirtualSpaceList* _space_list;

public:
  // 分配元数据
  static MetaWord* allocate(ClassLoaderData* loader_data,
                            size_t word_size,
                            MetaspaceObj::Type type);

  // 回收元数据
  static void purge(ClassLoaderData* loader_data);

  // 统计信息
  static size_t used_bytes() { return used_bytes(NonClassType) + used_bytes(ClassType); }
  static size_t capacity_bytes() { ... }
  static size_t reserved_bytes() { ... }
};
```

### 9.9.2 元空间布局

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Metaspace                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    Class Space（压缩类指针空间）                      │   │
│  │                                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │ Klass结构（InstanceKlass, ArrayKlass等）                     │   │   │
│  │  │ 大小受 CompressedClassSpaceSize 限制（默认1GB）               │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    Non-Class Space（非类空间）                       │   │
│  │                                                                     │   │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐     │   │
│  │  │   Method        │  │   ConstantPool  │  │   Annotations   │     │   │
│  │  │   (方法元数据)   │  │   (常量池)       │  │   (注解)         │     │   │
│  │  └─────────────────┘  └─────────────────┘  └─────────────────┘     │   │
│  │                                                                     │   │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐     │   │
│  │  │   Symbol        │  │   MethodData    │  │   ...           │     │   │
│  │  │   (符号)         │  │   (方法统计)     │  │                 │     │   │
│  │  └─────────────────┘  └─────────────────┘  └─────────────────┘     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.9.3 元空间参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| MetaspaceSize | 约20MB | 初始元空间大小 |
| MaxMetaspaceSize | 无限制 | 最大元空间大小 |
| CompressedClassSpaceSize | 1GB | 压缩类空间大小 |
| MinMetaspaceFreeRatio | 40% | 最小空闲比例 |
| MaxMetaspaceFreeRatio | 70% | 最大空闲比例 |

---

## 9.10 内存分配完整流程

### 9.10.1 对象分配决策树

```
                          new Object()
                               │
                               ▼
                    ┌──────────────────┐
                    │ 计算对象大小      │
                    │ (header + fields) │
                    └────────┬─────────┘
                             │
                             ▼
                    ┌──────────────────┐
                    │ size > 2MB ?     │ (Humongous阈值)
                    └────────┬─────────┘
                             │
              ┌──────────────┴──────────────┐
              │ Yes                         │ No
              ▼                             ▼
     ┌────────────────┐           ┌────────────────┐
     │ Humongous分配  │           │ TLAB分配尝试   │
     │ (连续Region)   │           │ (无锁快速路径) │
     └────────────────┘           └───────┬────────┘
                                          │
                                 ┌────────┴────────┐
                                 │ 成功            │ 失败
                                 ▼                 ▼
                          ┌──────────┐    ┌────────────────┐
                          │ 返回对象 │    │ TLAB剩余空间   │
                          └──────────┘    │ < 浪费阈值?    │
                                          └───────┬────────┘
                                                  │
                                    ┌─────────────┴─────────────┐
                                    │ Yes                       │ No
                                    ▼                           ▼
                           ┌────────────────┐          ┌────────────────┐
                           │ 申请新TLAB     │          │ 在TLAB外分配   │
                           │ (从Eden Region)│          │ (慢速路径)     │
                           └───────┬────────┘          └───────┬────────┘
                                   │                           │
                                   ▼                           ▼
                           ┌────────────────┐          ┌────────────────┐
                           │ 在新TLAB中分配 │          │ CAS分配        │
                           └───────┬────────┘          │ (可能触发GC)   │
                                   │                   └───────┬────────┘
                                   ▼                           │
                            ┌──────────┐                       │
                            │ 返回对象 │◄──────────────────────┘
                            └──────────┘
```

### 9.10.2 分配代码路径

```cpp
// 简化的分配流程（实际代码更复杂）
HeapWord* G1CollectedHeap::attempt_allocation(size_t word_size) {
  // 1. 尝试TLAB分配
  HeapWord* result = Thread::current()->tlab().allocate(word_size);
  if (result != NULL) {
    return result;
  }
  
  // 2. TLAB分配失败，尝试慢速路径
  return attempt_allocation_slow(word_size);
}

HeapWord* G1CollectedHeap::attempt_allocation_slow(size_t word_size) {
  // 3. 尝试在当前分配Region中分配
  HeapWord* result = _mutator_alloc_region.attempt_allocation(word_size);
  if (result != NULL) {
    return result;
  }
  
  // 4. 需要新Region
  result = attempt_allocation_at_safepoint(word_size, true /* expect_gc_triggered */);
  
  // 5. 如果还是失败，可能触发GC
  if (result == NULL) {
    result = do_collection_pause(word_size, ...);
  }
  
  return result;
}
```

---

## 9.11 NMT真实内存布局验证 ⭐

> **本节基于NMT(Native Memory Tracking)工具验证JVM真实内存占用**
> **验证时间**: 2026-01-15 | **验证配置**: 8GB堆, G1GC, Linux x86_64

### 9.11.1 传统八股文 vs 真实内存结构

**传统八股文描述**（只覆盖约85%）：
```
┌─────────────────────────────────────┐
│             JVM 内存结构              │
├─────────────────────────────────────┤
│  堆 (Heap)                           │
│  ├─ 新生代 (Eden + S0 + S1)          │
│  └─ 老年代                           │
├─────────────────────────────────────┤
│  方法区 / 元空间 (Metaspace)          │
├─────────────────────────────────────┤
│  虚拟机栈 (VM Stack)                  │
├─────────────────────────────────────┤
│  本地方法栈 (Native Method Stack)     │
├─────────────────────────────────────┤
│  程序计数器 (PC Register)             │
└─────────────────────────────────────┘
```

**真实内存结构（NMT验证）**：
```
Native Memory Tracking:
Total: reserved=10,360,591,563 (~9.65GB), committed=9,018,533,067 (~8.40GB)

┌──────────────────────────────────────────────────────────────────────────────┐
│ 内存区域              │  Reserved (保留)    │  Committed (提交)  │ 说明        │
├──────────────────────────────────────────────────────────────────────────────┤
│ Java Heap            │ 8,589,934,592 (8GB) │ 8,589,934,592 (8GB)│ 用户对象堆   │
│ Class (Metaspace)    │ 1,082,380,651 (~1GB)│ 7,197,035 (~6.9MB) │ 类元数据     │
│ Thread               │ 23,177,120 (~22MB)  │ 1,144,736 (~1.1MB) │ 线程栈       │
│ Code                 │ 254,936,025 (~243MB)│ 10,093,529 (~9.6MB)│ JIT代码缓存  │
│ GC                   │ 392,629,063 (~374MB)│ 392,629,063 (~374MB)│ GC辅助结构  │
│ Compiler             │ 1,662,234 (~1.6MB)  │ 1,662,234 (~1.6MB) │ 编译器       │
│ Internal             │ 604,603 (~590KB)    │ 604,603 (~590KB)   │ 内部结构     │
│ Symbol               │ 2,626,280 (~2.5MB)  │ 2,626,280 (~2.5MB) │ 符号表       │
│ NMT                  │ 961,736 (~939KB)    │ 961,736 (~939KB)   │ NMT追踪开销  │
│ Arena Chunk          │ 11,520,872 (~11MB)  │ 11,520,872 (~11MB) │ Arena分配    │
│ 其他                 │ ~6 MB               │ ~6 MB              │ 模块/同步等  │
└──────────────────────────────────────────────────────────────────────────────┘
```

**关键发现**: 8GB堆的JVM实际需要约 **9.65GB** 虚拟地址空间保留，**8.40GB** 物理内存提交！

### 9.11.2 64位虚拟地址空间布局（日志验证）

```
虚拟地址 (64-bit)                                           大小
    │
    ▼
0x0000000600000000 (24GB) ─┬──────────────────────────────  Java Heap 起始
                           │
                           │   G1 Heap: 2048个 Region
                           │   每个 Region: 4MB
                           │   总大小: 8GB
                           │
                           │   第一个Region: [0x600000000, 0x600400000)
                           │   最后Region: [0x7ffc00000, 0x800000000)
                           │
0x0000000800000000 (32GB) ─┴──────────────────────────────  Java Heap 结束
                           │
                           ├──────────────────────────────  Compressed Class Space 起始
                           │   大小: 1GB (1,073,741,824 bytes)
                           │   地址: [0x800000000, 0x840000000)
                           │   Narrow klass base: 0x800000000
                           │   Narrow klass shift: 0
                           │
0x0000000840000000 (33GB) ─┴──────────────────────────────  Compressed Class Space 结束

... (高地址区域) ...

0x00007f4d5c908000        ─┬──────────────────────────────  G1CardTable 起始
                           │   大小: 16MB (16,777,216 bytes)
                           │   覆盖: 8GB Heap (1 byte = 512 bytes)
0x00007f4d5d907fff        ─┴──────────────────────────────  G1CardTable 结束

0x00007f4d5d908000        ─┬──────────────────────────────  G1BlockOffsetTable 起始
                           │   大小: 16MB (16,777,216 bytes)
0x00007f4d5e908000        ─┴──────────────────────────────  G1BlockOffsetTable 结束

0x00007f79c9000000        ─┬──────────────────────────────  CodeHeap 起始
                           │   non-nmethods: 7.2MB
                           │   profiled nmethods: 116MB
                           │   non-profiled nmethods: 116MB
0x00007f79d8000000        ─┴──────────────────────────────  CodeCache 结束 (~245MB)
```

### 9.11.3 GC辅助数据结构详解

```
GC (reserved=392,629,063, committed=392,629,063) ~374MB

详细分布:
├── 134,217,728 (128MB) - Prev Bitmap    ← Heap/64, 标记上一次并发标记结果
├── 134,217,728 (128MB) - Next Bitmap    ← Heap/64, 当前并发标记结果  
├── 16,777,216 (16MB)   - G1CardTable    ← Heap/512, 跨Region引用追踪
├── 16,777,216 (16MB)   - G1BlockOffsetTable ← Heap/512, 快速定位对象
├── ~40MB               - 其他G1结构     ← RememberedSet, G1FromCardCache等
────────────────────────
总计: ~374MB (占堆的4.7%)
```

**GC结构计算公式验证**：

| 结构 | 公式 | 8GB堆计算 | 实际验证 |
|------|------|----------|---------|
| **Bitmap (单个)** | Heap / 64 | 8GB / 64 = 128MB | ✓ |
| **Bitmap (两个)** | Heap / 32 | 8GB / 32 = 256MB | ✓ |
| **CardTable** | Heap / 512 | 8GB / 512 = 16MB | ✓ |
| **BOT** | Heap / 512 | 8GB / 512 = 16MB | ✓ |

### 9.11.4 CodeCache三段式结构

```log
CodeHeap 'non-nmethods': size=7420Kb used=3433Kb max_used=3455Kb free=3986Kb
 bounds [0x00007f79c9000000, 0x00007f79c9370000, 0x00007f79c973f000]

CodeHeap 'profiled nmethods': size=119168Kb used=902Kb max_used=902Kb free=118265Kb
 bounds [0x00007f79c973f000, 0x00007f79c99af000, 0x00007f79d0b9f000]

CodeHeap 'non-profiled nmethods': size=119172Kb used=255Kb max_used=255Kb free=118916Kb
 bounds [0x00007f79d0b9f000, 0x00007f79d0e0f000, 0x00007f79d8000000]

total_blobs=1386 nmethods=511 adapters=794
```

```
CodeCache (总计 ~245MB reserved, ~10MB committed)
┌─────────────────────────────────────────────────────────────────────────────┐
│  non-nmethods (7.2MB)  │  profiled nmethods (116MB) │ non-profiled (116MB)  │
│  ─────────────────────  │  ───────────────────────── │ ───────────────────── │
│  • VM stubs            │  • C1编译的带profile代码    │ • C2编译的优化代码     │
│  • Adapters (794个)     │  • 热点分析中的方法         │ • 完全优化的方法       │
│  used: 3,433KB         │  used: 902KB              │ used: 255KB           │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.11.5 内存占用比例总结

| 区域 | Reserved | Committed | 占比(Reserved) |
|------|----------|-----------|----------------|
| Java Heap | 8,589,934,592 (8.00 GB) | 8,589,934,592 (8.00 GB) | **82.90%** |
| Class/Metaspace | 1,082,380,651 (1.01 GB) | 7,197,035 (6.87 MB) | 10.44% |
| GC | 392,629,063 (374.51 MB) | 392,629,063 (374.51 MB) | 3.79% |
| Code | 254,936,025 (243.15 MB) | 10,093,529 (9.63 MB) | 2.46% |
| Thread | 23,177,120 (22.10 MB) | 1,144,736 (1.09 MB) | 0.22% |
| 其他 | ~17 MB | ~17 MB | 0.19% |
| **总计** | **~9.65 GB** | **~8.40 GB** | 100% |

```
8GB 堆配置的真实内存分布 (Reserved):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Java Heap (8GB, 82.9%)  █████████████████████████████████████████████████████████████████████
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Class/Metaspace (~1GB)  ████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
GC (~374MB)             ███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Code (~243MB)           ██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
（█ = committed, ░ = reserved but not committed）
```

### 9.11.6 NMT验证命令

```bash
# 获取 NMT 内存统计
java -Xms8g -Xmx8g -XX:+UseG1GC -XX:-UseLargePages \
     -XX:NativeMemoryTracking=summary -XX:+UnlockDiagnosticVMOptions -XX:+PrintNMTStatistics \
     HelloWorld

# 获取详细 GC/Heap 日志
java -Xms8g -Xmx8g -XX:+UseG1GC -XX:-UseLargePages \
     -Xlog:gc+heap*=trace,gc+metaspace*=trace,gc+bot*=trace,gc+barrier*=trace,gc+region*=trace \
     HelloWorld

# 获取 CodeCache 信息
java -Xms8g -Xmx8g -XX:+UseG1GC -XX:-UseLargePages \
     -XX:+PrintCodeCache \
     HelloWorld
```

### 9.11.7 核心结论

1. **传统八股文只覆盖了约85%的内存**: 漏掉了GC数据结构（~374MB）、CodeCache（~243MB）等关键区域

2. **8GB堆需要约9.65GB虚拟地址空间**: 额外的1.65GB (17%)用于：
   - GC辅助结构: 374MB (Bitmap + CardTable + BOT)
   - CodeCache: 243MB (JIT编译代码)
   - Metaspace: 1GB reserved
   - Thread: 22MB
   - 其他: ~16MB

3. **G1的额外开销约4.7%**: 对于8GB堆，G1需要约374MB的辅助数据结构
   - 2个 Marking Bitmap: 256MB (128MB × 2)
   - CardTable: 16MB
   - BOT: 16MB
   - 其他: ~86MB

4. **Reserved ≠ Committed**: 
   - Reserved (9.65GB): 虚拟地址空间保留，不占用物理内存
   - Committed (8.40GB): 实际提交的物理内存

---

## 9.12 本章小结

本章详细分析了G1的内存结构：

| 组件 | 作用 | 8GB堆的关键数值 |
|------|------|----------------|
| **HeapRegion** | 堆的基本单元 | 4MB × 2048个 |
| **Card Table** | 跨代引用追踪 | 16MB（512B/卡） |
| **Block Offset Table** | 对象快速定位 | 16MB（512B/条目） |
| **Marking Bitmap ×2** | 并发标记 | 256MB（128MB×2） |
| **Remembered Set** | 记录"谁引用我" | 约6MB（估计） |
| **TLAB** | 线程私有分配缓冲 | 256KB-1MB/线程 |
| **PLAB** | GC线程私有缓冲 | 4KB-64KB/GC线程 |
| **Humongous** | 大对象分配 | >2MB的对象 |
| **Metaspace** | 类元数据存储 | 1GB reserved |
| **CodeCache** | JIT编译代码 | 243MB reserved |

**关键计算公式**：

```
Region大小 = MAX(堆大小 / 2048, 1MB)，向下取2的幂次，上限32MB
Region数量 = 堆大小 / Region大小
卡表大小 = 堆大小 / 512
Bitmap大小 = 堆大小 / 64 (单个)
每Region卡数 = Region大小 / 512
Humongous阈值 = Region大小 / 2
GC额外开销 ≈ 堆大小 × 4.7%
```

**下一章预告**：第10章将深入G1垃圾收集器的GC过程，包括Young GC、Mixed GC、并发标记等核心算法。
