# 第21章 性能监控与诊断

## 21.1 引言

性能监控与诊断是Java虚拟机运维和优化的核心功能，HotSpot VM提供了一套完整的监控体系，包括Java Flight Recorder (JFR)、Management API、诊断命令、性能计数器等多个层面的监控工具。这些工具不仅能够实时监控JVM的运行状态，还能帮助开发者和运维人员快速定位性能瓶颈和故障原因。

本章将深入分析HotSpot VM性能监控与诊断机制的实现原理，包括JFR事件系统、Management接口、诊断命令框架、性能数据收集以及各种监控工具的底层实现。

## 21.2 Java Flight Recorder (JFR)

### 21.2.1 JFR架构概述

Java Flight Recorder是HotSpot VM内置的低开销性能监控和诊断工具：

```cpp
// src/hotspot/share/jfr/jfr.cpp:36
bool Jfr::is_enabled() {
  return JfrRecorder::is_enabled();
}

bool Jfr::is_disabled() {
  return JfrRecorder::is_disabled();
}

bool Jfr::is_recording() {
  return JfrRecorder::is_recording();
}

// JFR生命周期管理
void Jfr::on_create_vm_1() {
  if (!JfrRecorder::on_create_vm_1()) {
    vm_exit_during_initialization("Failure when starting JFR on_create_vm_1");
  }
}

void Jfr::on_create_vm_2() {
  if (!JfrRecorder::on_create_vm_2()) {
    vm_exit_during_initialization("Failure when starting JFR on_create_vm_2");
  }
}

void Jfr::on_create_vm_3() {
  if (!JfrRecorder::on_create_vm_3()) {
    vm_exit_during_initialization("Failure when starting JFR on_create_vm_3");
  }
}
```

### 21.2.2 JfrRecorder核心类

JfrRecorder是JFR系统的核心管理类：

```cpp
// src/hotspot/share/jfr/recorder/jfrRecorder.hpp:37
class JfrRecorder : public JfrCHeapObj {
  friend class Jfr;
  friend void recorderthread_entry(JavaThread*, Thread*);
 private:
  static bool on_create_vm_1();
  static bool on_create_vm_2();
  static bool on_create_vm_3();
  static bool create_checkpoint_manager();
  static bool create_chunk_repository();
  static bool create_java_event_writer();
  static bool create_jvmti_agent();
  static bool create_os_interface();
  static bool create_post_box();
  static bool create_recorder_thread();
  static bool create_stacktrace_repository();
  static bool create_storage();
  static bool create_stringpool();
  static bool create_thread_sampling();
  static bool create_components();
  static void destroy_components();
  static void on_recorder_thread_exit();

 public:
  static bool is_enabled();
  static bool is_disabled();
  static bool create(bool simulate_failure);
  static bool is_created();
  static void destroy();
  static void start_recording();
  static bool is_recording();
  static void stop_recording();
};
```

JFR系统的初始化过程分为三个阶段，每个阶段创建不同的组件：

```cpp
// JFR组件创建
bool JfrRecorder::create_components() {
  if (!create_os_interface()) {
    return false;
  }
  if (!create_checkpoint_manager()) {
    return false;
  }
  if (!create_storage()) {
    return false;
  }
  if (!create_stringpool()) {
    return false;
  }
  if (!create_post_box()) {
    return false;
  }
  if (!create_chunk_repository()) {
    return false;
  }
  if (!create_stacktrace_repository()) {
    return false;
  }
  return true;
}

bool JfrRecorder::create_recorder_thread() {
  return JfrRecorderThread::start(THREAD);
}

bool JfrRecorder::create_thread_sampling() {
  return JfrThreadSampler::initialize();
}
```

### 21.2.3 JFR事件系统

JFR事件系统基于高效的事件生成和记录机制：

```cpp
// JFR事件的基本结构
template<typename T>
class JfrEvent : public StackObj {
 private:
  bool _started;
  bool _committed;
  bool _should_commit;
  
 protected:
  jlong _startTime;
  jlong _endTime;
  
 public:
  JfrEvent(EventStartTime timing = TIMED) : _started(false), _committed(false) {
    if (T::is_enabled()) {
      _should_commit = true;
      if (TIMED == timing && !T::isInstant) {
        set_starttime(JfrTicks::now());
      }
      _started = true;
    } else {
      _should_commit = false;
    }
  }
  
  void commit() {
    if (!should_commit()) {
      return;
    }
    
    if (_started) {
      if (!T::isInstant) {
        set_endtime(JfrTicks::now());
      }
      
      if (should_write()) {
        write_event();
        _committed = true;
      }
    }
  }
  
  bool should_commit() const {
    return _should_commit && !_committed;
  }
  
 private:
  bool should_write() const {
    return _startTime != 0;
  }
  
  void write_event() {
    Thread* const event_thread = Thread::current();
    JfrBuffer* const buffer = event_thread->jfr_thread_local()->native_buffer();
    if (buffer == NULL) {
      // 缓冲区不可用，跳过事件
      return;
    }
    
    JfrNativeEventWriter writer(buffer, event_thread);
    writer.write<u8>(T::eventId);
    writer.write(_startTime);
    if (!T::isInstant) {
      writer.write(_endTime);
    }
    
    // 写入事件特定数据
    static_cast<T*>(this)->writeData(writer);
  }
};
```

### 21.2.4 事件采样和线程采样

JFR提供了高效的线程采样机制：

```cpp
// src/hotspot/share/jfr/periodic/sampling/jfrThreadSampler.cpp
class JfrThreadSampler : public NonJavaThread {
 private:
  JfrBuffer* _enqueue_buffer;
  JfrBuffer* _subbuffer;
  Thread* _sampler_thread;
  JfrStackTrace* _stacktrace;
  volatile bool _disenrolled;
  
  static Monitor* _transition_block_lock;
  static JfrThreadSampler* _instance;
  static volatile bool _created;
  
 public:
  JfrThreadSampler();
  ~JfrThreadSampler();
  
  static bool initialize();
  static void destroy();
  static void start_thread();
  static void enroll();
  static void disenroll();
  static JfrThreadSampler* instance() { return _instance; }
  
  void run() override;
  void task_stacktrace(JfrSampleType type, JavaThread** last_thread);
  void pre_run() override;
  void post_run() override;
  
 private:
  void thread_sample();
  void sleep();
};

// 线程采样的核心逻辑
void JfrThreadSampler::task_stacktrace(JfrSampleType type, JavaThread** last_thread) {
  ResourceMark rm;
  EventExecutionSample sample(UNTIMED);
  
  JavaThreadIteratorWithHandle jtiwh;
  for (JavaThread* jt = jtiwh.next(); jt != NULL; jt = jtiwh.next()) {
    if (jt->is_Compiler_thread()) {
      continue;
    }
    
    if (thread_state_in_java(jt)) {
      sample.set_starttime(JfrTicks::now());
      sample.set_sampledThread(JfrThreadId::jfr_id(jt));
      
      if (_stacktrace->record_thread(*jt, sample.get_starttime())) {
        sample.set_stackTrace(_stacktrace->id());
        sample.set_state((u8)java_lang_Thread::get_thread_status(jt->threadObj()));
        sample.commit();
      }
    }
  }
}

// 执行采样
void JfrThreadSampler::thread_sample() {
  if (!_instance->_disenrolled) {
    task_stacktrace(JfrStackTrace::PROFILING, NULL);
  }
}

void JfrThreadSampler::run() {
  assert(_instance == this, "invariant");
  
  while (true) {
    if (!_disenrolled) {
      thread_sample();
    }
    
    if (_disenrolled) {
      break;
    }
    
    sleep();
  }
  
  delete _instance;
  _instance = NULL;
}
```

### 21.2.5 JFR存储和缓冲

JFR使用高效的缓冲机制来最小化性能开销：

```cpp
// JFR缓冲区管理
class JfrBuffer : public JfrCHeapObj {
 private:
  const void* _identity;
  void* _pos;
  const void* _top;
  u2 _flags;
  u2 _header_size;
  u4 _size;
  
 public:
  JfrBuffer() : _identity(NULL),
                _pos(NULL),
                _top(NULL),
                _flags(0),
                _header_size(0),
                _size(0) {}
  
  void* pos() const { return _pos; }
  void set_pos(void* position) { _pos = position; }
  
  const void* top() const { return _top; }
  void set_top(const void* top) { _top = top; }
  
  size_t free_size() const {
    return pointer_delta(_top, _pos, sizeof(char));
  }
  
  size_t used_size() const {
    return pointer_delta(_pos, start(), sizeof(char));
  }
  
  void* start() const {
    return ((char*)this) + _header_size;
  }
  
  bool acquire(Thread* thread) {
    return Atomic::cmpxchg(thread, (Thread**)&_identity, (Thread*)NULL) == NULL;
  }
  
  void release() {
    OrderAccess::storestore();
    _identity = NULL;
  }
};

// 线程本地JFR存储
class JfrThreadLocal {
 private:
  jobject _java_event_writer;
  mutable JfrBuffer* _java_buffer;
  mutable JfrBuffer* _native_buffer;
  JfrBuffer* _shelved_buffer;
  mutable u8 _data_lost;
  volatile jint _dead;
  
 public:
  JfrThreadLocal() : _java_event_writer(NULL),
                     _java_buffer(NULL),
                     _native_buffer(NULL),
                     _shelved_buffer(NULL),
                     _data_lost(0),
                     _dead(0) {}
  
  ~JfrThreadLocal() {
    if (_java_event_writer != NULL) {
      JNIHandles::destroy_global(_java_event_writer);
    }
    if (_java_buffer != NULL) {
      JfrStorage::release_thread_local(_java_buffer, Thread::current());
    }
    if (_native_buffer != NULL) {
      JfrStorage::release_thread_local(_native_buffer, Thread::current());
    }
  }
  
  JfrBuffer* native_buffer() const {
    if (_native_buffer == NULL) {
      _native_buffer = JfrStorage::acquire_thread_local(Thread::current());
    }
    return _native_buffer;
  }
  
  JfrBuffer* java_buffer() const {
    if (_java_buffer == NULL) {
      _java_buffer = JfrStorage::acquire_thread_local(Thread::current());
    }
    return _java_buffer;
  }
  
  void set_dead() {
    _dead = 1;
  }
  
  bool is_dead() const {
    return _dead == 1;
  }
};
```

## 21.3 Management API

### 21.3.1 Management接口架构

HotSpot VM通过Management类提供JMX监控接口：

```cpp
// src/hotspot/share/services/management.hpp:36
class Management : public AllStatic {
 private:
  static PerfVariable*      _begin_vm_creation_time;
  static PerfVariable*      _end_vm_creation_time;
  static PerfVariable*      _vm_init_done_time;
  static jmmOptionalSupport _optional_support;
  static TimeStamp          _stamp; // Timestamp since vm init done time

  // Management klasses
  static InstanceKlass*     _diagnosticCommandImpl_klass;
  static InstanceKlass*     _garbageCollectorExtImpl_klass;
  static InstanceKlass*     _garbageCollectorMXBean_klass;
  static InstanceKlass*     _gcInfo_klass;
  static InstanceKlass*     _managementFactoryHelper_klass;
  static InstanceKlass*     _memoryManagerMXBean_klass;
  static InstanceKlass*     _memoryPoolMXBean_klass;
  static InstanceKlass*     _memoryUsage_klass;
  static InstanceKlass*     _sensor_klass;
  static InstanceKlass*     _threadInfo_klass;

 public:
  static void init();
  static void initialize(TRAPS);
  
  static jlong ticks_to_ms(jlong ticks) NOT_MANAGEMENT_RETURN_(0L);
  static jlong timestamp() NOT_MANAGEMENT_RETURN_(0L);
  
  static void  oops_do(OopClosure* f) NOT_MANAGEMENT_RETURN;
  static void* get_jmm_interface(int version);
  static void  get_optional_support(jmmOptionalSupport* support);
  
  static void get_loaded_classes(JavaThread* cur_thread, GrowableArray<Klass*>* klass_array);
  
  static void  record_vm_startup_time(jlong begin, jlong duration) NOT_MANAGEMENT_RETURN;
  static void  record_vm_init_completed() {
    // Initialize the timestamp to get the current time
    _vm_init_done_time->set_value(os::javaTimeMillis());
    
    // Update the timestamp to the vm init done time
    _stamp.update();
  }
  
  static jlong begin_vm_creation_time() {
    return _begin_vm_creation_time->get_value();
  }
  static jlong vm_init_done_time() {
    return _vm_init_done_time->get_value();
  }
};
```

### 21.3.2 内存监控服务

MemoryService提供内存使用情况的监控：

```cpp
// src/hotspot/share/services/memoryService.hpp:43
class MemoryService : public AllStatic {
 private:
  enum {
    init_pools_list_size = 10,
    init_managers_list_size = 5,
    init_code_heap_pools_size = 9
  };

  static GrowableArray<MemoryPool*>*    _pools_list;
  static GrowableArray<MemoryManager*>* _managers_list;

  // memory manager and code heap pools for the CodeCache
  static MemoryManager*                 _code_cache_manager;
  static GrowableArray<MemoryPool*>*    _code_heap_pools;

  static MemoryPool*                    _metaspace_pool;
  static MemoryPool*                    _compressed_class_pool;

 public:
  static void set_universe_heap(CollectedHeap* heap);
  static void add_code_heap_memory_pool(CodeHeap* heap, const char* name);
  static void add_metaspace_memory_pools();

  static MemoryPool*    get_memory_pool(instanceHandle pool);
  static MemoryManager* get_memory_manager(instanceHandle mgr);

  static const int num_memory_pools() {
    return _pools_list->length();
  }
  static const int num_memory_managers() {
    return _managers_list->length();
  }

  static MemoryPool* get_memory_pool(int index) {
    return _pools_list->at(index);
  }

  static MemoryManager* get_memory_manager(int index) {
    return _managers_list->at(index);
  }

  static void track_memory_usage();
  static void track_code_cache_memory_usage() {
    // Track memory pool usage of all CodeCache memory pools
    for (int i = 0; i < _code_heap_pools->length(); ++i) {
      track_memory_pool_usage(_code_heap_pools->at(i));
    }
  }
  static void track_metaspace_memory_usage() {
    track_memory_pool_usage(_metaspace_pool);
  }
  static void track_compressed_class_memory_usage() {
    track_memory_pool_usage(_compressed_class_pool);
  }
  static void track_memory_pool_usage(MemoryPool* pool);

  static void gc_begin(GCMemoryManager* manager, bool recordGCBeginTime,
                       bool recordAccumulatedGCTime,
                       bool recordPreGCUsage, bool recordPeakUsage);
  static void gc_end(GCMemoryManager* manager, bool recordPostGCUsage,
                     bool recordAccumulatedGCTime,
                     bool recordGCEndTime, bool countCollection,
                     GCCause::Cause cause,
                     bool allMemoryPoolsAffected);

  static void oops_do(OopClosure* f);

  static bool get_verbose() { return log_is_enabled(Info, gc); }
  static bool set_verbose(bool verbose);

  // Create an instance of java/lang/management/MemoryUsage
  static Handle create_MemoryUsage_obj(MemoryUsage usage, TRAPS);
};
```

### 21.3.3 GC监控

GC监控通过TraceMemoryManagerStats类实现：

```cpp
// GC统计信息跟踪
class TraceMemoryManagerStats : public StackObj {
 private:
  GCMemoryManager* _gc_memory_manager;
  bool         _allMemoryPoolsAffected;
  bool         _recordGCBeginTime;
  bool         _recordPreGCUsage;
  bool         _recordPeakUsage;
  bool         _recordPostGCUsage;
  bool         _recordAccumulatedGCTime;
  bool         _recordGCEndTime;
  bool         _countCollection;
  GCCause::Cause _cause;

 public:
  TraceMemoryManagerStats() {}
  TraceMemoryManagerStats(GCMemoryManager* gc_memory_manager,
                          GCCause::Cause cause,
                          bool allMemoryPoolsAffected = true,
                          bool recordGCBeginTime = true,
                          bool recordPreGCUsage = true,
                          bool recordPeakUsage = true,
                          bool recordPostGCUsage = true,
                          bool recordAccumulatedGCTime = true,
                          bool recordGCEndTime = true,
                          bool countCollection = true);

  void initialize(GCMemoryManager* gc_memory_manager,
                  GCCause::Cause cause,
                  bool allMemoryPoolsAffected,
                  bool recordGCBeginTime,
                  bool recordPreGCUsage,
                  bool recordPeakUsage,
                  bool recordPostGCUsage,
                  bool recordAccumulatedGCTime,
                  bool recordGCEndTime,
                  bool countCollection);

  TraceMemoryManagerStats(const TraceMemoryManagerStats& gc_stat);

  ~TraceMemoryManagerStats();
};

// GC开始时的监控
void MemoryService::gc_begin(GCMemoryManager* manager, bool recordGCBeginTime,
                             bool recordAccumulatedGCTime,
                             bool recordPreGCUsage, bool recordPeakUsage) {
  manager->gc_begin(recordGCBeginTime, recordPreGCUsage, recordAccumulatedGCTime);
  
  // Track the peak memory usage when GC begins
  if (recordPeakUsage) {
    for (int i = 0; i < _pools_list->length(); i++) {
      MemoryPool* pool = _pools_list->at(i);
      pool->record_peak_memory_usage();
    }
  }
}

// GC结束时的监控
void MemoryService::gc_end(GCMemoryManager* manager, bool recordPostGCUsage,
                           bool recordAccumulatedGCTime,
                           bool recordGCEndTime, bool countCollection,
                           GCCause::Cause cause,
                           bool allMemoryPoolsAffected) {
  
  // register the GC end statistics and memory usage
  manager->gc_end(recordPostGCUsage, recordAccumulatedGCTime, recordGCEndTime,
                  countCollection, cause);

  if (allMemoryPoolsAffected) {
    for (int i = 0; i < _pools_list->length(); i++) {
      MemoryPool* pool = _pools_list->at(i);
      pool->set_last_collection_usage(pool->get_memory_usage());
    }
  }
}
```

## 21.4 诊断命令框架

### 21.4.1 诊断命令架构

HotSpot VM提供了完整的诊断命令框架：

```cpp
// src/hotspot/share/services/diagnosticCommand.hpp:43
class HelpDCmd : public DCmdWithParser {
 protected:
  DCmdArgument<bool> _all;
  DCmdArgument<char*> _cmd;
 public:
  HelpDCmd(outputStream* output, bool heap);
  static const char* name() { return "help"; }
  static const char* description() {
    return "For more information about a specific command use 'help <command>'. "
           "With no argument this will show a list of available commands. "
           "'help all' will show help for all commands.";
  }
  static const char* impact() { return "Low"; }
  static int num_arguments();
  virtual void execute(DCmdSource source, TRAPS);
};

class VersionDCmd : public DCmd {
 public:
  VersionDCmd(outputStream* output, bool heap) : DCmd(output,heap) { }
  static const char* name() { return "VM.version"; }
  static const char* description() {
    return "Print JVM version information.";
  }
  static const char* impact() { return "Low"; }
  static const JavaPermission permission() {
    JavaPermission p = {"java.util.PropertyPermission",
                        "java.vm.version", "read"};
    return p;
  }
  static int num_arguments() { return 0; }
  virtual void execute(DCmdSource source, TRAPS);
};

class CommandLineDCmd : public DCmd {
 public:
  CommandLineDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }
  static const char* name() { return "VM.command_line"; }
  static const char* description() {
    return "Print the command line used to start this VM instance.";
  }
  static const char* impact() { return "Low"; }
  static const JavaPermission permission() {
    JavaPermission p = {"java.lang.management.ManagementPermission",
                        "monitor", NULL};
    return p;
  }
  static int num_arguments() { return 0; }
  virtual void execute(DCmdSource source, TRAPS) {
    Arguments::print_on(_output);
  }
};
```

### 21.4.2 JFR诊断命令

JFR提供了专门的诊断命令：

```cpp
// src/hotspot/share/jfr/dcmd/jfrDcmds.hpp:30
class JfrDumpFlightRecordingDCmd : public DCmdWithParser {
 protected:
  DCmdArgument<char*> _name;
  DCmdArgument<char*> _filename;
  DCmdArgument<NanoTimeArgument> _maxage;
  DCmdArgument<MemorySizeArgument> _maxsize;
  DCmdArgument<char*> _begin;
  DCmdArgument<char*> _end;
  DCmdArgument<bool>  _path_to_gc_roots;

 public:
  JfrDumpFlightRecordingDCmd(outputStream* output, bool heap);
  static const char* name() {
    return "JFR.dump";
  }
  static const char* description() {
    return "Copies contents of a JFR recording to file. Either the name or the recording id must be specified.";
  }
  static const char* impact() {
    return "Low";
  }
  static const JavaPermission permission() {
    JavaPermission p = {"java.lang.management.ManagementPermission", "monitor", NULL};
    return p;
  }
  static int num_arguments();
  virtual void execute(DCmdSource source, TRAPS);
};

class JfrStartFlightRecordingDCmd : public DCmdWithParser {
 protected:
  DCmdArgument<char*> _name;
  DCmdArgument<StringArrayArgument*> _settings;
  DCmdArgument<NanoTimeArgument> _delay;
  DCmdArgument<NanoTimeArgument> _duration;
  DCmdArgument<bool> _disk;
  DCmdArgument<char*> _filename;
  DCmdArgument<NanoTimeArgument> _maxage;
  DCmdArgument<MemorySizeArgument> _maxsize;
  DCmdArgument<bool> _dump_on_exit;
  DCmdArgument<bool> _path_to_gc_roots;

 public:
  JfrStartFlightRecordingDCmd(outputStream* output, bool heap);
  static const char* name() {
    return "JFR.start";
  }
  static const char* description() {
    return "Starts a new JFR recording";
  }
  static const char* impact() {
    return "Medium: Depending on the settings for a recording, the impact can range from low to high.";
  }
  static const JavaPermission permission() {
    JavaPermission p = {"java.lang.management.ManagementPermission", "monitor", NULL};
    return p;
  }
  static int num_arguments();
  virtual void execute(DCmdSource source, TRAPS);
};

class JfrStopFlightRecordingDCmd : public DCmdWithParser {
 protected:
  DCmdArgument<char*> _name;
  DCmdArgument<char*> _filename;

 public:
  JfrStopFlightRecordingDCmd(outputStream* output, bool heap);
  static const char* name() {
    return "JFR.stop";
  }
  static const char* description() {
    return "Stops a JFR recording";
  }
  static const char* impact() {
    return "Low";
  }
  static const JavaPermission permission() {
    JavaPermission p = {"java.lang.management.ManagementPermission", "monitor", NULL};
    return p;
  }
  static int num_arguments();
  virtual void execute(DCmdSource source, TRAPS);
};
```

### 21.4.3 VM标志诊断命令

VM标志的查看和设置命令：

```cpp
// VM标志打印命令
class PrintVMFlagsDCmd : public DCmdWithParser {
 protected:
  DCmdArgument<bool> _all;
 public:
  PrintVMFlagsDCmd(outputStream* output, bool heap);
  static const char* name() { return "VM.flags"; }
  static const char* description() {
    return "Print VM flag options and their current values.";
  }
  static const char* impact() {
    return "Low";
  }
  static const JavaPermission permission() {
    JavaPermission p = {"java.lang.management.ManagementPermission",
                        "monitor", NULL};
    return p;
  }
  static int num_arguments();
  virtual void execute(DCmdSource source, TRAPS);
};

// VM标志设置命令
class SetVMFlagDCmd : public DCmdWithParser {
 protected:
  DCmdArgument<char*> _flag;
  DCmdArgument<char*> _value;

 public:
  SetVMFlagDCmd(outputStream* output, bool heap);
  static const char* name() { return "VM.set_flag"; }
  static const char* description() {
    return "Sets VM flag option using the provided value.";
  }
  static const char* impact() {
    return "Low";
  }
  static const JavaPermission permission() {
    JavaPermission p = {"java.lang.management.ManagementPermission",
                        "control", NULL};
    return p;
  }
  static int num_arguments();
  virtual void execute(DCmdSource source, TRAPS);
};

// 执行VM标志设置
void SetVMFlagDCmd::execute(DCmdSource source, TRAPS) {
  const char* flag_name = _flag.value();
  const char* flag_value = _value.value();

  JVMFlag* flag = JVMFlag::find_flag(flag_name);
  if (flag == NULL) {
    output()->print_cr("Error: VM option '%s' is unknown.", flag_name);
    return;
  }

  // 检查标志是否可写
  if (!flag->is_writeable()) {
    output()->print_cr("Error: VM option '%s' is not writeable.", flag_name);
    return;
  }

  bool succeed = false;
  if (flag->is_bool()) {
    bool bvalue;
    if (Arguments::parse_argument_bool(flag_value, &bvalue)) {
      succeed = JVMFlag::set_bool(flag_name, &bvalue, JVMFlag::MANAGEMENT);
    }
  } else if (flag->is_int()) {
    int ivalue;
    if (Arguments::parse_argument_int(flag_value, &ivalue)) {
      succeed = JVMFlag::set_int(flag_name, &ivalue, JVMFlag::MANAGEMENT);
    }
  } else if (flag->is_uint()) {
    uint uvalue;
    if (Arguments::parse_argument_uint(flag_value, &uvalue)) {
      succeed = JVMFlag::set_uint(flag_name, &uvalue, JVMFlag::MANAGEMENT);
    }
  } else if (flag->is_intx()) {
    intx xvalue;
    if (Arguments::parse_argument_intx(flag_value, &xvalue)) {
      succeed = JVMFlag::set_intx(flag_name, &xvalue, JVMFlag::MANAGEMENT);
    }
  } else if (flag->is_uintx()) {
    uintx uxvalue;
    if (Arguments::parse_argument_uintx(flag_value, &uxvalue)) {
      succeed = JVMFlag::set_uintx(flag_name, &uxvalue, JVMFlag::MANAGEMENT);
    }
  } else if (flag->is_uint64_t()) {
    uint64_t u64value;
    if (Arguments::parse_argument_uint64_t(flag_value, &u64value)) {
      succeed = JVMFlag::set_uint64_t(flag_name, &u64value, JVMFlag::MANAGEMENT);
    }
  } else if (flag->is_size_t()) {
    size_t stvalue;
    if (Arguments::parse_argument_size_t(flag_value, &stvalue)) {
      succeed = JVMFlag::set_size_t(flag_name, &stvalue, JVMFlag::MANAGEMENT);
    }
  } else if (flag->is_double()) {
    double dvalue;
    if (Arguments::parse_argument_double(flag_value, &dvalue)) {
      succeed = JVMFlag::set_double(flag_name, &dvalue, JVMFlag::MANAGEMENT);
    }
  } else if (flag->is_ccstr()) {
    succeed = JVMFlag::set_ccstr(flag_name, flag_value, JVMFlag::MANAGEMENT);
  }

  if (succeed) {
    output()->print_cr("%s set to %s", flag_name, flag_value);
  } else {
    output()->print_cr("Error: Could not set VM option '%s' to '%s'.", 
                       flag_name, flag_value);
  }
}
```

## 21.5 性能数据收集

### 21.5.1 PerfData框架

HotSpot VM使用PerfData框架收集性能数据：

```cpp
// src/hotspot/share/runtime/perfData.hpp:39
enum CounterNS {
  // top level name spaces
  JAVA_NS,
  COM_NS,
  SUN_NS,
  // subsystem name spaces
  JAVA_GC,              // Garbage Collection name spaces
  COM_GC,
  SUN_GC,
  JAVA_CI,              // Compiler name spaces
  COM_CI,
  SUN_CI,
  JAVA_CLS,             // Class Loader name spaces
  COM_CLS,
  SUN_CLS,
  JAVA_RT,              // Runtime name spaces
  COM_RT,
  SUN_RT,
  JAVA_OS,              // Operating System name spaces
  COM_OS,
  SUN_OS,
  JAVA_THREADS,         // Threads System name spaces
  COM_THREADS,
  SUN_THREADS,
  JAVA_PROPERTY,        // Java Property name spaces
  COM_PROPERTY,
  SUN_PROPERTY,
  NULL_NS,
  COUNTERNS_LAST = NULL_NS
};

// PerfData基类
class PerfData : public CHeapObj<mtInternal> {
  friend class StatSampler;      // for access to protected destructor
  friend class PerfDataManager;  // for access to protected destructor

 public:
  // the Units enum, to distinguish what the data measures:
  // None        - the data has no units
  // Bytes       - data is measured in bytes
  // Ticks       - data is measured in clock ticks
  // Events      - data is measured in events. For example,
  //               the number of garbage collection events or the
  //               number of methods compiled.
  // String      - data is not numerical. For example,
  //               the java command line options
  // Hertz       - data is a frequency
  //
  enum Units {
    U_None = 1,
    U_Bytes,
    U_Ticks,
    U_Events,
    U_String,
    U_Hertz
  };

  // the Variability enum, to distinguish how the data varies:
  // Constant - value is written to the PerfData memory once, on creation
  // Monotonic - value is monotonically changing (increasing or decreasing)
  // Variable - value is variable
  //
  enum Variability {
    V_Constant = 1,
    V_Monotonic,
    V_Variable
  };

 private:
  const char* _name;
  Units _u;
  Variability _v;
  bool _on_c_heap;
  bool _sampled;

 protected:
  void *_valuep;

  PerfData(CounterNS ns, const char* name, Units u, Variability v);
  ~PerfData();

  // create the entry for the PerfData item in the PerfData memory region
  void create_entry(BasicType dtype, size_t dsize, size_t vlen = 0);

  // sample the data item given at creation time and write its value
  // to the its corresponding PerfMemory location.
  virtual void sample() = 0;

 public:
  // accessors
  const char* name() const                { return _name; }
  Units units() const                     { return _u; }
  Variability variability() const         { return _v; }
  bool is_sampled() const                 { return _sampled; }
  bool is_on_c_heap() const               { return _on_c_heap; }
  void* get_address()                     { return _valuep; }
};
```

### 21.5.2 性能计数器

不同类型的性能计数器实现：

```cpp
// 长整型性能计数器
class PerfLongCounter : public PerfLong {
  friend class PerfDataManager;

 protected:
  PerfLongCounter(CounterNS ns, const char* namep, Units u,
                  jlong* valuep = NULL);

 public:
  inline void inc()               { (*_valuep)++; }
  inline void inc(jlong val)      { (*_valuep) += val; }
  inline void add(jlong val)      { (*_valuep) += val; }
  void sample()                   { /* empty */ }
};

// 长整型性能变量
class PerfLongVariable : public PerfLong {
  friend class PerfDataManager;

 protected:
  PerfLongVariable(CounterNS ns, const char* namep, Units u,
                   jlong* valuep = NULL, PerfData* pd = NULL);

 public:
  inline void inc()               { (*_valuep)++; }
  inline void inc(jlong val)      { (*_valuep) += val; }
  inline void dec(jlong val)      { (*_valuep) -= val; }
  inline void add(jlong val)      { (*_valuep) += val; }
  inline void set_value(jlong val) { (*_valuep) = val; }
  void sample()                   { /* empty */ }
};

// 字符串性能数据
class PerfStringVariable : public PerfString {
  friend class PerfDataManager;

 protected:
  PerfStringVariable(CounterNS ns, const char* namep,
                     const char* initial_value);

 public:
  inline void set_value(const char* val) {
    strncpy((char*)_valuep, val, _max_length);
    ((char*)_valuep)[_max_length-1] = '\0';
  }

  void sample() { /* empty */ }
};
```

### 21.5.3 PerfDataManager

PerfDataManager管理所有性能数据：

```cpp
class PerfDataManager : AllStatic {
  friend class StatSampler;

 private:
  static PerfDataList*      _all;
  static PerfDataList*      _sampled;
  static PerfDataList*      _constants;
  static const char*        _name_spaces[];
  static volatile bool      _has_PerfData;

 public:
  // method to check if PerfData on this platform supports the
  // specified CounterNS NameSpace.
  static bool ns_to_string(CounterNS ns, char** name);

  // methods to test the interface stability of a given counter namespace
  //
  static bool is_stable_supported(CounterNS ns) {
    return (ns != NULL_NS);
  }

  static bool is_unstable_supported(CounterNS ns) {
    return (ns != NULL_NS);
  }

  static bool is_unstable_unsupported(CounterNS ns) {
    return (ns == NULL_NS);
  }

  // method to construct counter name strings in a given name space.
  // The string object is allocated from the Resource Area and calls
  // to this method must be made within a ResourceMark.
  //
  static char* counter_name(const char* name_space, const char* name);

  // method to construct name space strings in a given name space.
  // The string object is allocated from the Resource Area and calls
  // to this method must be made within a ResourceMark.
  //
  static char* name_space(const char* name_space, const char* sub_space) {
    return counter_name(name_space, sub_space);
  }

  // same as above, but appends the instance number to the name space
  //
  static char* name_space(const char* name_space, const char* sub_space,
                          int instance);
  static char* name_space(const char* name_space, int instance);


  // these methods provide the general interface for creating
  // performance data resources. The basic interface is for creation
  // of a PerfData resource of the specified type (counter, variable,
  // or constant) in the given name space with the specified name.
  //
  static PerfStringConstant* create_string_constant(CounterNS ns,
                                                    const char* name,
                                                    const char *s, TRAPS);

  static PerfLongConstant* create_long_constant(CounterNS ns,
                                                const char* name,
                                                PerfData::Units u,
                                                jlong val, TRAPS);

  static PerfStringVariable* create_string_variable(CounterNS ns,
                                                    const char* name,
                                                    const char *s, TRAPS);

  static PerfLongVariable* create_long_variable(CounterNS ns,
                                                const char* name,
                                                PerfData::Units u,
                                                jlong* sp = NULL, TRAPS);

  static PerfLongVariable* create_long_variable(CounterNS ns,
                                                const char* name,
                                                PerfData::Units u,
                                                PerfSampleHelper* sh, TRAPS);

  static PerfLongCounter* create_long_counter(CounterNS ns, const char* name,
                                              PerfData::Units u,
                                              jlong* sp = NULL, TRAPS);

  static PerfLongCounter* create_long_counter(CounterNS ns, const char* name,
                                              PerfData::Units u,
                                              PerfSampleHelper* sh, TRAPS);


  // these methods provide convenience wrappers for the general
  // interface provided above.
  //
  static PerfStringConstant* create_string_constant(CounterNS ns,
                                                    const char* name,
                                                    const char *s) {
    EXCEPTION_MARK;
    return create_string_constant(ns, name, s, THREAD);
  }

  static PerfLongConstant* create_long_constant(CounterNS ns,
                                                const char* name,
                                                PerfData::Units u, jlong val) {
    EXCEPTION_MARK;
    return create_long_constant(ns, name, u, val, THREAD);
  }

  static PerfStringVariable* create_string_variable(CounterNS ns,
                                                    const char* name,
                                                    const char *s) {
    EXCEPTION_MARK;
    return create_string_variable(ns, name, s, THREAD);
  }

  static PerfLongVariable* create_long_variable(CounterNS ns,
                                                const char* name,
                                                PerfData::Units u) {
    EXCEPTION_MARK;
    return create_long_variable(ns, name, u, NULL, THREAD);
  }

  static PerfLongCounter* create_long_counter(CounterNS ns, const char* name,
                                              PerfData::Units u) {
    EXCEPTION_MARK;
    return create_long_counter(ns, name, u, NULL, THREAD);
  }

  // remove the PerfData item from the PerfData list.
  static bool destroy(PerfData* p);

  // calls to these methods should be done under the protection of
  // the PerfDataManager_lock
  static void add_item(PerfData* p, bool sampled);
  static void remove_item(PerfData* p, bool sampled);

  // return the list of all known PerfData items that are to be
  // sampled by the StatSampler.
  static PerfDataList* sampled() { return _sampled; }
  static PerfDataList* all()     { return _all; }
  static PerfDataList* constants() { return _constants; }

  static int count() { return _all->length(); }

  // return true if PerfData objects should be created
  // return false if PerfData objects should not be created
  static bool has_PerfData() { return _has_PerfData; }
};
```

### 21.5.4 统计采样器

StatSampler定期采样性能数据：

```cpp
class StatSampler : public NonJavaThread {
  friend class StatSamplerTask;

 private:
  static StatSampler* _sampler;
  static PerfDataList* _sampled;

  bool _active;
  static volatile bool _initialized;
  static volatile jint _initialized_count;

  void sample_data(PerfDataList* list);
  static void collect_sample();
  void create_misc_perfdata();
  void create_sampled_perfdata();
  void sample_perfdata();

 protected:
  virtual void task();

 public:
  // constructor and destructor
  StatSampler();
  ~StatSampler() { }

  // Accessors
  static StatSampler* sampler()             { return _sampler; }

  static void set_sampler(StatSampler* s)  { _sampler = s; }

  static PerfDataList* sampled()           { return _sampled; }
  static void set_sampled(PerfDataList* sl) { _sampled = sl; }

  static bool is_active()                  { return _sampler != NULL && _sampler->_active; }

  static void activate()   {
    if (_sampler != NULL) _sampler->_active = true;
  }
  static void deactivate() {
    if (_sampler != NULL) _sampler->_active = false;
  }

  static void initialize();
  static void destroy();

  void run() override;
  void pre_run() override;
  void post_run() override;

  // Called by WatcherThread
  static void sample();

  // Called to initialize the sampler
  static void engage();

  // Called to terminate the sampler
  static void disengage();

  static bool is_initialized() { return _initialized; }

  const char* name() const { return "StatSampler"; }
};

// 采样任务实现
void StatSampler::sample_data(PerfDataList* list) {
  for (int index = 0; index < list->length(); index++) {
    PerfData* item = list->at(index);
    item->sample();
  }
}

void StatSampler::sample_perfdata() {
  if (_sampled != NULL) {
    sample_data(_sampled);
  }
}

void StatSampler::task() {
  sample_perfdata();
  
  // Check if we should terminate
  if (should_terminate()) {
    return;
  }
  
  // Sleep until next sample time
  os::naked_short_sleep(PerfDataSamplingInterval);
}
```

## 21.6 JFR事件类型

### 21.6.1 系统事件

JFR提供了丰富的系统级事件：

```cpp
// JVM信息事件
TRACE_REQUEST_FUNC(JVMInformation) {
  ResourceMark rm;
  EventJVMInformation event;
  event.set_jvmName(VM_Version::vm_name());
  event.set_jvmVersion(VM_Version::vm_release());
  event.set_jvmArguments(Arguments::java_command());
  event.set_jvmFlags(Arguments::jvm_flags());
  event.set_javaArguments(Arguments::java_command_line());
  event.set_jvmStartTime(Management::vm_init_done_time());
  event.set_pid(os::current_process_id());
  event.commit();
}

// 操作系统信息事件
TRACE_REQUEST_FUNC(OSInformation) {
  ResourceMark rm;
  char* os_name = NEW_RESOURCE_ARRAY(char, 2048);
  JfrOSInterface::os_version(&os_name);
  EventOSInformation event;
  event.set_osVersion(os_name);
  event.commit();
}

// CPU信息事件
TRACE_REQUEST_FUNC(CPUInformation) {
  EventCPUInformation event;
  event.set_cpu(JfrOSInterface::cpu_information());
  event.set_description(JfrOSInterface::cpu_description());
  event.set_sockets(JfrOSInterface::cpu_sockets());
  event.set_cores(JfrOSInterface::cpu_cores());
  event.set_hwThreads(JfrOSInterface::cpu_hw_threads());
  event.commit();
}

// 内存摘要事件
TRACE_REQUEST_FUNC(PhysicalMemory) {
  EventPhysicalMemory event;
  event.set_totalSize(os::physical_memory());
  event.set_usedSize(os::physical_memory() - os::available_memory());
  event.commit();
}
```

### 21.6.2 GC事件

垃圾收集相关的事件：

```cpp
// GC事件基类
class GCTracer : public ResourceObj {
 protected:
  GCId _gc_id;
  GCName _gc_name;
  GCCause::Cause _gc_cause;
  Ticks _gc_start;
  Ticks _gc_end;

 public:
  GCTracer(GCName name) : _gc_name(name) {}
  virtual ~GCTracer() {}

  void report_gc_start(GCCause::Cause cause, const Ticks& timestamp);
  void report_gc_end(const Ticks& timestamp, TimePartitions* time_partitions);
  void report_gc_heap_summary(GCWhen::Type when, const GCHeapSummary& heap_summary);
  void report_metaspace_summary(GCWhen::Type when, const MetaspaceSummary& metaspace_summary);
  void report_gc_reference_stats(const ReferenceProcessorStats& rp_stats);
  void report_object_count_after_gc(BoolObjectClosure* is_alive_closure);
  void report_gc_cpu_time(double user_time, double sys_time, double real_time);

 protected:
  virtual void report_gc_start_impl(GCCause::Cause cause, const Ticks& timestamp);
  virtual void report_gc_end_impl(const Ticks& timestamp, TimePartitions* time_partitions);

 private:
  void send_garbage_collection_event() const;
  void send_gc_heap_summary_event(GCWhen::Type when, const GCHeapSummary& heap_summary) const;
  void send_metaspace_summary_event(GCWhen::Type when, const MetaspaceSummary& metaspace_summary) const;
  void send_metaspace_chunk_free_list_summary(GCWhen::Type when, Metaspace::MetadataType mdtype, const MetaspaceChunkFreeListSummary& summary) const;
};

// 发送GC事件
void GCTracer::send_garbage_collection_event() const {
  EventGarbageCollection event(UNTIMED);
  if (event.should_commit()) {
    event.set_gcId(GCId::current());
    event.set_name(_gc_name);
    event.set_cause((u2) _gc_cause);
    event.set_sumOfPauses(SUM_OF_PAUSES.milliseconds());
    event.set_longestPause(LONGEST_PAUSE.milliseconds());
    event.set_starttime(_gc_start);
    event.set_endtime(_gc_end);
    event.commit();
  }
}

// 堆摘要事件
void GCTracer::send_gc_heap_summary_event(GCWhen::Type when, const GCHeapSummary& heap_summary) const {
  EventGCHeapSummary event;
  if (event.should_commit()) {
    event.set_gcId(GCId::current());
    event.set_when((u1)when);
    event.set_heapSpace(to_struct(heap_summary));
    event.set_heapUsed(heap_summary.used());
    event.commit();
  }
}
```

### 21.6.3 编译事件

即时编译相关的事件：

```cpp
// 编译事件
class CompilerEvent : AllStatic {
 public:
  static jlong ticksNow() {
    return JfrTicks::now().value();
  }

  template<typename EventType>
  static void commit(EventType& event,
                     const Method* method,
                     jint compile_id,
                     jint comp_level,
                     bool success,
                     bool is_osr,
                     int code_size,
                     int inlined_bytecodes) {
    assert(method != NULL, "invariant");
    event.set_starttime(ticksNow());
    event.set_method(method);
    event.set_compileId(compile_id);
    event.set_compileLevel((short)comp_level);
    event.set_succeded(success);
    event.set_isOsr(is_osr);
    event.set_codeSize(code_size);
    event.set_inlinedBytes(inlined_bytecodes);
    event.commit();
  }
};

// 编译开始事件
void CompilerEvent::compilation_event(EventCompilation* event, Method* method, jint compile_id, jint comp_level,
                                      bool success, bool is_osr, int code_size, int inlined_bytecodes) {
  assert(event != NULL, "invariant");
  assert(method != NULL, "invariant");
  event->set_method(method);
  event->set_compileId(compile_id);
  event->set_compileLevel((short)comp_level);
  event->set_succeded(success);
  event->set_isOsr(is_osr);
  event->set_codeSize(code_size);
  event->set_inlinedBytes(inlined_bytecodes);
  event->commit();
}

// 编译阶段事件
void CompilerEvent::phase_event(EventCompilerPhase* event, const char* phase_name, jint compile_id, jint comp_level) {
  assert(event != NULL, "invariant");
  assert(phase_name != NULL, "invariant");
  event->set_phase(phase_name);
  event->set_compileId(compile_id);
  event->set_phaseLevel((short)comp_level);
  event->commit();
}
```

### 21.6.4 类加载事件

类加载相关的事件：

```cpp
// 类加载事件
void JfrEventClassTransformer::on_klass_creation(const InstanceKlass* ik, const ClassLoaderData* cld, const JfrTraceId trace_id) {
  assert(ik != NULL, "invariant");
  assert(cld != NULL, "invariant");
  if (EventClassLoad::is_enabled() || EventClassDefine::is_enabled()) {
    JfrKlassTraceId::set_trace_id(ik, trace_id);
    if (cld->is_unsafe_anonymous()) {
      // We do not track anonymous classes
      return;
    }
    post_klass_load_events(ik, cld, trace_id);
  }
}

static void post_klass_load_events(const InstanceKlass* ik, const ClassLoaderData* cld, JfrTraceId trace_id) {
  assert(ik != NULL, "invariant");
  assert(cld != NULL, "invariant");
  
  EventClassLoad event;
  if (event.should_commit()) {
    event.set_loadedClass(ik);
    event.set_definingClassLoader(cld);
    event.set_initiatingClassLoader(cld);
    event.commit();
  }
  
  EventClassDefine define_event;
  if (define_event.should_commit()) {
    define_event.set_definedClass(ik);
    define_event.set_definingClassLoader(cld);
    define_event.commit();
  }
}

// 类卸载事件
void JfrEventClassTransformer::on_klass_unload(const Klass* k) {
  assert(k != NULL, "invariant");
  
  EventClassUnload event;
  if (event.should_commit()) {
    event.set_unloadedClass(k);
    event.set_definingClassLoader(k->class_loader_data());
    event.commit();
  }
}
```

## 21.7 监控工具集成

### 21.7.1 jstat工具支持

jstat工具通过PerfData接口获取性能数据：

```cpp
// jstat相关的性能计数器
class StatSamplerTask : public PeriodicTask {
 private:
  int _interval;

 public:
  StatSamplerTask(int interval_time) : PeriodicTask(interval_time) {
    _interval = interval_time;
  }

  virtual void task() {
    StatSampler::sample();
  }
};

// GC统计信息
void CollectorCounters::update_all() {
  _invocations->set_value(_gc->invocations());
  _time->set_value(_gc->accumulated_time()->ticks());
  if (UsePerfData) {
    _last_entry_time->set_value(_gc->_last_gc_time.ticks());
    _last_exit_time->set_value(_gc->_last_gc_time.ticks() + 
                               _gc->_last_gc_duration.ticks());
  }
}

// 内存池统计信息
void MemoryPool::update_peak_memory_usage() {
  // Capture the peak memory usage
  MemoryUsage usage = get_memory_usage();
  size_t peak_used = usage.used();
  size_t peak_committed = usage.committed();
  size_t peak_max = usage.max();

  if (peak_used > _peak_usage.used()) {
    _peak_usage = MemoryUsage(usage.init(), peak_used, peak_committed, peak_max);
  }
}

// 编译器统计信息
void CompilerCounters::update_compile_count() {
  _total_compiles->inc();
  if (_compile_type == CompilerCounters::_c1_compile) {
    _c1_compiles->inc();
  } else if (_compile_type == CompilerCounters::_c2_compile) {
    _c2_compiles->inc();
  }
}
```

### 21.7.2 jcmd工具支持

jcmd工具通过诊断命令框架执行各种诊断操作：

```cpp
// 诊断命令注册
void DCmdFactory::register_DCmdFactory(DCmdFactory* factory) {
  assert(factory != NULL, "DCmdFactory cannot be NULL");
  if (_DCmdFactoryList == NULL) {
    _DCmdFactoryList = new (ResourceObj::C_HEAP, mtInternal) DCmdFactoryList;
  }
  _DCmdFactoryList->append(factory);
}

// 内置诊断命令注册
void register_jfr_dcmds() {
  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrCheckFlightRecordingDCmd>(full_export, true, false));
  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrDumpFlightRecordingDCmd>(full_export, true, false));
  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrStartFlightRecordingDCmd>(full_export, true, false));
  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrStopFlightRecordingDCmd>(full_export, true, false));
  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrConfigureFlightRecorderDCmd>(full_export, true, false));
}

// 线程转储命令
class ThreadDumpDCmd : public DCmdWithParser {
 protected:
  DCmdArgument<bool> _locks;
  DCmdArgument<bool> _extended;

 public:
  ThreadDumpDCmd(outputStream* output, bool heap);
  static const char* name() { return "Thread.print"; }
  static const char* description() {
    return "Print all threads with stacktraces.";
  }
  static const char* impact() {
    return "Medium: Depends on the number of threads.";
  }
  static const JavaPermission permission() {
    JavaPermission p = {"java.lang.management.ManagementPermission",
                        "monitor", NULL};
    return p;
  }
  static int num_arguments();
  virtual void execute(DCmdSource source, TRAPS);
};

// 执行线程转储
void ThreadDumpDCmd::execute(DCmdSource source, TRAPS) {
  // Ensure the services thread has started
  if (!os::create_attached_thread(JavaThread::current())) {
    output()->print_cr("Could not create thread dump");
    return;
  }

  // Request thread dump with optional arguments
  bool print_concurrent_locks = _locks.value();
  bool print_extended_info = _extended.value();
  
  ThreadDumpResult dump_result;
  ThreadService::dump_stack_traces(&dump_result, print_concurrent_locks, print_extended_info);
  
  // Print the results
  for (int i = 0; i < dump_result.num_threads(); i++) {
    ThreadSnapshot* ts = dump_result.thread_at(i);
    ts->print_thread_info_on(output());
    ts->print_stack_trace_on(output());
    if (print_concurrent_locks) {
      ts->print_concurrent_locks_on(output());
    }
    output()->cr();
  }
}
```

### 21.7.3 JMX集成

JMX通过Management接口暴露监控数据：

```cpp
// JMX接口实现
static jint jmm_GetVersion(JNIEnv *env) {
  return JMM_VERSION;
}

static jlong jmm_GetUsedMemory(JNIEnv *env) {
  return Universe::get_heap_used();
}

static jboolean jmm_GetBoolAttribute(JNIEnv *env, jmmBoolAttribute att) {
  switch (att) {
    case JMM_VERBOSE_GC:
      return MemoryService::get_verbose();
    case JMM_VERBOSE_CLASS:
      return ClassLoadingService::get_verbose();
    case JMM_THREAD_CONTENTION_MONITORING:
      return ThreadService::is_thread_monitoring_contention();
    case JMM_THREAD_CPU_TIME:
      return ThreadService::is_thread_cpu_time_enabled();
    case JMM_THREAD_ALLOCATED_MEMORY:
      return ThreadService::is_thread_allocated_memory_enabled();
    default:
      assert(0, "Unrecognized attribute");
      return false;
  }
}

static void jmm_SetBoolAttribute(JNIEnv *env, jmmBoolAttribute att, jboolean flag) {
  switch (att) {
    case JMM_VERBOSE_GC:
      MemoryService::set_verbose(flag != 0);
      break;
    case JMM_VERBOSE_CLASS:
      ClassLoadingService::set_verbose(flag != 0);
      break;
    case JMM_THREAD_CONTENTION_MONITORING:
      ThreadService::set_thread_monitoring_contention(flag != 0);
      break;
    case JMM_THREAD_CPU_TIME:
      ThreadService::set_thread_cpu_time_enabled(flag != 0);
      break;
    case JMM_THREAD_ALLOCATED_MEMORY:
      ThreadService::set_thread_allocated_memory_enabled(flag != 0);
      break;
    default:
      assert(0, "Unrecognized attribute");
  }
}

// 获取内存池信息
static jobject jmm_GetMemoryPools(JNIEnv* env, jobject mgr) {
  ResourceMark rm;

  int num_memory_pools = MemoryService::num_memory_pools();
  GrowableArray<instanceHandle>* pools =
    new GrowableArray<instanceHandle>(num_memory_pools);

  for (int i = 0; i < num_memory_pools; i++) {
    MemoryPool* pool = MemoryService::get_memory_pool(i);
    instanceOop p = pool->get_memory_pool_instance(CHECK_NULL);
    instanceHandle ph(THREAD, p);
    pools->append(ph);
  }

  objArrayOop op = oopFactory::new_objArray(SystemDictionary::MemoryPoolMXBean_klass(),
                                            num_memory_pools, CHECK_NULL);
  objArrayHandle poolArray(THREAD, op);
  for (int i = 0; i < num_memory_pools; i++) {
    poolArray->obj_at_put(i, pools->at(i)());
  }
  return JNIHandles::make_local(env, poolArray());
}

// 获取GC信息
static jobject jmm_GetGCManagers(JNIEnv* env, jobject mgr) {
  ResourceMark rm;

  int num_gc_managers = MemoryService::num_memory_managers();
  GrowableArray<instanceHandle>* gc_managers =
    new GrowableArray<instanceHandle>(num_gc_managers);

  for (int i = 0; i < num_gc_managers; i++) {
    MemoryManager* gc_manager = MemoryService::get_memory_manager(i);
    if (gc_manager->is_gc_memory_manager()) {
      instanceOop m = gc_manager->get_memory_manager_instance(CHECK_NULL);
      instanceHandle mh(THREAD, m);
      gc_managers->append(mh);
    }
  }

  objArrayOop op = oopFactory::new_objArray(SystemDictionary::GarbageCollectorMXBean_klass(),
                                            gc_managers->length(), CHECK_NULL);
  objArrayHandle managerArray(THREAD, op);
  for (int i = 0; i < gc_managers->length(); i++) {
    managerArray->obj_at_put(i, gc_managers->at(i)());
  }
  return JNIHandles::make_local(env, managerArray());
}
```

## 21.8 性能优化策略

### 21.8.1 低开销监控

JFR和其他监控工具采用多种策略降低性能开销：

```cpp
// 事件启用检查优化
template<typename T>
class JfrEventSetting : public JfrCHeapObj {
 private:
  jlong _threshold_ticks;
  jlong _cutoff_ticks;
  u1 _level;
  bool _enabled;

 public:
  JfrEventSetting() : _threshold_ticks(0), _cutoff_ticks(0), _level(0), _enabled(false) {}

  bool should_commit() const {
    return _enabled && (_threshold_ticks == 0 || 
                        JfrTicks::now().value() - _start_time >= _threshold_ticks);
  }

  bool is_enabled() const { return _enabled; }
  void set_enabled(bool enabled) { _enabled = enabled; }

  jlong threshold_ticks() const { return _threshold_ticks; }
  void set_threshold_ticks(jlong threshold) { _threshold_ticks = threshold; }
};

// 快速事件检查
#define EVENT_THREAD_LOCAL(T) \
  static bool is_enabled() { \
    return JfrEventSetting<T>::is_enabled(); \
  } \
  static bool should_commit() { \
    return is_enabled() && should_commit_impl(); \
  }

// 缓冲区优化
class JfrBufferManager : public JfrCHeapObj {
 private:
  static JfrBufferManager* _instance;
  JfrBufferList _free_list_small;
  JfrBufferList _free_list_large;
  
 public:
  static JfrBufferManager& instance() {
    return *_instance;
  }

  JfrBuffer* acquire(Thread* thread, size_t size) {
    if (size <= SMALL_BUFFER_SIZE) {
      return acquire_small(thread);
    } else {
      return acquire_large(thread, size);
    }
  }

  void release(JfrBuffer* buffer, Thread* thread) {
    if (buffer->size() <= SMALL_BUFFER_SIZE) {
      release_small(buffer, thread);
    } else {
      release_large(buffer, thread);
    }
  }

 private:
  JfrBuffer* acquire_small(Thread* thread) {
    JfrBuffer* buffer = _free_list_small.remove();
    if (buffer == NULL) {
      buffer = allocate_buffer(SMALL_BUFFER_SIZE);
    }
    buffer->acquire(thread);
    return buffer;
  }

  void release_small(JfrBuffer* buffer, Thread* thread) {
    buffer->release();
    buffer->reset();
    _free_list_small.add(buffer);
  }
};
```

### 21.8.2 采样优化

采样频率和策略的优化：

```cpp
// 自适应采样
class AdaptiveSampler : public JfrCHeapObj {
 private:
  volatile jlong _sample_count;
  volatile jlong _event_count;
  volatile jint _sample_rate;
  jlong _last_adjustment_time;
  
 public:
  AdaptiveSampler() : _sample_count(0), _event_count(0), 
                      _sample_rate(DEFAULT_SAMPLE_RATE),
                      _last_adjustment_time(0) {}

  bool should_sample() {
    jlong event_count = Atomic::add(1L, &_event_count);
    if (event_count % _sample_rate == 0) {
      Atomic::inc(&_sample_count);
      return true;
    }
    return false;
  }

  void adjust_sample_rate() {
    jlong current_time = os::javaTimeMillis();
    if (current_time - _last_adjustment_time > ADJUSTMENT_INTERVAL) {
      jlong sample_count = _sample_count;
      jlong event_count = _event_count;
      
      if (sample_count > 0) {
        double sample_ratio = (double)sample_count / event_count;
        if (sample_ratio > TARGET_SAMPLE_RATIO * 1.1) {
          // 采样过多，降低采样率
          _sample_rate = MIN2(_sample_rate * 2, MAX_SAMPLE_RATE);
        } else if (sample_ratio < TARGET_SAMPLE_RATIO * 0.9) {
          // 采样过少，提高采样率
          _sample_rate = MAX2(_sample_rate / 2, MIN_SAMPLE_RATE);
        }
      }
      
      _last_adjustment_time = current_time;
    }
  }
};

// 线程采样优化
class ThreadSamplingScheduler : public JfrCHeapObj {
 private:
  volatile bool _should_sample[MAX_THREADS];
  jlong _last_sample_time[MAX_THREADS];
  jint _sample_interval;

 public:
  ThreadSamplingScheduler() : _sample_interval(DEFAULT_THREAD_SAMPLE_INTERVAL) {
    for (int i = 0; i < MAX_THREADS; i++) {
      _should_sample[i] = false;
      _last_sample_time[i] = 0;
    }
  }

  bool should_sample_thread(JavaThread* thread) {
    int thread_id = thread->osthread()->thread_id() % MAX_THREADS;
    jlong current_time = os::javaTimeMillis();
    
    if (current_time - _last_sample_time[thread_id] >= _sample_interval) {
      _last_sample_time[thread_id] = current_time;
      return true;
    }
    return false;
  }

  void adjust_sample_interval(double cpu_usage) {
    if (cpu_usage > HIGH_CPU_THRESHOLD) {
      // CPU使用率高，降低采样频率
      _sample_interval = MIN2(_sample_interval * 2, MAX_SAMPLE_INTERVAL);
    } else if (cpu_usage < LOW_CPU_THRESHOLD) {
      // CPU使用率低，提高采样频率
      _sample_interval = MAX2(_sample_interval / 2, MIN_SAMPLE_INTERVAL);
    }
  }
};
```

### 21.8.3 内存优化

监控系统的内存使用优化：

```cpp
// 对象池优化
template<typename T>
class ObjectPool : public JfrCHeapObj {
 private:
  T* _pool;
  volatile jint _top;
  jint _capacity;
  
 public:
  ObjectPool(jint capacity) : _capacity(capacity), _top(0) {
    _pool = NEW_C_HEAP_ARRAY(T, capacity, mtInternal);
    for (jint i = 0; i < capacity; i++) {
      new (&_pool[i]) T();
    }
  }

  ~ObjectPool() {
    for (jint i = 0; i < _capacity; i++) {
      _pool[i].~T();
    }
    FREE_C_HEAP_ARRAY(T, _pool);
  }

  T* acquire() {
    jint current_top = _top;
    while (current_top > 0) {
      jint new_top = current_top - 1;
      if (Atomic::cmpxchg(new_top, &_top, current_top) == current_top) {
        return &_pool[new_top];
      }
      current_top = _top;
    }
    // 池为空，分配新对象
    return new T();
  }

  void release(T* obj) {
    jint current_top = _top;
    if (current_top < _capacity) {
      jint new_top = current_top + 1;
      if (Atomic::cmpxchg(new_top, &_top, current_top) == current_top) {
        obj->reset();
        _pool[current_top] = *obj;
        return;
      }
    }
    // 池已满，删除对象
    delete obj;
  }
};

// 字符串池优化
class JfrStringPool : public JfrCHeapObj {
 private:
  JfrHashtable<JfrString*, traceid> _table;
  JfrMutex _lock;

 public:
  JfrStringPool() : _table(this), _lock("JfrStringPool") {}

  traceid add(const char* str) {
    assert(str != NULL, "invariant");
    
    MutexLocker ml(&_lock);
    
    JfrString* jfr_string = _table.lookup_only(str);
    if (jfr_string != NULL) {
      return jfr_string->id();
    }

    // 创建新的字符串条目
    jfr_string = new JfrString(str);
    traceid id = JfrTraceId::assign_thread_id();
    jfr_string->set_id(id);
    
    _table.put(jfr_string);
    return id;
  }

  const char* lookup(traceid id) {
    MutexLocker ml(&_lock);
    JfrString* jfr_string = _table.lookup(id);
    return jfr_string != NULL ? jfr_string->value() : NULL;
  }
};
```

## 21.9 总结

性能监控与诊断是HotSpot VM的重要组成部分，通过多层次、多维度的监控体系为Java应用提供了全面的性能洞察能力。

### 21.9.1 核心特性

1. **JFR事件系统**：低开销、高性能的事件记录机制
2. **Management API**：标准化的JMX监控接口
3. **诊断命令框架**：灵活的运行时诊断工具
4. **性能数据收集**：全面的性能指标统计
5. **工具集成**：与jstat、jcmd、JMX等工具的无缝集成

### 21.9.2 技术亮点

1. **低开销设计**：通过缓冲、采样、对象池等技术最小化性能影响
2. **实时监控**：支持运行时动态启用/禁用监控功能
3. **丰富的事件类型**：涵盖GC、编译、类加载、线程等各个方面
4. **可扩展架构**：支持自定义事件和监控指标
5. **工具生态**：完整的监控工具链支持

### 21.9.3 实现价值

HotSpot VM的性能监控与诊断系统不仅提供了强大的监控能力，还通过精心的性能优化确保了监控本身不会成为性能瓶颈。其设计充分体现了系统监控的最佳实践，为Java应用的性能调优和故障诊断提供了坚实的基础。

通过深入理解性能监控与诊断机制，我们可以更好地：
- 设计高效的监控系统
- 优化应用性能
- 快速定位和解决性能问题
- 构建可观测的Java应用

性能监控与诊断是现代Java应用不可或缺的能力，HotSpot VM在这方面的实现为整个Java生态系统树立了标杆。