# 第10章：G1垃圾收集器

> **约定**：本章基于 **Linux x86-64**、**8GB堆内存**、**非大页模式**、**G1垃圾收集器**。
> 所有源码引用均来自本地 `/data/workspace/openjdk11-core/src/hotspot/` 目录。
> **本章新增**：基于GDB调试验证的G1对象模型实际数据。

---

## 10.1 G1概述

### 10.1.1 G1设计目标

G1（Garbage-First）是一款面向服务端应用的垃圾收集器，设计目标：

1. **可预测的停顿时间**：通过`-XX:MaxGCPauseMillis`设置目标停顿时间（默认200ms）
2. **高吞吐量**：尽量减少GC对应用的影响
3. **大堆支持**：适用于4GB以上的堆内存
4. **Region化设计**：将堆划分为多个Region，支持增量式回收

### 10.1.2 G1核心对象模型 (GDB验证) ⭐

**测试条件**: `-Xms8g -Xmx8g -XX:+UseG1GC -XX:-UseLargePages`

以下是通过GDB调试验证的G1核心对象：

| 对象 | 类型 | GDB地址 | 作用 |
|-----|------|---------|------|
| **G1CollectedHeap** | 堆管理器 | `0x7ffff00326b0` | G1堆的核心管理对象 |
| G1Allocator | 分配器 | `0x7ffff0041520` | 管理内存分配 |
| G1CardTable | 卡表 | `0x7ffff0042c60` | 16MB，跟踪跨Region引用 |
| G1Policy | 策略 | `0x7ffff0038b00` | GC决策（何时GC、回收哪些Region） |
| G1BlockOffsetTable | 块偏移表 | `0x7ffff0059180` | 16MB，快速定位对象起始位置 |
| G1HotCardCache | 热卡缓存 | `0x7ffff0042ed0` | 缓存频繁修改的卡 |
| G1RemSet | 记忆集 | `0x7ffff004c670` | 记录跨Region引用 |
| G1ConcurrentMark | 并发标记 | `0x7ffff005a360` | 并发标记管理 |
| G1ConcurrentRefine | 并发细化 | `0x7ffff0c7e460` | 后台处理脏卡 |
| WorkGang | 工作线程池 | `0x7ffff003f610` | 13个并行GC线程 |

**HeapRegion静态配置 (GDB验证)**：

| 属性 | GDB值 | 说明 |
|-----|-------|------|
| `GrainBytes` | 4194304 (4MB) | Region大小 |
| `LogOfHRGrainBytes` | 22 | log2(4MB) = 22 |
| `GrainWords` | 524288 | 4MB / 8 = 524288 words |
| `CardsPerRegion` | 8192 | 4MB / 512B = 8192 cards |
| `_humongous_object_threshold_in_words` | 262144 | 巨型对象阈值 = 2MB |

**堆内存区域 (GDB验证)**：

```
_reserved = {
  _start = 0x600000000    (24GB位置)
  _word_size = 1073741824 (8GB / 8 bytes per word)
}

Region数量: 2048个
每个Region: 4MB
总堆大小: 2048 × 4MB = 8GB
```

### 10.1.3 G1的GC类型

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          G1 GC 类型                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 1. Young GC（年轻代GC）                                              │   │
│  │    - 只回收Eden和Survivor Region                                     │   │
│  │    - STW（Stop-The-World）                                          │   │
│  │    - 并行执行                                                        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 2. Mixed GC（混合GC）                                                │   │
│  │    - 回收所有Young Region + 部分Old Region                           │   │
│  │    - 根据收益选择Old Region（Garbage-First策略）                      │   │
│  │    - STW，并行执行                                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 3. Concurrent Marking（并发标记）                                    │   │
│  │    - 与应用线程并发执行                                               │   │
│  │    - 标记存活对象，为Mixed GC做准备                                   │   │
│  │    - 包含Initial Mark、Concurrent Mark、Remark、Cleanup阶段          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 4. Full GC（完全GC）                                                 │   │
│  │    - 回收整个堆                                                      │   │
│  │    - 单线程或并行（JDK10+支持并行Full GC）                            │   │
│  │    - 应尽量避免                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 10.2 G1CollectedHeap详解 (GDB验证) ⭐

### 10.2.1 G1CollectedHeap类定义

源码位置：`src/hotspot/share/gc/g1/g1CollectedHeap.hpp:130`

```cpp
class G1CollectedHeap : public CollectedHeap {
private:
    // === 核心组件 ===
    G1CollectorPolicy*    _collector_policy;     // GC策略配置
    G1CardTable*          _card_table;           // 卡表(写屏障)
    HeapRegionManager     _hrm;                  // Region管理器
    G1Allocator*          _allocator;            // 内存分配器
    G1ConcurrentMark*     _cm;                   // 并发标记
    G1ConcurrentRefine*   _cr;                   // 并发细化
    G1RemSet*             _g1_rem_set;           // 记忆集
    G1Policy*             _g1_policy;            // 策略
    G1HotCardCache*       _hot_card_cache;       // 热卡缓存
    G1BlockOffsetTable*   _bot;                  // 块偏移表
    
    // === 工作线程 ===
    WorkGang*             _workers;              // 并行GC工作线程
    G1YoungRemSetSamplingThread* _young_gen_sampling_thread; // 年轻代采样
    
    // === 堆分区集合 ===
    G1EdenRegions         _eden;                 // Eden区Region列表
    G1SurvivorRegions     _survivor;             // Survivor区Region列表
    HeapRegionSet         _old_set;              // 老年代Region集合
    HeapRegionSet         _humongous_set;        // 巨型对象Region集合
    
    // === 收集集 ===
    G1CollectionSet       _collection_set;       // 待回收Region集合
    
    // === 引用处理 ===
    ReferenceProcessor*   _ref_processor_stw;    // STW引用处理器
    ReferenceProcessor*   _ref_processor_cm;     // 并发标记引用处理器
    
    // === 脏卡队列 ===
    DirtyCardQueueSet     _dirty_card_queue_set; // 脏卡队列集
    
    // === 统计 ===
    size_t                _summary_bytes_used;   // 已使用字节数
    G1EvacStats           _survivor_evac_stats;  // Survivor PLAB统计
    G1EvacStats           _old_evac_stats;       // Old PLAB统计
    
    // === 状态 ===
    G1CollectorState      _collector_state;      // 收集器状态
};
```

### 10.2.2 CollectorState (GDB验证)

```cpp
_collector_state = {
  _in_young_only_phase = true,           // 当前处于Young GC阶段
  _in_young_gc_before_mixed = false,     // 不在Mixed GC前的Young GC
  _in_initial_mark_gc = false,           // 不在初始标记
  _initiate_conc_mark_if_possible = false, // 不需要触发并发标记
  _mark_or_rebuild_in_progress = false,  // 无标记或重建进行中
  _clearing_next_bitmap = false,         // 不在清理bitmap
  _in_full_gc = false                    // 不在Full GC
}
```

### 10.2.3 G1CollectorState

源码位置：`src/hotspot/share/gc/g1/g1CollectorState.hpp:32-120`

```cpp
class G1CollectorState {
  // 是否在只收集年轻代的阶段
  bool _in_young_only_phase;
  
  // 是否在Mixed GC之前的最后一次Young GC
  bool _in_young_gc_before_mixed;
  
  // 是否在Initial Mark GC中
  volatile bool _in_initial_mark_gc;
  
  // 是否应该启动并发标记
  volatile bool _initiate_conc_mark_if_possible;
  
  // 标记或重建记忆集是否正在进行
  bool _mark_or_rebuild_in_progress;
  
  // 是否正在清理下一个位图
  bool _clearing_next_bitmap;
  
  // 是否在Full GC中
  bool _in_full_gc;

public:
  // 阶段判断
  bool in_young_only_phase() const { return _in_young_only_phase && !_in_full_gc; }
  bool in_mixed_phase() const { return !in_young_only_phase() && !_in_full_gc; }
  
  // GC类型判断
  G1YCType yc_type() const {
    if (in_initial_mark_gc()) {
      return InitialMark;
    } else if (mark_or_rebuild_in_progress()) {
      return DuringMarkOrRebuild;
    } else if (in_young_only_phase()) {
      return Normal;
    } else {
      return Mixed;
    }
  }
};
```

### 10.2.2 GC周期状态图

```
                                    ┌─────────────────────────────────────────┐
                                    │                                         │
                                    ▼                                         │
┌─────────────────┐    触发条件    ┌─────────────────┐                        │
│  Young-Only     │ ─────────────► │  Initial Mark   │                        │
│  Phase          │  (IHOP阈值)    │  (STW)          │                        │
│                 │                └────────┬────────┘                        │
│  - Young GC     │                         │                                 │
│  - Young GC     │                         ▼                                 │
│  - Young GC     │                ┌─────────────────┐                        │
│  ...            │                │ Root Region     │                        │
└─────────────────┘                │ Scanning        │                        │
        ▲                          │ (Concurrent)    │                        │
        │                          └────────┬────────┘                        │
        │                                   │                                 │
        │                                   ▼                                 │
        │                          ┌─────────────────┐                        │
        │                          │ Concurrent      │                        │
        │                          │ Marking         │                        │
        │                          │ (Concurrent)    │                        │
        │                          └────────┬────────┘                        │
        │                                   │                                 │
        │                                   ▼                                 │
        │                          ┌─────────────────┐                        │
        │                          │ Remark          │                        │
        │                          │ (STW)           │                        │
        │                          └────────┬────────┘                        │
        │                                   │                                 │
        │                                   ▼                                 │
        │                          ┌─────────────────┐                        │
        │                          │ Cleanup         │                        │
        │                          │ (STW + Conc)    │                        │
        │                          └────────┬────────┘                        │
        │                                   │                                 │
        │                                   ▼                                 │
        │                          ┌─────────────────┐                        │
        │  无垃圾可回收            │  Mixed Phase    │    回收完成            │
        └──────────────────────────│                 │────────────────────────┘
                                   │  - Mixed GC     │
                                   │  - Mixed GC     │
                                   │  ...            │
                                   └─────────────────┘
```

---

## 10.3 Young GC详解

### 10.3.1 触发条件

Young GC在以下情况触发：
1. Eden区满（无法分配新对象）
2. Humongous分配失败

### 10.3.2 Young GC流程

```
Young GC 执行流程
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. STW（Stop-The-World）
   │
   ▼
2. 选择收集集合（Collection Set）
   ├── 所有Eden Region
   └── 所有Survivor Region
   │
   ▼
3. 根扫描（Root Scanning）
   ├── 线程栈
   ├── JNI Handles
   ├── 类加载器
   ├── 代码缓存（编译代码中的引用）
   └── 记忆集（RSet）
   │
   ▼
4. 对象复制（Evacuation）
   ├── 存活对象复制到Survivor Region
   ├── 达到晋升年龄的对象复制到Old Region
   └── 使用PLAB减少锁竞争
   │
   ▼
5. 引用处理
   ├── 软引用
   ├── 弱引用
   ├── 虚引用
   └── Finalizer
   │
   ▼
6. 清理
   ├── 释放Collection Set中的Region
   ├── 更新记忆集
   └── 重新分配空闲Region给Eden
   │
   ▼
7. 恢复应用线程
```

### 10.3.3 G1ParScanThreadState

每个GC工作线程都有自己的状态，用于并行扫描和复制对象。

源码位置：`src/hotspot/share/gc/g1/g1ParScanThreadState.hpp:45-150`

```cpp
class G1ParScanThreadState : public CHeapObj<mtGC> {
  G1CollectedHeap* _g1h;
  RefToScanQueue*  _refs;          // 待扫描引用队列
  DirtyCardQueue   _dcq;           // 脏卡队列
  G1CardTable*     _ct;            // 卡表
  G1EvacuationRootClosures* _closures;  // 根闭包

  G1PLABAllocator*  _plab_allocator;  // PLAB分配器

  AgeTable          _age_table;    // 年龄表
  InCSetState       _dest[InCSetState::Num];  // 目标Region状态
  uint              _tenuring_threshold;  // 晋升阈值
  G1ScanEvacuatedObjClosure  _scanner;  // 对象扫描器

  uint _worker_id;  // 工作线程ID

  // 存活对象统计
  size_t* _surviving_young_words;

public:
  // 更新记忆集
  template <class T> void update_rs(HeapRegion* from, T* p, oop o) {
    // 如果不是同一个Region，且源Region不是年轻代
    if (!from->is_young() && 
        _g1h->heap_region_containing((HeapWord*)o)->rem_set()->is_tracked()) {
      size_t card_index = ct()->index_for(p);
      if (ct()->mark_card_deferred(card_index)) {
        dirty_card_queue().enqueue((jbyte*)ct()->byte_for_index(card_index));
      }
    }
  }
};
```

### 10.3.4 对象复制过程

```cpp
// 简化的对象复制逻辑
oop G1ParScanThreadState::copy_to_survivor_space(InCSetState state, oop old) {
  size_t word_sz = old->size();
  
  // 1. 计算目标区域（Survivor或Old）
  uint age = 0;
  InCSetState dest_state = next_state(state, old->mark(), age);
  
  // 2. 在PLAB中分配空间
  HeapWord* obj_ptr = _plab_allocator->allocate(dest_state, word_sz);
  if (obj_ptr == NULL) {
    // PLAB分配失败，尝试直接分配
    obj_ptr = allocate_in_next_plab(dest_state, word_sz);
  }
  
  if (obj_ptr == NULL) {
    // 分配失败，标记为疏散失败
    return handle_evacuation_failure(old);
  }
  
  // 3. 复制对象
  Copy::aligned_disjoint_words((HeapWord*)old, obj_ptr, word_sz);
  oop new_obj = (oop)obj_ptr;
  
  // 4. 设置转发指针
  old->forward_to(new_obj);
  
  // 5. 更新年龄和统计
  if (dest_state.is_young()) {
    new_obj->incr_age();
    _age_table.add(age, word_sz);
  }
  
  // 6. 将新对象的引用加入扫描队列
  push_on_queue(new_obj);
  
  return new_obj;
}
```

### 10.3.5 Young GC时间分解（8GB堆示例）

```
Young GC 时间分解（目标200ms）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

假设：
- Eden: 200个Region (800MB)
- Survivor: 20个Region (80MB)
- 存活率: 10%
- GC线程: 8个

时间分解：
┌────────────────────────────────────────────────────────────────────────────┐
│ 阶段                    │ 时间(ms) │ 说明                                  │
├────────────────────────────────────────────────────────────────────────────┤
│ 1. Pre Evacuate         │    2     │ 准备工作，选择CSet                    │
├────────────────────────────────────────────────────────────────────────────┤
│ 2. Evacuate             │   45     │ 主要工作                              │
│    ├─ Ext Root Scan     │   (5)    │ 外部根扫描                            │
│    ├─ Thread Roots      │   (3)    │ 线程栈扫描                            │
│    ├─ Code Root Scan    │   (2)    │ 代码根扫描                            │
│    ├─ Object Copy       │  (30)    │ 对象复制（最耗时）                    │
│    └─ Termination       │   (5)    │ 工作窃取终止                          │
├────────────────────────────────────────────────────────────────────────────┤
│ 3. Post Evacuate        │    8     │ 后处理                                │
│    ├─ Ref Processing    │   (3)    │ 引用处理                              │
│    ├─ Clear Card Table  │   (2)    │ 清理卡表                              │
│    └─ Free CSet         │   (3)    │ 释放CSet                              │
├────────────────────────────────────────────────────────────────────────────┤
│ 总计                    │   55     │ 远低于200ms目标                       │
└────────────────────────────────────────────────────────────────────────────┘
```

---

## 10.4 收集集合（Collection Set）

### 10.4.1 G1CollectionSet结构

源码位置：`src/hotspot/share/gc/g1/g1CollectionSet.hpp:39-150`

```cpp
class G1CollectionSet {
  G1CollectedHeap* _g1h;
  G1Policy* _policy;

  CollectionSetChooser* _cset_chooser;  // 收集集合选择器

  uint _eden_region_length;      // Eden Region数量
  uint _survivor_region_length;  // Survivor Region数量
  uint _old_region_length;       // Old Region数量

  // 收集集合（Region索引数组）
  uint* _collection_set_regions;
  volatile size_t _collection_set_cur_length;
  size_t _collection_set_max_length;

  // 收集前的字节数
  size_t _bytes_used_before;

  // 增量构建状态
  enum CSetBuildType {
    Active,    // 活跃构建状态
    Inactive   // 非活跃状态
  };
  CSetBuildType _inc_build_state;

public:
  uint region_length() const { 
    return young_region_length() + old_region_length(); 
  }
  uint young_region_length() const { 
    return eden_region_length() + survivor_region_length(); 
  }
};
```

### 10.4.2 收集集合选择策略

```
收集集合选择（Mixed GC时）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. 必选Region：
   ┌─────────────────────────────────────────────────────────────────────┐
   │ • 所有Eden Region                                                   │
   │ • 所有Survivor Region                                               │
   └─────────────────────────────────────────────────────────────────────┘

2. 可选Old Region（按收益排序）：
   ┌─────────────────────────────────────────────────────────────────────┐
   │ 收益 = 可回收空间 / 回收成本                                         │
   │                                                                     │
   │ Region #100: 垃圾90%, RSet小 → 高收益 ✓ 优先选择                    │
   │ Region #200: 垃圾80%, RSet中 → 中收益 ✓ 次优先                      │
   │ Region #300: 垃圾50%, RSet大 → 低收益 ✗ 可能不选                    │
   └─────────────────────────────────────────────────────────────────────┘

3. 约束条件：
   ┌─────────────────────────────────────────────────────────────────────┐
   │ • 预测停顿时间 ≤ MaxGCPauseMillis (200ms)                           │
   │ • Old Region数量 ≤ G1MixedGCCountTarget (8次)                       │
   │ • 存活率 ≤ G1MixedGCLiveThresholdPercent (85%)                      │
   └─────────────────────────────────────────────────────────────────────┘
```

---

## 10.5 并发标记（Concurrent Marking）

### 10.5.1 SATB（Snapshot-At-The-Beginning）

G1使用SATB算法保证并发标记的正确性。

源码位置：`src/hotspot/share/gc/g1/satbMarkQueue.hpp:45-87`

```cpp
// SATB标记队列
class SATBMarkQueue: public PtrQueue {
  friend class SATBMarkQueueSet;

private:
  // 过滤掉不需要的条目
  void filter();

public:
  SATBMarkQueue(SATBMarkQueueSet* qset, bool permanent = false);

  // 刷新队列
  void flush();

  // 应用闭包处理队列
  void apply_closure_and_empty(SATBBufferClosure* cl);
};
```

**SATB原理**：

```
SATB（Snapshot-At-The-Beginning）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

核心思想：在并发标记开始时，对堆做一个逻辑快照，标记快照中存活的对象。

写屏障（Pre-write Barrier）：
┌─────────────────────────────────────────────────────────────────────────┐
│ // 当修改引用时，记录旧值                                                │
│ void pre_write_barrier(oop* field, oop new_value) {                     │
│   oop old_value = *field;                                               │
│   if (satb_active && old_value != NULL) {                               │
│     // 将旧值加入SATB队列                                                │
│     satb_queue.enqueue(old_value);                                      │
│   }                                                                     │
│   *field = new_value;                                                   │
│ }                                                                       │
└─────────────────────────────────────────────────────────────────────────┘

示例：
┌─────────────────────────────────────────────────────────────────────────┐
│ 初始状态:  A ──────► B ──────► C                                        │
│                                                                         │
│ 应用修改:  A.ref = D  (原来A.ref = B)                                   │
│                                                                         │
│ SATB记录:  将B加入SATB队列                                              │
│                                                                         │
│ 结果:      B仍然被认为是存活的（即使没有其他引用）                        │
│            这是保守的，可能产生浮动垃圾                                   │
└─────────────────────────────────────────────────────────────────────────┘
```

### 10.5.2 G1ConcurrentMark结构

源码位置：`src/hotspot/share/gc/g1/g1ConcurrentMark.hpp:288-400`

```cpp
class G1ConcurrentMark : public CHeapObj<mtGC> {
  friend class G1ConcurrentMarkThread;
  friend class G1CMTask;

  G1ConcurrentMarkThread* _cm_thread;  // 并发标记线程
  G1CollectedHeap*        _g1h;        // G1堆

  // 标记位图（双缓冲）
  G1CMBitMap              _mark_bitmap_1;
  G1CMBitMap              _mark_bitmap_2;
  G1CMBitMap*             _prev_mark_bitmap;  // 上次标记结果
  G1CMBitMap*             _next_mark_bitmap;  // 当前标记中

  // 根Region追踪
  G1CMRootRegions         _root_regions;

  // 全局标记栈
  G1CMMarkStack           _global_mark_stack;
  HeapWord* volatile      _finger;  // 全局扫描指针

  // 任务管理
  uint                    _max_num_tasks;
  uint                    _num_active_tasks;
  G1CMTask**              _tasks;
  G1CMTaskQueueSet*       _task_queues;
  ParallelTaskTerminator  _terminator;

  // 溢出处理
  volatile bool           _has_overflown;
  volatile bool           _concurrent;
  volatile bool           _has_aborted;

  // 统计信息
  NumberSeq _init_times;
  NumberSeq _remark_times;
  NumberSeq _cleanup_times;
};
```

### 10.5.3 并发标记阶段

```
并发标记的5个阶段
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────────────────────────────────────────────────┐
│ 阶段1: Initial Mark (STW)                                                   │
│ ─────────────────────────────────────────────────────────────────────────── │
│ • 标记GC Roots直接可达的对象                                                 │
│ • 通常与Young GC一起执行（piggyback）                                        │
│ • 设置TAMS（Top-At-Mark-Start）                                             │
│ • 时间：通常 < 10ms                                                         │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 阶段2: Root Region Scanning (Concurrent)                                    │
│ ─────────────────────────────────────────────────────────────────────────── │
│ • 扫描Survivor Region中的对象                                               │
│ • 这些对象可能引用Old区对象                                                  │
│ • 必须在下次Young GC之前完成                                                 │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 阶段3: Concurrent Marking (Concurrent)                                      │
│ ─────────────────────────────────────────────────────────────────────────── │
│ • 遍历整个堆，标记存活对象                                                   │
│ • 使用三色标记法（白/灰/黑）                                                 │
│ • 处理SATB队列中的引用                                                       │
│ • 可以被Young GC打断                                                        │
│ • 时间：取决于堆大小和存活对象数量                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 阶段4: Remark (STW)                                                         │
│ ─────────────────────────────────────────────────────────────────────────── │
│ • 处理并发标记期间产生的SATB日志                                             │
│ • 完成标记                                                                  │
│ • 处理引用（软/弱/虚引用）                                                   │
│ • 时间：通常 < 50ms                                                         │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 阶段5: Cleanup (STW + Concurrent)                                           │
│ ─────────────────────────────────────────────────────────────────────────── │
│ • 统计每个Region的存活对象                                                   │
│ • 识别完全空闲的Region（直接回收）                                           │
│ • 按收益排序Old Region（为Mixed GC准备）                                     │
│ • 交换标记位图                                                              │
│ • 时间：STW部分 < 10ms                                                      │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 10.5.4 三色标记法

```
三色标记法
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

颜色定义：
┌─────────────────────────────────────────────────────────────────────────┐
│ 白色: 未被访问的对象（可能是垃圾）                                        │
│ 灰色: 已被访问，但其引用的对象还未全部访问                                 │
│ 黑色: 已被访问，且其引用的对象都已访问                                     │
└─────────────────────────────────────────────────────────────────────────┘

标记过程：
┌─────────────────────────────────────────────────────────────────────────┐
│ 初始状态:                                                               │
│                                                                         │
│   [GC Root] ──► [A:白] ──► [B:白] ──► [C:白]                           │
│                   │                                                     │
│                   └──────► [D:白]                                       │
│                                                                         │
│ 步骤1: 从GC Root开始，标记A为灰色                                        │
│                                                                         │
│   [GC Root] ──► [A:灰] ──► [B:白] ──► [C:白]                           │
│                   │                                                     │
│                   └──────► [D:白]                                       │
│                                                                         │
│ 步骤2: 处理A的引用，标记B和D为灰色，A变黑                                 │
│                                                                         │
│   [GC Root] ──► [A:黑] ──► [B:灰] ──► [C:白]                           │
│                   │                                                     │
│                   └──────► [D:灰]                                       │
│                                                                         │
│ 步骤3: 继续处理灰色对象...                                               │
│                                                                         │
│ 最终状态:                                                               │
│                                                                         │
│   [GC Root] ──► [A:黑] ──► [B:黑] ──► [C:黑]                           │
│                   │                                                     │
│                   └──────► [D:黑]                                       │
│                                                                         │
│ 白色对象 = 垃圾（可回收）                                                │
└─────────────────────────────────────────────────────────────────────────┘
```

### 10.5.5 TAMS（Top-At-Mark-Start）

```
TAMS的作用
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

每个Region有两个TAMS指针：
- prevTAMS: 上次标记开始时的top
- nextTAMS: 当前标记开始时的top

Region内存布局：
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│  bottom                prevTAMS        nextTAMS        top       end   │
│    │                      │               │             │          │    │
│    ▼                      ▼               ▼             ▼          ▼    │
│    ┌──────────────────────┬───────────────┬─────────────┬──────────┐   │
│    │   上次标记的对象      │ 上次标记后    │ 本次标记后  │  空闲    │   │
│    │   (使用prevBitmap)   │ 分配的对象    │ 分配的对象  │  空间    │   │
│    │                      │ (隐式存活)    │ (隐式存活)  │          │   │
│    └──────────────────────┴───────────────┴─────────────┴──────────┘   │
│                                                                         │
│ 规则：                                                                  │
│ • bottom ~ prevTAMS: 使用prev位图判断存活                               │
│ • prevTAMS ~ nextTAMS: 隐式存活（上次标记后分配）                        │
│ • nextTAMS ~ top: 隐式存活（本次标记后分配）                             │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 10.6 Mixed GC详解

### 10.6.1 Mixed GC触发条件

Mixed GC在并发标记完成后触发，条件：
1. 并发标记已完成
2. 存在可回收的Old Region
3. 可回收空间比例 > G1HeapWastePercent（默认5%）

### 10.6.2 Mixed GC流程

```
Mixed GC 与 Young GC 的区别
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────────────────────────────────────────────────┐
│                    Young GC                    Mixed GC                     │
├─────────────────────────────────────────────────────────────────────────────┤
│ 收集范围:      Eden + Survivor              Eden + Survivor + 部分Old      │
│                                                                             │
│ Old Region:    不收集                        选择高收益的Old Region          │
│                                                                             │
│ 触发条件:      Eden满                        并发标记完成后                  │
│                                                                             │
│ 停顿时间:      较短                          较长（但仍受MaxGCPauseMillis限制）│
│                                                                             │
│ 执行次数:      频繁                          多次（直到Old区垃圾清理完）      │
└─────────────────────────────────────────────────────────────────────────────┘

Mixed GC的Old Region选择：
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│  并发标记后的Old Region列表（按收益排序）：                                  │
│                                                                             │
│  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐        │
│  │Region  │ │Region  │ │Region  │ │Region  │ │Region  │ │Region  │        │
│  │#100    │ │#205    │ │#88     │ │#156    │ │#312    │ │#401    │        │
│  │垃圾95% │ │垃圾90% │ │垃圾85% │ │垃圾70% │ │垃圾60% │ │垃圾40% │        │
│  └────────┘ └────────┘ └────────┘ └────────┘ └────────┘ └────────┘        │
│      ▲          ▲          ▲                                               │
│      └──────────┴──────────┘                                               │
│           第1次Mixed GC选择                                                 │
│                                                                             │
│  G1MixedGCCountTarget = 8 → 分8次回收所有高收益Old Region                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 10.6.3 Mixed GC相关参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| G1MixedGCCountTarget | 8 | Mixed GC的目标次数 |
| G1MixedGCLiveThresholdPercent | 85 | Old Region存活率阈值 |
| G1HeapWastePercent | 5 | 允许的堆浪费比例 |
| G1OldCSetRegionThresholdPercent | 10 | 每次Mixed GC的Old Region上限 |

---

## 10.7 Full GC

### 10.7.1 Full GC触发条件

Full GC是最后的保障，在以下情况触发：

1. **Allocation Failure**：分配失败，且Young GC无法释放足够空间
2. **Evacuation Failure**：疏散失败（没有足够空间存放存活对象）
3. **Humongous Allocation Failure**：大对象分配失败
4. **Metaspace不足**：元空间满
5. **System.gc()**：显式调用（除非禁用）

### 10.7.2 G1FullCollector

源码位置：`src/hotspot/share/gc/g1/g1FullCollector.hpp:56-103`

```cpp
class G1FullCollector : StackObj {
  G1CollectedHeap*          _heap;
  G1FullGCScope             _scope;
  uint                      _num_workers;
  G1FullGCMarker**          _markers;
  G1FullGCCompactionPoint** _compaction_points;
  OopQueueSet               _oop_queue_set;
  ObjArrayTaskQueueSet      _array_queue_set;
  PreservedMarksSet         _preserved_marks_set;
  G1FullGCCompactionPoint   _serial_compaction_point;
  G1IsAliveClosure          _is_alive;

public:
  void prepare_collection();
  void collect();
  void complete_collection();

private:
  // Full GC的四个阶段
  void phase1_mark_live_objects();    // 标记存活对象
  void phase2_prepare_compaction();   // 准备压缩
  void phase3_adjust_pointers();      // 调整指针
  void phase4_do_compaction();        // 执行压缩
};
```

### 10.7.3 Full GC四阶段

```
Full GC 四阶段
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────────────────────────────────────────────────┐
│ Phase 1: Mark Live Objects（标记存活对象）                                  │
│ ─────────────────────────────────────────────────────────────────────────── │
│ • 从GC Roots开始，标记所有存活对象                                          │
│ • 并行执行                                                                  │
│ • 使用标记位图                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ Phase 2: Prepare Compaction（准备压缩）                                     │
│ ─────────────────────────────────────────────────────────────────────────── │
│ • 计算每个对象的新地址                                                       │
│ • 确定Region的压缩目标                                                       │
│ • 建立转发信息                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ Phase 3: Adjust Pointers（调整指针）                                        │
│ ─────────────────────────────────────────────────────────────────────────── │
│ • 遍历所有存活对象                                                          │
│ • 将对象中的引用更新为新地址                                                 │
│ • 并行执行                                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ Phase 4: Do Compaction（执行压缩）                                          │
│ ─────────────────────────────────────────────────────────────────────────── │
│ • 将对象移动到新位置                                                        │
│ • 释放空Region                                                              │
│ • 重建辅助数据结构                                                          │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 10.7.4 疏散失败（Evacuation Failure）

源码位置：`src/hotspot/share/gc/g1/g1EvacFailure.cpp`

```cpp
class RemoveSelfForwardPtrObjClosure: public ObjectClosure {
  G1CollectedHeap* _g1h;
  G1ConcurrentMark* _cm;
  HeapRegion* _hr;
  size_t _marked_bytes;
  bool _during_initial_mark;

public:
  // 处理疏散失败的对象
  // 这些对象无法被复制，需要保留在原位置
  void do_object(oop obj) {
    // 如果对象有转发指针指向自己，说明疏散失败
    if (obj->forwardee() == obj) {
      // 移除自转发指针
      obj->init_mark();
      
      // 如果在Initial Mark阶段，需要标记这些对象
      if (_during_initial_mark) {
        _cm->mark_in_next_bitmap(obj);
      }
      
      // 更新记忆集
      _update_rset_cl->do_object(obj);
    }
  }
};
```

**疏散失败的影响**：

```
疏散失败处理
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

正常情况：
┌─────────────────────────────────────────────────────────────────────────┐
│ CSet Region                     Survivor/Old Region                     │
│ ┌─────────────────┐             ┌─────────────────┐                     │
│ │ [A] [B] [C]     │  ────────►  │ [A'] [B'] [C']  │                     │
│ │                 │   复制      │                 │                     │
│ └─────────────────┘             └─────────────────┘                     │
│        ↓                                                                │
│   Region被释放                                                          │
└─────────────────────────────────────────────────────────────────────────┘

疏散失败：
┌─────────────────────────────────────────────────────────────────────────┐
│ CSet Region                     目标空间不足！                          │
│ ┌─────────────────┐                                                     │
│ │ [A] [B] [C]     │  ────X────►  无法复制                               │
│ │                 │                                                     │
│ └─────────────────┘                                                     │
│        ↓                                                                │
│   对象保留在原位置                                                       │
│   Region转为Old Region                                                  │
│   需要特殊处理（移除自转发指针）                                          │
│   可能触发Full GC                                                       │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 10.8 写屏障

### 10.8.1 G1的两种写屏障

G1使用两种写屏障：

```
G1写屏障
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Pre-Write Barrier（SATB屏障）
┌─────────────────────────────────────────────────────────────────────────┐
│ 作用：记录被覆盖的旧引用值，支持SATB并发标记                              │
│                                                                         │
│ void pre_write_barrier(oop* field) {                                    │
│   if (satb_marking_active) {                                            │
│     oop old_value = *field;                                             │
│     if (old_value != NULL) {                                            │
│       satb_log_buffer.enqueue(old_value);                               │
│     }                                                                   │
│   }                                                                     │
│ }                                                                       │
└─────────────────────────────────────────────────────────────────────────┘

2. Post-Write Barrier（卡表屏障）
┌─────────────────────────────────────────────────────────────────────────┐
│ 作用：记录跨Region引用，维护记忆集                                       │
│                                                                         │
│ void post_write_barrier(oop* field, oop new_value) {                    │
│   // 检查是否跨Region引用                                                │
│   if (cross_region(field, new_value)) {                                 │
│     // 标记卡为脏                                                        │
│     card_table[card_index(field)] = DIRTY;                              │
│     // 加入脏卡队列                                                      │
│     dirty_card_queue.enqueue(card_ptr);                                 │
│   }                                                                     │
│ }                                                                       │
└─────────────────────────────────────────────────────────────────────────┘
```

### 10.8.2 写屏障的JIT实现

C2编译器生成的写屏障代码（简化）：

```asm
; x86-64 Post-Write Barrier
; 假设 rdi = field地址, rsi = new_value

; 1. 计算卡索引
mov rax, rdi
shr rax, 9                    ; rax = field >> 9 (卡索引)

; 2. 检查是否已经是脏卡
mov rbx, [card_table_base]
cmp byte ptr [rbx + rax], DIRTY_CARD
je  done                      ; 已经脏，跳过

; 3. 检查是否跨Region
mov rcx, rdi
xor rcx, rsi
shr rcx, 22                   ; 22 = log2(4MB Region)
je  done                      ; 同一Region，跳过

; 4. 标记卡为脏
mov byte ptr [rbx + rax], DIRTY_CARD

; 5. 加入脏卡队列
call enqueue_dirty_card

done:
```

---

## 10.9 并发细化（Concurrent Refinement）

### 10.9.1 并发细化线程

并发细化线程处理脏卡队列，更新记忆集。

```
并发细化流程
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│  应用线程                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 执行写操作 ──► Post-Write Barrier ──► 脏卡队列（线程本地）           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    │ 队列满或周期性刷新                      │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     全局脏卡队列                                     │   │
│  │  ┌────┐ ┌────┐ ┌────┐ ┌────┐ ┌────┐ ┌────┐ ┌────┐ ┌────┐          │   │
│  │  │Card│ │Card│ │Card│ │Card│ │Card│ │Card│ │Card│ │Card│          │   │
│  │  └────┘ └────┘ └────┘ └────┘ └────┘ └────┘ └────┘ └────┘          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    │ 并发细化线程处理                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 并发细化线程 (G1ConcurrentRefineThread)                              │   │
│  │                                                                     │   │
│  │ 1. 从队列取出脏卡                                                    │   │
│  │ 2. 扫描卡对应的内存区域                                              │   │
│  │ 3. 找出跨Region引用                                                  │   │
│  │ 4. 更新目标Region的记忆集                                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

线程数量调节：
- 队列长度 < Green Zone: 0个线程工作
- 队列长度 ∈ [Green, Yellow): 1个线程
- 队列长度 ∈ [Yellow, Red): 逐步增加线程
- 队列长度 >= Red Zone: 所有线程 + 应用线程帮助
```

---

## 10.10 G1对象关系图 (GDB验证) ⭐

基于GDB调试验证的完整对象关系：

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                            G1CollectedHeap (0x7ffff00326b0)                         │
│                               G1 GC 核心管理对象                                     │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────┐   │
│  │ HeapRegionManager (_hrm)                                                    │   │
│  │  _num_committed = 2048                                                      │   │
│  │  _free_list: 空闲Region链表                                                 │   │
│  │  _regions: HeapRegion* 数组 [0..2047]                                       │   │
│  │      │                                                                      │   │
│  │      ├── HeapRegion[0]: bottom=0x600000000, 4MB                            │   │
│  │      ├── HeapRegion[1]: bottom=0x600400000, 4MB                            │   │
│  │      ├── ...                                                               │   │
│  │      └── HeapRegion[2047]: bottom=0x7FC000000                              │   │
│  └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│  ┌──────────────────────┐  ┌──────────────────────┐  ┌──────────────────────┐      │
│  │ G1Allocator          │  │ G1CardTable          │  │ G1BlockOffsetTable   │      │
│  │ (0x7ffff0041520)     │  │ (0x7ffff0042c60)     │  │ (0x7ffff0059180)     │      │
│  │ - 内存分配器         │  │ - 16MB卡表           │  │ - 16MB BOT           │      │
│  │ - mutator_alloc      │  │ - 每512B→1字节       │  │ - 快速定位对象       │      │
│  │ - survivor_alloc     │  │ - 脏卡跟踪           │  │                      │      │
│  │ - old_alloc          │  │                      │  │                      │      │
│  └──────────────────────┘  └──────────────────────┘  └──────────────────────┘      │
│                                                                                     │
│  ┌──────────────────────┐  ┌──────────────────────┐  ┌──────────────────────┐      │
│  │ G1Policy             │  │ G1RemSet             │  │ G1HotCardCache       │      │
│  │ (0x7ffff0038b00)     │  │ (0x7ffff004c670)     │  │ (0x7ffff0042ed0)     │      │
│  │ - GC决策             │  │ - 跨Region引用       │  │ - 热卡缓存           │      │
│  │ - 暂停时间预测       │  │ - RSet更新           │  │ - 避免重复处理       │      │
│  │ - CSet选择           │  │ - 脏卡处理           │  │                      │      │
│  └──────────────────────┘  └──────────────────────┘  └──────────────────────┘      │
│                                                                                     │
│  ┌──────────────────────┐  ┌──────────────────────┐  ┌──────────────────────┐      │
│  │ G1ConcurrentMark     │  │ G1ConcurrentRefine   │  │ WorkGang             │      │
│  │ (0x7ffff005a360)     │  │ (0x7ffff0c7e460)     │  │ (0x7ffff003f610)     │      │
│  │ - 并发标记           │  │ - 并发细化           │  │ - 13个GC线程         │      │
│  │ - prev/next位图      │  │ - 后台RSet更新       │  │ - 并行GC任务         │      │
│  │ - 标记栈             │  │                      │  │                      │      │
│  └──────────────────────┘  └──────────────────────┘  └──────────────────────┘      │
│                                                                                     │
│  ┌──────────────────────────────────────────────────────────────────────────────┐  │
│  │ CollectorState                                                               │  │
│  │ _in_young_only_phase = true      (当前处于Young GC阶段)                      │  │
│  │ _in_initial_mark_gc = false                                                  │  │
│  │ _mark_or_rebuild_in_progress = false                                         │  │
│  │ _in_full_gc = false                                                          │  │
│  └──────────────────────────────────────────────────────────────────────────────┘  │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────────┐
│ HeapRegion 内部结构 (每个Region 4MB)                                               │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│  ┌────────────────────────────────────────────────────────────────────────┐         │
│  │ HeapRegion                                                             │         │
│  │ _hrm_index: Region索引 (0~2047)                                        │         │
│  │ _type: Free/Eden/Survivor/Old/HumStart/HumCont                         │         │
│  │ _rem_set → HeapRegionRemSet (记录指向本Region的引用)                   │         │
│  │     └── OtherRegionsTable (三级存储)                                   │         │
│  │         ├── _coarse_map: 粗粒度位图 (2048位)                           │         │
│  │         ├── _fine_grain_regions: PerRegionTable* 哈希表               │         │
│  │         └── SparsePRT: 稀疏卡表 (引用少时)                            │         │
│  │                                                                        │         │
│  │ 内存布局:                                                              │         │
│  │ bottom ────────────────────────────────────────────────── end          │         │
│  │ │ 已分配对象 │ top │       空闲空间                      │             │         │
│  │ └────────────┴─────┴──────────────────────────────────────┘             │         │
│  └────────────────────────────────────────────────────────────────────────┘         │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 10.10 G1 GC实战验证 (GDB调试) ⭐ NEW!

> 本节通过GDB调试验证G1 GC的完整执行流程，使用特制的HelloWorld程序触发多次GC。
> 详细文档请参考: `openjdk11-core/md/g1_gc_action_md/`

### 10.10.1 测试程序与参数

```java
// HelloWorld.java - G1 GC测试场景
public class HelloWorld {
    static List<byte[]> survivors = new ArrayList<>();
    static List<byte[]> garbage = new ArrayList<>();
    
    public static void main(String[] args) {
        triggerYoungGC();    // 阶段1: 触发Young GC
        promoteToOld();      // 阶段2: 对象晋升
        triggerMixedGC();    // 阶段3: 触发Mixed GC
    }
}
```

**JVM参数**：
```bash
-Xms256m -Xmx256m -XX:+UseG1GC -XX:-UseLargePages \
-XX:G1HeapRegionSize=1m -XX:MaxGCPauseMillis=200 \
-XX:InitiatingHeapOccupancyPercent=20
```

### 10.10.2 GDB验证的Young GC 5阶段流程

| 阶段 | 函数 | GDB验证数据 |
|------|------|-------------|
| 1. GC入口 | `G1CollectedHeap::do_collection_pause_at_safepoint` | `this=0x7ffff0031e20` |
| 2. CSet选择 | `G1CollectionSet::finalize_young_part` | Eden=59, Survivor=0 |
| 3. 对象疏散 | `G1ParEvacuateFollowersClosure::do_void` | 并行工作窃取 |
| 4. 对象复制 | `G1ParScanThreadState::copy_to_survivor_space` | 设置转发指针 |
| 5. GC完成 | `G1Policy::record_collection_pause_end` | 目标200ms, 实际43.75ms |

### 10.10.3 GDB验证的并发标记流程

| 阶段 | 函数 | 类型 | 耗时 |
|------|------|------|------|
| Initial Mark | 搭载Young GC | STW | - |
| Root Region Scan | `scan_root_regions` | Concurrent | 22.437ms |
| Concurrent Mark | `mark_from_roots` | Concurrent | 0.624ms |
| Remark | `remark` | STW | 14.623ms |
| Cleanup | `cleanup` | STW+Conc | - |

### 10.10.4 GDB验证的Mixed GC策略

```
时间预算计算:
  time_remaining_ms = MaxGCPauseMillis - young_gc_time
  GDB验证: 200ms - 116.55ms = 83.45ms

Region选择策略 (Garbage-First):
  1. 按垃圾率排序Old Region
  2. 优先选择垃圾最多的Region
  3. 在时间预算内贪心选择
```

### 10.10.5 关键GDB数据汇总

| 对象 | GDB地址 | 说明 |
|------|---------|------|
| G1CollectedHeap | `0x7ffff0031e20` | G1堆管理器 |
| G1CollectionSet | `0x7ffff0032338` | 收集集合 |
| G1ConcurrentMark | `0x7ffff004a3f0` | 并发标记 |
| G1Policy | `0x7ffff0038200` | GC策略 |

| 指标 | GDB值 | 说明 |
|------|-------|------|
| 目标暂停 | 200ms | MaxGCPauseMillis |
| 实际暂停 | 43.75ms | Young GC |
| GC线程数 | 6/13 | 并行/并发 |
| IHOP | 20% | 触发并发标记阈值 |

### 10.10.6 GC日志验证

```
[GC(0) Pause Young (Concurrent Start)] 59M->52M(256M) 43.746ms
  Eden regions: 59->0(37)
  Survivor regions: 0->8(8)
  Old regions: 0->52

[GC(1) Concurrent Cycle] 44.161ms
  Concurrent Scan Root Regions 22.437ms
  Concurrent Mark From Roots 0.624ms
  Pause Remark 14.623ms

[GC(5) Pause Young (Mixed)] 128M->89M(256M) 28.456ms
```

---

## 10.11 真实GC日志深度分析 (NEW!)

### 10.11.1 测试环境配置

```bash
java -Xms8g -Xmx8g -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \
     -XX:InitiatingHeapOccupancyPercent=45 \
     -XX:G1HeapRegionSize=4m \
     -Xlog:gc*=debug:file=gc_detailed.log:time,uptime,level,tags:filecount=5,filesize=100m \
     G1GCTestScenarios
```

**GC日志验证的关键参数**：

| 参数 | 配置值 | 日志验证 |
|-----|-------|---------|
| Region大小 | 4MB | `Heap region size: 4M` |
| Region数量 | 2,048个 | `8GB / 4MB = 2,048` |
| 并行GC线程 | 13 | `ParallelGCThreads: 13` |
| 并发标记线程 | 3 | `ConcGCThreads: 3` |
| IHOP阈值 | 45% | `Target occupancy: 3865470566B` |
| Refinement绿区 | 13 | 基于Region数量 |

### 10.11.2 Young GC详细日志分析

```
[1.358s][debug][gc,heap] GC(0) Heap before GC invocations=0 (full 0): 
                        garbage-first heap total 8388608K, used 413696K
[1.358s][debug][gc,heap] GC(0) region size 4096K, 102 young (417792K), 0 survivors (0K)
[1.360s][info ][gc,start] GC(0) Pause Young (Normal) (G1 Evacuation Pause)
[1.362s][info ][gc,task ] GC(0) Using 13 workers of 13 for evacuation
```

**关键指标解读**：

| 指标 | 值 | 说明 |
|------|-----|------|
| GC编号 | `GC(0)` | 第一次GC |
| GC类型 | `Pause Young (Normal)` | 普通Young GC |
| 触发原因 | `G1 Evacuation Pause` | Eden区满触发 |
| 堆使用前 | 413696K ≈ 404MB | 102个Eden Region × 4MB |
| Worker线程 | 13个 | 并行Evacuation |

### 10.11.3 三大阶段时间分解

```
[1.846s][info ][gc,phases] GC(0)   Pre Evacuate Collection Set: 0.2ms
[1.846s][debug][gc,phases] GC(0)     Prepare TLABs: 0.9ms
[1.846s][debug][gc,phases] GC(0)     Choose Collection Set: 0.0ms
[1.846s][debug][gc,phases] GC(0)     Humongous Register: 0.2ms

[1.846s][info ][gc,phases] GC(0)   Evacuate Collection Set: 341.2ms
[1.846s][debug][gc,phases] GC(0)     Ext Root Scanning (ms):   Min:0.9, Avg:4.8, Max:49.7
[1.846s][debug][gc,phases] GC(0)     Object Copy (ms):         Min:290.3, Avg:335.2, Max:339.6
[1.846s][debug][gc,phases] GC(0)     Termination (ms):         Min:0.0, Avg:0.5, Max:0.9

[1.846s][info ][gc,phases] GC(0)   Post Evacuate Collection Set: 140.4ms
[1.846s][debug][gc,phases] GC(0)     Free Collection Set: 139.0ms
[1.846s][debug][gc,phases] GC(0)     Humongous Reclaim: 0.2ms
```

**阶段时间分析**：

| 阶段 | 耗时 | 占比 | 主要操作 |
|------|------|------|----------|
| Pre Evacuate | 0.2ms | 0.04% | TLAB准备、CSet选择 |
| **Evacuate** | **341.2ms** | **70.1%** | **对象复制（核心）** |
| Post Evacuate | 140.4ms | 28.9% | CSet释放、引用处理 |
| Other | 6.3ms | 1.3% | 其他开销 |
| **总计** | **488.1ms** | **100%** | - |

### 10.11.4 Evacuation阶段详细分析

**Worker线程统计**：

```
Object Copy (ms): Min:290.3, Avg:335.2, Max:339.6, Sum:4357.8, Workers:13
```

| 指标 | 值 | 分析 |
|------|-----|------|
| 最小耗时 | 290.3ms | 最快Worker |
| 平均耗时 | 335.2ms | 平均负载 |
| 最大耗时 | 339.6ms | 最慢Worker（决定总耗时）|
| 总CPU时间 | 4357.8ms | 13 Worker × ~335ms |
| 负载不均衡度 | 17% | (Max-Min)/Avg |

**根扫描分布**：

| 根类型 | 最小 | 平均 | 最大 | 说明 |
|--------|------|------|------|------|
| Thread Roots | 0.1ms | 2.3ms | 15.2ms | 线程栈扫描 |
| JNI Handles | 0.0ms | 0.1ms | 0.3ms | JNI引用 |
| CLDG | 0.0ms | 0.5ms | 2.1ms | 类加载器图 |
| Code Roots | 0.0ms | 0.1ms | 0.9ms | 编译代码引用 |

### 10.11.5 并发标记日志分析

```
[2.156s][info ][gc] GC(3) Pause Young (Concurrent Start) (G1 Humongous Allocation)
[2.234s][info ][gc] GC(3) 384M->320M(8192M) 78.123ms

[2.235s][info ][gc] GC(4) Concurrent Cycle
[2.240s][debug][gc,marking] GC(4) Concurrent Clear Claimed Marks
[2.242s][debug][gc,marking] GC(4) Concurrent Scan Root Regions

[2.264s][info ][gc,marking] GC(4) Concurrent Mark From Roots
[2.264s][debug][gc,marking] GC(4)   Using 3 workers of 3 for marking
[2.889s][info ][gc,marking] GC(4) Concurrent Mark From Roots 624.538ms

[2.891s][info ][gc] GC(4) Pause Remark 14.623ms
[2.891s][debug][gc,phases] GC(4)   Finalize Marking 2.123ms
[2.891s][debug][gc,phases] GC(4)   System Purge 3.456ms
```

**并发标记阶段时间**：

| 阶段 | 类型 | 耗时 | 说明 |
|------|------|------|------|
| Clear Claimed Marks | 并发 | 5ms | 清除标记位 |
| Root Region Scan | 并发 | 22ms | 扫描Survivor引用 |
| **Concurrent Mark** | **并发** | **624ms** | **核心标记阶段** |
| Remark | **STW** | 14.6ms | 最终标记 |
| Cleanup | 混合 | 8.2ms | 清理空Region |

### 10.11.6 Mixed GC日志分析

```
[3.456s][info ][gc,start] GC(8) Pause Young (Mixed) (G1 Evacuation Pause)
[3.456s][debug][gc,ergo,cset] GC(8) Finish choosing CSet. 
    old: 45 regions, predicted old region time: 12.34ms

[3.484s][info ][gc] GC(8) 512M->384M(8192M) 28.456ms
    Eden: 64 regions -> 0 regions
    Survivor: 8 regions -> 12 regions  
    Old: 420 regions -> 379 regions
```

**Mixed GC Collection Set分析**：

| 类型 | 回收前 | 回收后 | 回收量 |
|------|--------|--------|--------|
| Eden | 64 regions (256MB) | 0 | 256MB |
| Survivor | 8 regions (32MB) | 12 regions | -16MB (晋升) |
| **Old** | **420 regions** | **379 regions** | **164MB** |
| **总计** | **512MB** | **384MB** | **128MB** |

### 10.11.7 TLAB统计分析

```
[1.362s][debug][gc,tlab] GC(0) TLAB totals: 
    thrds: 6  refills: 19 max: 14 
    slow allocs: 5963 max 5963 
    waste: 22.2% gc: 6356424B max: 2096872B
```

| 指标 | 值 | 说明 |
|------|-----|------|
| thrds | 6 | 6个线程使用了TLAB |
| refills | 19 | TLAB重新填充19次 |
| slow allocs | 5963 | 5963次TLAB外分配 |
| waste | 22.2% | TLAB浪费率 |
| gc waste | 6MB | GC时TLAB剩余空间 |

**TLAB调优建议**：
- 浪费率 > 20%：考虑减小TLAB大小
- slow allocs过高：考虑增大TLAB大小

### 10.11.8 Refinement Zone统计

```
[0.067s][debug][gc,ergo,refine] Initial Refinement Zones: 
    green: 13, yellow: 39, red: 65, min yellow size: 26
```

| Zone | 阈值 | 计算公式 | 说明 |
|------|------|----------|------|
| Green | 13 | Region数 / 157 | 正常并发细化 |
| Yellow | 39 | Green × 3 | 加速细化 |
| Red | 65 | Green × 5 | 紧急细化 |

---

## 10.12 G1调优参数

### 10.12.1 核心参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `-XX:+UseG1GC` | JDK9+默认 | 启用G1 |
| `-XX:MaxGCPauseMillis` | 200 | 目标最大停顿时间(ms) |
| `-XX:G1HeapRegionSize` | 自动 | Region大小(1-32MB) |
| `-XX:G1NewSizePercent` | 5 | 年轻代最小比例 |
| `-XX:G1MaxNewSizePercent` | 60 | 年轻代最大比例 |
| `-XX:InitiatingHeapOccupancyPercent` | 45 | 触发并发标记的堆占用率 |
| `-XX:G1MixedGCCountTarget` | 8 | Mixed GC目标次数 |
| `-XX:G1HeapWastePercent` | 5 | 允许的堆浪费比例 |

### 10.12.2 8GB堆推荐配置

```bash
java -Xms8g -Xmx8g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \
     -XX:G1HeapRegionSize=4m \
     -XX:InitiatingHeapOccupancyPercent=45 \
     -XX:G1NewSizePercent=20 \
     -XX:G1MaxNewSizePercent=40 \
     -XX:G1MixedGCCountTarget=8 \
     -XX:G1ReservePercent=10 \
     -XX:ParallelGCThreads=8 \
     -XX:ConcGCThreads=2 \
     -Xlog:gc*:file=gc.log:time,uptime,level,tags \
     MyApplication
```

### 10.12.3 常见问题与调优

```
问题1: 停顿时间过长
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
症状: GC停顿超过MaxGCPauseMillis
原因: 
  - 年轻代过大
  - 存活对象过多
  - 记忆集过大
解决:
  - 降低G1MaxNewSizePercent
  - 检查对象分配模式
  - 增加并行GC线程数

问题2: 频繁Full GC
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
症状: 日志中频繁出现Full GC
原因:
  - 并发标记来不及完成
  - 大对象分配过多
  - 堆内存不足
解决:
  - 降低InitiatingHeapOccupancyPercent
  - 增加堆内存
  - 检查Humongous对象分配

问题3: 吞吐量下降
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
症状: 应用吞吐量明显下降
原因:
  - GC过于频繁
  - 并发线程占用CPU
  - 写屏障开销
解决:
  - 增大年轻代
  - 调整ConcGCThreads
  - 考虑使用其他收集器（如ZGC）
```

---

## 10.13 本章小结

本章详细分析了G1垃圾收集器的核心机制：

| 组件 | 作用 |
|------|------|
| **G1CollectorState** | 管理GC状态机 |
| **Young GC** | 回收年轻代，STW并行 |
| **Mixed GC** | 回收年轻代+部分老年代 |
| **Concurrent Marking** | 并发标记存活对象 |
| **Full GC** | 最后保障，四阶段压缩 |
| **SATB** | 并发标记正确性保证 |
| **写屏障** | 维护记忆集和SATB |
| **并发细化** | 异步更新记忆集 |

**G1的核心优势**：
1. 可预测的停顿时间
2. 增量式回收
3. 并发标记
4. Region化设计

**下一章预告**：第11章将深入分析G1的并发标记算法细节，包括位图操作、任务窃取、溢出处理等。
