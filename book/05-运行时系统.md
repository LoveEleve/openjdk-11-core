# ç¬¬5ç« ï¼šè¿è¡Œæ—¶ç³»ç»Ÿ - çº¿ç¨‹ã€é”ä¸åŒæ­¥

> **æœ¬ç« å¯¼è¯»**ï¼šå­—èŠ‚ç æ‰§è¡Œéœ€è¦å¼ºå¤§çš„è¿è¡Œæ—¶æ”¯æŒã€‚æœ¬ç« æ·±å…¥HotSpotçš„çº¿ç¨‹ç®¡ç†ã€synchronizedé”å®ç°ã€å®‰å…¨ç‚¹åè®®ç­‰æ ¸å¿ƒæœºåˆ¶ï¼Œè¿™äº›æ˜¯ç†è§£G1å¹¶å‘æ‰§è¡Œçš„åŸºç¡€ã€‚
> 
> **ä¸ç¬¬1.5ç« çš„å…³è”**ï¼šç¬¬1.5ç« é€šè¿‡GDBè°ƒè¯•åˆ†æäº†è¿è¡Œæ—¶ç³»ç»Ÿçš„åˆå§‹åŒ–è¿‡ç¨‹ï¼Œæœ¬ç« å°†æ·±å…¥è¿™äº›å·²åˆå§‹åŒ–ç»„ä»¶çš„å·¥ä½œæœºåˆ¶ã€‚

---

## 5.0 è¿è¡Œæ—¶ç³»ç»Ÿåˆå§‹åŒ–å›é¡¾

åœ¨ç¬¬1.5ç« ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡GDBè°ƒè¯•éªŒè¯äº†è¿è¡Œæ—¶ç³»ç»Ÿçš„åˆå§‹åŒ–è¿‡ç¨‹ã€‚è®©æˆ‘ä»¬å›é¡¾å‡ ä¸ªå…³é”®çš„åˆå§‹åŒ–å‡½æ•°ï¼š

### å·²éªŒè¯çš„åˆå§‹åŒ–æ­¥éª¤
```gdb
# ä»ç¬¬1.5ç« çš„GDBè°ƒè¯•æ•°æ®
Thread 2 "java" hit Breakpoint: invocationCounter_init()  # 0x7ffff6224674
Thread 2 "java" hit Breakpoint: templateTable_init()      # 0x7ffff69059c2
Thread 2 "java" hit Breakpoint: vtableStubs_init()        # 0x7ffff6a19235
```

è¿™äº›åˆå§‹åŒ–ä¸ºæœ¬ç« è®¨è®ºçš„è¿è¡Œæ—¶æœºåˆ¶å¥ å®šäº†åŸºç¡€ï¼š
- **invocationCounter_init()** â†’ JITç¼–è¯‘è§¦å‘æœºåˆ¶
- **templateTable_init()** â†’ è§£é‡Šå™¨æ‰§è¡Œæ¨¡æ¿
- **vtableStubs_init()** â†’ è™šæ–¹æ³•è°ƒç”¨ä¼˜åŒ–

ç°åœ¨è®©æˆ‘ä»¬æ·±å…¥è¿™äº›å·²åˆå§‹åŒ–ç»„ä»¶çš„è¿è¡Œæ—¶è¡Œä¸ºã€‚

---

## 5.1 çº¿ç¨‹æ¨¡å‹

### 5.1.1 Javaçº¿ç¨‹ä¸OSçº¿ç¨‹çš„æ˜ å°„

HotSpoté‡‡ç”¨**1:1çº¿ç¨‹æ¨¡å‹**ï¼šæ¯ä¸ªJavaçº¿ç¨‹å¯¹åº”ä¸€ä¸ªOSçº¿ç¨‹ï¼ˆPOSIXçº¿ç¨‹ï¼‰ã€‚

```cpp
// hotspot/share/runtime/thread.hpp
class JavaThread: public Thread {
private:
  OSThread*      _osthread;        // æ“ä½œç³»ç»Ÿçº¿ç¨‹
  ThreadState    _thread_state;    // çº¿ç¨‹çŠ¶æ€
  JavaFrameAnchor _anchor;         // å½“å‰æ ˆå¸§é”šç‚¹
  
  oop            _threadObj;       // å¯¹åº”çš„java.lang.Threadå¯¹è±¡
  
  // GCç›¸å…³
  SATBMarkQueue  _satb_mark_queue; // G1çš„SATBé˜Ÿåˆ—
  DirtyCardQueue _dirty_card_queue; // G1çš„è„å¡é˜Ÿåˆ—
  
public:
  enum ThreadState {
    _thread_new            = 0,    // æ–°å»º
    _thread_in_Java        = 2,    // æ‰§è¡ŒJavaä»£ç 
    _thread_in_vm          = 6,    // æ‰§è¡ŒVMä»£ç 
    _thread_in_native      = 10,   // æ‰§è¡Œæœ¬åœ°ä»£ç 
    _thread_blocked        = 14    // é˜»å¡çŠ¶æ€
  };
};
```

**å…³é”®æ–‡ä»¶**ï¼š
```
hotspot/share/runtime/
â”œâ”€â”€ thread.hpp/cpp               # çº¿ç¨‹åŸºç±»
â”œâ”€â”€ javaThread.hpp/cpp           # Javaçº¿ç¨‹å®ç°
â””â”€â”€ osThread.hpp/cpp             # OSçº¿ç¨‹å°è£…

hotspot/os/linux/
â””â”€â”€ os_linux.cpp                 # Linuxçº¿ç¨‹å®ç°
```

---

### 5.1.2 çº¿ç¨‹åˆ›å»ºæµç¨‹

```cpp
// hotspot/share/runtime/thread.cpp
void JavaThread::run() {
  // 1. åˆå§‹åŒ–çº¿ç¨‹æœ¬åœ°å­˜å‚¨
  this->initialize_thread_local_storage();
  
  // 2. è®¾ç½®æ ˆä¿æŠ¤é¡µï¼ˆStackYellowZone/StackRedZoneï¼‰
  this->create_stack_guard_pages();
  
  // 3. ç¼“å­˜çº¿ç¨‹æŒ‡é’ˆåˆ°TLS
  ThreadLocalStorage::set_thread(this);
  
  // 4. åˆå§‹åŒ–å¼‚å¸¸å¤„ç†
  this->initialize_tlab();
  
  // 5. æ‰§è¡Œjava.lang.Thread.run()
  JavaCalls::call_virtual(&result, thread_oop, ...);
  
  // 6. æ¸…ç†èµ„æº
  this->exit(false);
}
```

**çº¿ç¨‹æœ¬åœ°å­˜å‚¨ï¼ˆTLSï¼‰**ï¼š
```cpp
// x86-64æ¶æ„ä½¿ç”¨r15å¯„å­˜å™¨ç¼“å­˜JavaThread*
// hotspot/cpu/x86/thread_linux_x86.hpp
register JavaThread* r15_thread asm("r15");
```

---

### 5.1.3 çº¿ç¨‹çŠ¶æ€è½¬æ¢

```
          +------------------+
          |   _thread_new    |
          +------------------+
                   â†“
          +------------------+
    â”Œâ”€â”€â”€â”€â†’| _thread_in_Java  |â†â”€â”€â”€â”€â”
    â”‚     +------------------+     â”‚
    â”‚              â†“               â”‚
    â”‚     +------------------+     â”‚
    â”‚     |  _thread_in_vm   |     â”‚
    â”‚     +------------------+     â”‚
    â”‚              â†“               â”‚
    â”‚     +------------------+     â”‚
    â””â”€â”€â”€â”€â”€| _thread_in_native|â”€â”€â”€â”€â”€â”˜
          +------------------+
                   â†“
          +------------------+
          | _thread_blocked  |
          +------------------+
```

**çŠ¶æ€è½¬æ¢å®**ï¼š
```cpp
// hotspot/share/runtime/interfaceSupport.inline.hpp
#define TRAPS JavaThread* THREAD

// è¿›å…¥VMçŠ¶æ€
#define VM_ENTRY(result_type, name, signature) \
  result_type name signature { \
    ThreadInVMfromJava __tiv(THREAD); \
    // ... VMæ“ä½œ ...
  }

// è¿›å…¥NativeçŠ¶æ€
#define JVM_ENTRY(result_type, name, signature) \
  result_type JNICALL name signature { \
    ThreadInVMfromNative __tiv(THREAD); \
    // ... JNIæ“ä½œ ...
  }
```

---

## 5.2 Synchronizedå®ç°

### 5.2.1 é”çš„ä¸‰ç§çŠ¶æ€

HotSpotçš„é”ä¼šæ ¹æ®ç«äº‰æƒ…å†µ**è‡ªé€‚åº”å‡çº§**ï¼š

| é”çŠ¶æ€ | Mark Word | è¯´æ˜ | æ€§èƒ½ |
|-------|-----------|------|------|
| **åå‘é”** | çº¿ç¨‹ID + epoch | æ— ç«äº‰ï¼ŒCASè®¾ç½®çº¿ç¨‹ID | æœ€å¿« |
| **è½»é‡çº§é”** | Lock RecordæŒ‡é’ˆ | è½»å¾®ç«äº‰ï¼ŒCASè‡ªæ—‹ | è¾ƒå¿« |
| **é‡é‡çº§é”** | ObjectMonitoræŒ‡é’ˆ | æ¿€çƒˆç«äº‰ï¼ŒOSäº’æ–¥é‡ | æœ€æ…¢ |

### 5.2.2 Mark Wordçš„é”çŠ¶æ€ç¼–ç 

```
64ä½ç³»ç»Ÿä¸‹çš„Mark Wordå¸ƒå±€ï¼ˆ8å­—èŠ‚ï¼‰ï¼š

åå‘é”ï¼ˆbiasedï¼‰ï¼š
|------------------------------------------------------------|----|
|  Thread ID (54ä½) | epoch (2ä½) | unused (1ä½) | age (4ä½) | 101|
|------------------------------------------------------------|----|

è½»é‡çº§é”ï¼ˆlightweightï¼‰ï¼š
|------------------------------------------------------------|----|
|          æŒ‡å‘æ ˆä¸­Lock Recordçš„æŒ‡é’ˆï¼ˆ62ä½ï¼‰                  | 00 |
|------------------------------------------------------------|----|

é‡é‡çº§é”ï¼ˆheavyweightï¼‰ï¼š
|------------------------------------------------------------|----|
|          æŒ‡å‘ObjectMonitorçš„æŒ‡é’ˆï¼ˆ62ä½ï¼‰                    | 10 |
|------------------------------------------------------------|----|
```

**æºç å®šä¹‰**ï¼š
```cpp
// hotspot/share/oops/markOop.hpp
enum {
  locked_value             = 0,  // 00 è½»é‡çº§é”
  unlocked_value           = 1,  // 01 æ— é”
  monitor_value            = 2,  // 10 é‡é‡çº§é”
  marked_value             = 3,  // 11 GCæ ‡è®°
  biased_lock_pattern      = 5   // 101 åå‘é”
};
```

---

### 5.2.3 åå‘é”å®ç°

**åŸç†**ï¼šå¯¹è±¡åå‘äºç¬¬ä¸€ä¸ªè·å–å®ƒçš„çº¿ç¨‹ï¼Œåç»­è¯¥çº¿ç¨‹è·å–é”æ—¶æ— éœ€CASæ“ä½œã€‚

```cpp
// hotspot/share/runtime/biasedLocking.cpp
BiasedLocking::Condition BiasedLocking::revoke_and_rebias(
    Handle obj, bool attempt_rebias, TRAPS) {
  
  markOop mark = obj->mark();
  
  // 1. æ£€æŸ¥æ˜¯å¦æ˜¯åå‘æ¨¡å¼
  if (!mark->has_bias_pattern()) {
    return NOT_BIASED;
  }
  
  // 2. æ£€æŸ¥epochæ˜¯å¦è¿‡æœŸ
  markOop prototype = obj->klass()->prototype_header();
  if (mark->bias_epoch() != prototype->bias_epoch()) {
    // Epochè¿‡æœŸï¼Œå°è¯•é‡åå‘
    if (attempt_rebias) {
      markOop new_mark = mark->set_bias_epoch(prototype->bias_epoch());
      if (obj->cas_set_mark(new_mark, mark) == mark) {
        return BIAS_REVOKED_AND_REBIASED;
      }
    }
  }
  
  // 3. æ£€æŸ¥æ˜¯å¦åå‘å½“å‰çº¿ç¨‹
  if (mark->biased_locker() == THREAD) {
    return BIAS_REVOKED; // å·²ç»åå‘ï¼Œç›´æ¥è¿”å›
  }
  
  // 4. åå‘å…¶ä»–çº¿ç¨‹ï¼Œéœ€è¦æ’¤é”€åå‘
  VM_RevokeBias op(obj, THREAD);
  VMThread::execute(&op);
  
  return BIAS_REVOKED;
}
```

**æ’¤é”€åå‘çš„æ—¶æœº**ï¼š
1. å…¶ä»–çº¿ç¨‹å°è¯•è·å–é”
2. è°ƒç”¨`Object.hashCode()`ï¼ˆMark Wordéœ€è¦å­˜å‚¨å“ˆå¸Œå€¼ï¼‰
3. è°ƒç”¨`System.identityHashCode()`

---

### 5.2.4 è½»é‡çº§é”å®ç°

**åŸç†**ï¼šåœ¨æ ˆå¸§ä¸­åˆ›å»ºLock Recordï¼Œé€šè¿‡CASå°†å¯¹è±¡å¤´æŒ‡å‘Lock Recordã€‚

```cpp
// hotspot/share/runtime/synchronizer.cpp
void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, TRAPS) {
  markOop mark = obj->mark();
  
  // 1. æ£€æŸ¥æ˜¯å¦æ˜¯æ— é”çŠ¶æ€
  if (mark->is_neutral()) {
    // åœ¨æ ˆä¸­å¤åˆ¶Mark Word
    lock->set_displaced_header(mark);
    
    // CASæ›¿æ¢å¯¹è±¡å¤´ä¸ºLock RecordæŒ‡é’ˆ
    if (mark == obj()->cas_set_mark((markOop)lock, mark)) {
      return; // åŠ é”æˆåŠŸ
    }
    // CASå¤±è´¥ï¼Œå‡çº§åˆ°é‡é‡çº§é”
  }
  
  // 2. æ£€æŸ¥æ˜¯å¦æ˜¯é”é‡å…¥
  else if (mark->has_locker() && 
           THREAD->is_lock_owned((address)mark->locker())) {
    lock->set_displaced_header(NULL); // é‡å…¥æ ‡è®°
    return;
  }
  
  // 3. å‡çº§åˆ°é‡é‡çº§é”
  lock->set_displaced_header(markOopDesc::unused_mark());
  ObjectSynchronizer::inflate(THREAD, obj(), inflate_cause_monitor_enter)
      ->enter(THREAD);
}
```

**Lock Recordç»“æ„**ï¼š
```cpp
// hotspot/share/runtime/basicLock.hpp
class BasicLock {
private:
  volatile markOop _displaced_header; // ä¿å­˜åŸå§‹Mark Word
};
```

---

### 5.2.5 é‡é‡çº§é”å®ç°ï¼šObjectMonitor

```cpp
// hotspot/share/runtime/objectMonitor.hpp
class ObjectMonitor {
private:
  void*     _owner;           // æŒæœ‰é”çš„çº¿ç¨‹
  volatile int _recursions;   // é‡å…¥è®¡æ•°
  ObjectWaiter* _cxq;         // ç«äº‰é˜Ÿåˆ—ï¼ˆContention Queueï¼‰
  ObjectWaiter* _EntryList;   // ç­‰å¾…é˜Ÿåˆ—
  ObjectWaiter* _WaitSet;     // waité˜Ÿåˆ—
  
  volatile int _count;        // ç­‰å¾…çº¿ç¨‹æ•°
  volatile int _waiters;      // waitä¸­çš„çº¿ç¨‹æ•°
  
public:
  void enter(TRAPS);          // åŠ é”
  void exit(TRAPS);           // è§£é”
  void wait(jlong millis, TRAPS);  // Object.wait()
  void notify(TRAPS);         // Object.notify()
  void notifyAll(TRAPS);      // Object.notifyAll()
};
```

**åŠ é”æµç¨‹**ï¼š
```cpp
void ObjectMonitor::enter(TRAPS) {
  Thread* Self = THREAD;
  
  // 1. å¿«é€Ÿè·¯å¾„ï¼šæ— ç«äº‰æ—¶ç›´æ¥CASè®¾ç½®owner
  void* cur = Atomic::cmpxchg_ptr(Self, &_owner, NULL);
  if (cur == NULL) {
    return; // åŠ é”æˆåŠŸ
  }
  
  // 2. é”é‡å…¥
  if (cur == Self) {
    _recursions++;
    return;
  }
  
  // 3. è‡ªæ—‹å°è¯•è·å–é”
  if (TrySpin(Self) > 0) {
    return;
  }
  
  // 4. è‡ªæ—‹å¤±è´¥ï¼ŒåŠ å…¥ç­‰å¾…é˜Ÿåˆ—
  ObjectWaiter node(Self);
  for (;;) {
    node._next = _cxq;
    if (Atomic::cmpxchg_ptr(&node, &_cxq, node._next) == node._next) {
      break;
    }
  }
  
  // 5. é˜»å¡çº¿ç¨‹
  for (;;) {
    if (TryLock(Self) > 0) break;
    
    // ä½¿ç”¨pthread_cond_waité˜»å¡
    ParkEvent * const _event = Self->_ParkEvent;
    _event->park();
  }
}
```

**é˜Ÿåˆ—ç»“æ„**ï¼š
```
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   _owner    â”‚ â† æŒæœ‰é”çš„çº¿ç¨‹
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚    _cxq     â”‚ â† æœ€æ–°åˆ°è¾¾çš„ç­‰å¾…çº¿ç¨‹ï¼ˆæ— é”æ ˆï¼‰
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ _EntryList  â”‚ â† å‡†å¤‡ç«äº‰çš„çº¿ç¨‹ï¼ˆæœ‰é”é˜Ÿåˆ—ï¼‰
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  _WaitSet   â”‚ â† waitä¸­çš„çº¿ç¨‹
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.2.6 è§£é”æµç¨‹

```cpp
void ObjectMonitor::exit(TRAPS) {
  Thread* Self = THREAD;
  
  // 1. æ£€æŸ¥æ˜¯å¦æ˜¯é”æŒæœ‰è€…
  if (_owner != Self) {
    TEVENT(Exit - Not Owner);
    throw IllegalMonitorStateException;
  }
  
  // 2. å¤„ç†é”é‡å…¥
  if (_recursions != 0) {
    _recursions--;
    return;
  }
  
  // 3. å”¤é†’ç­‰å¾…çº¿ç¨‹
  ObjectWaiter* w = NULL;
  int QMode = Knob_QMode; // å”¤é†’ç­–ç•¥
  
  if (QMode == 2 && _cxq != NULL) {
    // ä»_cxqä¸­å–å‡ºçº¿ç¨‹
    w = _cxq;
    _cxq = w->_next;
  } else if (QMode == 3 && _cxq != NULL) {
    // å°†_cxqæ‰¹é‡è½¬ç§»åˆ°_EntryList
    w = _cxq;
    for (;;) {
      ObjectWaiter* u = (ObjectWaiter*)Atomic::cmpxchg_ptr(NULL, &_cxq, w);
      if (u == w) break;
      w = u;
    }
  }
  
  // 4. é‡Šæ”¾é”
  OrderAccess::release_store(&_owner, (void*)NULL);
  
  // 5. å”¤é†’çº¿ç¨‹
  if (w != NULL) {
    w->_event->unpark();
  }
}
```

---

## 5.3 å®‰å…¨ç‚¹ï¼ˆSafepointï¼‰

### 5.3.1 ä»€ä¹ˆæ˜¯å®‰å…¨ç‚¹ï¼Ÿ

**å®‰å…¨ç‚¹**ï¼šæ‰€æœ‰Javaçº¿ç¨‹éƒ½åœä¸‹æ¥çš„æ—¶åˆ»ï¼Œæ­¤æ—¶å¯ä»¥å®‰å…¨åœ°æ‰§è¡Œï¼š
- åƒåœ¾å›æ”¶
- å»ä¼˜åŒ–ï¼ˆDeoptimizationï¼‰
- åå‘é”æ’¤é”€
- çº¿ç¨‹æ ˆdump
- Class Redefinitionï¼ˆJVMTIï¼‰

### 5.3.2 å®‰å…¨ç‚¹çš„æ¡ä»¶

```cpp
// hotspot/share/runtime/safepoint.hpp
class Safepoint : AllStatic {
private:
  enum SynchronizeState {
    _not_synchronized = 0,     // æœªåŒæ­¥
    _synchronizing    = 1,     // æ­£åœ¨åŒæ­¥
    _synchronized     = 2      // å·²åŒæ­¥
  };
  
  static volatile SynchronizeState _state;
  static volatile int _waiting_to_block; // ç­‰å¾…é˜»å¡çš„çº¿ç¨‹æ•°
  
public:
  static void begin();  // å‘èµ·å®‰å…¨ç‚¹
  static void end();    // ç»“æŸå®‰å…¨ç‚¹
};
```

**å®‰å…¨ç‚¹çš„ä½ç½®**ï¼š
1. **æ–¹æ³•è¿”å›å‰**
2. **å¾ªç¯çš„æœ«å°¾**ï¼ˆåå‘è·³è½¬ï¼‰
3. **å¯èƒ½é•¿æ—¶é—´è¿è¡Œçš„æœ¬åœ°ä»£ç å‰**

---

### 5.3.3 è½®è¯¢æœºåˆ¶ï¼ˆPollingï¼‰

```cpp
// è§£é‡Šå™¨ä¸­çš„å®‰å…¨ç‚¹æ£€æŸ¥
void TemplateTable::if_icmp(Condition cc) {
  // ... æ¡ä»¶è·³è½¬é€»è¾‘ ...
  
  // åå‘è·³è½¬æ—¶æ£€æŸ¥å®‰å…¨ç‚¹
  if (is_backward_branch) {
    __ testl(Address(r15_thread, JavaThread::polling_page_offset()));
    // å¦‚æœé¡µé¢è¢«ä¿æŠ¤ï¼Œè§¦å‘SIGSEGV â†’ SafepointSynchronize::handle_polling_page_exception()
  }
}
```

**JITç¼–è¯‘å™¨ä¸­çš„è½®è¯¢**ï¼š
```cpp
// hotspot/share/opto/parse2.cpp
void Parse::do_one_bytecode() {
  // åœ¨å¾ªç¯åå‘è·³è½¬å¤„æ’å…¥å®‰å…¨ç‚¹æ£€æŸ¥
  if (is_backward_branch(bci())) {
    add_safepoint();
  }
}
```

---

### 5.3.4 å®‰å…¨ç‚¹æ‰§è¡Œæµç¨‹

```cpp
// hotspot/share/runtime/safepoint.cpp
void SafepointSynchronize::begin() {
  // 1. è®¾ç½®å…¨å±€æ ‡å¿—
  _state = _synchronizing;
  OrderAccess::fence();
  
  // 2. ä¿æŠ¤è½®è¯¢é¡µï¼ˆè§¦å‘æ‰€æœ‰çº¿ç¨‹çš„SIGSEGVï¼‰
  os::make_polling_page_unreadable();
  
  // 3. ç­‰å¾…æ‰€æœ‰Javaçº¿ç¨‹åˆ°è¾¾å®‰å…¨ç‚¹
  int iterations = 0;
  while (_waiting_to_block > 0) {
    if (iterations++ > 10000) {
      // è¶…æ—¶ï¼Œæ‰“å°æ…¢çº¿ç¨‹ä¿¡æ¯
      print_safepoint_timeout(_spinning_timeout);
    }
    os::naked_short_sleep(1);
  }
  
  // 4. æ ‡è®°è¿›å…¥å®‰å…¨ç‚¹
  _state = _synchronized;
  OrderAccess::fence();
  
  // 5. æ‰§è¡ŒVMæ“ä½œï¼ˆå¦‚GCï¼‰
  RuntimeService::record_safepoint_begin();
}

void SafepointSynchronize::end() {
  // 1. æ¢å¤è½®è¯¢é¡µ
  os::make_polling_page_readable();
  
  // 2. å”¤é†’æ‰€æœ‰çº¿ç¨‹
  _state = _not_synchronized;
  OrderAccess::fence();
  
  // 3. è®°å½•ç»Ÿè®¡ä¿¡æ¯
  RuntimeService::record_safepoint_end();
}
```

---

### 5.3.5 çº¿ç¨‹çŠ¶æ€ä¸å®‰å…¨ç‚¹

```cpp
// ä¸åŒçŠ¶æ€çš„çº¿ç¨‹å¦‚ä½•åˆ°è¾¾å®‰å…¨ç‚¹

// 1. _thread_in_Javaï¼šæ‰§è¡ŒJavaä»£ç 
//    â†’ æ£€æµ‹åˆ°è½®è¯¢é¡µä¸å¯è¯» â†’ è¿›å…¥VM â†’ é˜»å¡åœ¨å®‰å…¨ç‚¹

// 2. _thread_in_vmï¼šæ‰§è¡ŒVMä»£ç 
//    â†’ æ£€æŸ¥_stateæ ‡å¿— â†’ ä¸»åŠ¨é˜»å¡

// 3. _thread_in_nativeï¼šæ‰§è¡Œæœ¬åœ°ä»£ç 
//    â†’ ä¸éœ€è¦é˜»å¡ï¼è¿”å›JVMæ—¶æ£€æŸ¥_state

// 4. _thread_blockedï¼šå·²ç»é˜»å¡
//    â†’ ä¸éœ€è¦å¤„ç†
```

**çŠ¶æ€è½¬æ¢å®**ï¼š
```cpp
// hotspot/share/runtime/interfaceSupport.inline.hpp
class ThreadInVMfromJava {
public:
  ThreadInVMfromJava(JavaThread* thread) : _thread(thread) {
    transition_from_java(_thread, _thread_in_vm);
  }
  
  ~ThreadInVMfromJava() {
    transition_from_vm(_thread, _thread_in_Java, true /* check_asyncs */);
  }
};
```

---

## 5.4 æ ˆå¸§ç®¡ç†

### 5.4.1 æ ˆå¸§ç»“æ„

```cpp
// hotspot/share/runtime/frame.hpp
class frame {
private:
  intptr_t* _sp;  // æ ˆæŒ‡é’ˆï¼ˆStack Pointerï¼‰
  intptr_t* _fp;  // å¸§æŒ‡é’ˆï¼ˆFrame Pointerï¼‰
  address   _pc;  // PCæŒ‡é’ˆï¼ˆProgram Counterï¼‰
  
public:
  // è§£é‡Šå™¨æ ˆå¸§
  intptr_t* interpreter_frame_locals();      // å±€éƒ¨å˜é‡è¡¨
  intptr_t* interpreter_frame_expression_stack(); // æ“ä½œæ•°æ ˆ
  Method*   interpreter_frame_method();      // å½“å‰æ–¹æ³•
  ConstantPoolCache* interpreter_frame_cache(); // å¸¸é‡æ± ç¼“å­˜
  
  // ç¼–è¯‘å™¨æ ˆå¸§
  int compiled_frame_size();
  CompiledMethod* compiled_frame_nm();
};
```

**å†…å­˜å¸ƒå±€**ï¼ˆx86-64ï¼‰ï¼š
```
é«˜åœ°å€ â†‘
+------------------------+
| è°ƒç”¨è€…çš„å‚æ•°ï¼ˆé€†åºï¼‰     |
+------------------------+
| è¿”å›åœ°å€ï¼ˆreturn PCï¼‰   | â† è°ƒç”¨è€…çš„rip
+------------------------+
| ä¿å­˜çš„rbp              | â† å½“å‰rbpæŒ‡å‘è¿™é‡Œ
+------------------------+
| å±€éƒ¨å˜é‡è¡¨              | â† locals
| - å‚æ•°                 |
| - å±€éƒ¨å˜é‡             |
+------------------------+
| æ“ä½œæ•°æ ˆ               | â† stack
+------------------------+
| å¸§æ•°æ®                 |
| - Method*             |
| - ConstantPoolCache*  |
| - ä¸Šä¸€ä¸ªæ ˆå¸§çš„bcp      |
+------------------------+
| ä¸‹ä¸€ä¸ªæ ˆå¸§...          | â† rsp
+------------------------+
ä½åœ°å€ â†“
```

---

### 5.4.2 æ ˆå¸§éå†

```cpp
// hotspot/share/runtime/vframe.cpp
void vframeStreamCommon::next() {
  do {
    // ç‰©ç†æ ˆå¸§å‰è¿›
    _frame = _frame.sender(&_reg_map);
    
    // å¦‚æœæ˜¯ç¼–è¯‘å¸§ï¼Œå¯èƒ½å¯¹åº”å¤šä¸ªé€»è¾‘æ ˆå¸§ï¼ˆå†…è”ï¼‰
    if (_frame.is_compiled_frame()) {
      _vframe_id++;
      if (_vframe_id < scope_count()) {
        continue; // å¤„ç†å†…è”å¸§
      }
    }
    
    _vframe_id = 0;
  } while (!fill_from_frame());
}
```

**åº”ç”¨åœºæ™¯**ï¼š
- å¼‚å¸¸å †æ ˆæ‰“å°
- JVMTIçš„GetStackTrace
- JFRçš„çº¿ç¨‹é‡‡æ ·
- å»ä¼˜åŒ–æ—¶çš„æ ˆé‡å»º

---

## 5.5 å¼‚å¸¸å¤„ç†

### 5.5.1 å¼‚å¸¸è¡¨ï¼ˆException Tableï¼‰

```java
// Javaä»£ç 
public void test() {
    try {
        riskyOperation();
    } catch (IOException e) {
        handleIO(e);
    } catch (Exception e) {
        handleGeneric(e);
    } finally {
        cleanup();
    }
}
```

**å­—èŠ‚ç å¼‚å¸¸è¡¨**ï¼š
```
Exception table:
from    to  target type
   0     5     8   Class java/io/IOException
   0     5    16   Class java/lang/Exception
   0    24    27   any (finally)
   8    16    27   any (finally)
  16    24    27   any (finally)
```

---

### 5.5.2 å¼‚å¸¸åˆ†å‘æµç¨‹

```cpp
// hotspot/share/interpreter/interpreterRuntime.cpp
JRT_ENTRY(address, InterpreterRuntime::exception_handler_for_exception(
    JavaThread* thread, oopDesc* exception))
  
  // 1. è·å–å½“å‰æ–¹æ³•å’Œbci
  Method* method = last_frame.interpreter_frame_method();
  int bci = last_frame.interpreter_frame_bci();
  
  // 2. æŸ¥æ‰¾å¼‚å¸¸å¤„ç†å™¨
  int handler_bci = method->fast_exception_handler_bci_for(
      exception->klass(), bci, THREAD);
  
  if (handler_bci < 0) {
    // æ²¡æœ‰æ‰¾åˆ°å¤„ç†å™¨ï¼Œunwindæ ˆå¸§
    return Interpreter::remove_activation_entry();
  }
  
  // 3. è·³è½¬åˆ°catchå—
  return method->code_base() + handler_bci;
JRT_END
```

---

### 5.5.3 å¼‚å¸¸å¯¹è±¡çš„åˆ›å»º

```cpp
// hotspot/share/classfile/systemDictionary.cpp
Handle Exceptions::new_exception(Thread* thread, Symbol* name, ...) {
  // 1. åˆ†é…å¼‚å¸¸å¯¹è±¡
  InstanceKlass* klass = SystemDictionary::resolve_or_fail(name, ...);
  Handle exception = klass->allocate_instance_handle(CHECK_NH);
  
  // 2. å¡«å……stackTraceï¼ˆæ•è·è°ƒç”¨æ ˆï¼‰
  java_lang_Throwable::fill_in_stack_trace(exception, method, CHECK_NH);
  
  // 3. è°ƒç”¨æ„é€ å™¨
  JavaCalls::call_special(&result, exception, klass, 
                          vmSymbols::object_initializer_name(), ...);
  
  return exception;
}
```

**fill_in_stack_traceçš„å¼€é”€**ï¼š
```cpp
// æ•è·è°ƒç”¨æ ˆéœ€è¦éå†æ‰€æœ‰æ ˆå¸§ï¼Œè¿™æ˜¯å¼‚å¸¸å¤„ç†çš„ä¸»è¦å¼€é”€
void java_lang_Throwable::fill_in_stack_trace(Handle throwable, ...) {
  JavaThread* thread = JavaThread::current();
  
  // éå†æ ˆå¸§
  int depth = 0;
  for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
    Method* method = vfst.method();
    int bci = vfst.bci();
    // è®°å½•æ–¹æ³•å’Œè¡Œå·
    backtrace.push(method, bci);
    depth++;
  }
  
  // å­˜å‚¨åˆ°Throwableå¯¹è±¡
  java_lang_Throwable::set_backtrace(throwable(), backtrace.obj());
}
```

---

## 5.6 TLABï¼ˆThread-Local Allocation Bufferï¼‰

### 5.6.1 ä»€ä¹ˆæ˜¯TLABï¼Ÿ

**TLAB**ï¼šæ¯ä¸ªçº¿ç¨‹ç‹¬å çš„å†…å­˜ç¼“å†²åŒºï¼Œç”¨äºæ— é”çš„å¯¹è±¡åˆ†é…ã€‚

```cpp
// hotspot/share/gc/shared/threadLocalAllocBuffer.hpp
class ThreadLocalAllocBuffer {
private:
  HeapWord* _start;    // TLABèµ·å§‹åœ°å€
  HeapWord* _top;      // å½“å‰åˆ†é…æŒ‡é’ˆ
  HeapWord* _end;      // TLABç»“æŸåœ°å€
  size_t    _desired_size; // æœŸæœ›å¤§å°
  
public:
  HeapWord* allocate(size_t size) {
    HeapWord* obj = _top;
    if (pointer_delta(_end, obj) >= size) {
      _top = obj + size;
      return obj; // å¿«é€Ÿåˆ†é…
    }
    return NULL; // TLABä¸è¶³ï¼Œéœ€è¦æ…¢é€Ÿè·¯å¾„
  }
};
```

**åˆ†é…æµç¨‹**ï¼š
```
1. æ£€æŸ¥TLABæ˜¯å¦æœ‰è¶³å¤Ÿç©ºé—´
   â”œâ”€ æ˜¯ â†’ æŒ‡é’ˆç¢°æ’åˆ†é…ï¼ˆæ— é”ï¼‰
   â””â”€ å¦ â†’ æ…¢é€Ÿè·¯å¾„
       â”œâ”€ å°è¯•åˆ†é…æ–°çš„TLAB
       â””â”€ ç›´æ¥ä»å †ä¸­åˆ†é…ï¼ˆéœ€è¦åŒæ­¥ï¼‰
```

---

### 5.6.2 TLABä¸G1çš„é›†æˆ

```cpp
// hotspot/share/gc/g1/g1Allocator.cpp
HeapWord* G1Allocator::par_allocate_during_gc(InCSet state, size_t word_size) {
  switch (state) {
  case InCSet::NotInCSet:
    // ä»å½“å‰regionåˆ†é…
    return _mutator_alloc_region.par_allocate(word_size);
    
  case InCSet::Young:
    // GCæœŸé—´ï¼Œä»survivor regionåˆ†é…
    return _survivor_gc_alloc_region.par_allocate(word_size);
    
  case InCSet::Old:
    // æ™‹å‡åˆ°è€å¹´ä»£
    return _old_gc_alloc_region.par_allocate(word_size);
  }
}
```

**TLABå¤§å°çš„åŠ¨æ€è°ƒæ•´**ï¼š
```cpp
// hotspot/share/gc/shared/threadLocalAllocBuffer.cpp
void ThreadLocalAllocBuffer::resize() {
  // æ ¹æ®åˆ†é…é€Ÿç‡è°ƒæ•´å¤§å°
  size_t alloc = _allocated_since_last_gc;
  size_t waste = (_end - _top); // å‰©ä½™ç©ºé—´
  
  // è®¡ç®—æ–°çš„æœŸæœ›å¤§å°
  double alloc_frac = alloc / _gc_waste_limit;
  if (alloc_frac > 1.0) {
    _desired_size = MIN2(_desired_size * 2, _max_size);
  } else if (alloc_frac < 0.5) {
    _desired_size = MAX2(_desired_size / 2, _min_size);
  }
}
```

---

## 5.7 è¿è¡Œæ—¶å¸¸é‡æ± è§£æ

### 5.7.1 å¸¸é‡æ± ç¼“å­˜ï¼ˆConstantPoolCacheï¼‰

```cpp
// hotspot/share/oops/cpCache.hpp
class ConstantPoolCacheEntry {
private:
  volatile intx _f1;   // ç¼“å­˜çš„å…ƒæ•°æ®ï¼ˆMethod*/Klass*/å­—æ®µåç§»é‡ï¼‰
  volatile intx _f2;   // è¾…åŠ©ä¿¡æ¯ï¼ˆvtableç´¢å¼•/å‚æ•°å¤§å°ï¼‰
  volatile int  _flags; // çŠ¶æ€æ ‡å¿—
  
public:
  enum {
    tos_state_shift       = 28,  // æ ˆé¡¶çŠ¶æ€
    is_field_entry_shift  = 26,  // æ˜¯å¦æ˜¯å­—æ®µ
    is_final_shift        = 25,  // æ˜¯å¦æ˜¯final
    is_volatile_shift     = 24,  // æ˜¯å¦æ˜¯volatile
  };
  
  Method* f1_as_method() { return (Method*)_f1; }
  Klass*  f1_as_klass()  { return (Klass*)_f1; }
  int     f2_as_index()  { return (int)_f2; }
};
```

---

### 5.7.2 å­—æ®µè®¿é—®è§£æ

```cpp
// hotspot/share/interpreter/linkResolver.cpp
void LinkResolver::resolve_field(FieldAccessInfo& result, ...) {
  // 1. æŸ¥æ‰¾å­—æ®µ
  Klass* sel_klass = sel_klass_h();
  fieldDescriptor fd;
  sel_klass->find_field(name, signature, &fd);
  
  // 2. æ£€æŸ¥è®¿é—®æƒé™
  check_field_accessability(current_klass, resolved_klass, &fd, CHECK);
  
  // 3. ç¼“å­˜åˆ°ConstantPoolCache
  int field_offset = fd.offset();
  result.set(resolved_klass, fd.field_holder(), field_offset, ...);
}
```

**å¥½å¤„**ï¼šé¿å…æ¯æ¬¡éƒ½è§£æç¬¦å·å¼•ç”¨ï¼Œæå‡æ€§èƒ½ã€‚

---

## 5.8 ä¸G1çš„äº¤äº’

### 5.8.1 å†™å±éšœï¼ˆWrite Barrierï¼‰

G1éœ€è¦åœ¨**æ¯æ¬¡å¼•ç”¨å­—æ®µå†™å…¥æ—¶**æ’å…¥å†™å±éšœï¼š

```cpp
// hotspot/share/gc/g1/g1BarrierSet.hpp
void G1BarrierSet::write_ref_field_pre(T* field, oop new_val) {
  // SATB pre-barrierï¼ˆæ ‡è®°å‰ï¼‰
  if (new_val != NULL && _satb_mark_queue_set.is_active()) {
    enqueue(pre_val); // è®°å½•æ—§å€¼
  }
}

void G1BarrierSet::write_ref_field_post(T* field, oop new_val) {
  // Post-barrierï¼ˆæ ‡è®°åï¼‰
  HeapRegion* hr = _g1->heap_region_containing(field);
  if (hr->is_young()) return; // YoungåŒºä¸éœ€è¦
  
  // è®°å½•è„å¡
  _dirty_card_queue_set.enqueue(card_addr);
}
```

**æ’å…¥ä½ç½®**ï¼š
1. **è§£é‡Šå™¨**ï¼š`putfield`/`aastore`å­—èŠ‚ç æ¨¡æ¿ä¸­
2. **C1ç¼–è¯‘å™¨**ï¼šIRèŠ‚ç‚¹ä¸­æ’å…¥
3. **C2ç¼–è¯‘å™¨**ï¼šIdealå›¾ä¸­æ’å…¥

---

### 5.8.2 å®‰å…¨ç‚¹ä¸GC

```cpp
// G1è§¦å‘GCçš„æµç¨‹
void G1CollectedHeap::collect(GCCause::Cause cause) {
  // 1. å‘èµ·å®‰å…¨ç‚¹
  VM_G1CollectFull op(gc_count_before, full_gc_count_before, cause);
  VMThread::execute(&op);
}

// VMçº¿ç¨‹æ‰§è¡ŒGC
void VM_G1CollectFull::doit() {
  // æ­¤æ—¶æ‰€æœ‰Javaçº¿ç¨‹éƒ½åœ¨å®‰å…¨ç‚¹
  G1CollectedHeap* g1h = G1CollectedHeap::heap();
  g1h->do_full_collection(false);
}
```

---

### 5.8.3 SATBé˜Ÿåˆ—

```cpp
// hotspot/share/gc/g1/satbMarkQueue.hpp
class SATBMarkQueue: public PtrQueue {
public:
  void enqueue(oop obj) {
    if (_index == 0) {
      flush(); // é˜Ÿåˆ—æ»¡ï¼Œåˆ·æ–°åˆ°å…¨å±€é˜Ÿåˆ—
    }
    _buf[--_index] = obj;
  }
};
```

**æ¯ä¸ªJavaThreadéƒ½æœ‰ä¸€ä¸ªSATBé˜Ÿåˆ—**ï¼Œè®°å½•å¹¶å‘æ ‡è®°æœŸé—´çš„å¼•ç”¨å˜åŒ–ã€‚

---

## 5.9 æ€§èƒ½ç›‘æ§

### 5.9.1 è¿è¡Œæ—¶ç»Ÿè®¡

```cpp
// hotspot/share/runtime/runtimeService.hpp
class RuntimeService {
public:
  static jlong safepoint_count();
  static jlong safepoint_sync_time_ms();
  static jlong safepoint_total_time_ms();
  static jlong application_time_ms();
};
```

**JMX Bean**ï¼š
```java
// java.lang.management.ThreadMXBean
long getThreadCpuTime(long threadId);
long getThreadUserTime(long threadId);
ThreadInfo[] getThreadInfo(long[] ids, int maxDepth);
```

---

### 5.9.2 å®‰å…¨ç‚¹æ—¥å¿—

```bash
# å¯ç”¨å®‰å…¨ç‚¹æ—¥å¿—
java -XX:+PrintGCApplicationStoppedTime \
     -XX:+PrintSafepointStatistics \
     -XX:PrintSafepointStatisticsCount=1 \
     YourApp
```

**è¾“å‡ºç¤ºä¾‹**ï¼š
```
         vmop                    [threads: total initially_running wait_to_block]    [time: spin block sync cleanup vmop] page_trap_count
0.284: G1CollectForAllocation          [      10          0              1    ]      [     0     0     0     0    18    ]  0

vmop: è§¦å‘çš„VMæ“ä½œ
threads: çº¿ç¨‹æ•°
time: å„é˜¶æ®µè€—æ—¶ï¼ˆmsï¼‰
  - spin: è‡ªæ—‹ç­‰å¾…
  - block: é˜»å¡ç­‰å¾…
  - sync: åŒæ­¥æ—¶é—´
  - vmop: VMæ“ä½œæ—¶é—´
```

---

## 5.10 å®æˆ˜æ¡ˆä¾‹ï¼šè¿½è¸ªä¸€æ¬¡synchronized

### 5.10.1 Javaä»£ç 
```java
public class LockTest {
    private final Object lock = new Object();
    
    public void test() {
        synchronized (lock) {
            // ä¸´ç•ŒåŒºä»£ç 
        }
    }
}
```

### 5.10.2 å­—èŠ‚ç 
```
0: aload_0
1: getfield      #2  // Field lock:Ljava/lang/Object;
4: dup
5: astore_1
6: monitorenter       // åŠ é”
7: aload_1
8: monitorexit        // è§£é”
9: goto          17
12: astore_2
13: aload_1
14: monitorexit       // å¼‚å¸¸è·¯å¾„è§£é”
15: aload_2
16: athrow
17: return
```

### 5.10.3 æ‰§è¡Œæµç¨‹

**ç¬¬ä¸€æ¬¡è·å–é”ï¼ˆåå‘é”ï¼‰**ï¼š
```cpp
// 1. æ£€æŸ¥Mark Word
markOop mark = obj->mark();
if (mark->is_neutral()) {
  // 2. CASè®¾ç½®åå‘çº¿ç¨‹ID
  markOop biased_mark = mark->set_biased_locking_pattern();
  biased_mark = biased_mark->set_bias_epoch(klass->prototype_header()->bias_epoch());
  biased_mark = biased_mark->set_biased_locker(THREAD);
  
  if (obj->cas_set_mark(biased_mark, mark) == mark) {
    return; // åå‘æˆåŠŸ
  }
}
```

**ç¬¬äºŒæ¬¡è·å–é”ï¼ˆåŒä¸€çº¿ç¨‹ï¼‰**ï¼š
```cpp
// æ£€æŸ¥Mark Wordä¸­çš„çº¿ç¨‹ID
if (mark->biased_locker() == THREAD) {
  return; // å·²åå‘å½“å‰çº¿ç¨‹ï¼Œç›´æ¥è¿”å›ï¼ˆæ— éœ€CASï¼‰
}
```

**ç¬¬ä¸‰æ¬¡è·å–é”ï¼ˆå…¶ä»–çº¿ç¨‹ï¼‰**ï¼š
```cpp
// 1. æ’¤é”€åå‘é”ï¼ˆéœ€è¦å®‰å…¨ç‚¹ï¼‰
VM_RevokeBias op(obj, THREAD);
VMThread::execute(&op);

// 2. å‡çº§ä¸ºè½»é‡çº§é”
BasicLock* lock = ...;
lock->set_displaced_header(mark);
if (obj->cas_set_mark((markOop)lock, mark) == mark) {
  return; // è½»é‡çº§é”åŠ é”æˆåŠŸ
}

// 3. å‡çº§ä¸ºé‡é‡çº§é”
ObjectMonitor* monitor = ObjectSynchronizer::inflate(obj);
monitor->enter(THREAD);
```

---

## 5.11 å…³é”®æ•°æ®ç»“æ„æ€»ç»“

```cpp
// çº¿ç¨‹
class JavaThread {
  OSThread*       _osthread;       // OSçº¿ç¨‹
  ThreadState     _thread_state;   // çº¿ç¨‹çŠ¶æ€
  SATBMarkQueue   _satb_mark_queue; // G1çš„SATBé˜Ÿåˆ—
  DirtyCardQueue  _dirty_card_queue; // G1çš„è„å¡é˜Ÿåˆ—
  ThreadLocalAllocBuffer _tlab;    // çº¿ç¨‹æœ¬åœ°åˆ†é…ç¼“å†²
};

// é”
class ObjectMonitor {
  void*           _owner;          // é”æŒæœ‰è€…
  int             _recursions;     // é‡å…¥è®¡æ•°
  ObjectWaiter*   _cxq;            // ç«äº‰é˜Ÿåˆ—
  ObjectWaiter*   _EntryList;      // ç­‰å¾…é˜Ÿåˆ—
  ObjectWaiter*   _WaitSet;        // waité˜Ÿåˆ—
};

// å®‰å…¨ç‚¹
class SafepointSynchronize {
  static volatile SynchronizeState _state;  // åŒæ­¥çŠ¶æ€
  static int      _waiting_to_block;        // ç­‰å¾…é˜»å¡çš„çº¿ç¨‹æ•°
};
```

---

## 5.12 æœ¬ç« å°ç»“

### æ ¸å¿ƒè¦ç‚¹
1. **çº¿ç¨‹æ¨¡å‹**ï¼š1:1æ˜ å°„ï¼Œä½¿ç”¨r15å¯„å­˜å™¨ç¼“å­˜JavaThread*
2. **é”å‡çº§è·¯å¾„**ï¼šåå‘é” â†’ è½»é‡çº§é” â†’ é‡é‡çº§é”ï¼ˆObjectMonitorï¼‰
3. **å®‰å…¨ç‚¹æœºåˆ¶**ï¼šè½®è¯¢é¡µ + çŠ¶æ€æ£€æŸ¥ï¼Œå®ç°æ‰€æœ‰çº¿ç¨‹çš„åŒæ­¥åœæ­¢
4. **TLAB**ï¼šçº¿ç¨‹æœ¬åœ°åˆ†é…ï¼Œå‡å°‘åŒæ­¥å¼€é”€
5. **å†™å±éšœ**ï¼šG1çš„SATBå’ŒPost-Barrieré›†æˆåœ¨è¿è¡Œæ—¶
6. **å¼‚å¸¸å¤„ç†**ï¼šå¼‚å¸¸è¡¨æŸ¥æ‰¾ + æ ˆå¸§unwind

### æ€§èƒ½è°ƒä¼˜å»ºè®®
```bash
# åå‘é”ï¼ˆé»˜è®¤å¼€å¯ï¼Œå¯åŠ¨æ…¢å¯å…³é—­ï¼‰
-XX:+UseBiasedLocking
-XX:BiasedLockingStartupDelay=0

# è‡ªæ—‹é”
-XX:+UseSpinning
-XX:PreBlockSpin=10

# TLAB
-XX:+UseTLAB
-XX:TLABSize=256k

# å®‰å…¨ç‚¹æ—¥å¿—
-XX:+PrintSafepointStatistics
-XX:+PrintGCApplicationStoppedTime
```

### ä¸åç»­ç« èŠ‚çš„è”ç³»
- **ç¬¬6ç« ï¼ˆJITç¼–è¯‘ï¼‰**ï¼šç¼–è¯‘ä»£ç å¦‚ä½•ç”Ÿæˆé”ã€å®‰å…¨ç‚¹æ£€æŸ¥
- **ç¬¬12ç« ï¼ˆG1ï¼‰**ï¼šå†™å±éšœçš„å®Œæ•´å®ç°ã€å¹¶å‘æ ‡è®°ä¸å®‰å…¨ç‚¹çš„é…åˆ

---

## 5.13 è¿›é˜¶é˜…è¯»

**æºç æ–‡ä»¶**ï¼š
```
hotspot/share/runtime/
â”œâ”€â”€ thread.cpp                # çº¿ç¨‹ç®¡ç†
â”œâ”€â”€ synchronizer.cpp          # é”å®ç°
â”œâ”€â”€ biasedLocking.cpp         # åå‘é”
â”œâ”€â”€ objectMonitor.cpp         # é‡é‡çº§é”
â”œâ”€â”€ safepoint.cpp             # å®‰å…¨ç‚¹
â””â”€â”€ interfaceSupport.inline.hpp # çŠ¶æ€è½¬æ¢

hotspot/share/gc/g1/
â”œâ”€â”€ g1BarrierSet.cpp          # G1å†™å±éšœ
â””â”€â”€ satbMarkQueue.cpp         # SATBé˜Ÿåˆ—
```

**æ¨èå®éªŒ**ï¼š
1. ä½¿ç”¨`jstack`è§‚å¯Ÿçº¿ç¨‹çŠ¶æ€
2. ä½¿ç”¨`-XX:+PrintBiasedLockingStatistics`æŸ¥çœ‹åå‘é”ç»Ÿè®¡
3. ä½¿ç”¨`-XX:+PrintSafepointStatistics`åˆ†æå®‰å…¨ç‚¹è€—æ—¶
4. ä½¿ç”¨JFRè®°å½•é”ç«äº‰äº‹ä»¶

---

**ä¸‹ä¸€ç« é¢„å‘Š**ï¼š  
ã€Šç¬¬6ç« ï¼šJITç¼–è¯‘ç³»ç»Ÿã€‹å°†æ·±å…¥è®²è§£C1/C2ç¼–è¯‘å™¨ã€åˆ†å±‚ç¼–è¯‘ç­–ç•¥ã€å†…è”ä¼˜åŒ–ã€é€ƒé€¸åˆ†æç­‰ï¼Œè¿™äº›ä¼˜åŒ–æŠ€æœ¯ä¼šç”Ÿæˆé«˜æ€§èƒ½çš„æœºå™¨ç ï¼Œå¹¶ä¸G1ååŒå·¥ä½œã€‚

å…„å¼Ÿï¼Œå‡†å¤‡å¥½è¿›å…¥ç¼–è¯‘å™¨çš„ä¸–ç•Œäº†å—ï¼ŸğŸš€
