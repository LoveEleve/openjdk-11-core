# 第11章：并发标记算法

> **约定**：本章基于 **Linux x86-64**、**8GB堆内存**（2048个4MB Region）、**非大页模式**、**G1垃圾收集器**。
> 所有源码引用均来自本地 `/data/workspace/openjdk11-core/src/hotspot/` 目录。

---

## 11.1 并发标记概述

### 11.1.1 并发标记的挑战

并发标记需要解决的核心问题：**在应用线程持续修改对象图的同时，正确标记所有存活对象**。

```
并发标记的挑战
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

问题1：漏标（Miss）
┌─────────────────────────────────────────────────────────────────────────┐
│ 标记开始时:  A(黑) ──► B(白)                                            │
│                                                                         │
│ 应用修改:    A.ref = null; C.ref = B;                                   │
│                                                                         │
│ 结果:        B被遗漏（本应存活但被回收）→ 程序崩溃！                      │
└─────────────────────────────────────────────────────────────────────────┘

问题2：多标（Float）
┌─────────────────────────────────────────────────────────────────────────┐
│ 标记开始时:  A ──► B ──► C                                              │
│                                                                         │
│ 标记B后:     A.ref = null (B变成垃圾)                                   │
│                                                                         │
│ 结果:        B仍被标记为存活（浮动垃圾）→ 下次GC回收，可接受              │
└─────────────────────────────────────────────────────────────────────────┘

G1的解决方案：SATB（Snapshot-At-The-Beginning）
- 在标记开始时对对象图做逻辑快照
- 使用写屏障记录被覆盖的引用
- 保守策略：宁可多标，不可漏标
```

### 11.1.2 G1ConcurrentMark核心结构

源码位置：`src/hotspot/share/gc/g1/g1ConcurrentMark.cpp:344-399`

```cpp
G1ConcurrentMark::G1ConcurrentMark(G1CollectedHeap* g1h,
                                   G1RegionToSpaceMapper* prev_bitmap_storage,
                                   G1RegionToSpaceMapper* next_bitmap_storage) :
  _g1h(g1h),                           // G1堆引用
  _completed_initialization(false),    // 初始化完成标志
  
  // 双缓冲位图
  _mark_bitmap_1(),
  _mark_bitmap_2(),
  _prev_mark_bitmap(&_mark_bitmap_1),  // 上次标记结果
  _next_mark_bitmap(&_mark_bitmap_2),  // 当前正在标记
  
  _heap(_g1h->reserved_region()),      // 堆内存范围
  _root_regions(),                     // 根Region管理器
  _global_mark_stack(),                // 全局标记栈
  
  // 工作线程管理
  _worker_id_offset(DirtyCardQueueSet::num_par_ids() + G1ConcRefinementThreads),
  _max_num_tasks(ParallelGCThreads),   // 最大任务数
  _task_queues(new G1CMTaskQueueSet((int) _max_num_tasks)),
  _terminator(ParallelTaskTerminator((int) _max_num_tasks, _task_queues)),
  
  // 溢出处理
  _first_overflow_barrier_sync(),
  _second_overflow_barrier_sync(),
  _has_overflown(false),               // 溢出标志
  
  // 状态标志
  _concurrent(false),                  // 是否并发执行
  _has_aborted(false)                  // 是否中止
  { ... }
```

---

## 11.2 标记位图

### 11.2.1 G1CMBitMap结构

源码位置：`src/hotspot/share/gc/g1/g1ConcurrentMarkBitMap.hpp:62-120`

```cpp
class G1CMBitMap {
  MemRegion _covered;    // 覆盖的堆区域
  const int _shifter;    // 位移量（LogMinObjAlignment = 3）
  BitMapView _bm;        // 实际位图

  // 地址转位图偏移
  size_t addr_to_offset(const HeapWord* addr) const {
    return pointer_delta(addr, _covered.start()) >> _shifter;
  }

  // 位图偏移转地址
  HeapWord* offset_to_addr(size_t offset) const {
    return _covered.start() + (offset << _shifter);
  }

public:
  // 检查对象是否被标记
  bool is_marked(HeapWord* addr) const {
    return _bm.at(addr_to_offset(addr));
  }

  // 标记对象（非原子）
  void mark(HeapWord* addr) {
    _bm.set_bit(addr_to_offset(addr));
  }

  // 并行标记（原子CAS）
  bool par_mark(HeapWord* addr) {
    return _bm.par_set_bit(addr_to_offset(addr));
  }

  // 清除标记
  void clear(HeapWord* addr) {
    _bm.clear_bit(addr_to_offset(addr));
  }
};
```

### 11.2.2 位图大小计算（8GB堆）

```
位图大小计算
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

参数：
- 堆大小: 8GB = 8 × 1024 × 1024 × 1024 = 8,589,934,592 字节
- 最小对象对齐: 8字节（LogMinObjAlignment = 3）
- 每个对象对应1位

计算：
- 可能的对象位置数 = 8GB / 8 = 1,073,741,824 个位置
- 位图大小 = 1,073,741,824 bits = 134,217,728 字节 = 128MB

每个Region的位图：
- Region大小: 4MB
- 每Region位数: 4MB / 8 = 524,288 bits = 64KB

双缓冲总开销：
- prev位图: 128MB
- next位图: 128MB
- 总计: 256MB（占堆的3.125%）

┌─────────────────────────────────────────────────────────────────────────────┐
│                        标记位图布局                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  堆内存 (8GB)                                                               │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ obj0 │ obj1 │ obj2 │ ... │ objN │                                  │    │
│  │ @0   │ @8   │ @24  │     │      │                                  │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│      │      │      │                                                        │
│      ▼      ▼      ▼                                                        │
│  位图 (128MB)                                                               │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ bit0 │ bit1 │ bit3 │ ... │ bitN │                                  │    │
│  │  1   │  0   │  1   │     │      │                                  │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  1 = 对象存活    0 = 未标记/垃圾                                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 11.2.3 双缓冲机制

```
双缓冲位图切换
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

第N次标记周期：
┌─────────────────────────────────────────────────────────────────────────┐
│ _prev_mark_bitmap ──► bitmap_1 (第N-1次结果，只读)                       │
│ _next_mark_bitmap ──► bitmap_2 (第N次正在标记)                           │
└─────────────────────────────────────────────────────────────────────────┘

Cleanup阶段结束，交换指针：
┌─────────────────────────────────────────────────────────────────────────┐
│ swap_mark_bitmaps() {                                                   │
│   G1CMBitMap* temp = _prev_mark_bitmap;                                 │
│   _prev_mark_bitmap = _next_mark_bitmap;  // bitmap_2变成prev           │
│   _next_mark_bitmap = temp;               // bitmap_1变成next           │
│ }                                                                       │
└─────────────────────────────────────────────────────────────────────────┘

第N+1次标记周期：
┌─────────────────────────────────────────────────────────────────────────┐
│ _prev_mark_bitmap ──► bitmap_2 (第N次结果，只读)                         │
│ _next_mark_bitmap ──► bitmap_1 (清空后用于第N+1次标记)                   │
└─────────────────────────────────────────────────────────────────────────┘

优势：
- O(1)切换，无需复制
- prev位图在GC时用于判断对象存活
- next位图在并发标记时更新
```

---

## 11.3 并发标记线程

### 11.3.1 G1ConcurrentMarkThread

源码位置：`src/hotspot/share/gc/g1/g1ConcurrentMarkThread.cpp:79-89`

```cpp
G1ConcurrentMarkThread::G1ConcurrentMarkThread(G1ConcurrentMark* cm) :
  ConcurrentGCThread(),
  _cm(cm),
  _state(Idle),
  _phase_manager_stack(),
  _vtime_accum(0.0),
  _vtime_mark_accum(0.0) {

  set_name("G1 Main Marker");
  create_and_start();
}
```

### 11.3.2 并发标记主循环

源码位置：`src/hotspot/share/gc/g1/g1ConcurrentMarkThread.cpp:247-404`

```cpp
void G1ConcurrentMarkThread::run_service() {
  G1CollectedHeap* g1h = G1CollectedHeap::heap();
  G1Policy* g1_policy = g1h->g1_policy();

  while (!should_terminate()) {
    // 等待启动信号
    sleep_before_next_cycle();
    
    _cm->concurrent_cycle_start();

    // 阶段1: 清除ClassLoaderData的claimed标记
    {
      G1ConcPhase p(G1ConcurrentPhase::CLEAR_CLAIMED_MARKS, this);
      ClassLoaderDataGraph::clear_claimed_marks();
    }

    // 阶段2: 扫描根Region（Survivor）
    {
      G1ConcPhase p(G1ConcurrentPhase::SCAN_ROOT_REGIONS, this);
      _cm->scan_root_regions();
    }

    // 阶段3: 并发标记（可能循环多次处理溢出）
    for (uint iter = 1; !_cm->has_aborted(); ++iter) {
      // 从根开始标记
      {
        G1ConcPhase p(G1ConcurrentPhase::MARK_FROM_ROOTS, this);
        _cm->mark_from_roots();
      }
      
      // 预清理（可选）
      if (G1UseReferencePrecleaning) {
        G1ConcPhase p(G1ConcurrentPhase::PRECLEAN, this);
        _cm->preclean();
      }

      // Remark暂停（STW）
      delay_to_keep_mmu(g1_policy, true /* remark */);
      CMRemark cl(_cm);
      VM_CGC_Operation op(&cl, "Pause Remark");
      VMThread::execute(&op);
      
      if (!_cm->restart_for_overflow()) {
        break;  // 无溢出，退出循环
      }
      // 有溢出，重新开始标记
      log_info(gc, marking)("Restart for Mark Stack Overflow (iteration #%u)", iter);
    }

    // 阶段4: 重建记忆集
    if (!_cm->has_aborted()) {
      G1ConcPhase p(G1ConcurrentPhase::REBUILD_REMEMBERED_SETS, this);
      _cm->rebuild_rem_set_concurrently();
    }

    // 阶段5: Cleanup暂停（STW）
    if (!_cm->has_aborted()) {
      CMCleanup cl_cl(_cm);
      VM_CGC_Operation op(&cl_cl, "Pause Cleanup");
      VMThread::execute(&op);
    }

    // 阶段6: 为下次标记清理位图
    if (!_cm->has_aborted()) {
      G1ConcPhase p(G1ConcurrentPhase::CLEANUP_FOR_NEXT_MARK, this);
      _cm->cleanup_for_next_mark();
    }

    _cm->concurrent_cycle_end();
  }
}
```

### 11.3.3 并发标记阶段时序图

```
并发标记完整时序
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

时间 ──────────────────────────────────────────────────────────────────────►

应用线程  ████████░░░░████████████████████████░░░░░████████████████░░░░████████
                 ↑                              ↑                  ↑
                 │                              │                  │
              Initial                        Remark             Cleanup
               Mark                          (STW)              (STW)
               (STW)

CM线程    ─────────█████████████████████████████─────█████████████─────────────
                   │                           │     │           │
                   │                           │     │           │
                   ▼                           ▼     ▼           ▼
              Root Region                   Mark   Rebuild    Clear
              Scan + Mark                  完成    RSet       Bitmap
              From Roots

阶段详情：
┌─────────────────────────────────────────────────────────────────────────────┐
│ 阶段                    │ 类型      │ 典型时间 │ 说明                        │
├─────────────────────────────────────────────────────────────────────────────┤
│ Initial Mark            │ STW       │ <10ms   │ 与Young GC一起执行          │
│ Root Region Scan        │ Concurrent│ 变化    │ 扫描Survivor Region         │
│ Concurrent Mark         │ Concurrent│ 秒级    │ 遍历整个堆                  │
│ Remark                  │ STW       │ <50ms   │ 处理SATB队列                │
│ Cleanup                 │ STW+Conc  │ <10ms   │ 统计存活对象                │
│ Clear Bitmap            │ Concurrent│ 变化    │ 为下次标记准备              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 11.4 标记任务（G1CMTask）

### 11.4.1 do_marking_step核心流程

源码位置：`src/hotspot/share/gc/g1/g1ConcurrentMark.cpp:2613-2807`

```cpp
void G1CMTask::do_marking_step(double time_target_ms,
                               bool do_termination,
                               bool is_serial) {
  _start_time_ms = os::elapsedVTime() * 1000.0;
  
  // 是否启用工作窃取
  bool do_stealing = do_termination && !is_serial;
  
  // 设置时间目标
  _time_target_ms = time_target_ms - diff_prediction_ms;
  
  // 重置计数器
  _words_scanned = 0;
  _refs_reached  = 0;
  
  // 设置闭包
  G1CMBitMapClosure bitmap_closure(this, _cm);
  G1CMOopClosure cm_oop_closure(_g1h, this);

  // 检查溢出
  if (_cm->has_overflown()) {
    set_has_aborted();
  }

  // 1. 首先处理SATB缓冲区
  drain_satb_buffers();
  
  // 2. 部分排空本地队列和全局栈
  drain_local_queue(true);
  drain_global_stack(true);

  // 3. 主循环：扫描Region
  do {
    if (!has_aborted() && _curr_region != NULL) {
      // 更新Region边界
      update_region_limit();
      MemRegion mr = MemRegion(_finger, _region_limit);

      if (mr.is_empty()) {
        giveup_current_region();
      } else if (_curr_region->is_humongous()) {
        // Humongous对象特殊处理
        if (_next_mark_bitmap->is_marked(mr.start())) {
          bitmap_closure.do_addr(mr.start());
        }
        giveup_current_region();
      } else {
        // 遍历位图，处理标记的对象
        _next_mark_bitmap->iterate(&bitmap_closure, mr);
      }
    }

    // 部分排空队列
    drain_local_queue(true);
    drain_global_stack(true);

    // 尝试领取新Region
    while (!has_aborted() && _curr_region == NULL && !_cm->out_of_regions()) {
      HeapRegion* claimed_region = _cm->claim_region(_worker_id);
      if (claimed_region != NULL) {
        setup_for_region(claimed_region);
      }
      regular_clock_call();  // 检查是否需要让出CPU
    }
  } while (_curr_region != NULL && !has_aborted());

  // 4. 完全排空队列
  drain_local_queue(false);
  drain_global_stack(false);

  // 5. 工作窃取
  if (do_stealing && !has_aborted()) {
    while (!has_aborted()) {
      G1TaskQueueEntry entry;
      if (_cm->try_stealing(_worker_id, &_hash_seed, entry)) {
        scan_task_entry(entry);
        drain_local_queue(false);
        drain_global_stack(false);
      } else {
        // 进入终止协议
        break;
      }
    }
  }
}
```

### 11.4.2 任务队列与工作窃取

```
工作窃取机制
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

每个标记线程有自己的任务队列（LIFO）：
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│  Task 0                Task 1                Task 2                Task 3   │
│  ┌──────────┐         ┌──────────┐         ┌──────────┐         ┌──────────┐│
│  │ Queue 0  │         │ Queue 1  │         │ Queue 2  │         │ Queue 3  ││
│  ├──────────┤         ├──────────┤         ├──────────┤         ├──────────┤│
│  │ obj_a    │         │ obj_d    │         │ (empty)  │         │ obj_g    ││
│  │ obj_b    │         │ obj_e    │         │          │         │ obj_h    ││
│  │ obj_c    │         │ obj_f    │         │          │         │          ││
│  └──────────┘         └──────────┘         └──────────┘         └──────────┘│
│       │                    │                    ▲                    │      │
│       │                    │                    │                    │      │
│       │                    └────────────────────┘                    │      │
│       │                         工作窃取                              │      │
│       └──────────────────────────────────────────────────────────────┘      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

工作窃取规则：
1. 本地操作：push/pop从队列尾部（LIFO，缓存友好）
2. 窃取操作：从其他队列头部窃取（FIFO，减少冲突）
3. 窃取时机：本地队列为空且全局栈为空

try_stealing实现：
┌─────────────────────────────────────────────────────────────────────────┐
│ bool try_stealing(uint worker_id, int* hash_seed, G1TaskQueueEntry& e) {│
│   // 随机选择一个受害者队列                                              │
│   uint victim = random_victim(hash_seed);                               │
│   if (victim != worker_id) {                                            │
│     return _task_queues->steal(victim, hash_seed, e);                   │
│   }                                                                     │
│   return false;                                                         │
│ }                                                                       │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 11.5 全局标记栈

### 11.5.1 G1CMMarkStack结构

源码位置：`src/hotspot/share/gc/g1/g1ConcurrentMark.hpp:141-226`

```cpp
class G1CMMarkStack {
public:
  // 每个Chunk可容纳的条目数
  static const size_t EntriesPerChunk = 1024 - 1;  // 留1个给next指针

private:
  struct TaskQueueEntryChunk {
    TaskQueueEntryChunk* next;
    G1TaskQueueEntry data[EntriesPerChunk];  // 1023个条目
  };

  size_t _max_chunk_capacity;      // 最大Chunk数量
  TaskQueueEntryChunk* _base;      // Chunk数组基地址
  size_t _chunk_capacity;          // 当前Chunk容量

  TaskQueueEntryChunk* volatile _free_list;   // 空闲Chunk链表
  TaskQueueEntryChunk* volatile _chunk_list;  // 使用中的Chunk链表
  volatile size_t _chunks_in_chunk_list;      // 使用中的Chunk数量
  volatile size_t _hwm;                       // 高水位标记

public:
  // 并行push一个Chunk
  bool par_push_chunk(G1TaskQueueEntry* ptr_arr);
  
  // 并行pop一个Chunk
  bool par_pop_chunk(G1TaskQueueEntry* ptr_arr);
  
  // 扩展栈容量
  void expand();
};
```

### 11.5.2 全局栈操作

源码位置：`src/hotspot/share/gc/g1/g1ConcurrentMark.cpp:220-251`

```cpp
bool G1CMMarkStack::par_push_chunk(G1TaskQueueEntry* ptr_arr) {
  // 1. 尝试从空闲链表获取Chunk
  TaskQueueEntryChunk* new_chunk = remove_chunk_from_free_list();

  if (new_chunk == NULL) {
    // 2. 空闲链表为空，从后备内存分配
    new_chunk = allocate_new_chunk();
    if (new_chunk == NULL) {
      return false;  // 分配失败，触发溢出
    }
  }

  // 3. 复制数据到Chunk
  Copy::conjoint_memory_atomic(ptr_arr, new_chunk->data, 
                               EntriesPerChunk * sizeof(G1TaskQueueEntry));

  // 4. 加入使用中链表
  add_chunk_to_chunk_list(new_chunk);
  return true;
}

bool G1CMMarkStack::par_pop_chunk(G1TaskQueueEntry* ptr_arr) {
  // 1. 从使用中链表取出Chunk
  TaskQueueEntryChunk* cur = remove_chunk_from_chunk_list();
  if (cur == NULL) {
    return false;
  }

  // 2. 复制数据
  Copy::conjoint_memory_atomic(cur->data, ptr_arr, 
                               EntriesPerChunk * sizeof(G1TaskQueueEntry));

  // 3. 归还到空闲链表
  add_chunk_to_free_list(cur);
  return true;
}
```

### 11.5.3 溢出处理

```
标记栈溢出处理
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

溢出检测：
┌─────────────────────────────────────────────────────────────────────────┐
│ bool mark_stack_push(G1TaskQueueEntry* arr) {                           │
│   if (!_global_mark_stack.par_push_chunk(arr)) {                        │
│     set_has_overflown();  // 设置溢出标志                                │
│     return false;                                                       │
│   }                                                                     │
│   return true;                                                          │
│ }                                                                       │
└─────────────────────────────────────────────────────────────────────────┘

溢出处理流程：
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│  1. 检测到溢出                                                              │
│     │                                                                       │
│     ▼                                                                       │
│  2. 所有任务进入第一个同步屏障                                               │
│     │  enter_first_sync_barrier()                                           │
│     │  - 停止操作全局数据结构                                                │
│     │  - 等待所有任务到达                                                    │
│     ▼                                                                       │
│  3. Task 0 重新初始化全局数据结构                                            │
│     │  - 扩展标记栈容量                                                      │
│     │  - 重置finger到堆起始位置                                              │
│     ▼                                                                       │
│  4. 所有任务进入第二个同步屏障                                               │
│     │  enter_second_sync_barrier()                                          │
│     │  - 确认新数据结构初始化完成                                            │
│     ▼                                                                       │
│  5. 重新开始标记                                                            │
│     - 从头遍历位图                                                          │
│     - 已标记的对象不会重复处理                                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

源码：src/hotspot/share/gc/g1/g1ConcurrentMark.cpp:827-849
```

---

## 11.6 根Region扫描

### 11.6.1 根Region定义

根Region是Initial Mark后的Survivor Region，它们包含从Young区存活下来的对象，可能引用Old区对象。

源码位置：`src/hotspot/share/gc/g1/g1ConcurrentMark.cpp:260-335`

```cpp
class G1CMRootRegions {
  const G1SurvivorRegions* _survivors;  // Survivor Region列表
  G1ConcurrentMark* _cm;
  volatile bool _scan_in_progress;
  volatile bool _should_abort;
  volatile int _claimed_survivor_index;  // 已领取的索引

public:
  // 准备扫描
  void prepare_for_scan() {
    _claimed_survivor_index = 0;
    _scan_in_progress = _survivors->regions()->is_nonempty();
    _should_abort = false;
  }

  // 领取下一个根Region
  HeapRegion* claim_next() {
    if (_should_abort) return NULL;
    
    const GrowableArray<HeapRegion*>* survivor_regions = _survivors->regions();
    int claimed_index = Atomic::add(1, &_claimed_survivor_index) - 1;
    
    if (claimed_index < survivor_regions->length()) {
      return survivor_regions->at(claimed_index);
    }
    return NULL;
  }
};
```

### 11.6.2 根Region扫描实现

源码位置：`src/hotspot/share/gc/g1/g1ConcurrentMark.cpp:912-946`

```cpp
void G1ConcurrentMark::scan_root_region(HeapRegion* hr, uint worker_id) {
  // Survivor Region的nTAMS == bottom
  assert(hr->next_top_at_mark_start() == hr->bottom(), "invariant");
  
  G1RootRegionScanClosure cl(_g1h, this, worker_id);

  const uintx interval = PrefetchScanIntervalInBytes;
  HeapWord* curr = hr->bottom();
  const HeapWord* end = hr->top();
  
  // 遍历Region中的所有对象
  while (curr < end) {
    Prefetch::read(curr, interval);  // 预取优化
    oop obj = oop(curr);
    int size = obj->oop_iterate_size(&cl);  // 扫描对象的引用
    curr += size;
  }
}

// 并行扫描任务
class G1CMRootRegionScanTask : public AbstractGangTask {
  void work(uint worker_id) {
    G1CMRootRegions* root_regions = _cm->root_regions();
    HeapRegion* hr = root_regions->claim_next();
    while (hr != NULL) {
      _cm->scan_root_region(hr, worker_id);
      hr = root_regions->claim_next();
    }
  }
};
```

### 11.6.3 根Region扫描时序

```
根Region扫描
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Initial Mark (STW)
      │
      │ Young GC完成，产生Survivor Region
      │
      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ Survivor Regions (根Region)                                                 │
│ ┌──────────┐ ┌──────────┐ ┌──────────┐                                     │
│ │ Surv #0  │ │ Surv #1  │ │ Surv #2  │                                     │
│ │ [A,B,C]  │ │ [D,E]    │ │ [F,G,H]  │                                     │
│ └──────────┘ └──────────┘ └──────────┘                                     │
│      │            │            │                                            │
│      │ 可能引用Old区对象                                                    │
│      ▼            ▼            ▼                                            │
│ ┌──────────┐ ┌──────────┐ ┌──────────┐                                     │
│ │ Old #10  │ │ Old #20  │ │ Old #30  │                                     │
│ │ [X,Y]    │ │ [Z]      │ │ [W]      │                                     │
│ └──────────┘ └──────────┘ └──────────┘                                     │
└─────────────────────────────────────────────────────────────────────────────┘
      │
      │ 并发扫描，标记被引用的Old区对象
      │
      ▼
Concurrent Mark继续...

关键约束：
- 根Region扫描必须在下次Young GC之前完成
- 否则Survivor可能被移动，导致标记错误
```

---

## 11.7 SATB队列处理

### 11.7.1 drain_satb_buffers

```cpp
void G1CMTask::drain_satb_buffers() {
  // 设置标志，表示正在处理SATB缓冲区
  _draining_satb_buffers = true;

  G1CMSATBBufferClosure satb_cl(this, _g1h);
  SATBMarkQueueSet& satb_mq_set = G1BarrierSet::satb_mark_queue_set();

  // 处理已完成的SATB缓冲区
  while (!has_aborted() && satb_mq_set.apply_closure_to_completed_buffer(&satb_cl)) {
    regular_clock_call();  // 检查时间/让出CPU
  }

  _draining_satb_buffers = false;
}
```

### 11.7.2 SATB处理流程

```
SATB缓冲区处理
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

应用线程执行写操作：
┌─────────────────────────────────────────────────────────────────────────┐
│ // Pre-write barrier                                                    │
│ old_value = obj.field;                                                  │
│ if (satb_active && old_value != null) {                                 │
│   thread_local_satb_buffer.add(old_value);                              │
│   if (buffer_full) {                                                    │
│     enqueue_to_global_satb_set();                                       │
│   }                                                                     │
│ }                                                                       │
│ obj.field = new_value;                                                  │
└─────────────────────────────────────────────────────────────────────────┘

标记线程处理SATB：
┌─────────────────────────────────────────────────────────────────────────┐
│ 1. 从全局SATB队列集取出缓冲区                                            │
│ 2. 遍历缓冲区中的每个对象引用                                            │
│ 3. 如果对象在堆中且未被标记：                                            │
│    - 在next位图中标记                                                   │
│    - 加入任务队列（后续扫描其引用）                                      │
│ 4. 归还缓冲区到空闲池                                                    │
└─────────────────────────────────────────────────────────────────────────┘

SATB保证：
┌─────────────────────────────────────────────────────────────────────────┐
│ 标记开始时存活的对象 ∪ 标记期间新分配的对象 ⊆ 标记结果                   │
│                                                                         │
│ • 标记开始时存活 → 通过SATB记录保证不丢失                                │
│ • 标记期间新分配 → 分配在TAMS之上，隐式存活                              │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 11.8 Remark阶段

### 11.8.1 Remark的作用

Remark是STW阶段，完成以下工作：
1. 处理剩余的SATB缓冲区
2. 完成标记（排空所有队列）
3. 处理引用（软/弱/虚引用）

### 11.8.2 Remark实现

```cpp
void G1ConcurrentMark::remark() {
  // 1. 设置为非并发模式
  set_concurrency_and_phase(active_workers, false /* concurrent */);

  // 2. 处理所有线程的SATB缓冲区
  {
    G1CMRemarkTask remark_task(this, active_workers);
    _concurrent_workers->run_task(&remark_task, active_workers);
  }

  // 3. 处理引用
  {
    GCTraceTime(Debug, gc, phases) trace("Reference Processing", _gc_timer_cm);
    weak_refs_work(false /* clear_all_soft_refs */);
  }

  // 4. 卸载不再使用的类
  if (ClassUnloadingWithConcurrentMark) {
    // 清理类加载器数据
    ClassLoaderDataGraph::purge();
  }

  // 5. 完成标记
  finalize_marking();
}
```

---

## 11.9 Cleanup阶段

### 11.9.1 Cleanup的作用

```
Cleanup阶段任务
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

STW部分：
┌─────────────────────────────────────────────────────────────────────────┐
│ 1. 统计每个Region的存活字节数                                            │
│ 2. 识别完全空闲的Region（存活字节 = 0）                                  │
│ 3. 按收益排序Old Region（为Mixed GC准备）                                │
│ 4. 交换prev和next位图指针                                               │
│ 5. 更新IHOP（启动堆占用率阈值）                                          │
└─────────────────────────────────────────────────────────────────────────┘

并发部分：
┌─────────────────────────────────────────────────────────────────────────┐
│ 1. 回收完全空闲的Region（直接归还给空闲列表）                            │
│ 2. 清理next位图（为下次标记准备）                                        │
└─────────────────────────────────────────────────────────────────────────┘
```

### 11.9.2 Region收益计算

```cpp
// 计算Region的GC收益
double G1CollectionSetChooser::calculate_gc_efficiency(HeapRegion* hr) {
  size_t live_bytes = hr->live_bytes();  // 存活字节
  size_t region_size = HeapRegion::GrainBytes;  // 4MB
  size_t garbage_bytes = region_size - live_bytes;  // 垃圾字节
  
  // 回收成本（与RSet大小相关）
  double reclaim_cost = predict_reclaim_time_ms(hr);
  
  // 收益 = 可回收空间 / 回收成本
  return (double)garbage_bytes / reclaim_cost;
}
```

### 11.9.3 Region排序

```
Old Region按收益排序
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Cleanup后的Old Region列表（按gc_efficiency降序）：
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐          │
│  │Region#42 │ │Region#108│ │Region#77 │ │Region#201│ │Region#156│ ...      │
│  │存活: 5%  │ │存活: 10% │ │存活: 25% │ │存活: 40% │ │存活: 60% │          │
│  │效率: 高  │ │效率: 高  │ │效率: 中  │ │效率: 中  │ │效率: 低  │          │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘          │
│       ▲                                                                     │
│       │                                                                     │
│       └── Mixed GC优先选择这些Region                                        │
│                                                                             │
│  过滤条件：                                                                 │
│  • 存活率 < G1MixedGCLiveThresholdPercent (85%)                            │
│  • 完全空闲的Region直接回收，不进入此列表                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 11.10 位图清理

### 11.10.1 并发清理位图

源码位置：`src/hotspot/share/gc/g1/g1ConcurrentMark.cpp:642-719`

```cpp
class G1ClearBitMapTask : public AbstractGangTask {
public:
  static size_t chunk_size() { return M; }  // 1MB块

private:
  class G1ClearBitmapHRClosure : public HeapRegionClosure {
    G1CMBitMap* _bitmap;
    G1ConcurrentMark* _cm;
    
  public:
    virtual bool do_heap_region(HeapRegion* r) {
      size_t const chunk_size_in_words = G1ClearBitMapTask::chunk_size() / HeapWordSize;

      HeapWord* cur = r->bottom();
      const HeapWord* end = r->end();

      while (cur < end) {
        MemRegion mr(cur, MIN2(cur + chunk_size_in_words, end));
        _bitmap->clear_range(mr);  // 清除一块
        cur += chunk_size_in_words;

        // 检查是否需要让出CPU
        if (_cm != NULL && _cm->do_yield_check() && _cm->has_aborted()) {
          return true;  // 中止
        }
      }
      return false;
    }
  };
};

void G1ConcurrentMark::clear_bitmap(G1CMBitMap* bitmap, WorkGang* workers, bool may_yield) {
  // 计算工作量
  size_t num_bytes_to_clear = (HeapRegion::GrainBytes * _g1h->num_regions()) 
                              / G1CMBitMap::heap_map_factor();
  // 8GB堆: (4MB * 2048) / 64 = 128MB
  
  size_t num_chunks = align_up(num_bytes_to_clear, G1ClearBitMapTask::chunk_size()) 
                      / G1ClearBitMapTask::chunk_size();
  // 128MB / 1MB = 128个块

  uint num_workers = MIN2(num_chunks, workers->active_workers());

  G1ClearBitMapTask cl(bitmap, this, num_workers, may_yield);
  workers->run_task(&cl, num_workers);
}
```

### 11.10.2 清理时间估算

```
位图清理时间（8GB堆）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

参数：
- 位图大小: 128MB
- 块大小: 1MB
- 块数量: 128
- 工作线程: 8

计算：
- 每线程块数: 128 / 8 = 16块
- 内存带宽: ~10GB/s (典型DDR4)
- 清理速度: ~10GB/s
- 理论时间: 128MB / 10GB/s ≈ 12.8ms

实际时间（含调度开销）: 15-30ms
```

---

## 11.11 本章小结

本章详细分析了G1并发标记算法的实现：

| 组件 | 作用 | 关键源码 |
|------|------|----------|
| **G1CMBitMap** | 标记位图（128MB×2） | `g1ConcurrentMarkBitMap.hpp` |
| **G1CMMarkStack** | 全局溢出栈 | `g1ConcurrentMark.hpp:141-226` |
| **G1CMTask** | 标记任务 | `g1ConcurrentMark.cpp:2613+` |
| **G1CMRootRegions** | 根Region管理 | `g1ConcurrentMark.cpp:260-335` |
| **SATB队列** | 写屏障日志 | `satbMarkQueue.hpp` |

**8GB堆的关键数值**：

| 参数 | 值 |
|------|-----|
| 位图大小 | 128MB × 2 = 256MB |
| 每Region位图 | 64KB |
| 全局栈Chunk | 1023条目/Chunk |
| 清理块大小 | 1MB |

**并发标记的正确性保证**：
1. **SATB**：记录被覆盖的引用，保证不漏标
2. **TAMS**：标记开始后分配的对象隐式存活
3. **双缓冲**：prev位图用于GC，next位图用于标记

**下一章预告**：第12章将分析G1的疏散（Evacuation）过程，包括对象复制、转发指针、并行疏散等。
