# 第12章 疏散过程

> **环境声明**：本章所有分析基于本地真实源码，目标平台为 **Linux x86-64**，堆大小 **8GB**，Region大小 **4MB**，共 **2048个Region**。

疏散（Evacuation）是G1 GC的核心操作，负责将Collection Set中的存活对象复制到新的Region。本章深入分析疏散过程的实现细节。

## 12.1 疏散概述

### 12.1.1 疏散的定义

疏散是将存活对象从源Region复制到目标Region的过程：

```
源码位置: src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:214-324
```

```cpp
// 疏散核心函数
oop G1ParScanThreadState::copy_to_survivor_space(InCSetState const state,
                                                 oop const old,
                                                 markOop const old_mark) {
  const size_t word_sz = old->size();
  HeapRegion* const from_region = _g1h->heap_region_containing(old);
  // +1 to make the -1 indexes valid...
  const int young_index = from_region->young_index_in_cset()+1;
  
  uint age = 0;
  InCSetState dest_state = next_state(state, old_mark, age);
  
  // 分配目标空间
  HeapWord* obj_ptr = _plab_allocator->plab_allocate(dest_state, word_sz);
  // ...
}
```

### 12.1.2 疏散触发场景

| 场景 | 描述 | 源Region类型 |
|------|------|--------------|
| Young GC | 疏散所有Eden和Survivor | Young |
| Mixed GC | 疏散Young + 部分Old | Young + Old |
| Full GC | 压缩整个堆 | All |

### 12.1.3 疏散目标

```
源码位置: src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:75-79
```

```cpp
// 目标Region类型映射
_dest[InCSetState::NotInCSet]    = InCSetState::NotInCSet;
// Young对象晋升到Old
_dest[InCSetState::Young]        = InCSetState::Old;
_dest[InCSetState::Old]          = InCSetState::Old;
```

## 12.2 G1ParScanThreadState

### 12.2.1 线程状态结构

```
源码位置: src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:40-82
```

```cpp
G1ParScanThreadState::G1ParScanThreadState(G1CollectedHeap* g1h, 
                                           uint worker_id, 
                                           size_t young_cset_length)
  : _g1h(g1h),
    _refs(g1h->task_queue(worker_id)),      // 任务队列
    _dcq(&g1h->dirty_card_queue_set()),     // 脏卡队列
    _ct(g1h->card_table()),                 // 卡表
    _plab_allocator(NULL),                  // PLAB分配器
    _age_table(false),                      // 年龄表
    _tenuring_threshold(g1h->g1_policy()->tenuring_threshold()),  // 晋升阈值
    _scanner(g1h, this),                    // 对象扫描器
    _worker_id(worker_id),
    _stack_trim_upper_threshold(GCDrainStackTargetSize * 2 + 1),
    _stack_trim_lower_threshold(GCDrainStackTargetSize),
    _old_gen_is_full(false)
{
  // 分配存活字节统计数组
  size_t real_length = 1 + young_cset_length;
  size_t array_length = PADDING_ELEM_NUM + real_length + PADDING_ELEM_NUM;
  _surviving_young_words_base = NEW_C_HEAP_ARRAY(size_t, array_length, mtGC);
  _surviving_young_words = _surviving_young_words_base + PADDING_ELEM_NUM;
  memset(_surviving_young_words, 0, real_length * sizeof(size_t));

  // 创建PLAB分配器
  _plab_allocator = new G1PLABAllocator(_g1h->allocator());
  
  // 创建根闭包
  _closures = G1EvacuationRootClosures::create_root_closures(this, _g1h);
}
```

### 12.2.2 关键字段说明

```
8GB堆配置下的G1ParScanThreadState:

┌─────────────────────────────────────────────────────────────┐
│                   G1ParScanThreadState                       │
├─────────────────────────────────────────────────────────────┤
│ _refs: RefToScanQueue*           任务队列（引用扫描）        │
│ _dcq: DirtyCardQueue            脏卡队列                     │
│ _ct: G1CardTable*               卡表指针                     │
│ _plab_allocator: G1PLABAllocator*  PLAB分配器               │
│ _age_table: AgeTable            年龄表（15个桶）            │
│ _tenuring_threshold: uint       晋升阈值（默认15）          │
│ _scanner: G1ScanEvacuatedObjClosure  对象扫描闭包           │
│ _worker_id: uint                工作线程ID                   │
│ _surviving_young_words: size_t* 存活字节统计                │
│ _old_gen_is_full: bool          老年代是否已满              │
└─────────────────────────────────────────────────────────────┘
```

## 12.3 PLAB分配器

### 12.3.1 PLAB结构

```
源码位置: src/hotspot/share/gc/shared/plab.hpp:36-143
```

```cpp
// Promotion Local Allocation Buffer
class PLAB: public CHeapObj<mtGC> {
protected:
  char      head[32];
  size_t    _word_sz;          // 缓冲区大小（HeapWord单位）
  HeapWord* _bottom;           // 缓冲区起始
  HeapWord* _top;              // 当前分配位置
  HeapWord* _end;              // 最后可分配地址+1
  HeapWord* _hard_end;         // _end + AlignmentReserve
  size_t    _allocated;        // 已分配（HeapWord单位）
  size_t    _wasted;           // 浪费空间
  size_t    _undo_wasted;      // 撤销浪费
  char      tail[32];
  static size_t AlignmentReserve;
  
  // 快速分配
  HeapWord* allocate(size_t word_sz) {
    HeapWord* res = _top;
    if (pointer_delta(_end, _top) >= word_sz) {
      _top = _top + word_sz;
      return res;
    } else {
      return NULL;
    }
  }
};
```

### 12.3.2 PLAB内存布局

```
PLAB结构（默认4KB）:

     _bottom                    _top                 _end    _hard_end
        │                         │                    │          │
        ▼                         ▼                    ▼          ▼
        ┌─────────────────────────┬────────────────────┬──────────┐
        │    已分配对象区域        │    可分配空间       │ Reserve  │
        │  (Allocated Objects)    │   (Free Space)     │          │
        └─────────────────────────┴────────────────────┴──────────┘
        │◄──────── _word_sz ─────────────────────────────────────►│

分配过程:
1. 检查 (_end - _top) >= word_sz
2. 若满足: res = _top; _top += word_sz; return res
3. 若不满足: return NULL，需要重新填充PLAB
```

### 12.3.3 G1PLABAllocator

```
源码位置: src/hotspot/share/gc/g1/g1Allocator.hpp:127-150
```

```cpp
class G1PLABAllocator : public CHeapObj<mtGC> {
  friend class G1ParScanThreadState;
private:
  G1CollectedHeap* _g1h;
  G1Allocator* _allocator;

  PLAB  _surviving_alloc_buffer;   // Survivor分配缓冲
  PLAB  _tenured_alloc_buffer;     // Old分配缓冲
  PLAB* _alloc_buffers[InCSetState::Num];  // 缓冲区数组

  const uint _survivor_alignment_bytes;    // Survivor对齐字节

  size_t _direct_allocated[InCSetState::Num];  // 直接分配统计
};
```

### 12.3.4 PLAB分配流程

```
源码位置: src/hotspot/share/gc/g1/g1Allocator.inline.hpp:73-91
```

```cpp
inline HeapWord* G1PLABAllocator::plab_allocate(InCSetState dest,
                                                size_t word_sz) {
  PLAB* buffer = alloc_buffer(dest);
  if (_survivor_alignment_bytes == 0 || !dest.is_young()) {
    return buffer->allocate(word_sz);  // 普通分配
  } else {
    return buffer->allocate_aligned(word_sz, _survivor_alignment_bytes);  // 对齐分配
  }
}

inline HeapWord* G1PLABAllocator::allocate(InCSetState dest,
                                           size_t word_sz,
                                           bool* refill_failed) {
  HeapWord* const obj = plab_allocate(dest, word_sz);
  if (obj != NULL) {
    return obj;
  }
  // PLAB分配失败，尝试直接分配或重新填充PLAB
  return allocate_direct_or_new_plab(dest, word_sz, refill_failed);
}
```

## 12.4 对象复制核心流程

### 12.4.1 copy_to_survivor_space详解

```
源码位置: src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:214-324
```

完整流程：

```cpp
oop G1ParScanThreadState::copy_to_survivor_space(InCSetState const state,
                                                 oop const old,
                                                 markOop const old_mark) {
  // 步骤1: 获取对象大小
  const size_t word_sz = old->size();
  HeapRegion* const from_region = _g1h->heap_region_containing(old);
  const int young_index = from_region->young_index_in_cset()+1;

  // 步骤2: 确定目标状态和年龄
  uint age = 0;
  InCSetState dest_state = next_state(state, old_mark, age);
  
  // 步骤3: 检查老年代是否已满
  if (_old_gen_is_full && dest_state.is_old()) {
    return handle_evacuation_failure_par(old, old_mark);
  }
  
  // 步骤4: 尝试PLAB分配
  HeapWord* obj_ptr = _plab_allocator->plab_allocate(dest_state, word_sz);

  // 步骤5: PLAB分配失败，尝试其他方式
  if (obj_ptr == NULL) {
    bool plab_refill_failed = false;
    obj_ptr = _plab_allocator->allocate_direct_or_new_plab(dest_state, word_sz, 
                                                            &plab_refill_failed);
    if (obj_ptr == NULL) {
      obj_ptr = allocate_in_next_plab(state, &dest_state, word_sz, plab_refill_failed);
      if (obj_ptr == NULL) {
        // 疏散失败
        return handle_evacuation_failure_par(old, old_mark);
      }
    }
  }

  // 步骤6: 预取目标内存
  Prefetch::write(obj_ptr, PrefetchCopyIntervalInBytes);

  // 步骤7: 原子安装转发指针
  const oop obj = oop(obj_ptr);
  const oop forward_ptr = old->forward_to_atomic(obj, memory_order_relaxed);
  
  if (forward_ptr == NULL) {
    // 步骤8: 成功获得复制权，执行复制
    Copy::aligned_disjoint_words((HeapWord*) old, obj_ptr, word_sz);

    // 步骤9: 处理年龄
    if (dest_state.is_young()) {
      if (age < markOopDesc::max_age) {
        age++;
      }
      if (old_mark->has_displaced_mark_helper()) {
        obj->set_mark_raw(old_mark);
        markOop new_mark = old_mark->displaced_mark_helper()->set_age(age);
        old_mark->set_displaced_mark_helper(new_mark);
      } else {
        obj->set_mark_raw(old_mark->set_age(age));
      }
      _age_table.add(age, word_sz);
    } else {
      obj->set_mark_raw(old_mark);
    }

    // 步骤10: 字符串去重
    if (G1StringDedup::is_enabled()) {
      G1StringDedup::enqueue_from_evacuation(...);
    }

    // 步骤11: 统计存活字节
    _surviving_young_words[young_index] += word_sz;

    // 步骤12: 处理大数组分块
    if (obj->is_objArray() && arrayOop(obj)->length() >= ParGCArrayScanChunk) {
      arrayOop(obj)->set_length(0);
      oop* old_p = set_partial_array_mask(old);
      do_oop_partial_array(old_p);
    } else {
      // 步骤13: 扫描对象引用
      HeapRegion* const to_region = _g1h->heap_region_containing(obj_ptr);
      _scanner.set_region(to_region);
      obj->oop_iterate_backwards(&_scanner);
    }
    return obj;
  } else {
    // 步骤14: 其他线程已复制，撤销分配
    _plab_allocator->undo_allocation(dest_state, obj_ptr, word_sz);
    return forward_ptr;
  }
}
```

### 12.4.2 流程图

```
copy_to_survivor_space 流程:

                    ┌─────────────────────┐
                    │   获取对象大小       │
                    │   word_sz = old->size()
                    └──────────┬──────────┘
                               │
                    ┌──────────▼──────────┐
                    │   确定目标状态       │
                    │   next_state()       │
                    └──────────┬──────────┘
                               │
                    ┌──────────▼──────────┐
                    │   老年代是否已满？   │
                    └──────────┬──────────┘
                         │Yes  │No
          ┌──────────────┘     │
          ▼                    ▼
    ┌─────────────┐   ┌─────────────────┐
    │ 疏散失败处理 │   │  PLAB分配空间    │
    └─────────────┘   └────────┬────────┘
                               │
                         ┌─────▼─────┐
                         │ 分配成功？ │
                         └─────┬─────┘
                         │No   │Yes
          ┌──────────────┘     │
          ▼                    ▼
    ┌─────────────┐   ┌─────────────────┐
    │尝试其他分配  │   │ forward_to_atomic│
    │方式         │   │  原子安装转发指针 │
    └──────┬──────┘   └────────┬────────┘
           │                   │
           │              ┌────▼────┐
           │              │返回NULL?│
           │              └────┬────┘
           │              │No  │Yes
           │    ┌─────────┘    │
           │    ▼              ▼
           │ ┌────────┐  ┌────────────┐
           │ │撤销分配│  │ 复制对象    │
           │ │返回转发│  │ 设置年龄    │
           │ └────────┘  │ 扫描引用    │
           │             └────────────┘
           ▼
    ┌─────────────┐
    │ 疏散失败处理 │
    └─────────────┘
```

## 12.5 转发指针机制

### 12.5.1 forward_to_atomic

```
源码位置: src/hotspot/share/oops/oop.inline.hpp:373-393
```

```cpp
oop oopDesc::forward_to_atomic(oop p, atomic_memory_order order) {
  markOop oldMark = mark_raw();
  markOop forwardPtrMark = markOopDesc::encode_pointer_as_mark(p);
  markOop curMark;

  assert(forwardPtrMark->decode_pointer() == p, "encoding must be reversable");
  assert(sizeof(markOop) == sizeof(intptr_t), "CAS below requires this.");

  // CAS循环安装转发指针
  while (!oldMark->is_marked()) {
    curMark = cas_set_mark_raw(forwardPtrMark, oldMark, order);
    assert(is_forwarded(), "object should have been forwarded");
    if (curMark == oldMark) {
      return NULL;  // 成功安装，返回NULL表示"我是赢家"
    }
    oldMark = curMark;
  }
  return forwardee();  // 其他线程已安装，返回转发目标
}
```

### 12.5.2 转发指针编码

```
Mark Word转发指针编码:

原始Mark Word（64位）:
┌────────────────────────────────────────────────────────────────┐
│ unused:25 │ hash:31 │ unused:1 │ age:4 │ biased:1 │ lock:2    │
└────────────────────────────────────────────────────────────────┘

转发后Mark Word:
┌────────────────────────────────────────────────────────────────┐
│              forwarding pointer (62 bits)              │ 11   │
└────────────────────────────────────────────────────────────────┘
                                                          ▲
                                                          │
                                                    marked bits

is_marked() 检查: (mark & 0x3) == 0x3
decode_pointer(): mark & ~0x3
```

### 12.5.3 竞争场景

```
多线程竞争复制同一对象:

Thread 1                          Thread 2
────────                          ────────
read old->mark                    read old->mark
  ↓                                 ↓
allocate space (obj1)             allocate space (obj2)
  ↓                                 ↓
forward_to_atomic(obj1)           forward_to_atomic(obj2)
  ↓                                 ↓
CAS成功，返回NULL                 CAS失败，返回obj1
  ↓                                 ↓
复制对象到obj1                    撤销obj2分配
  ↓                                 ↓
扫描obj1引用                      使用obj1（已复制的对象）
```

## 12.6 年龄计算与晋升

### 12.6.1 next_state计算

```
源码位置: src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:189-198
```

```cpp
InCSetState G1ParScanThreadState::next_state(InCSetState const state, 
                                              markOop const m, 
                                              uint& age) {
  if (state.is_young()) {
    // 从Mark Word获取年龄
    age = !m->has_displaced_mark_helper() ? m->age()
                                          : m->displaced_mark_helper()->age();
    // 年龄小于阈值，保持Young
    if (age < _tenuring_threshold) {
      return state;
    }
  }
  // 年龄达到阈值或来自Old，目标是Old
  return dest(state);
}
```

### 12.6.2 年龄表更新

```cpp
// 复制成功后更新年龄表
if (dest_state.is_young()) {
  if (age < markOopDesc::max_age) {
    age++;  // 年龄+1
  }
  // 设置新年龄到Mark Word
  obj->set_mark_raw(old_mark->set_age(age));
  // 更新年龄表
  _age_table.add(age, word_sz);
}
```

### 12.6.3 晋升阈值计算

```
年龄表结构（15个桶）:

Age:  0    1    2    3    4    5   ...  14   15
     ┌────┬────┬────┬────┬────┬────┬───┬────┬────┐
Size:│100K│200K│150K│ 80K│ 50K│ 30K│...│ 5K │ 2K │
     └────┴────┴────┴────┴────┴────┴───┴────┴────┘

晋升阈值计算:
- 累加各年龄存活大小
- 当累计超过Survivor空间的TargetSurvivorRatio(50%)时
- 该年龄即为新的晋升阈值
```

## 12.7 大数组分块处理

### 12.7.1 分块机制

```
源码位置: src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:307-318
```

```cpp
// 大数组分块处理（ParGCArrayScanChunk = 50）
if (obj->is_objArray() && arrayOop(obj)->length() >= ParGCArrayScanChunk) {
  // 使用length字段记录下一个扫描起始索引
  arrayOop(obj)->set_length(0);
  // 设置部分数组掩码
  oop* old_p = set_partial_array_mask(old);
  // 处理第一块
  do_oop_partial_array(old_p);
} else {
  // 普通对象，直接扫描所有引用
  obj->oop_iterate_backwards(&_scanner);
}
```

### 12.7.2 do_oop_partial_array

```
源码位置: src/hotspot/share/gc/g1/g1ParScanThreadState.inline.hpp:70-117
```

```cpp
inline void G1ParScanThreadState::do_oop_partial_array(oop* p) {
  assert(has_partial_array_mask(p), "invariant");
  oop from_obj = clear_partial_array_mask(p);

  objArrayOop from_obj_array = objArrayOop(from_obj);
  int length = from_obj_array->length();  // 原始长度

  oop to_obj = from_obj->forwardee();
  objArrayOop to_obj_array = objArrayOop(to_obj);
  int next_index = to_obj_array->length();  // 下一个起始索引

  int start = next_index;
  int end = length;
  int remainder = end - start;
  
  // 如果剩余超过2倍chunk，继续分块
  if (remainder > 2 * ParGCArrayScanChunk) {
    end = start + ParGCArrayScanChunk;
    to_obj_array->set_length(end);
    // 将剩余部分推入队列
    oop* from_obj_p = set_partial_array_mask(from_obj);
    push_on_queue(from_obj_p);
  } else {
    // 最后一块，恢复正确长度
    to_obj_array->set_length(end);
  }
  
  // 扫描[start, end)范围
  to_obj_array->oop_iterate_range(&_scanner, start, end);
}
```

### 12.7.3 分块示意图

```
大数组分块处理（长度200，chunk=50）:

原始数组（from-space）:
┌────────────────────────────────────────────────────────────────┐
│  0   │  1   │ ... │  49  │  50  │ ... │  99  │ 100 │ ... │ 199 │
└────────────────────────────────────────────────────────────────┘
       │◄─── chunk 0 ───►│◄─── chunk 1 ───►│◄─── chunk 2 ───►│...

处理流程:
1. 复制数组头到to-space
2. to_obj.length = 0（记录进度）
3. 处理chunk 0 [0-49]
4. to_obj.length = 50
5. 推入队列（剩余150 > 2*50）
6. 其他线程窃取，处理chunk 1 [50-99]
7. to_obj.length = 100
8. 推入队列（剩余100 > 2*50）
9. 处理chunk 2 [100-149]
10. to_obj.length = 150
11. 推入队列（剩余50 <= 2*50，不再分块）
12. 处理最后块[150-199]
13. to_obj.length = 200（恢复正确长度）
```

## 12.8 疏散失败处理

### 12.8.1 handle_evacuation_failure_par

```
源码位置: src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:356-385
```

```cpp
oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markOop m) {
  assert(_g1h->is_in_cset(old), "Object should be in the CSet");

  // 尝试自转发（forward to self）
  oop forward_ptr = old->forward_to_atomic(old, memory_order_relaxed);
  
  if (forward_ptr == NULL) {
    // 成功自转发，我们是"所有者"
    HeapRegion* r = _g1h->heap_region_containing(old);

    // 标记Region疏散失败
    if (!r->evacuation_failed()) {
      r->set_evacuation_failed(true);
      _g1h->hr_printer()->evac_failure(r);
    }

    // 保存原始Mark Word
    _g1h->preserve_mark_during_evac_failure(_worker_id, old, m);

    // 扫描对象引用（对象留在原地）
    _scanner.set_region(r);
    old->oop_iterate_backwards(&_scanner);

    return old;
  } else {
    // 其他线程已处理
    return forward_ptr;
  }
}
```

### 12.8.2 自转发机制

```
自转发（Self-Forwarding）:

正常疏散:
┌─────────────┐    forward    ┌─────────────┐
│ old object  │ ────────────► │ new object  │
│ (from-space)│               │ (to-space)  │
└─────────────┘               └─────────────┘

疏散失败（自转发）:
┌─────────────┐
│ old object  │ ◄────┐
│ (from-space)│      │ forward to self
└─────────────┘ ─────┘

Mark Word变化:
原始: [hash:31 | age:4 | ...]
自转发后: [self_address | 11]  （marked bits = 11）
```

### 12.8.3 RemoveSelfForwardPtrObjClosure

```
源码位置: src/hotspot/share/gc/g1/g1EvacFailure.cpp:72-154
```

```cpp
class RemoveSelfForwardPtrObjClosure: public ObjectClosure {
  G1CollectedHeap* _g1h;
  G1ConcurrentMark* _cm;
  HeapRegion* _hr;
  size_t _marked_bytes;
  UpdateRSetDeferred* _update_rset_cl;
  bool _during_initial_mark;
  uint _worker_id;
  HeapWord* _last_forwarded_object_end;

public:
  void do_object(oop obj) {
    HeapWord* obj_addr = (HeapWord*) obj;

    if (obj->is_forwarded() && obj->forwardee() == obj) {
      // 对象自转发，需要恢复

      // 填充死亡区域
      zap_dead_objects(_last_forwarded_object_end, obj_addr);
      
      // 在prev位图中标记存活
      if (!_cm->is_marked_in_prev_bitmap(obj)) {
        _cm->mark_in_prev_bitmap(obj);
      }
      
      // 初始标记期间也标记next位图
      if (_during_initial_mark) {
        _cm->mark_in_next_bitmap(_worker_id, obj);
      }
      
      size_t obj_size = obj->size();
      _marked_bytes += (obj_size * HeapWordSize);
      
      // 恢复原始Mark Word
      PreservedMarks::init_forwarded_mark(obj);

      // 更新RSet
      obj->oop_iterate(_update_rset_cl);

      HeapWord* obj_end = obj_addr + obj_size;
      _last_forwarded_object_end = obj_end;
      _hr->cross_threshold(obj_addr, obj_end);
    }
  }
};
```

### 12.8.4 疏散失败后处理流程

```
疏散失败恢复流程:

1. 遍历CSet中疏散失败的Region
   │
   ▼
2. 对每个Region:
   ├─ 重置BOT
   ├─ 遍历所有对象
   │   ├─ 自转发对象:
   │   │   ├─ 在prev位图标记存活
   │   │   ├─ 恢复原始Mark Word
   │   │   ├─ 更新RSet
   │   │   └─ 更新BOT
   │   └─ 正常对象（已疏散）:
   │       └─ 填充为dummy对象
   ├─ 清理RSet
   └─ 更新存活字节统计
   │
   ▼
3. Region保留在堆中（不回收）
```

## 12.9 G1Allocator

### 12.9.1 分配区域类型

```
源码位置: src/hotspot/share/gc/g1/g1Allocator.hpp:38-122
```

```cpp
class G1Allocator : public CHeapObj<mtGC> {
private:
  G1CollectedHeap* _g1h;

  bool _survivor_is_full;
  bool _old_is_full;

  // Mutator分配区域（应用线程分配）
  MutatorAllocRegion _mutator_alloc_region;

  // Survivor GC分配区域
  SurvivorGCAllocRegion _survivor_gc_alloc_region;

  // Old GC分配区域
  OldGCAllocRegion _old_gc_alloc_region;

  // 保留的Old区域（跨GC复用）
  HeapRegion* _retained_old_gc_alloc_region;
};
```

### 12.9.2 分配层次

```
GC期间分配层次:

┌─────────────────────────────────────────────────────────────────┐
│                     G1ParScanThreadState                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                   G1PLABAllocator                        │    │
│  │  ┌─────────────────┐   ┌─────────────────┐              │    │
│  │  │ Survivor PLAB   │   │   Old PLAB      │              │    │
│  │  │ (per-thread)    │   │ (per-thread)    │              │    │
│  │  └────────┬────────┘   └────────┬────────┘              │    │
│  └───────────┼─────────────────────┼────────────────────────┘    │
│              │                     │                             │
│              ▼                     ▼                             │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                      G1Allocator                           │  │
│  │  ┌─────────────────┐   ┌─────────────────┐                │  │
│  │  │SurvivorGCAlloc  │   │ OldGCAllocRegion│                │  │
│  │  │    Region       │   │                 │                │  │
│  │  └────────┬────────┘   └────────┬────────┘                │  │
│  └───────────┼─────────────────────┼─────────────────────────┘  │
│              │                     │                             │
└──────────────┼─────────────────────┼─────────────────────────────┘
               │                     │
               ▼                     ▼
         ┌──────────┐          ┌──────────┐
         │ Survivor │          │   Old    │
         │  Region  │          │  Region  │
         │  (4MB)   │          │  (4MB)   │
         └──────────┘          └──────────┘
```

### 12.9.3 分配尝试顺序

```
对象分配尝试顺序:

1. PLAB快速分配 (plab_allocate)
   │ 成功 → 返回
   │ 失败 ↓
   
2. 直接分配或新PLAB (allocate_direct_or_new_plab)
   │ 成功 → 返回
   │ 失败 ↓
   
3. 尝试其他目标 (allocate_in_next_plab)
   │ Young → 尝试Old
   │ 成功 → 返回
   │ 失败 ↓
   
4. 疏散失败 (handle_evacuation_failure_par)
   │ 自转发对象
   │ 对象留在原Region
```

## 12.10 引用处理与RSet更新

### 12.10.1 do_oop_evac

```
源码位置: src/hotspot/share/gc/g1/g1ParScanThreadState.inline.hpp:33-63
```

```cpp
template <class T> void G1ParScanThreadState::do_oop_evac(T* p) {
  oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);

  const InCSetState in_cset_state = _g1h->in_cset_state(obj);
  
  if (in_cset_state.is_in_cset()) {
    // 对象在CSet中，需要疏散
    markOop m = obj->mark_raw();
    if (m->is_marked()) {
      // 已被复制，获取转发地址
      obj = (oop) m->decode_pointer();
    } else {
      // 未复制，执行复制
      obj = copy_to_survivor_space(in_cset_state, obj, m);
    }
    // 更新引用
    RawAccess<IS_NOT_NULL>::oop_store(p, obj);
  } else if (in_cset_state.is_humongous()) {
    // Humongous对象，标记存活
    _g1h->set_humongous_is_live(obj);
  }

  // 跨Region引用，更新RSet
  if (!HeapRegion::is_in_same_region(p, obj)) {
    HeapRegion* from = _g1h->heap_region_containing(p);
    update_rs(from, p, obj);
  }
}
```

### 12.10.2 RSet更新

```
RSet更新时机:

复制对象后扫描引用:
┌─────────────────────────────────────────────────────────────┐
│ 新复制的对象 (to-space)                                      │
│ ┌─────────┬─────────┬─────────┬─────────┐                   │
│ │ header  │ field1  │ field2  │ field3  │                   │
│ └─────────┴────┬────┴────┬────┴────┬────┘                   │
│                │         │         │                         │
│                ▼         ▼         ▼                         │
│           ┌────────┐ ┌────────┐ ┌────────┐                  │
│           │ obj A  │ │ obj B  │ │ obj C  │                  │
│           │(same R)│ │(diff R)│ │(diff R)│                  │
│           └────────┘ └────────┘ └────────┘                  │
│                          │         │                         │
│                          ▼         ▼                         │
│                     更新B的RSet  更新C的RSet                  │
└─────────────────────────────────────────────────────────────┘

update_rs(from, p, obj):
- 如果p和obj不在同一Region
- 将p所在卡片加入obj所在Region的RSet
```

## 12.11 工作窃取

### 12.11.1 任务队列

```
源码位置: src/hotspot/share/gc/g1/g1ParScanThreadState.cpp:142-148
```

```cpp
void G1ParScanThreadState::trim_queue() {
  StarTask ref;
  do {
    // 完全排空队列
    trim_queue_to_threshold(0);
  } while (!_refs->is_empty());
}
```

### 12.11.2 工作窃取机制

```
工作窃取示意:

Worker 0                Worker 1                Worker 2
┌────────────┐         ┌────────────┐         ┌────────────┐
│ 本地队列    │         │ 本地队列    │         │ 本地队列    │
│ [ref1]     │         │ [ref3]     │         │ [空]       │
│ [ref2]     │         │ [ref4]     │         │            │
│ [...]      │         │ [ref5]     │         │            │
└────────────┘         └────────────┘         └────────────┘
      │                      │                      │
      │                      │                      │
      ▼                      ▼                      │
   处理ref1               处理ref3                  │
   处理ref2               处理ref4                  │
      │                      │                      │
      │                      ▼                      ▼
      │                   处理ref5              窃取Worker0的任务
      │                      │                      │
      ▼                      ▼                      ▼
   队列空                  队列空                 处理窃取的任务

窃取策略:
- 本地队列空时，尝试从其他Worker窃取
- 从队列尾部窃取（LIFO push，FIFO steal）
- 减少竞争，提高缓存局部性
```

## 12.12 性能优化

### 12.12.1 预取优化

```cpp
// 复制前预取目标内存
Prefetch::write(obj_ptr, PrefetchCopyIntervalInBytes);

// 预取间隔（默认576字节）
// 提前将目标缓存行加载到L1/L2缓存
```

### 12.12.2 PLAB大小调优

```
PLAB大小影响:

太小:
- 频繁重新填充
- 更多同步开销
- 内存碎片少

太大:
- 减少重新填充
- 浪费空间（未使用部分）
- 可能跨缓存行

推荐配置（8GB堆）:
-XX:YoungPLABSize=4096      # Young PLAB大小（字）
-XX:OldPLABSize=1024        # Old PLAB大小（字）
-XX:ResizePLAB=true         # 动态调整PLAB大小
```

### 12.12.3 大数组分块大小

```
ParGCArrayScanChunk影响:

太小（如10）:
- 更多队列操作
- 更好的负载均衡
- 更多开销

太大（如200）:
- 较少队列操作
- 负载均衡差
- 减少开销

默认值: 50
- 平衡负载均衡和开销
- 适合大多数场景
```

## 12.13 8GB堆疏散示例

### 12.13.1 Young GC疏散场景

```
配置:
- 堆大小: 8GB
- Region大小: 4MB
- Eden: 400个Region (1.6GB)
- Survivor: 40个Region (160MB)
- 存活率: 10%

疏散过程:
1. Eden存活对象: 1.6GB × 10% = 160MB
2. Survivor存活对象: 160MB × 50% = 80MB
3. 总需疏散: 240MB

4. 目标分配:
   - 年龄 < 15: → Survivor (约200MB)
   - 年龄 >= 15: → Old (约40MB)

5. 需要Survivor Region: 200MB / 4MB = 50个
6. 需要Old Region: 40MB / 4MB = 10个

7. 疏散时间估算:
   - 复制速度: ~500MB/s (per thread)
   - 8线程: ~4GB/s
   - 240MB疏散: ~60ms
```

### 12.13.2 Mixed GC疏散场景

```
配置:
- Young: 440个Region (1.76GB)
- Old CSet: 200个Region (800MB，垃圾率80%）
- 目标停顿: 200ms

疏散计算:
1. Young存活: 1.76GB × 10% = 176MB
2. Old存活: 800MB × 20% = 160MB
3. 总需疏散: 336MB

4. 目标分配:
   - Young → Survivor/Old: 176MB
   - Old → Old: 160MB

5. 疏散时间:
   - 8线程，4GB/s
   - 336MB: ~84ms

6. 加上其他阶段:
   - 根扫描: ~30ms
   - RSet处理: ~50ms
   - 其他: ~36ms
   - 总计: ~200ms ✓
```

## 12.14 本章小结

本章详细分析了G1疏散过程的实现：

1. **G1ParScanThreadState**：每个GC工作线程的状态，包含PLAB分配器、任务队列、年龄表等

2. **PLAB机制**：线程本地分配缓冲，减少同步开销，提高分配效率

3. **copy_to_survivor_space**：疏散核心函数，包含分配、复制、转发指针安装、年龄处理、引用扫描

4. **转发指针**：原子CAS安装，确保对象只被复制一次

5. **大数组分块**：ParGCArrayScanChunk=50，支持工作窃取

6. **疏散失败**：自转发机制，保留对象在原Region

7. **工作窃取**：任务队列支持负载均衡

**关键源码文件**：
- `g1ParScanThreadState.cpp`: 疏散核心实现
- `g1Allocator.hpp/cpp`: 分配器实现
- `plab.hpp`: PLAB结构定义
- `g1EvacFailure.cpp`: 疏散失败处理
- `oop.inline.hpp`: 转发指针操作
