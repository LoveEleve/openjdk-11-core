# 第8章：C2编译器详解

> **环境约定**：Linux x86-64，8GB堆内存（-Xmx8g），非大页模式，OpenJDK 11源码

C2（Server Compiler）是HotSpot的高性能优化编译器，采用**Sea-of-Nodes**中间表示，执行激进的优化策略。本章基于本地源码深入分析C2的核心实现。

---

## 8.1 C2编译器架构

### 8.1.1 核心类：Compile

C2的编译过程由`Compile`类统一管理：

```
源码位置: src/hotspot/share/opto/compile.hpp
```

```cpp
// 第169-178行：Compile类定义
class Compile : public Phase {
  friend class VMStructs;

 public:
  // Fixed alias indexes.  (See also MergeMemNode.)
  enum {
    AliasIdxTop = 1,  // pseudo-index, aliases to nothing (used as sentinel value)
    AliasIdxBot = 2,  // pseudo-index, aliases to everything
    AliasIdxRaw = 3   // hard-wired index for TypeRawPtr::BOTTOM
  };
```

### 8.1.2 编译控制参数

```cpp
// 第362-418行：编译控制参数
private:
  // Fixed parameters to this compilation.
  const int             _compile_id;
  const bool            _save_argument_registers;
  const bool            _subsume_loads;         // Load can be matched as part of a larger op.
  const bool            _do_escape_analysis;    // Do escape analysis.
  const bool            _eliminate_boxing;      // Do boxing elimination.
  const bool            _do_locks_coarsening;   // Do locks coarsening
  ciMethod*             _method;                // The method being compiled.
  int                   _entry_bci;             // entry bci for osr methods.
  
  // Control of this compilation.
  int                   _num_loop_opts;         // Number of iterations for doing loop optimizations
  int                   _max_inline_size;       // Max inline size for this compilation
  int                   _freq_inline_size;      // Max hot method inline size for this compilation
  bool                  _has_loops;             // True if the method _may_ have some loops
  bool                  _has_unsafe_access;     // True if the method _may_ produce faults
  bool                  _has_stringbuilder;     // True StringBuffers or StringBuilders are allocated
  bool                  _has_boxed_value;       // True if a boxed object is allocated
```

### 8.1.3 编译阶段

C2的主要编译阶段：

```cpp
// 第1325-1331行：编译阶段入口
private:
  // Phase control:
  void Init(int aliaslevel);                     // Prepare for a single compilation
  int  Inline_Warm();                            // Find more inlining work.
  void Finish_Warm();                            // Give up on further inlines.
  void Optimize();                               // Given a graph, optimize it
  void Code_Gen();                               // Generate code from a graph
```

**编译流程图**：

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         C2 编译流程                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  字节码                                                                  │
│     │                                                                   │
│     ▼                                                                   │
│  ┌─────────────┐                                                        │
│  │   Parse     │  字节码 → Ideal Graph (Sea-of-Nodes)                   │
│  └─────────────┘                                                        │
│         │                                                               │
│         ▼                                                               │
│  ┌─────────────┐                                                        │
│  │  Optimize   │  GVN, 内联, 逃逸分析, 循环优化...                        │
│  └─────────────┘                                                        │
│         │                                                               │
│         ▼                                                               │
│  ┌─────────────┐                                                        │
│  │   Matcher   │  Ideal Graph → MachNode Graph                          │
│  └─────────────┘                                                        │
│         │                                                               │
│         ▼                                                               │
│  ┌─────────────┐                                                        │
│  │  RegAlloc   │  Chaitin-Briggs 图着色寄存器分配                        │
│  └─────────────┘                                                        │
│         │                                                               │
│         ▼                                                               │
│  ┌─────────────┐                                                        │
│  │  Output     │  机器码生成                                             │
│  └─────────────┘                                                        │
│         │                                                               │
│         ▼                                                               │
│     nmethod                                                             │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 8.2 Sea-of-Nodes IR

### 8.2.1 Node基类

Sea-of-Nodes是C2的核心中间表示，所有节点都继承自`Node`类：

```
源码位置: src/hotspot/share/opto/node.hpp
```

```cpp
// 第198-200行：Node类注释
// Nodes define actions in the program.  They create values, which have types.
// They are both vertices in a directed graph and program primitives.
```

### 8.2.2 节点类型层次

```
Node (基类)
├── TypeNode          # 带类型的节点
│   ├── PhiNode       # φ节点（SSA合并）
│   ├── ConNode       # 常量节点
│   └── ...
├── MultiNode         # 多输出节点
│   ├── CallNode      # 方法调用
│   ├── IfNode        # 条件分支
│   └── ...
├── ProjNode          # 投影节点（从MultiNode取值）
├── RegionNode        # 控制流合并
├── LoopNode          # 循环头
├── MemNode           # 内存操作
│   ├── LoadNode      # 加载
│   └── StoreNode     # 存储
└── MachNode          # 机器指令节点
```

### 8.2.3 Sea-of-Nodes的特点

**传统CFG vs Sea-of-Nodes**：

```
传统CFG（C1使用）:
┌─────────────────────────────────────────┐
│  基本块 → 基本块 → 基本块                 │
│  指令严格按序排列                         │
│  控制流和数据流分离                       │
└─────────────────────────────────────────┘

Sea-of-Nodes（C2使用）:
┌─────────────────────────────────────────┐
│  节点之间通过边连接                       │
│  - 数据边：值的流动                       │
│  - 控制边：执行顺序约束                   │
│  - 内存边：内存依赖                       │
│  节点可以自由移动（只要保持依赖）          │
└─────────────────────────────────────────┘
```

**节点的输入/输出**：

```cpp
// node.hpp 中的节点结构
class Node {
  Node** _in;        // 输入边数组
  Node** _out;       // 输出边数组（use-def链）
  uint   _cnt;       // 输入边数量
  uint   _outcnt;    // 输出边数量
  uint   _idx;       // 唯一节点ID
};
```

### 8.2.4 示例：简单表达式的Sea-of-Nodes

Java代码：
```java
int add(int a, int b) {
    return a + b;
}
```

Sea-of-Nodes表示：
```
     ┌─────────┐
     │  Root   │
     └────┬────┘
          │ control
          ▼
     ┌─────────┐
     │  Start  │
     └────┬────┘
          │
    ┌─────┴─────┐
    ▼           ▼
┌───────┐   ┌───────┐
│Parm(a)│   │Parm(b)│
└───┬───┘   └───┬───┘
    │           │
    └─────┬─────┘
          ▼
     ┌─────────┐
     │  AddI   │
     └────┬────┘
          │
          ▼
     ┌─────────┐
     │ Return  │
     └─────────┘
```

---

## 8.3 优化阶段详解

### 8.3.1 GVN（Global Value Numbering）

GVN是C2的核心优化，通过哈希表消除冗余计算：

```
源码位置: src/hotspot/share/opto/phaseX.hpp
```

```cpp
// 第53-114行：NodeHash类
class NodeHash : public StackObj {
protected:
  Arena *_a;                    // Arena to allocate in
  uint   _max;                  // Size of table (power of 2)
  uint   _inserts;              // For grow and debug, count of hash_inserts
  uint   _insert_limit;         // 'grow' when _inserts reaches _insert_limit
  Node **_table;                // Hash table of Node pointers
  Node  *_sentinel;             // Replaces deleted entries in hash table

public:
  Node  *hash_find(const Node*);// Find an equivalent version in hash table
  Node  *hash_find_insert(Node*);// If not in table insert else return found node
  void   hash_insert(Node*);    // Insert into hash table
  bool   hash_delete(const Node*);// Replace with _sentinel in hash table
```

**GVN优化示例**：

```java
// 优化前
int x = a + b;
int y = a + b;  // 冗余计算

// GVN优化后
int x = a + b;
int y = x;      // 复用x的值
```

### 8.3.2 IGVN（Iterative GVN）

IGVN是GVN的迭代版本，使用工作列表驱动优化：

```cpp
// phaseX.hpp中的PhaseIterGVN
class PhaseIterGVN : public PhaseGVN {
  Unique_Node_List _worklist;  // 待处理节点列表
  
  // 迭代优化直到不动点
  void optimize();
};
```

### 8.3.3 循环优化

循环优化是C2性能的关键，定义在`loopnode.hpp`：

```
源码位置: src/hotspot/share/opto/loopnode.hpp
```

```cpp
// 第56-79行：LoopNode类
class LoopNode : public RegionNode {
protected:
  uint _loop_flags;
  // Names for flag bitfields
  enum { Normal=0, Pre=1, Main=2, Post=3, PreMainPostFlagsMask=3,
         MainHasNoPreLoop=4,
         HasExactTripCount=8,
         InnerLoop=16,
         PartialPeelLoop=32,
         PartialPeelFailed=64,
         HasReductions=128,
         WasSlpAnalyzed=256,
         PassedSlpAnalysis=512,
         DoUnrollOnly=1024,
         VectorizedLoop=2048,
         HasAtomicPostLoop=4096,
         HasRangeChecks=8192,
         IsMultiversioned=16384,
         StripMined=32768,
         SubwordLoop=65536,
         ProfileTripFailed=131072};
```

**循环优化类型**：

| 优化类型 | 标志位 | 描述 |
|---------|--------|------|
| Pre/Main/Post | PreMainPostFlagsMask | 循环分裂 |
| InnerLoop | 16 | 标记为内层循环 |
| PartialPeelLoop | 32 | 部分剥离 |
| VectorizedLoop | 2048 | 已向量化 |
| StripMined | 32768 | 条带挖掘 |

**循环展开**：

```java
// 原始循环
for (int i = 0; i < 100; i++) {
    a[i] = b[i] + c[i];
}

// 展开后（假设展开因子=4）
for (int i = 0; i < 100; i += 4) {
    a[i]   = b[i]   + c[i];
    a[i+1] = b[i+1] + c[i+1];
    a[i+2] = b[i+2] + c[i+2];
    a[i+3] = b[i+3] + c[i+3];
}
```

**循环分裂（Pre/Main/Post）**：

```
原始循环:
┌────────────────────────────────────────┐
│  for (i = 0; i < n; i++) {             │
│      if (i >= 0 && i < a.length)       │  ← 边界检查
│          a[i] = ...;                   │
│  }                                     │
└────────────────────────────────────────┘

分裂后:
┌────────────────────────────────────────┐
│  Pre-loop:  处理前几次迭代（带检查）     │
├────────────────────────────────────────┤
│  Main-loop: 主循环（无边界检查！）       │  ← 快速路径
├────────────────────────────────────────┤
│  Post-loop: 处理剩余迭代（带检查）       │
└────────────────────────────────────────┘
```

---

## 8.4 逃逸分析

### 8.4.1 逃逸分析概述

逃逸分析基于[Choi99]论文实现：

```
源码位置: src/hotspot/share/opto/escape.hpp
```

```cpp
// 第32-39行：论文引用
// Adaptation for C2 of the escape analysis algorithm described in:
//
// [Choi99] Jong-Deok Shoi, Manish Gupta, Mauricio Seffano,
//          Vugranam C. Sreedhar, Sam Midkiff,
//          "Escape Analysis for Java", Procedings of ACM SIGPLAN
//          OOPSLA  Conference, November 1, 1999
//
// The flow-insensitive analysis described in the paper has been implemented.
```

### 8.4.2 逃逸状态

```cpp
// 第153-161行：EscapeState枚举
typedef enum {
  UnknownEscape = 0,
  NoEscape      = 1, // An object does not escape method or thread and it is
                     // not passed to call. It could be replaced with scalar.
  ArgEscape     = 2, // An object does not escape method or thread but it is
                     // passed as argument to call or referenced by argument
                     // and it does not escape during call.
  GlobalEscape  = 3  // An object escapes the method or thread.
} EscapeState;
```

**逃逸状态说明**：

| 状态 | 含义 | 可优化 |
|------|------|--------|
| NoEscape | 不逃逸，可标量替换 | ✅ 栈分配、锁消除 |
| ArgEscape | 作为参数传递但不逃逸 | ✅ 部分优化 |
| GlobalEscape | 逃逸到方法/线程外 | ❌ 必须堆分配 |

### 8.4.3 连接图（Connection Graph）

```cpp
// 第320-341行：ConnectionGraph类
class ConnectionGraph: public ResourceObj {
  friend class PointsToNode;
private:
  GrowableArray<PointsToNode*>  _nodes; // Map from ideal nodes to
                                        // ConnectionGraph nodes.
  GrowableArray<PointsToNode*>  _worklist; // Nodes to be processed
  VectorSet                  _in_worklist;
  uint                         _next_pidx;

  bool            _collecting; // Indicates whether escape information
                               // is still being collected.
  bool               _verify;  // verify graph

  JavaObjectNode* phantom_obj; // Unknown object
  JavaObjectNode*    null_obj;
  
  Compile*           _compile; // Compile object for current compilation
  PhaseIterGVN*         _igvn; // Value numbering
```

### 8.4.4 连接图节点类型

```cpp
// 第145-151行：NodeType枚举
typedef enum {
  UnknownType = 0,
  JavaObject  = 1,  // 对象分配点
  LocalVar    = 2,  // 局部变量
  Field       = 3,  // 字段
  Arraycopy   = 4   // 数组拷贝
} NodeType;
```

**连接图边类型**：

```cpp
// 第49-54行：边类型说明
// The CG contains 3 types of edges:
//
//   -  PointsTo  (-P>)    {LV, OF} to JO
//   -  Deferred  (-D>)    from {LV, OF} to {LV, OF}
//   -  Field     (-F>)    from JO to OF
```

### 8.4.5 逃逸分析示例

```java
public int sum(int[] data) {
    // Point对象不逃逸 → 可以标量替换
    Point p = new Point(0, 0);
    for (int i = 0; i < data.length; i++) {
        p.x += data[i];
    }
    return p.x;
}
```

**优化后**：

```java
public int sum(int[] data) {
    // Point被标量替换为两个局部变量
    int p_x = 0;
    int p_y = 0;  // 死代码，会被消除
    for (int i = 0; i < data.length; i++) {
        p_x += data[i];
    }
    return p_x;
}
```

### 8.4.6 标量替换条件

```cpp
// 第163-168行：标量替换标志
typedef enum {
  ScalarReplaceable = 1,  // Not escaped object could be replaced with scalar
  PointsToUnknown   = 2,  // Has edge to phantom_object
  ArraycopySrc      = 4,  // Has edge from Arraycopy node
  ArraycopyDst      = 8   // Has edge to Arraycopy node
} NodeFlags;
```

**标量替换的限制**：

1. 对象必须是`NoEscape`
2. 对象类型必须已知（非多态）
3. 所有字段访问必须可追踪
4. 不能有`phantom_object`边

---

## 8.5 指令选择（Matcher）

### 8.5.1 Matcher类

Matcher负责将Ideal Graph转换为MachNode Graph：

```
源码位置: src/hotspot/share/opto/matcher.hpp
```

```cpp
// 第41-51行：Matcher类定义
class Matcher : public PhaseTransform {
  friend class VMStructs;

public:
  // State and MStack class used in xform() and find_shared() iterative methods.
  enum Node_State { Pre_Visit,  // node has to be pre-visited
                    Visit,  // visit node
                    Post_Visit,  // post-visit node
                    Alt_Post_Visit   // alternative post-visit path
  };
```

### 8.5.2 ADLC（Architecture Description Language Compiler）

C2使用ADLC描述目标平台的指令：

```
源码位置: src/hotspot/cpu/x86/x86_64.ad
```

**ADL文件结构**：

```
// 伪代码示例
instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr) %{
  match(Set dst (AddI dst src));
  effect(KILL cr);
  
  format %{ "addl    $dst, $src" %}
  opcode(0x03);
  ins_encode %{
    __ addl($dst$$Register, $src$$Register);
  %}
  ins_pipe(ialu_reg_reg);
%}
```

### 8.5.3 指令选择过程

```
Ideal Graph:
┌─────────────────────────────────────────┐
│   AddI                                  │
│   ├── LoadI (从内存加载)                 │
│   └── ConI (常量)                       │
└─────────────────────────────────────────┘
                    │
                    ▼ Matcher
┌─────────────────────────────────────────┐
│   MachAddI                              │
│   ├── MachLoad (可能被合并到AddI)        │
│   └── MachConI                          │
└─────────────────────────────────────────┘
```

**Load合并优化**：

```cpp
// compile.hpp 第366行
const bool            _subsume_loads;  // Load can be matched as part of a larger op.
```

当`_subsume_loads=true`时，可以将Load合并到使用它的指令中：

```asm
# 未合并
movl  (%rdi), %eax
addl  %eax, %ebx

# 合并后
addl  (%rdi), %ebx    # Load直接作为AddI的操作数
```

---

## 8.6 寄存器分配（Chaitin-Briggs）

### 8.6.1 LRG（Live Range）

```
源码位置: src/hotspot/share/opto/chaitin.hpp
```

```cpp
// 第49-68行：LRG类
class LRG : public ResourceObj {
  friend class VMStructs;
public:
  static const uint AllStack_size = 0xFFFFF;
  enum { SPILL_REG=29999 };     // Register number of a spilled LRG

  double _cost;                 // 2 for loads/1 for stores times block freq
  double _area;                 // Sum of all simultaneously live values
  double score() const;         // Compute score from cost and area
  double _maxfreq;              // Maximum frequency of any def or use

  Node *_def;                   // Check for multi-def live ranges

  uint _risk_bias;              // Index of LRG which we want to avoid color
  uint _copy_bias;              // Index of LRG which we want to share color

  uint _next;                   // Index of next LRG in linked list
  uint _prev;                   // Index of prev LRG in linked list
```

### 8.6.2 寄存器掩码

```cpp
// 第107-141行：寄存器掩码操作
private:
  RegMask _mask;                // Allowed registers for this LRG
  uint _mask_size;              // cache of _mask.Size();
public:
  const RegMask &mask() const { return _mask; }
  void set_mask( const RegMask &rm ) { _mask = rm; }
  void AND( const RegMask &rm ) { _mask.AND(rm); }
  void SUBTRACT( const RegMask &rm ) { _mask.SUBTRACT(rm); }
  void Clear()   { _mask.Clear(); _mask_size = 0; }
  void Set_All() { _mask.Set_All(); _mask_size = RegMask::CHUNK_SIZE; }

  void Insert( OptoReg::Name reg ) { _mask.Insert(reg); }
  void Remove( OptoReg::Name reg ) { _mask.Remove(reg); }
```

### 8.6.3 Chaitin-Briggs算法

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Chaitin-Briggs 寄存器分配                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. Build: 构建干涉图                                                    │
│     - 分析活跃区间                                                       │
│     - 同时活跃的LRG之间添加干涉边                                         │
│                                                                         │
│  2. Coalesce: 合并复制相关的LRG                                          │
│     - 消除不必要的复制                                                   │
│                                                                         │
│  3. Simplify: 简化图                                                    │
│     - 移除低度数节点（度数 < 可用寄存器数）                               │
│     - 压入栈中                                                          │
│                                                                         │
│  4. Spill: 处理无法简化的节点                                            │
│     - 选择溢出候选                                                       │
│     - 插入Load/Store                                                    │
│                                                                         │
│  5. Select: 着色                                                        │
│     - 从栈中弹出节点                                                     │
│     - 分配不与邻居冲突的颜色（寄存器）                                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 8.6.4 溢出代价计算

```cpp
// 第56-58行：代价计算
double _cost;                 // 2 for loads/1 for stores times block freq
double _area;                 // Sum of all simultaneously live values
double score() const;         // Compute score from cost and area
```

**溢出选择策略**：

```
score = cost / area

- cost: 溢出代价（Load=2, Store=1，乘以块频率）
- area: 活跃区间面积

选择score最低的LRG进行溢出
```

---

## 8.7 与G1的协作

### 8.7.1 写屏障生成

C2在生成存储指令时必须插入G1写屏障：

```cpp
// 在Store节点生成时检查是否需要屏障
// compile.hpp 第426行
void*                 _barrier_set_state;     // Potential GC barrier state for Compile
```

**写屏障的IR表示**：

```
// 对象字段写入
StoreP (obj.field = value)
    │
    ▼
┌─────────────────────────────────────────┐
│  G1 Pre-Barrier (SATB)                  │
│  - 加载旧值                              │
│  - 如果非空，加入SATB队列                 │
├─────────────────────────────────────────┤
│  实际存储                                │
├─────────────────────────────────────────┤
│  G1 Post-Barrier                        │
│  - 检查跨Region引用                      │
│  - 如果需要，标记卡表                     │
└─────────────────────────────────────────┘
```

### 8.7.2 安全点轮询

C2在以下位置插入安全点轮询：

1. **循环回边**：每次循环迭代
2. **方法返回**：返回调用者前
3. **长时间操作**：可能阻塞的调用

```cpp
// compile.hpp 第611行
OopMapSet*        _oop_map_set;           // Table of oop maps (one for each safepoint location)
```

### 8.7.3 OopMap生成

```cpp
// 第1267-1268行：OopMap构建
// Build OopMaps for each GC point
void BuildOopMaps();
```

OopMap记录每个安全点的活跃对象引用位置：

```
安全点 @ offset 0x100:
  OopMap {
    rax: oop          // rax寄存器持有对象引用
    [rbp-8]: oop      // 栈槽rbp-8持有对象引用
    [rbp-16]: derived // 派生指针（需要特殊处理）
  }
```

---

## 8.8 C2优化示例

### 8.8.1 完整优化追踪

**Java源码**：

```java
public class Example {
    public int compute(int[] data) {
        int sum = 0;
        for (int i = 0; i < data.length; i++) {
            sum += data[i];
        }
        return sum;
    }
}
```

**优化过程**：

```
阶段1: Parse（字节码 → Ideal Graph）
┌─────────────────────────────────────────┐
│  创建基本的Sea-of-Nodes结构              │
│  - LoadI节点加载数组元素                  │
│  - AddI节点累加                          │
│  - CountedLoop表示循环                   │
└─────────────────────────────────────────┘
            │
            ▼
阶段2: Loop Optimization
┌─────────────────────────────────────────┐
│  1. 循环分裂（Pre/Main/Post）            │
│  2. 范围检查消除（Main loop无检查）       │
│  3. 循环展开（展开因子=4）               │
│  4. 向量化（如果可能）                   │
└─────────────────────────────────────────┘
            │
            ▼
阶段3: GVN/IGVN
┌─────────────────────────────────────────┐
│  - 常量折叠                              │
│  - 公共子表达式消除                       │
│  - 死代码消除                            │
└─────────────────────────────────────────┘
            │
            ▼
阶段4: Matching
┌─────────────────────────────────────────┐
│  Ideal节点 → MachNode                   │
│  - AddI → addl指令                      │
│  - LoadI → movl指令（可能合并）          │
└─────────────────────────────────────────┘
            │
            ▼
阶段5: Register Allocation
┌─────────────────────────────────────────┐
│  Chaitin-Briggs分配寄存器                │
│  - sum → %eax                           │
│  - i → %ecx                             │
│  - data → %rdi                          │
└─────────────────────────────────────────┘
            │
            ▼
阶段6: Code Generation
┌─────────────────────────────────────────┐
│  生成最终机器码                          │
│  插入安全点轮询                          │
│  生成OopMap                             │
└─────────────────────────────────────────┘
```

### 8.8.2 生成的机器码（简化）

```asm
# 方法入口
compute:
    push   %rbp
    mov    %rsp, %rbp
    
    # 加载数组长度
    mov    0x8(%rdi), %ecx      # data.length
    
    # 初始化
    xor    %eax, %eax           # sum = 0
    xor    %edx, %edx           # i = 0
    
    # 边界检查
    test   %ecx, %ecx
    jle    .done
    
    # 主循环（展开4次）
.main_loop:
    add    0x10(%rdi,%rdx,4), %eax    # sum += data[i]
    add    0x14(%rdi,%rdx,4), %eax    # sum += data[i+1]
    add    0x18(%rdi,%rdx,4), %eax    # sum += data[i+2]
    add    0x1c(%rdi,%rdx,4), %eax    # sum += data[i+3]
    add    $4, %edx                    # i += 4
    cmp    %ecx, %edx
    jl     .main_loop
    
    # 安全点轮询
    test   %eax, (%r15)         # 轮询页检查
    
.done:
    pop    %rbp
    ret
```

---

## 8.9 C2调试与诊断

### 8.9.1 编译日志

```bash
# 打印C2编译过程
java -XX:+UnlockDiagnosticVMOptions \
     -XX:+PrintCompilation \
     -XX:+PrintInlining \
     -XX:+PrintOptoAssembly \
     MyApp
```

### 8.9.2 IdealGraphVisualizer

```bash
# 生成IGV可视化数据
java -XX:+UnlockDiagnosticVMOptions \
     -XX:+PrintIdealGraphLevel=3 \
     -XX:PrintIdealGraphFile=ideal.xml \
     MyApp
```

### 8.9.3 常见编译失败原因

| 原因 | 日志标识 | 解决方案 |
|------|----------|----------|
| 节点数超限 | "NodeCountInliningCutoff" | 减少内联 |
| 编译超时 | "compilation timeout" | 增加超时时间 |
| 不支持的字节码 | "unsupported" | 检查代码模式 |
| 逃逸分析失败 | "EA failed" | 检查对象使用 |

---

## 8.10 本章小结

C2编译器的核心特点：

1. **Sea-of-Nodes IR**：灵活的图表示，便于优化
2. **激进优化**：逃逸分析、循环优化、GVN
3. **ADLC**：平台无关的指令描述
4. **Chaitin-Briggs**：高质量寄存器分配
5. **与G1协作**：正确的写屏障和OopMap

**关键源码文件**：

| 文件 | 作用 |
|------|------|
| `compile.hpp/cpp` | 编译主控 |
| `node.hpp` | 节点基类 |
| `escape.hpp/cpp` | 逃逸分析 |
| `loopnode.hpp` | 循环优化 |
| `matcher.hpp` | 指令选择 |
| `chaitin.hpp` | 寄存器分配 |

**下一章预告**：第9章将深入分析**内存结构**，包括堆布局、Region设计、卡表等，为理解G1 GC打下基础。
